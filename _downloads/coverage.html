<html>
  <head>
    <title>pycobertura report</title>
    <meta charset="UTF-8">
    <style>
/*! normalize.css v3.0.2 | MIT License | git.io/normalize */

/**
 * 1. Set default font family to sans-serif.
 * 2. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
  font-family: sans-serif; /* 1 */
  -ms-text-size-adjust: 100%; /* 2 */
  -webkit-text-size-adjust: 100%; /* 2 */
}

/**
 * Remove default margin.
 */

body {
  margin: 0;
}

/* HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined for any HTML5 element in IE 8/9.
 * Correct `block` display not defined for `details` or `summary` in IE 10/11
 * and Firefox.
 * Correct `block` display not defined for `main` in IE 11.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
menu,
nav,
section,
summary {
  display: block;
}

/**
 * 1. Correct `inline-block` display not defined in IE 8/9.
 * 2. Normalize vertical alignment of `progress` in Chrome, Firefox, and Opera.
 */

audio,
canvas,
progress,
video {
  display: inline-block; /* 1 */
  vertical-align: baseline; /* 2 */
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
  display: none;
  height: 0;
}

/**
 * Address `[hidden]` styling not present in IE 8/9/10.
 * Hide the `template` element in IE 8/9/11, Safari, and Firefox < 22.
 */

[hidden],
template {
  display: none;
}

/* Links
   ========================================================================== */

/**
 * Remove the gray background color from active links in IE 10.
 */

a {
  background-color: transparent;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
  outline: 0;
}

/* Text-level semantics
   ========================================================================== */

/**
 * Address styling not present in IE 8/9/10/11, Safari, and Chrome.
 */

abbr[title] {
  border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 4+, Safari, and Chrome.
 */

b,
strong {
  font-weight: bold;
}

/**
 * Address styling not present in Safari and Chrome.
 */

dfn {
  font-style: italic;
}

/**
 * Address variable `h1` font-size and margin within `section` and `article`
 * contexts in Firefox 4+, Safari, and Chrome.
 */

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

/**
 * Address styling not present in IE 8/9.
 */

mark {
  background: #ff0;
  color: #000;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
  font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sup {
  top: -0.5em;
}

sub {
  bottom: -0.25em;
}

/* Embedded content
   ========================================================================== */

/**
 * Remove border when inside `a` element in IE 8/9/10.
 */

img {
  border: 0;
}

/**
 * Correct overflow not hidden in IE 9/10/11.
 */

svg:not(:root) {
  overflow: hidden;
}

/* Grouping content
   ========================================================================== */

/**
 * Address margin not present in IE 8/9 and Safari.
 */

figure {
  margin: 1em 40px;
}

/**
 * Address differences between Firefox and other browsers.
 */

hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

/**
 * Contain overflow in all browsers.
 */

pre {
  overflow: auto;
}

/**
 * Address odd `em`-unit font size rendering in all browsers.
 */

code,
kbd,
pre,
samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

/* Forms
   ========================================================================== */

/**
 * Known limitation: by default, Chrome and Safari on OS X allow very limited
 * styling of `select`, unless a `border` property is set.
 */

/**
 * 1. Correct color not being inherited.
 *    Known issue: affects color of disabled elements.
 * 2. Correct font properties not being inherited.
 * 3. Address margins set differently in Firefox 4+, Safari, and Chrome.
 */

button,
input,
optgroup,
select,
textarea {
  color: inherit; /* 1 */
  font: inherit; /* 2 */
  margin: 0; /* 3 */
}

/**
 * Address `overflow` set to `hidden` in IE 8/9/10/11.
 */

button {
  overflow: visible;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Firefox, IE 8/9/10/11, and Opera.
 * Correct `select` style inheritance in Firefox.
 */

button,
select {
  text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
  -webkit-appearance: button; /* 2 */
  cursor: pointer; /* 3 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
  cursor: default;
}

/**
 * Remove inner padding and border in Firefox 4+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
  border: 0;
  padding: 0;
}

/**
 * Address Firefox 4+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

input {
  line-height: normal;
}

/**
 * It's recommended that you don't attempt to style these elements.
 * Firefox's implementation doesn't respect box-sizing, padding, or width.
 *
 * 1. Address box sizing set to `content-box` in IE 8/9/10.
 * 2. Remove excess padding in IE 8/9/10.
 */

input[type="checkbox"],
input[type="radio"] {
  box-sizing: border-box; /* 1 */
  padding: 0; /* 2 */
}

/**
 * Fix the cursor style for Chrome's increment/decrement buttons. For certain
 * `font-size` values of the `input`, it causes the cursor style of the
 * decrement button to change from `default` to `text`.
 */

input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  height: auto;
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
  -webkit-appearance: textfield; /* 1 */
  -moz-box-sizing: content-box;
  -webkit-box-sizing: content-box; /* 2 */
  box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari and Chrome on OS X.
 * Safari (but not Chrome) clips the cancel button when the search input has
 * padding (and `textfield` appearance).
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
  border: 1px solid #c0c0c0;
  margin: 0 2px;
  padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct `color` not being inherited in IE 8/9/10/11.
 * 2. Remove padding so people aren't caught out if they zero out fieldsets.
 */

legend {
  border: 0; /* 1 */
  padding: 0; /* 2 */
}

/**
 * Remove default vertical scrollbar in IE 8/9/10/11.
 */

textarea {
  overflow: auto;
}

/**
 * Don't inherit the `font-weight` (applied by a rule above).
 * NOTE: the default cannot safely be changed in Chrome and Safari on OS X.
 */

optgroup {
  font-weight: bold;
}

/* Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
  border-collapse: collapse;
  border-spacing: 0;
}

td,
th {
  padding: 0;
}
/*
* Skeleton V2.0.4
* Copyright 2014, Dave Gamache
* www.getskeleton.com
* Free to use under the MIT license.
* http://www.opensource.org/licenses/mit-license.php
* 12/29/2014
*/


/* Table of contents
––––––––––––––––––––––––––––––––––––––––––––––––––
- Grid
- Base Styles
- Typography
- Links
- Buttons
- Forms
- Lists
- Code
- Tables
- Spacing
- Utilities
- Clearing
- Media Queries
*/


/* Grid
–––––––––––––––––––––––––––––––––––––––––––––––––– */
.container {
  position: relative;
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  box-sizing: border-box; }
.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box; }

/* For devices larger than 400px */
@media (min-width: 400px) {
  .container {
    width: 85%;
    padding: 0; }
}

/* For devices larger than 550px */
@media (min-width: 550px) {
  .container {
    width: 80%; }
  .column,
  .columns {
    margin-left: 4%; }
  .column:first-child,
  .columns:first-child {
    margin-left: 0; }

  .one.column,
  .one.columns                    { width: 4.66666666667%; }
  .two.columns                    { width: 13.3333333333%; }
  .three.columns                  { width: 22%;            }
  .four.columns                   { width: 30.6666666667%; }
  .five.columns                   { width: 39.3333333333%; }
  .six.columns                    { width: 48%;            }
  .seven.columns                  { width: 56.6666666667%; }
  .eight.columns                  { width: 65.3333333333%; }
  .nine.columns                   { width: 74.0%;          }
  .ten.columns                    { width: 82.6666666667%; }
  .eleven.columns                 { width: 91.3333333333%; }
  .twelve.columns                 { width: 100%; margin-left: 0; }

  .one-third.column               { width: 30.6666666667%; }
  .two-thirds.column              { width: 65.3333333333%; }

  .one-half.column                { width: 48%; }

  /* Offsets */
  .offset-by-one.column,
  .offset-by-one.columns          { margin-left: 8.66666666667%; }
  .offset-by-two.column,
  .offset-by-two.columns          { margin-left: 17.3333333333%; }
  .offset-by-three.column,
  .offset-by-three.columns        { margin-left: 26%;            }
  .offset-by-four.column,
  .offset-by-four.columns         { margin-left: 34.6666666667%; }
  .offset-by-five.column,
  .offset-by-five.columns         { margin-left: 43.3333333333%; }
  .offset-by-six.column,
  .offset-by-six.columns          { margin-left: 52%;            }
  .offset-by-seven.column,
  .offset-by-seven.columns        { margin-left: 60.6666666667%; }
  .offset-by-eight.column,
  .offset-by-eight.columns        { margin-left: 69.3333333333%; }
  .offset-by-nine.column,
  .offset-by-nine.columns         { margin-left: 78.0%;          }
  .offset-by-ten.column,
  .offset-by-ten.columns          { margin-left: 86.6666666667%; }
  .offset-by-eleven.column,
  .offset-by-eleven.columns       { margin-left: 95.3333333333%; }

  .offset-by-one-third.column,
  .offset-by-one-third.columns    { margin-left: 34.6666666667%; }
  .offset-by-two-thirds.column,
  .offset-by-two-thirds.columns   { margin-left: 69.3333333333%; }

  .offset-by-one-half.column,
  .offset-by-one-half.columns     { margin-left: 52%; }

}


/* Base Styles
–––––––––––––––––––––––––––––––––––––––––––––––––– */
/* NOTE
html is set to 62.5% so that all the REM measurements throughout Skeleton
are based on 10px sizing. So basically 1.5rem = 15px :) */
html {
  font-size: 62.5%; }
body {
  font-size: 1.5em; /* currently ems cause chrome bug misinterpreting rems on body element */
  line-height: 1.6;
  font-weight: 400;
  font-family: "Raleway", "HelveticaNeue", "Helvetica Neue", Helvetica, Arial, sans-serif;
  color: #222; }


/* Typography
–––––––––––––––––––––––––––––––––––––––––––––––––– */
h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
  margin-bottom: 2rem;
  font-weight: 300; }
h1 { font-size: 4.0rem; line-height: 1.2;  letter-spacing: -.1rem;}
h2 { font-size: 3.6rem; line-height: 1.25; letter-spacing: -.1rem; }
h3 { font-size: 3.0rem; line-height: 1.3;  letter-spacing: -.1rem; }
h4 { font-size: 2.4rem; line-height: 1.35; letter-spacing: -.08rem; }
h5 { font-size: 1.8rem; line-height: 1.5;  letter-spacing: -.05rem; }
h6 { font-size: 1.5rem; line-height: 1.6;  letter-spacing: 0; }

/* Larger than phablet */
@media (min-width: 550px) {
  h1 { font-size: 5.0rem; }
  h2 { font-size: 4.2rem; }
  h3 { font-size: 3.6rem; }
  h4 { font-size: 3.0rem; }
  h5 { font-size: 2.4rem; }
  h6 { font-size: 1.5rem; }
}

p {
  margin-top: 0; }


/* Links
–––––––––––––––––––––––––––––––––––––––––––––––––– */
a {
  color: #1EAEDB; }
a:hover {
  color: #0FA0CE; }


/* Buttons
–––––––––––––––––––––––––––––––––––––––––––––––––– */
.button,
button,
input[type="submit"],
input[type="reset"],
input[type="button"] {
  display: inline-block;
  height: 38px;
  padding: 0 30px;
  color: #555;
  text-align: center;
  font-size: 11px;
  font-weight: 600;
  line-height: 38px;
  letter-spacing: .1rem;
  text-transform: uppercase;
  text-decoration: none;
  white-space: nowrap;
  background-color: transparent;
  border-radius: 4px;
  border: 1px solid #bbb;
  cursor: pointer;
  box-sizing: border-box; }
.button:hover,
button:hover,
input[type="submit"]:hover,
input[type="reset"]:hover,
input[type="button"]:hover,
.button:focus,
button:focus,
input[type="submit"]:focus,
input[type="reset"]:focus,
input[type="button"]:focus {
  color: #333;
  border-color: #888;
  outline: 0; }
.button.button-primary,
button.button-primary,
input[type="submit"].button-primary,
input[type="reset"].button-primary,
input[type="button"].button-primary {
  color: #FFF;
  background-color: #33C3F0;
  border-color: #33C3F0; }
.button.button-primary:hover,
button.button-primary:hover,
input[type="submit"].button-primary:hover,
input[type="reset"].button-primary:hover,
input[type="button"].button-primary:hover,
.button.button-primary:focus,
button.button-primary:focus,
input[type="submit"].button-primary:focus,
input[type="reset"].button-primary:focus,
input[type="button"].button-primary:focus {
  color: #FFF;
  background-color: #1EAEDB;
  border-color: #1EAEDB; }


/* Forms
–––––––––––––––––––––––––––––––––––––––––––––––––– */
input[type="email"],
input[type="number"],
input[type="search"],
input[type="text"],
input[type="tel"],
input[type="url"],
input[type="password"],
textarea,
select {
  height: 38px;
  padding: 6px 10px; /* The 6px vertically centers text on FF, ignored by Webkit */
  background-color: #fff;
  border: 1px solid #D1D1D1;
  border-radius: 4px;
  box-shadow: none;
  box-sizing: border-box; }
/* Removes awkward default styles on some inputs for iOS */
input[type="email"],
input[type="number"],
input[type="search"],
input[type="text"],
input[type="tel"],
input[type="url"],
input[type="password"],
textarea {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none; }
textarea {
  min-height: 65px;
  padding-top: 6px;
  padding-bottom: 6px; }
input[type="email"]:focus,
input[type="number"]:focus,
input[type="search"]:focus,
input[type="text"]:focus,
input[type="tel"]:focus,
input[type="url"]:focus,
input[type="password"]:focus,
textarea:focus,
select:focus {
  border: 1px solid #33C3F0;
  outline: 0; }
label,
legend {
  display: block;
  margin-bottom: .5rem;
  font-weight: 600; }
fieldset {
  padding: 0;
  border-width: 0; }
input[type="checkbox"],
input[type="radio"] {
  display: inline; }
label > .label-body {
  display: inline-block;
  margin-left: .5rem;
  font-weight: normal; }


/* Lists
–––––––––––––––––––––––––––––––––––––––––––––––––– */
ul {
  list-style: circle inside; }
ol {
  list-style: decimal inside; }
ol, ul {
  padding-left: 0;
  margin-top: 0; }
ul ul,
ul ol,
ol ol,
ol ul {
  margin: 1.5rem 0 1.5rem 3rem;
  font-size: 90%; }
li {
  margin-bottom: 1rem; }


/* Code
–––––––––––––––––––––––––––––––––––––––––––––––––– */
code {
  padding: .2rem .5rem;
  margin: 0 .2rem;
  font-size: 90%;
  white-space: nowrap;
  background: #F1F1F1;
  border: 1px solid #E1E1E1;
  border-radius: 4px; }
pre > code {
  display: block;
  padding: 1rem 1.5rem;
  white-space: pre; }


/* Tables
–––––––––––––––––––––––––––––––––––––––––––––––––– */
th,
td {
  padding: 12px 15px;
  text-align: left;
  border-bottom: 1px solid #E1E1E1; }
th:first-child,
td:first-child {
  padding-left: 0; }
th:last-child,
td:last-child {
  padding-right: 0; }


/* Spacing
–––––––––––––––––––––––––––––––––––––––––––––––––– */
button,
.button {
  margin-bottom: 1rem; }
input,
textarea,
select,
fieldset {
  margin-bottom: 1.5rem; }
pre,
blockquote,
dl,
figure,
table,
p,
ul,
ol,
form {
  margin-bottom: 2.5rem; }


/* Utilities
–––––––––––––––––––––––––––––––––––––––––––––––––– */
.u-full-width {
  width: 100%;
  box-sizing: border-box; }
.u-max-full-width {
  max-width: 100%;
  box-sizing: border-box; }
.u-pull-right {
  float: right; }
.u-pull-left {
  float: left; }


/* Misc
–––––––––––––––––––––––––––––––––––––––––––––––––– */
hr {
  margin-top: 3rem;
  margin-bottom: 3.5rem;
  border-width: 0;
  border-top: 1px solid #E1E1E1; }


/* Clearing
–––––––––––––––––––––––––––––––––––––––––––––––––– */

/* Self Clearing Goodness */
.container:after,
.row:after,
.u-cf {
  content: "";
  display: table;
  clear: both; }


/* Media Queries
–––––––––––––––––––––––––––––––––––––––––––––––––– */
/*
Note: The best way to structure the use of media queries is to create the queries
near the relevant code. For example, if you wanted to change the styles for buttons
on small devices, paste the mobile query code up in the buttons section and style it
there.
*/


/* Larger than mobile */
@media (min-width: 400px) {}

/* Larger than phablet (also point when grid becomes active) */
@media (min-width: 550px) {}

/* Larger than tablet */
@media (min-width: 750px) {}

/* Larger than desktop */
@media (min-width: 1000px) {}

/* Larger than Desktop HD */
@media (min-width: 1200px) {}
.hit {background-color: #EAFFEA}
.miss {background-color: #FFECEC}
.container .code {margin-left: 0}
pre {line-height: 1.3}
    </style>
  </head>
  <body>
    <div class="container">
      <table class="u-full-width">
        <thead>
          <tr>
            <th>Filename</th>
            <th>Stmts</th>
            <th>Miss</th>
            <th>Cover</th>
            <th>Missing</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><a href="#__init__.py">__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#test_pyplot_backend.py">test_pyplot_backend.py</a></td>
            <td>8</td>
            <td>8</td>
            <td>0.00%</td>
            <td>2-21</td>
          </tr>
          <tr>
            <td><a href="#unittests_01_pointerutils.py">unittests_01_pointerutils.py</a></td>
            <td>191</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_02_timetools.py">unittests_02_timetools.py</a></td>
            <td>407</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_03_filetools.py">unittests_03_filetools.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_04_devicetools.py">unittests_04_devicetools.py</a></td>
            <td>326</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_05_connectiontools.py">unittests_05_connectiontools.py</a></td>
            <td>53</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_06_selectiontools.py">unittests_06_selectiontools.py</a></td>
            <td>133</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_07_parametertools.py">unittests_07_parametertools.py</a></td>
            <td>1</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_08_indextools.py">unittests_08_indextools.py</a></td>
            <td>100</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/__init__.py</a></td>
            <td>34</td>
            <td>1</td>
            <td>97.06%</td>
            <td>42</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/pub.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/pub.py</a></td>
            <td>13</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/anntools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/anntools.py</a></td>
            <td>223</td>
            <td>27</td>
            <td>87.89%</td>
            <td>712, 715-722, 728, 805, 835-839, 843, 847, 850-867, 872</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/armatools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/armatools.py</a></td>
            <td>209</td>
            <td>4</td>
            <td>98.09%</td>
            <td>220-222, 656-658</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/iuhtools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/iuhtools.py</a></td>
            <td>135</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/networktools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/networktools.py</a></td>
            <td>86</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/smoothtools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/smoothtools.py</a></td>
            <td>20</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/statstools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/statstools.py</a></td>
            <td>27</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/validtools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/validtools.py</a></td>
            <td>15</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/conf/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/conf/__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/autodoctools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/autodoctools.py</a></td>
            <td>99</td>
            <td>3</td>
            <td>96.97%</td>
            <td>121, 186, 190</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/connectiontools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/connectiontools.py</a></td>
            <td>39</td>
            <td>2</td>
            <td>94.87%</td>
            <td>40, 68</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/devicetools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/devicetools.py</a></td>
            <td>497</td>
            <td>79</td>
            <td>84.10%</td>
            <td>260-261, 346, 352, 355, 358, 549-550, 555, 569, 577, 591-593, 603-605, 614, 616-617, 630-631, 638, 645, 648-652, 657-667, 895-896, 1004-1006, 1014, 1039, 1042-1053, 1061, 1069, 1077, 1097-1100, 1449-1450, 1549-1550, 1555-1556, 1561-1562, 1573-1574, 1579-1580, 1585-1586, 1591-1592</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/dummytools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/dummytools.py</a></td>
            <td>25</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/filetools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/filetools.py</a></td>
            <td>571</td>
            <td>390</td>
            <td>31.70%</td>
            <td>24-37, 40, 44-45, 50-57, 60, 63-64, 67-75, 78-91, 94, 101-102, 106, 112, 115-120, 126, 132, 139-140, 151-176, 185-196, 203-213, 216, 227-229, 233, 239, 242-247, 253, 259-265, 271-274, 280-296, 302-307, 312, 319, 334-351, 369-381, 390-393, 396-401, 406, 409, 412, 415-427, 430, 443, 447, 451, 455, 459, 463, 467, 471, 475, 485, 490, 493-498, 504, 510-516, 522-525, 531-548, 555-560, 565, 572-589, 596-601, 606, 613-630, 637-642, 647, 655-672, 679-684, 689, 696, 701, 706, 711, 717, 720-724, 733, 738, 749, 752-756, 764, 767, 772, 775, 780, 783, 788, 791, 796, 803-806, 810, 818, 821-826, 832, 840-846, 852-874, 881-886, 891, 898-920, 927-932, 937, 944, 950, 955-965</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/hydpytools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/hydpytools.py</a></td>
            <td>265</td>
            <td>132</td>
            <td>50.19%</td>
            <td>30, 41-46, 50-52, 56-76, 81-93, 98, 104, 109-136, 139-140, 143-144, 147-149, 153-157, 161-176, 189, 199, 219-222, 263, 284-285, 289-290, 294-295, 299-300, 304-305, 309-310, 314-315, 319-321, 325, 329, 333, 336-344, 351-352, 356, 360, 363-369</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/indextools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/indextools.py</a></td>
            <td>80</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/magictools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/magictools.py</a></td>
            <td>299</td>
            <td>136</td>
            <td>54.52%</td>
            <td>49-52, 56, 60-107, 126, 132-136, 139-141, 144-152, 155, 158-159, 162, 189-204, 227-229, 300, 322, 325-340, 347, 351, 372, 382-412, 450-453, 467-477, 604-605</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/modelimports.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/modelimports.py</a></td>
            <td>10</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/modeltools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/modeltools.py</a></td>
            <td>301</td>
            <td>22</td>
            <td>92.69%</td>
            <td>50, 123-124, 147-153, 165-167, 204-206, 228, 234-235, 524-531, 727</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/objecttools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/objecttools.py</a></td>
            <td>491</td>
            <td>93</td>
            <td>81.06%</td>
            <td>55, 173, 215, 631, 964, 980, 985, 1006, 1013, 1017, 1032, 1112, 1126-1127, 1133-1134, 1139-1140, 1145-1146, 1149-1150, 1155-1156, 1168-1169, 1174-1175, 1182-1185, 1188-1191, 1194-1195, 1198-1201, 1204-1207, 1210-1211, 1214-1217, 1220-1223, 1226-1227, 1233, 1236, 1239, 1242, 1245, 1248, 1251, 1254, 1259-1260, 1265-1266, 1271-1272, 1277-1278, 1283-1284, 1289-1290, 1297-1303, 1309, 1315, 1319, 1323, 1326, 1329, 1351, 1356, 1360</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/optiontools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/optiontools.py</a></td>
            <td>59</td>
            <td>3</td>
            <td>94.92%</td>
            <td>32, 38, 67</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/parametertools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/parametertools.py</a></td>
            <td>670</td>
            <td>130</td>
            <td>80.60%</td>
            <td>43-44, 56-57, 64-87, 91-102, 106-109, 124, 127, 199-200, 228-229, 245-248, 253-254, 258, 276, 281, 285-287, 305-325, 342, 353, 359-362, 379-380, 393, 416, 461, 464, 483, 498, 506-507, 521-522, 541-544, 581-582, 588, 601, 612-613, 630, 641-646, 669-670, 674, 688, 694, 714-715, 751, 769, 939, 1107, 1126-1127, 1156-1162, 1169-1173, 1175, 1192, 1357-1358, 1365-1366, 1374-1375, 1412, 1425, 1434, 1505</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/selectiontools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/selectiontools.py</a></td>
            <td>216</td>
            <td>93</td>
            <td>56.94%</td>
            <td>26-27, 32, 36-38, 42, 47, 50, 53, 56-59, 62-63, 66, 78-89, 98-102, 105-108, 111-118, 121-127, 130, 138-142, 145, 205-208, 256-258, 268-270, 280-289, 377-387, 403, 407, 411, 415, 419, 423, 427, 451</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/sequencetools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/sequencetools.py</a></td>
            <td>941</td>
            <td>357</td>
            <td>62.06%</td>
            <td>36-37, 43, 46-48, 51-53, 56-58, 61-63, 86-88, 101-103, 110-112, 116-127, 133-144, 149-168, 171-172, 175, 261-262, 292-293, 307, 312-315, 320-321, 325, 342-343, 346-347, 350-351, 354-355, 358-359, 403-405, 418-419, 427-428, 461-462, 497, 510, 521-522, 534-535, 556-557, 569-573, 577-589, 602-603, 607, 619, 637-649, 659, 662, 669-672, 675, 678, 685, 691-702, 711, 714, 720-726, 735, 738, 743-746, 749, 752, 758-761, 764, 767, 775, 791, 804, 813, 822, 842-843, 854, 858, 867, 871, 876-879, 887-923, 1021-1027, 1033-1046, 1049-1054, 1058-1061, 1067, 1071, 1076, 1080-1087, 1092-1093, 1101, 1108-1110, 1114-1118, 1122-1126, 1139-1148, 1156, 1159, 1184-1187, 1201, 1204, 1211, 1214, 1230, 1237-1238, 1278-1280, 1300, 1311-1315, 1320-1321, 1331-1332, 1385-1386, 1390, 1396, 1405, 1409-1410, 1417-1418, 1428-1437, 1445, 1448, 1460-1464, 1481-1487, 1493-1499, 1513-1519, 1525-1531, 1538, 1550, 1553, 1589-1597, 1603-1604, 1614-1626, 1634, 1645-1655</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/testtools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/testtools.py</a></td>
            <td>247</td>
            <td>14</td>
            <td>94.33%</td>
            <td>104-107, 224, 231-232, 237-238, 366, 370, 411-415</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/timetools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/timetools.py</a></td>
            <td>510</td>
            <td>37</td>
            <td>92.75%</td>
            <td>155, 193-196, 239-240, 354-355, 399, 545-546, 552, 572-573, 589, 630-631, 640, 696-697, 703, 865-870, 1046, 1066, 1178, 1195-1197, 1248, 1251-1252, 1255, 1279</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/cythons/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/cythons/__init__.py</a></td>
            <td>7</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/cythons/modelutils.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/cythons/modelutils.py</a></td>
            <td>751</td>
            <td>87</td>
            <td>88.42%</td>
            <td>34-35, 82, 123-124, 128-129, 165, 186, 222, 265-279, 287, 492, 498-504, 700, 819, 822, 861-876, 934-937, 947-965, 974-987, 997-1013, 1026-1042, 1065, 1073, 1077, 1204-1205</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/cythons/autogen/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/cythons/autogen/__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/docs/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/docs/__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/docs/apidoc.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/docs/apidoc.py</a></td>
            <td>18</td>
            <td>18</td>
            <td>0.00%</td>
            <td>2-28</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/docs/conf.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/docs/conf.py</a></td>
            <td>35</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma_v1.py</a></td>
            <td>32</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam_v1.py</a></td>
            <td>46</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch_v1.py</a></td>
            <td>27</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland_v1.py</a></td>
            <td>39</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream_v1.py</a></td>
            <td>29</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake_v1.py</a></td>
            <td>36</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland_v1.py</a></td>
            <td>36</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland_v2.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland_v2.py</a></td>
            <td>36</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream_v1.py</a></td>
            <td>36</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test_v1.py</a></td>
            <td>25</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test_v2.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test_v2.py</a></td>
            <td>25</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/__init__.py</a></td>
            <td>14</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_control.py</a></td>
            <td>109</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_derived.py</a></td>
            <td>56</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_fluxes.py</a></td>
            <td>16</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_inlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_inlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_logs.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_logs.py</a></td>
            <td>8</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_model.py</a></td>
            <td>72</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/__init__.py</a></td>
            <td>18</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_aides.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_aides.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_control.py</a></td>
            <td>39</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_derived.py</a></td>
            <td>40</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_fluxes.py</a></td>
            <td>26</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_inlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_inlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_logs.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_logs.py</a></td>
            <td>8</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_model.py</a></td>
            <td>106</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_receivers.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_receivers.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_solver.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_solver.py</a></td>
            <td>21</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_states.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/__init__.py</a></td>
            <td>13</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_control.py</a></td>
            <td>56</td>
            <td>21</td>
            <td>62.50%</td>
            <td>22, 28, 47-48, 58, 65, 73, 77-86, 91-100</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_derived.py</a></td>
            <td>14</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_fluxes.py</a></td>
            <td>18</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_inlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_inlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_model.py</a></td>
            <td>44</td>
            <td>5</td>
            <td>88.64%</td>
            <td>177, 185-192</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/__init__.py</a></td>
            <td>18</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_aides.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_aides.py</a></td>
            <td>8</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_constants.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_constants.py</a></td>
            <td>7</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_control.py</a></td>
            <td>122</td>
            <td>4</td>
            <td>96.72%</td>
            <td>301, 305, 314-315</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_derived.py</a></td>
            <td>25</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_fluxes.py</a></td>
            <td>66</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_inputs.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_inputs.py</a></td>
            <td>12</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_logs.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_logs.py</a></td>
            <td>17</td>
            <td>7</td>
            <td>58.82%</td>
            <td>19-29</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_model.py</a></td>
            <td>270</td>
            <td>5</td>
            <td>98.15%</td>
            <td>1782, 2198-2201</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_parameters.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_parameters.py</a></td>
            <td>98</td>
            <td>7</td>
            <td>92.86%</td>
            <td>178-184</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_states.py</a></td>
            <td>47</td>
            <td>1</td>
            <td>97.87%</td>
            <td>56</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/__init__.py</a></td>
            <td>14</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_control.py</a></td>
            <td>8</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_derived.py</a></td>
            <td>12</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_inlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_inlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_model.py</a></td>
            <td>21</td>
            <td>7</td>
            <td>66.67%</td>
            <td>111-113, 119-122</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_parameters.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_parameters.py</a></td>
            <td>17</td>
            <td>2</td>
            <td>88.24%</td>
            <td>19-20</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_states.py</a></td>
            <td>16</td>
            <td>6</td>
            <td>62.50%</td>
            <td>19-24</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/__init__.py</a></td>
            <td>15</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_aides.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_aides.py</a></td>
            <td>10</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_control.py</a></td>
            <td>43</td>
            <td>2</td>
            <td>95.35%</td>
            <td>152-153</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_derived.py</a></td>
            <td>28</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_fluxes.py</a></td>
            <td>8</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_inlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_inlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_model.py</a></td>
            <td>84</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_states.py</a></td>
            <td>8</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/__init__.py</a></td>
            <td>17</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_aides.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_aides.py</a></td>
            <td>18</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_constants.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_constants.py</a></td>
            <td>19</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_control.py</a></td>
            <td>222</td>
            <td>6</td>
            <td>97.30%</td>
            <td>241, 246, 373, 436, 544, 549</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_derived.py</a></td>
            <td>55</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_fluxes.py</a></td>
            <td>38</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_inputs.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_inputs.py</a></td>
            <td>12</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_model.py</a></td>
            <td>282</td>
            <td>5</td>
            <td>98.23%</td>
            <td>1502, 1567, 1632, 1696, 1760</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_parameters.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_parameters.py</a></td>
            <td>18</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_sequences.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_sequences.py</a></td>
            <td>3</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_states.py</a></td>
            <td>51</td>
            <td>1</td>
            <td>98.04%</td>
            <td>53</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/__init__.py</a></td>
            <td>15</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_aides.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_aides.py</a></td>
            <td>16</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_control.py</a></td>
            <td>36</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_derived.py</a></td>
            <td>36</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_fluxes.py</a></td>
            <td>34</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_inlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_inlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_model.py</a></td>
            <td>168</td>
            <td>3</td>
            <td>98.21%</td>
            <td>866-867, 943</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_states.py</a></td>
            <td>8</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/__init__.py</a></td>
            <td>12</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_control.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_fluxes.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_model.py</a></td>
            <td>22</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_solver.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_solver.py</a></td>
            <td>16</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_states.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
        </tbody>
        <tfoot>
          <tr>
            <td>TOTAL</td>
            <td>11349</td>
            <td>1718</td>
            <td>84.86%</td>
            <td></td>
          </tr>
        </tfoot>
      </table>
<h4 id="__init__.py">__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre></pre>
      </td>
      <td class="source">
        <pre></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="test_pyplot_backend.py">test_pyplot_backend.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="miss">&#34;&#34;&#34;
</span><span class="noop">Test if the default backend of matplotlib required for pyplot is available.
</span><span class="noop">
</span><span class="noop">Required for Travis CI, where it is not available.
</span><span class="noop">
</span><span class="noop">If the backend is available, the exit code of this script is 0, otherwise 1.
</span><span class="noop">
</span><span class="noop">Actually, the only test is calling pyplots `plot` command.  If this script
</span><span class="noop">fails due to another reason than a missing backend, one will be informed by
</span><span class="noop">another failure in the testing routines defined somewhere else.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="miss">import sys
</span><span class="miss">from matplotlib import pyplot
</span><span class="miss">try:
</span><span class="miss">    pyplot.plot()
</span><span class="miss">except BaseException:
</span><span class="miss">    sys.exit(1)
</span><span class="noop">else:
</span><span class="miss">    sys.exit(0)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_01_pointerutils.py">unittests_01_pointerutils.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.cythons import pointerutils
</span><span class="noop">
</span><span class="hit">class Test1Initialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.test_1_init_double()
</span><span class="hit">        self.test_2_init_p_double()
</span><span class="hit">        self.test_3_change_double()
</span><span class="hit">        self.test_4_change_p_double()
</span><span class="noop">
</span><span class="hit">    def test_1_init_double(self):
</span><span class="hit">        self.d = pointerutils.Double(2.)
</span><span class="hit">    def test_2_init_p_double(self):
</span><span class="hit">        self.p = pointerutils.PDouble(self.d)
</span><span class="hit">    def test_3_change_double(self):
</span><span class="hit">        self.d.setvalue(4.)
</span><span class="hit">        self.assertEqual(self.d, self.p)
</span><span class="hit">    def test_4_change_p_double(self):
</span><span class="hit">        self.p.setvalue(-3.)
</span><span class="hit">        self.assertEqual(self.d, self.p)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test2InputConversion(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_x = 2.1
</span><span class="hit">        self.f_y = 5.6
</span><span class="hit">        self.d_x = pointerutils.Double(self.f_x)
</span><span class="hit">        self.d_y = pointerutils.Double(self.f_y)
</span><span class="hit">        self.p_x = pointerutils.PDouble(self.d_x)
</span><span class="hit">        self.p_y = pointerutils.PDouble(self.d_y)
</span><span class="noop">
</span><span class="hit">    def test_double_add_float(self):
</span><span class="hit">        self.assertEqual(self.d_x + self.f_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_float_add_double(self):
</span><span class="hit">        self.assertEqual(self.f_x + self.d_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_p_double_add_float(self):
</span><span class="hit">        self.assertEqual(self.p_x + self.f_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_float_add_p_double(self):
</span><span class="hit">        self.assertEqual(self.f_x + self.p_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_double_add_p_double(self):
</span><span class="hit">        self.assertEqual(self.d_x + self.p_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_p_double_add_double(self):
</span><span class="hit">        self.assertEqual(self.p_x + self.d_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TestRhichCompare(object):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_small = 2.1
</span><span class="hit">        self.f_large = 5.3
</span><span class="noop">
</span><span class="hit">    def test_small_lt_large(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt; self.d_large,
</span><span class="noop">                         self.f_large &gt; self.f_large)
</span><span class="hit">    def test_large_lt_small(self):
</span><span class="hit">        self.assertEqual(self.d_large &lt; self.d_small,
</span><span class="noop">                         self.f_large &lt; self.f_small)
</span><span class="hit">    def test_small_lt_small(self):
</span><span class="hit">        self.assertEqual(self.d_small &lt; self.d_small,
</span><span class="noop">                         self.f_small &lt; self.f_small)
</span><span class="hit">    def test_small_le_large(self):
</span><span class="hit">        self.assertEqual(self.d_small &lt;= self.d_large,
</span><span class="noop">                         self.f_small &lt;= self.f_large)
</span><span class="hit">    def test_large_le_small(self):
</span><span class="hit">        self.assertEqual(self.d_large &lt;= self.d_small,
</span><span class="noop">                         self.f_large &lt;= self.f_small)
</span><span class="hit">    def test_small_le_small(self):
</span><span class="hit">        self.assertEqual(self.d_small &lt;= self.d_small,
</span><span class="noop">                         self.f_small &lt;= self.f_small)
</span><span class="hit">    def test_small_eq_large(self):
</span><span class="hit">        self.assertEqual(self.d_small == self.d_large,
</span><span class="noop">                         self.f_small == self.f_large)
</span><span class="hit">    def test_large_eq_small(self):
</span><span class="hit">        self.assertEqual(self.d_large == self.d_small,
</span><span class="noop">                         self.f_large == self.f_small)
</span><span class="hit">    def test_small_eq_small(self):
</span><span class="hit">        self.assertEqual(self.d_small == self.d_small,
</span><span class="noop">                         self.f_small == self.f_small)
</span><span class="hit">    def test_small_gt_large(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt; self.d_large,
</span><span class="noop">                         self.f_small &gt; self.f_large)
</span><span class="hit">    def test_large_gt_small(self):
</span><span class="hit">        self.assertEqual(self.d_large &gt; self.d_small,
</span><span class="noop">                         self.f_large &gt; self.f_small)
</span><span class="hit">    def test_small_gt_small(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt; self.d_small,
</span><span class="noop">                         self.f_small &gt; self.f_small)
</span><span class="hit">    def test_small_ge_large(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt;= self.d_large,
</span><span class="noop">                         self.f_small &gt;= self.f_large)
</span><span class="hit">    def test_large_ge_small(self):
</span><span class="hit">        self.assertEqual(self.d_large &gt;= self.d_small,
</span><span class="noop">                         self.f_large &gt;= self.f_small)
</span><span class="hit">    def test_small_ge_small(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt;= self.d_small,
</span><span class="noop">                         self.f_small &gt;= self.f_small)
</span><span class="hit">    def test_small_ne_large(self):
</span><span class="hit">        self.assertEqual(self.d_small != self.d_large,
</span><span class="noop">                         self.f_small != self.f_large)
</span><span class="hit">    def test_large_ne_small(self):
</span><span class="hit">        self.assertEqual(self.d_large != self.d_small,
</span><span class="noop">                         self.f_large != self.f_small)
</span><span class="hit">    def test_small_ne_small(self):
</span><span class="hit">        self.assertEqual(self.d_small != self.d_small,
</span><span class="noop">                         self.f_small != self.f_small)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test3RhichCompareDouble(unittest.TestCase, TestRhichCompare):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestRhichCompare.setUp(self)
</span><span class="hit">        self.d_small = pointerutils.Double(self.f_small)
</span><span class="hit">        self.d_large = pointerutils.Double(self.f_large)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test4RhichComparePDouble(unittest.TestCase, TestRhichCompare):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestRhichCompare.setUp(self)
</span><span class="hit">        self._small = pointerutils.Double(self.f_small)
</span><span class="hit">        self._large = pointerutils.Double(self.f_large)
</span><span class="hit">        self.d_small = pointerutils.PDouble(self._small)
</span><span class="hit">        self.d_large = pointerutils.PDouble(self._large)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TestArithmetic(object):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_x = 2.1
</span><span class="hit">        self.f_y = 5.3
</span><span class="noop">
</span><span class="hit">    def test_add(self):
</span><span class="hit">        self.assertEqual(self.d_x + self.d_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_sub(self):
</span><span class="hit">        self.assertEqual(self.d_x - self.d_y,
</span><span class="noop">                         self.f_x - self.f_y)
</span><span class="hit">    def test_mul(self):
</span><span class="hit">        self.assertEqual(self.d_x * self.d_y,
</span><span class="noop">                         self.f_x * self.f_y)
</span><span class="hit">    def test_div(self):
</span><span class="hit">        self.assertEqual(self.d_x / self.d_y,
</span><span class="noop">                         self.f_x / self.f_y)
</span><span class="hit">    def test_floordiv(self):
</span><span class="hit">        self.assertEqual(self.d_x // self.d_y,
</span><span class="noop">                         self.f_x // self.f_y)
</span><span class="hit">    def test_truediv(self):
</span><span class="hit">        self.assertEqual(self.d_x / self.d_y,
</span><span class="noop">                         self.f_x / self.f_y)
</span><span class="hit">    def test_mod(self):
</span><span class="hit">        self.assertEqual(self.d_x % self.d_y,
</span><span class="noop">                         self.f_x % self.f_y)
</span><span class="hit">    def test_pow(self):
</span><span class="hit">        self.assertEqual(self.d_x ** self.d_y,
</span><span class="noop">                         self.f_x ** self.f_y)
</span><span class="hit">    def test_neg(self):
</span><span class="hit">        self.assertEqual(-self.d_x,
</span><span class="noop">                         -self.f_x)
</span><span class="hit">    def test_pos(self):
</span><span class="hit">        self.assertEqual(+self.d_x,
</span><span class="noop">                         +self.f_x)
</span><span class="hit">    def test_nonzero(self):
</span><span class="hit">        self.assertEqual(bool(self.d_x),
</span><span class="noop">                         bool(self.f_x))
</span><span class="hit">    def test_invert(self):
</span><span class="hit">        self.assertEqual(~self.d_x,
</span><span class="noop">                         1./self.f_x)
</span><span class="noop">
</span><span class="hit">class Test5ArithmeticDouble(unittest.TestCase, TestArithmetic):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestArithmetic.setUp(self)
</span><span class="hit">        self.d_x = pointerutils.Double(self.f_x)
</span><span class="hit">        self.d_y = pointerutils.Double(self.f_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test6ArithmeticPDouble(unittest.TestCase, TestArithmetic):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestArithmetic.setUp(self)
</span><span class="hit">        self._d_x = pointerutils.Double(self.f_x)
</span><span class="hit">        self._d_y = pointerutils.Double(self.f_y)
</span><span class="hit">        self.d_x = pointerutils.PDouble(self._d_x)
</span><span class="hit">        self.d_y = pointerutils.PDouble(self._d_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TestNumericConversion(object):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_x = 2.1
</span><span class="noop">
</span><span class="hit">    def test_int(self):
</span><span class="hit">        self.assertEqual(int(self.d_x),
</span><span class="noop">                         int(self.f_x))
</span><span class="noop">
</span><span class="hit">    def test_float(self):
</span><span class="hit">        self.assertEqual(float(self.d_x),
</span><span class="noop">                         float(self.f_x))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test7NumericConversionDouble(unittest.TestCase, TestNumericConversion):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestNumericConversion.setUp(self)
</span><span class="hit">        self.d_x = pointerutils.Double(self.f_x)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test8NumericConversionPDouble(unittest.TestCase, TestNumericConversion):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestNumericConversion.setUp(self)
</span><span class="hit">        self._d_x = pointerutils.Double(self.f_x)
</span><span class="hit">        self.d_x = pointerutils.PDouble(self._d_x)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TestInPlaceOperators(object):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_x = 2.1
</span><span class="hit">        self.f_y = 5.3
</span><span class="noop">
</span><span class="hit">    def test_iadd(self):
</span><span class="hit">        self.d_x += self.d_y
</span><span class="hit">        self.f_x += self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_isub(self):
</span><span class="hit">        self.d_x -= self.d_y
</span><span class="hit">        self.f_x -= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_imul(self):
</span><span class="hit">        self.d_x *= self.d_y
</span><span class="hit">        self.f_x *= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_idiv(self):
</span><span class="hit">        self.d_x /= self.d_y
</span><span class="hit">        self.f_x /= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_ifloordiv(self):
</span><span class="hit">        self.d_x //= self.d_y
</span><span class="hit">        self.f_x //= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_itruediv(self):
</span><span class="hit">        self.d_x /= self.d_y
</span><span class="hit">        self.f_x /= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_imod(self):
</span><span class="hit">        self.d_x %= self.d_y
</span><span class="hit">        self.f_x %= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="noop">
</span><span class="hit">class Test9InPlaceOperatorsDouble(unittest.TestCase, TestInPlaceOperators):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestInPlaceOperators.setUp(self)
</span><span class="hit">        self.d_x = pointerutils.Double(self.f_x)
</span><span class="hit">        self.d_y = pointerutils.Double(self.f_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test10InPlaceOperatorsPDouble(unittest.TestCase, TestInPlaceOperators):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestInPlaceOperators.setUp(self)
</span><span class="hit">        self._d_x = pointerutils.Double(self.f_x)
</span><span class="hit">        self._d_y = pointerutils.Double(self.f_y)
</span><span class="hit">        self.d_x = pointerutils.PDouble(self._d_x)
</span><span class="hit">        self.d_y = pointerutils.PDouble(self._d_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_02_timetools.py">unittests_02_timetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="hit">import datetime
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import timetools
</span><span class="noop">
</span><span class="hit">class Test01DateInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.refdate_day = datetime.datetime(1996, 11, 1)
</span><span class="hit">        self.refdate_hour = datetime.datetime(1996, 11, 1, 12)
</span><span class="hit">        self.refdate_minute = datetime.datetime(1996, 11, 1, 12, 30)
</span><span class="hit">        self.refdate_second = datetime.datetime(1996, 11, 1, 12, 30, 5)
</span><span class="noop">
</span><span class="hit">    def test_01_os_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_day,
</span><span class="noop">                         timetools.Date(&#39;1996_11_01&#39;).datetime)
</span><span class="hit">    def test_02_os_style_hour(self):
</span><span class="hit">        self.assertEqual(self.refdate_hour,
</span><span class="noop">                         timetools.Date(&#39;1996_11_01_12&#39;).datetime)
</span><span class="hit">    def test_03_os_style_minute(self):
</span><span class="hit">        self.assertEqual(self.refdate_minute,
</span><span class="noop">                         timetools.Date(&#39;1996_11_01_12_30&#39;).datetime)
</span><span class="hit">    def test_03_os_style_second(self):
</span><span class="hit">        self.assertEqual(self.refdate_second,
</span><span class="noop">                         timetools.Date(&#39;1996_11_01_12_30_05&#39;).datetime)
</span><span class="noop">
</span><span class="hit">    def test_04_iso_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_day,
</span><span class="noop">                         timetools.Date(&#39;1996.11.01&#39;).datetime)
</span><span class="hit">    def test_05_iso_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_hour,
</span><span class="noop">                         timetools.Date(&#39;1996.11.01 12&#39;).datetime)
</span><span class="hit">    def test_06_iso_style_minute(self):
</span><span class="hit">        self.assertEqual(self.refdate_minute,
</span><span class="noop">                         timetools.Date(&#39;1996.11.01 12:30&#39;).datetime)
</span><span class="hit">    def test_07_iso_style_second(self):
</span><span class="hit">        self.assertEqual(self.refdate_second,
</span><span class="noop">                         timetools.Date(&#39;1996.11.01 12:30:05&#39;).datetime)
</span><span class="noop">
</span><span class="hit">    def test_08_din_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_day,
</span><span class="noop">                         timetools.Date(&#39;01.11.1996&#39;).datetime)
</span><span class="hit">    def test_09_din_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_hour,
</span><span class="noop">                         timetools.Date(&#39;01.11.1996 12&#39;).datetime)
</span><span class="hit">    def test_10_din_style_minute(self):
</span><span class="hit">        self.assertEqual(self.refdate_minute,
</span><span class="noop">                         timetools.Date(&#39;01.11.1996 12:30&#39;).datetime)
</span><span class="hit">    def test_11_din_style_second(self):
</span><span class="hit">        self.assertEqual(self.refdate_second,
</span><span class="noop">                         timetools.Date(&#39;01.11.1996 12:30:05&#39;).datetime)
</span><span class="noop">
</span><span class="hit">    def test_11_datetime_second(self):
</span><span class="hit">        self.assertEqual(self.refdate_second,
</span><span class="noop">                         timetools.Date(self.refdate_second).datetime)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test02DateProperties(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.refdate = datetime.datetime(1996, 11, 1, 12, 30, 5)
</span><span class="hit">        self.testdate = timetools.Date(self.refdate)
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        self.testdate.refmonth = &#39;November&#39;
</span><span class="noop">
</span><span class="hit">    def test_01_get_year(self):
</span><span class="hit">        self.assertEqual(self.refdate.year, self.testdate.year)
</span><span class="hit">    def test_02_get_month(self):
</span><span class="hit">        self.assertEqual(self.refdate.month, self.testdate.month)
</span><span class="hit">    def test_03_get_day(self):
</span><span class="hit">        self.assertEqual(self.refdate.day, self.testdate.day)
</span><span class="hit">    def test_04_get_hour(self):
</span><span class="hit">        self.assertEqual(self.refdate.hour, self.testdate.hour)
</span><span class="hit">    def test_05_get_minute(self):
</span><span class="hit">        self.assertEqual(self.refdate.minute, self.testdate.minute)
</span><span class="hit">    def test_06_get_second(self):
</span><span class="hit">        self.assertEqual(self.refdate.second, self.testdate.second)
</span><span class="noop">
</span><span class="hit">    def test_07_set_year(self):
</span><span class="hit">        self.testdate.year = 2000
</span><span class="hit">        refdate = datetime.datetime(2000, 11, 1, 12, 30, 5)
</span><span class="hit">        self.assertEqual(refdate.year, self.testdate.datetime.year)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.year = &#39;wrong&#39;
</span><span class="hit">    def test_08_set_month(self):
</span><span class="hit">        self.testdate.month = 5
</span><span class="hit">        refdate = datetime.datetime(1996, 5, 1, 12, 30, 5)
</span><span class="hit">        self.assertEqual(refdate.month, self.testdate.datetime.month)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.month = &#39;wrong&#39;
</span><span class="hit">    def test_09_set_day(self):
</span><span class="hit">        self.testdate.day = 30
</span><span class="hit">        refdate = datetime.datetime(1996, 11, 30, 12, 30, 5)
</span><span class="hit">        self.assertEqual(refdate.day, self.testdate.datetime.day)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.day = &#39;wrong&#39;
</span><span class="hit">    def test_10_set_hour(self):
</span><span class="hit">        self.testdate.hour = 0
</span><span class="hit">        refdate = datetime.datetime(1996, 11, 1, 0, 30, 5)
</span><span class="hit">        self.assertEqual(refdate.hour, self.testdate.datetime.hour)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.hour = &#39;wrong&#39;
</span><span class="hit">    def test_11_set_minute(self):
</span><span class="hit">        self.testdate.minute = 59
</span><span class="hit">        refdate = datetime.datetime(1996, 11, 1, 12, 59, 5)
</span><span class="hit">        self.assertEqual(refdate.minute, self.testdate.datetime.minute)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.minute = &#39;wrong&#39;
</span><span class="hit">    def test_12_set_second(self):
</span><span class="hit">        self.testdate.second = 7
</span><span class="hit">        refdate = datetime.datetime(1996, 11, 1, 12, 30, 7)
</span><span class="hit">        self.assertEqual(refdate.second, self.testdate.datetime.second)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.second = &#39;wrong&#39;
</span><span class="hit">    def test_13_get_wateryear(self):
</span><span class="hit">        self.assertEqual(self.testdate.wateryear, self.testdate.year+1)
</span><span class="hit">        self.testdate.month = 10
</span><span class="hit">        self.assertEqual(self.testdate.wateryear, self.testdate.year)
</span><span class="hit">    def test_14_set_refmonth(self):
</span><span class="hit">        self.testdate.refmonth = 3
</span><span class="hit">        self.assertEqual(self.testdate.refmonth, 3)
</span><span class="hit">        self.testdate.refmonth = &#39;July&#39;
</span><span class="hit">        self.assertEqual(self.testdate.refmonth, 7)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.refmonth = &#39;Ju&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test03DateStyle(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.date = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_remember_style(self):
</span><span class="hit">        self.assertEqual(self.date.style, &#39;din&#39;)
</span><span class="hit">    def test_02_dontforget_style(self):
</span><span class="hit">        self.date.string(&#39;iso&#39;)
</span><span class="hit">        self.assertEqual(self.date.style, &#39;din&#39;)
</span><span class="hit">    def test_03_change_style(self):
</span><span class="hit">        self.date.style = &#39;iso&#39;
</span><span class="hit">        self.assertEqual(self.date.style, &#39;iso&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test04DateCopy(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.date = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_ids(self):
</span><span class="hit">        testdate = self.date.copy()
</span><span class="hit">        self.assertNotEqual(id(testdate), id(self.date))
</span><span class="hit">    def test_02_values(self):
</span><span class="hit">        testdate = self.date.copy()
</span><span class="hit">        testdate.year = 2000
</span><span class="hit">        self.assertNotEqual(testdate.datetime.year, self.date.datetime.year)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test05DateComparisons(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.early1 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.early2 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.late = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_lt(self):
</span><span class="hit">        self.assertTrue(self.early1 &lt; self.late)
</span><span class="hit">        self.assertFalse(self.early1 &lt; self.early2)
</span><span class="hit">        self.assertFalse(self.late &lt; self.early2)
</span><span class="hit">    def test_021_le(self):
</span><span class="hit">        self.assertTrue(self.early1 &lt;= self.late)
</span><span class="hit">        self.assertTrue(self.early1 &lt;= self.early2)
</span><span class="hit">        self.assertFalse(self.late &lt;= self.early2)
</span><span class="hit">    def test_03_eq(self):
</span><span class="hit">        self.assertFalse(self.early1 == self.late)
</span><span class="hit">        self.assertTrue(self.early1 == self.early2)
</span><span class="hit">        self.assertFalse(self.late == self.early2)
</span><span class="hit">    def test_04_ne(self):
</span><span class="hit">        self.assertTrue(self.early1 != self.late)
</span><span class="hit">        self.assertFalse(self.early1 != self.early2)
</span><span class="hit">        self.assertTrue(self.late != self.early2)
</span><span class="hit">    def test_05_gt(self):
</span><span class="hit">        self.assertFalse(self.early1 &gt; self.late)
</span><span class="hit">        self.assertFalse(self.early1 &gt; self.early2)
</span><span class="hit">        self.assertTrue(self.late &gt; self.early2)
</span><span class="hit">    def test_06_ge(self):
</span><span class="hit">        self.assertFalse(self.early1 &gt;= self.late)
</span><span class="hit">        self.assertTrue(self.early1 &gt;= self.early2)
</span><span class="hit">        self.assertTrue(self.late &gt;= self.early2)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test06DateArithmetic(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.earlydate = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.latedate = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.period = timetools.Period(&#39;365d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_add(self):
</span><span class="hit">        testdate = self.earlydate + self.period
</span><span class="hit">        self.assertEqual(self.latedate, testdate)
</span><span class="hit">        self.assertEqual(testdate.style, &#39;din&#39;)
</span><span class="hit">    def test_02_iadd(self):
</span><span class="hit">        self.earlydate += self.period
</span><span class="hit">        self.assertEqual(self.earlydate, self.latedate)
</span><span class="hit">        self.assertEqual(self.earlydate.style, &#39;din&#39;)
</span><span class="hit">    def test_03_sub(self):
</span><span class="hit">        testdate = self.latedate - self.period
</span><span class="hit">        self.assertEqual(self.earlydate, testdate)
</span><span class="hit">        self.assertEqual(testdate.style, &#39;din&#39;)
</span><span class="hit">    def test_04_isub(self):
</span><span class="hit">        self.latedate -= self.period
</span><span class="hit">        self.assertEqual(self.latedate, self.earlydate)
</span><span class="hit">        self.assertEqual(self.latedate.style, &#39;din&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test07PeriodInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def test_01_string_day(self):
</span><span class="hit">        self.assertEqual(datetime.timedelta(1),
</span><span class="noop">                         timetools.Period(&#39;1d&#39;).timedelta)
</span><span class="hit">        self.assertEqual(datetime.timedelta(365),
</span><span class="noop">                         timetools.Period(&#39;365d&#39;).timedelta)
</span><span class="hit">    def test_02_string_hour(self):
</span><span class="hit">        self.assertEqual(datetime.timedelta(0, 60*60),
</span><span class="noop">                         timetools.Period(&#39;1h&#39;).timedelta)
</span><span class="hit">    def test_03_string_minute(self):
</span><span class="hit">        self.assertEqual(datetime.timedelta(0, 60),
</span><span class="noop">                         timetools.Period(&#39;1m&#39;).timedelta)
</span><span class="hit">    def test_04_string_second(self):
</span><span class="hit">        self.assertEqual(datetime.timedelta(0, 1),
</span><span class="noop">                         timetools.Period(&#39;1s&#39;).timedelta)
</span><span class="hit">    def test_05_timedelta(self):
</span><span class="hit">        timedelta = datetime.timedelta(365)
</span><span class="hit">        self.assertEqual(timedelta, timetools.Period(timedelta).timedelta)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test08PeriodProperties(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        seconds = int(60*60*24*365*3.2)
</span><span class="hit">        self.refperiod = datetime.timedelta(0, seconds)
</span><span class="hit">        self.testperiod = timetools.Period(&#39;%ds&#39; % seconds)
</span><span class="noop">
</span><span class="hit">    def test_01_get_days(self):
</span><span class="hit">        self.assertEqual(self.refperiod.total_seconds()/60/60/24,
</span><span class="noop">                         self.testperiod.days)
</span><span class="hit">    def test_02_get_hours(self):
</span><span class="hit">        self.assertEqual(self.refperiod.total_seconds()/60/60,
</span><span class="noop">                         self.testperiod.hours)
</span><span class="hit">    def test_03_get_minutes(self):
</span><span class="hit">        self.assertEqual(self.refperiod.total_seconds()/60,
</span><span class="noop">                         self.testperiod.minutes)
</span><span class="hit">    def test_04_get_seconds(self):
</span><span class="hit">        self.assertEqual(self.refperiod.total_seconds(),
</span><span class="noop">                         self.testperiod.seconds)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test09PeriodUnit(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def test_01_day(self):
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;365d&#39;).unit, &#39;d&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1d&#39;).unit, &#39;d&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;24h&#39;).unit, &#39;d&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1440m&#39;).unit, &#39;d&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;86400m&#39;).unit, &#39;d&#39;)
</span><span class="hit">    def test_02_hour(self):
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;25h&#39;).unit, &#39;h&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1h&#39;).unit, &#39;h&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;60m&#39;).unit, &#39;h&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;3600s&#39;).unit, &#39;h&#39;)
</span><span class="hit">    def test_03_minute(self):
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;777m&#39;).unit, &#39;m&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1m&#39;).unit, &#39;m&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;60s&#39;).unit, &#39;m&#39;)
</span><span class="hit">    def test_04_second(self):
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;999s&#39;).unit, &#39;s&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1s&#39;).unit, &#39;s&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test10PeriodCopy(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.period = timetools.Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_ids(self):
</span><span class="hit">        testperiod = self.period.copy()
</span><span class="hit">        self.assertNotEqual(id(testperiod), id(self.period))
</span><span class="hit">    def test_02_values(self):
</span><span class="hit">        testperiod = self.period.copy()
</span><span class="hit">        testperiod += &#39;1d&#39;
</span><span class="hit">        self.assertNotEqual(testperiod.timedelta,
</span><span class="noop">                            self.period.timedelta)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test11PeriodComparisons(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.short1 = timetools.Period(&#39;1h&#39;)
</span><span class="hit">        self.short2 = timetools.Period(&#39;1h&#39;)
</span><span class="hit">        self.long = timetools.Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_lt(self):
</span><span class="hit">        self.assertTrue(self.short1 &lt; self.long)
</span><span class="hit">        self.assertFalse(self.short1 &lt; self.short2)
</span><span class="hit">        self.assertFalse(self.long &lt; self.short2)
</span><span class="hit">    def test_021_le(self):
</span><span class="hit">        self.assertTrue(self.short1 &lt;= self.long)
</span><span class="hit">        self.assertTrue(self.short1 &lt;= self.short2)
</span><span class="hit">        self.assertFalse(self.long &lt;= self.short2)
</span><span class="hit">    def test_03_eq(self):
</span><span class="hit">        self.assertFalse(self.short1 == self.long)
</span><span class="hit">        self.assertTrue(self.short1 == self.short2)
</span><span class="hit">        self.assertFalse(self.long == self.short2)
</span><span class="hit">    def test_04_ne(self):
</span><span class="hit">        self.assertTrue(self.short1 != self.long)
</span><span class="hit">        self.assertFalse(self.short1 != self.short2)
</span><span class="hit">        self.assertTrue(self.long != self.short2)
</span><span class="hit">    def test_05_gt(self):
</span><span class="hit">        self.assertFalse(self.short1 &gt; self.long)
</span><span class="hit">        self.assertFalse(self.short1 &gt; self.short2)
</span><span class="hit">        self.assertTrue(self.long &gt; self.short2)
</span><span class="hit">    def test_06_ge(self):
</span><span class="hit">        self.assertFalse(self.short1 &gt;= self.long)
</span><span class="hit">        self.assertTrue(self.short1 &gt;= self.short2)
</span><span class="hit">        self.assertTrue(self.long &gt;= self.short2)
</span><span class="noop">#    def test_07_true(self):
</span><span class="noop">#        self.assertTrue(self.short1)
</span><span class="noop">#        self.assertTrue(self.long)
</span><span class="noop">#        self.assertFalse(timetools.Period(&#39;0d&#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test12PeriodArithmetic(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.year97 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.year98 = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.oneyear = timetools.Period(&#39;365d&#39;)
</span><span class="hit">        self.oneday = timetools.Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_add(self):
</span><span class="hit">        testdate = self.oneyear + self.year97
</span><span class="hit">        self.assertEqual(self.year98, testdate)
</span><span class="hit">        self.assertEqual(testdate.style, &#39;din&#39;)
</span><span class="hit">        self.assertEqual(self.oneyear + self.oneday, timetools.Period(&#39;366d&#39;))
</span><span class="hit">    def test_02_iadd(self):
</span><span class="hit">        self.oneyear += self.oneday
</span><span class="hit">        self.assertEqual(self.oneyear, timetools.Period(&#39;366d&#39;))
</span><span class="hit">    def test_03_sub(self):
</span><span class="hit">        testdate = self.year98 - self.oneyear
</span><span class="hit">        self.assertEqual(self.year97, testdate)
</span><span class="hit">    def test_04_isub(self):
</span><span class="hit">        self.oneyear -= self.oneday
</span><span class="hit">        self.assertEqual(self.oneyear, timetools.Period(&#39;364d&#39;))
</span><span class="hit">    def test_05_mul(self):
</span><span class="hit">        testperiod = self.oneday * 365
</span><span class="hit">        self.assertEqual(testperiod, self.oneyear)
</span><span class="hit">    def test_06_rmul(self):
</span><span class="hit">        testperiod = 365 * self.oneday
</span><span class="hit">        self.assertEqual(testperiod, self.oneyear)
</span><span class="hit">    def test_07_imul(self):
</span><span class="hit">        self.oneday *= 365
</span><span class="hit">        self.assertEqual(self.oneday, self.oneyear)
</span><span class="hit">    def test_08_div(self):
</span><span class="hit">        testperiod = self.oneyear / self.oneday
</span><span class="hit">        self.assertEqual(testperiod, 365)
</span><span class="hit">        testinteger = self.oneyear / 365
</span><span class="hit">        self.assertEqual(testinteger, self.oneday)
</span><span class="hit">    def test_09_idiv(self):
</span><span class="hit">        self.oneyear /= 365
</span><span class="hit">        self.assertEqual(self.oneyear,  self.oneday)
</span><span class="hit">    def test_10_mod(self):
</span><span class="hit">        self.assertFalse(self.oneyear % self.oneday)
</span><span class="hit">        self.assertTrue(self.oneyear % timetools.Period(&#39;360d&#39;))
</span><span class="hit">    def test_11_floordiv(self):
</span><span class="hit">        self.assertTrue(self.oneyear // self.oneday)
</span><span class="hit">        self.assertFalse(self.oneyear // timetools.Period(&#39;360d&#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test13TimegridInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.year97 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.year98 = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.oneday = timetools.Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_right(self):
</span><span class="hit">        timetools.Timegrid(self.year97, self.year98, self.oneday)
</span><span class="hit">    def test_02_wrong(self):
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            timetools.Timegrid(self.year97, self.year97, self.oneday)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            timetools.Timegrid(self.year98, self.year97, self.oneday)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            timetools.Timegrid(self.year97, self.year98,
</span><span class="noop">                               timetools.Period(&#39;360d&#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test14TimegridIterable(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.year97 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.year98 = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.oneday = timetools.Period(&#39;1d&#39;)
</span><span class="hit">        self.timegrid = timetools.Timegrid(self.year97, self.year98,
</span><span class="noop">                                           self.oneday)
</span><span class="noop">
</span><span class="hit">    def test_01_indexing_with_integers(self):
</span><span class="hit">        self.assertEqual(self.timegrid[0], self.year97)
</span><span class="hit">        self.assertEqual(self.timegrid[365], self.year98)
</span><span class="hit">        self.assertEqual(self.timegrid[1], self.year97+self.oneday)
</span><span class="hit">        self.assertEqual(self.timegrid[-1], self.year97-self.oneday)
</span><span class="hit">        self.assertEqual(self.timegrid[366], self.year98+self.oneday)
</span><span class="hit">        self.assertEqual(self.timegrid[364], self.year98-self.oneday)
</span><span class="noop">
</span><span class="hit">    def test_02_indexing_with_dates(self):
</span><span class="hit">        self.assertEqual(self.timegrid[self.year97], 0)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year98], 365)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year97+self.oneday], 1)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year97-self.oneday], -1)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year98+self.oneday], 366)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year98-self.oneday], 364)
</span><span class="noop">
</span><span class="hit">    def test_03_indexing_errors(self):
</span><span class="hit">        with self.assertRaises(TypeError):
</span><span class="hit">            self.timegrid[0.]
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.timegrid[self.year97 + &#39;1m&#39;]
</span><span class="noop">
</span><span class="hit">    def test_04_iteration(self):
</span><span class="hit">        self.assertEqual(list(self.timegrid)[1], self.year97+self.oneday)
</span><span class="noop">
</span><span class="hit">    def test_05_len(self):
</span><span class="hit">        self.assertEqual(len(self.timegrid), 365)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test15TimegridComparisons(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.year97 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.year98 = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.oneday = timetools.Period(&#39;1d&#39;)
</span><span class="hit">        self.onehour = timetools.Period(&#39;1h&#39;)
</span><span class="hit">        self.timegrid = timetools.Timegrid(self.year97, self.year98,
</span><span class="noop">                                           self.oneday)
</span><span class="noop">
</span><span class="hit">    def test_01_eq(self):
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        self.assertTrue(timegridtest == self.timegrid)
</span><span class="hit">        timegridtest.firstdate.year = 1995
</span><span class="hit">        self.assertFalse(timegridtest == self.timegrid)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.lastdate.year = 1998
</span><span class="hit">        self.assertFalse(timegridtest == self.timegrid)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.stepsize = self.onehour
</span><span class="hit">        self.assertFalse(timegridtest == self.timegrid)
</span><span class="noop">
</span><span class="hit">    def test_02_ne(self):
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        self.assertFalse(timegridtest != self.timegrid)
</span><span class="hit">        timegridtest.firstdate.year = 1995
</span><span class="hit">        self.assertTrue(timegridtest != self.timegrid)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.lastdate.year = 1998
</span><span class="hit">        self.assertTrue(timegridtest != self.timegrid)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.stepsize = self.onehour
</span><span class="hit">        self.assertTrue(timegridtest != self.timegrid)
</span><span class="noop">
</span><span class="hit">    def test_03_date_in(self):
</span><span class="hit">        self.assertTrue(self.year97 in self.timegrid)
</span><span class="hit">        self.assertTrue(self.year98 in self.timegrid)
</span><span class="hit">        self.assertTrue(self.year97+&#39;1d&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year97-&#39;1d&#39; in self.timegrid)
</span><span class="hit">        self.assertTrue(self.year98-&#39;1d&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year98+&#39;1d&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year97+&#39;12h&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year97-&#39;12h&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year98-&#39;12h&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year98+&#39;12h&#39; in self.timegrid)
</span><span class="noop">
</span><span class="hit">    def test_04_timegrid_in(self):
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        self.assertTrue(timegridtest in self.timegrid)
</span><span class="hit">        self.assertTrue(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest.firstdate -= &#39;1d&#39;
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertTrue(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.lastdate += &#39;1d&#39;
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertTrue(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.firstdate -= &#39;1d&#39;
</span><span class="hit">        timegridtest.lastdate += &#39;1d&#39;
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertTrue(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.firstdate += &#39;12h&#39;
</span><span class="hit">        timegridtest.lastdate -= &#39;12d&#39;
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertFalse(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.stepsize /= 24
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertFalse(self.timegrid in timegridtest)</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_03_filetools.py">unittests_03_filetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="noop">#from __future__ import division, print_function
</span><span class="noop">#import os
</span><span class="noop">#import unittest
</span><span class="noop">## ...from HydPy
</span><span class="noop">#from hydpy.core import filetools
</span><span class="noop">#from hydpy import pub
</span><span class="noop">#
</span><span class="noop">#PROJECTNAME = &#39;projectnamemock&#39;
</span><span class="noop">#
</span><span class="noop">#class NetworkFileMock(filetools.NetworkFile):
</span><span class="noop">#    def checkpath(self):
</span><span class="noop">#        pass
</span><span class="noop">#
</span><span class="noop">#class Test02NetwortFile(unittest.TestCase):
</span><span class="noop">#
</span><span class="noop">#    def setUp(self):
</span><span class="noop">#        pub.projectname = PROJECTNAME
</span><span class="noop">#        self.testdirectory = os.path.abspath(&#39;controlfiles&#39;)
</span><span class="noop">#
</span><span class="noop">#    def test_01_getdirectory(self):
</span><span class="noop">#        networkfile = NetworkFileMock()
</span><span class="noop">#        self.assertEqual(networkfile.directory, self.testdirectory)
</span><span class="noop">#
</span><span class="noop">#    def test_02_getfilename(self):
</span><span class="noop">#        networkfile = NetworkFileMock()
</span><span class="noop">#        self.assertEqual(networkfile.filename, PROJECTNAME+&#39;_network.py&#39;)
</span><span class="noop">#        networkfile._filename = &#39;testname&#39;
</span><span class="noop">#        self.assertEqual(networkfile.filename, &#39;testname.py&#39;)
</span><span class="noop">#
</span><span class="noop">#    def test_03_setwrongfilename(self):
</span><span class="noop">#        with self.assertRaises(IOError):
</span><span class="noop">#             filetools.NetworkFile(&#39;testname&#39;)
</span><span class="noop">#
</span><span class="noop">#    def test_04_setcorrectfilename(self):
</span><span class="noop">#        networkfile = NetworkFileMock(&#39;testname&#39;)
</span><span class="noop">#        self.assertEqual(networkfile.filename, &#39;testname.py&#39;)
</span><span class="noop">#        networkfile = NetworkFileMock(&#39;testname.py&#39;)
</span><span class="noop">#        self.assertEqual(networkfile.filename, &#39;testname.py&#39;)
</span><span class="noop">#        networkfile.filename = None
</span><span class="noop">#        self.assertEqual(networkfile.filename, PROJECTNAME+&#39;_network.py&#39;)
</span><span class="noop">#        networkfile = NetworkFileMock()
</span><span class="noop">#        networkfile.filename = &#39;testname&#39;
</span><span class="noop">#        self.assertEqual(networkfile.filename, &#39;testname.py&#39;)
</span><span class="noop">#
</span><span class="noop">#    def test_5_savefile(self):
</span><span class="noop">#        pass
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_04_devicetools.py">unittests_04_devicetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import sys
</span><span class="hit">import unittest
</span><span class="noop"># ...from HydPy
</span><span class="hit">sys.path.insert(0, &#39;..\\..\\..\\HydPy&#39;)
</span><span class="hit">from hydpy.core.devicetools import *
</span><span class="hit">from hydpy.core.connectiontools import *
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test01NodeCreation(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clear_registry()
</span><span class="hit">        Node.clear_registry()
</span><span class="noop">
</span><span class="hit">    def test_01_fromstring(self):
</span><span class="hit">        test1a = Node(&#39;test1&#39;)
</span><span class="hit">        self.assertIsInstance(test1a, Node)
</span><span class="hit">        self.assertEqual(test1a.name, &#39;test1&#39;)
</span><span class="hit">        test1b = Node(&#39;test1&#39;)
</span><span class="hit">        self.assertIs(test1a, test1b)
</span><span class="hit">        test2 = Node(&#39;test2&#39;)
</span><span class="hit">        self.assertIsNot(test1a, test2)
</span><span class="hit">    def test_02_fromnode(self):
</span><span class="hit">        test1 = Node(&#39;test&#39;)
</span><span class="hit">        test2 = Node(test1)
</span><span class="hit">        self.assertIsInstance(test2, Node)
</span><span class="hit">        self.assertIs(test1, test2)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Node([test1, test2])
</span><span class="hit">    def test_03_fromwronginput(self):
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Node([&#39;test&#39;])
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Node(5)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Node({&#39;test&#39;: &#39;test&#39;})
</span><span class="hit">    def test_04_attributes(self):
</span><span class="hit">        test1 = Node(&#39;test1&#39;)
</span><span class="hit">        self.assertIsInstance(test1.entries, Connections)
</span><span class="hit">        self.assertIsInstance(test1.exits, Connections)
</span><span class="hit">        self.assertEqual(test1.variable, &#39;Q&#39;)
</span><span class="hit">        test2 = Node(&#39;test2&#39;, &#39;T&#39;)
</span><span class="hit">        self.assertIsInstance(test2.entries, Connections)
</span><span class="hit">        self.assertIsInstance(test2.exits, Connections)
</span><span class="hit">        self.assertEqual(test2.variable, &#39;T&#39;)
</span><span class="hit">    def test_03_wrongredefinition(self):
</span><span class="hit">        test = Node(&#39;test&#39;)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Node(&#39;test&#39;, &#39;T&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test02ElementCreation(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clear_registry()
</span><span class="hit">        Node.clear_registry()
</span><span class="noop">
</span><span class="hit">    def test_01_fromstring(self):
</span><span class="hit">        test1a = Element(&#39;test1&#39;)
</span><span class="hit">        self.assertIsInstance(test1a, Element)
</span><span class="hit">        self.assertEqual(test1a.name, &#39;test1&#39;)
</span><span class="hit">        test1b = Element(&#39;test1&#39;)
</span><span class="hit">        self.assertIs(test1a, test1b)
</span><span class="hit">        test2 = Element(&#39;test2&#39;)
</span><span class="hit">        self.assertIsNot(test1a, test2)
</span><span class="hit">    def test_02_fromelement(self):
</span><span class="hit">        test1 = Element(&#39;test&#39;)
</span><span class="hit">        test2 = Element(test1)
</span><span class="hit">        self.assertIsInstance(test2, Element)
</span><span class="hit">        self.assertIs(test1, test2)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element([test1, test2])
</span><span class="hit">    def test_03_fromwronginput(self):
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Element([&#39;test&#39;])
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Element(5)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Element({&#39;test&#39;: &#39;test&#39;})
</span><span class="hit">    def test_04_attributes(self):
</span><span class="hit">        test = Element(&#39;test&#39;)
</span><span class="hit">        self.assertIsInstance(test.inlets, Connections)
</span><span class="hit">        self.assertIsInstance(test.outlets, Connections)
</span><span class="hit">        self.assertIsInstance(test.receivers, Connections)
</span><span class="hit">        self.assertIsInstance(test.senders, Connections)
</span><span class="hit">        self.assertIsNone(test.model)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test03ElementInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.n1Q = Node(&#39;n1Q&#39;, &#39;Q&#39;)
</span><span class="hit">        self.n2Q = Node(&#39;n2Q&#39;, &#39;Q&#39;)
</span><span class="hit">        self.n3W = Node(&#39;n3W&#39;, &#39;W&#39;)
</span><span class="hit">        self.n4T = Node(&#39;n4T&#39;, &#39;T&#39;)
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clear_registry()
</span><span class="hit">        Node.clear_registry()
</span><span class="noop">
</span><span class="hit">    def test_01_inlet(self):
</span><span class="hit">        e = Element(&#39;e&#39;, inlets=self.n1Q)
</span><span class="hit">        self.assertIsInstance(e, Element)
</span><span class="hit">        self.assertIs(e.inlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIsInstance(self.n1Q.exits.e, Element)
</span><span class="hit">        self.assertIs(self.n1Q.exits.e, e)
</span><span class="hit">        self.assertIs(e.inlets.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, inlets=self.n1Q)
</span><span class="hit">        self.assertIs(e.inlets.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, inlets=self.n4T)
</span><span class="hit">        self.assertIs(e.inlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e.inlets.n4T, self.n4T)
</span><span class="hit">        e = Element(&#39;e&#39;, inlets=self.n3W)
</span><span class="hit">        self.assertIs(e.inlets.n3W, self.n3W)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            e = Element(&#39;e&#39;, outlets=self.n2Q)
</span><span class="hit">            e = Element(&#39;e&#39;, inlets=self.n2Q)
</span><span class="noop">
</span><span class="hit">    def test_02_outlet(self):
</span><span class="hit">        e = Element(&#39;e&#39;, outlets=self.n1Q)
</span><span class="hit">        self.assertIsInstance(e, Element)
</span><span class="hit">        self.assertIs(e.outlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIsInstance(self.n1Q.entries.e, Element)
</span><span class="hit">        self.assertIs(self.n1Q.entries.e, e)
</span><span class="hit">        e = Element(&#39;e&#39;, outlets=self.n1Q)
</span><span class="hit">        self.assertIs(e.outlets.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, outlets=self.n4T)
</span><span class="hit">        self.assertIs(e.outlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e.outlets.n4T, self.n4T)
</span><span class="hit">        e = Element(&#39;e&#39;, outlets=self.n3W)
</span><span class="hit">        self.assertIs(e.outlets.n3W, self.n3W)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            e = Element(&#39;e&#39;, inlets=self.n2Q)
</span><span class="hit">            e = Element(&#39;e&#39;, outlets=self.n2Q)
</span><span class="noop">
</span><span class="hit">    def test_03_receiver(self):
</span><span class="hit">        e = Element(&#39;e&#39;, receivers=self.n1Q)
</span><span class="hit">        self.assertIsInstance(e, Element)
</span><span class="hit">        self.assertIs(e.receivers.n1Q, self.n1Q)
</span><span class="hit">        self.assertIsInstance(self.n1Q.exits.e, Element)
</span><span class="hit">        self.assertIs(self.n1Q.exits.e, e)
</span><span class="hit">        e = Element(&#39;e&#39;, receivers=self.n1Q)
</span><span class="hit">        self.assertIs(e.receivers.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, receivers=self.n4T)
</span><span class="hit">        self.assertIs(e.receivers.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e.receivers.n4T, self.n4T)
</span><span class="hit">        e = Element(&#39;e&#39;, receivers=self.n3W)
</span><span class="hit">        self.assertIs(e.receivers.n3W, self.n3W)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            e = Element(&#39;e&#39;, senders=self.n2Q)
</span><span class="hit">            e = Element(&#39;e&#39;, receivers=self.n2Q)
</span><span class="noop">
</span><span class="hit">    def test_04_sender(self):
</span><span class="hit">        e = Element(&#39;e&#39;, senders=self.n1Q)
</span><span class="hit">        self.assertIsInstance(e, Element)
</span><span class="hit">        self.assertIs(e.senders.n1Q, self.n1Q)
</span><span class="hit">        self.assertIsInstance(self.n1Q.entries.e, Element)
</span><span class="hit">        self.assertIs(self.n1Q.entries.e, e)
</span><span class="hit">        e = Element(&#39;e&#39;, senders=self.n1Q)
</span><span class="hit">        self.assertIs(e.senders.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, senders=self.n4T)
</span><span class="hit">        self.assertIs(e.senders.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e.senders.n4T, self.n4T)
</span><span class="hit">        e = Element(&#39;e&#39;, senders=self.n3W)
</span><span class="hit">        self.assertIs(e.senders.n3W, self.n3W)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            e = Element(&#39;e&#39;, receivers=self.n2Q)
</span><span class="hit">            e = Element(&#39;e&#39;, senders=self.n2Q)
</span><span class="noop">
</span><span class="hit">    def test_05_inletandoutlet(self):
</span><span class="hit">        e1 = Element(&#39;e1&#39;, inlets=self.n1Q, outlets=self.n2Q)
</span><span class="hit">        self.assertIs(e1.inlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e1.outlets.n2Q, self.n2Q)
</span><span class="hit">        e2 = Element(&#39;e2&#39;, inlets=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e2&#39;, outlets=self.n1Q)
</span><span class="hit">        e3 = Element(&#39;e3&#39;, outlets=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e3&#39;, inlets=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e4&#39;, inlets=self.n1Q, outlets=self.n1Q)
</span><span class="noop">
</span><span class="hit">    def test_06_receiverandsender(self):
</span><span class="hit">        e1 = Element(&#39;e1&#39;, receivers=self.n1Q, senders=self.n2Q)
</span><span class="hit">        self.assertIs(e1.receivers.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e1.senders.n2Q, self.n2Q)
</span><span class="hit">        e2 = Element(&#39;e2&#39;, receivers=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e2&#39;, senders=self.n1Q)
</span><span class="hit">        e3 = Element(&#39;e3&#39;, senders=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e3&#39;, receivers=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e4&#39;, receivers=self.n1Q, senders=self.n1Q)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">#class Test04NodesCreation(unittest.TestCase):
</span><span class="noop">#
</span><span class="noop">#    def setUp(self):
</span><span class="noop">#        asdf
</span><span class="noop">
</span><span class="hit">class Test05ElementsCreation(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.element1 = Element(&#39;element1&#39;)
</span><span class="hit">        self.element2 = Element(&#39;element2&#39;)
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clear_registry()
</span><span class="hit">        Node.clear_registry()
</span><span class="noop">
</span><span class="hit">    def test_00_fromnone(self):
</span><span class="hit">        test = Elements(None)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="noop">
</span><span class="hit">    def test_01_fromelements(self):
</span><span class="hit">        test = Elements(self.element1)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements(self.element1, self.element2)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_02_fromstrings(self):
</span><span class="hit">        test = Elements(&#39;element1&#39;)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements(&#39;element1&#39;, &#39;element2&#39;)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_03_fromelements(self):
</span><span class="hit">        test1 = Elements(&#39;element1&#39;)
</span><span class="hit">        test2 = Elements(test1)
</span><span class="hit">        self.assertIsInstance(test2, Elements)
</span><span class="noop">
</span><span class="hit">    def test_04_fromemptycontainer(self):
</span><span class="hit">        test = Elements([])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="noop">
</span><span class="hit">    def test_05_fromcontaineredelements1(self):
</span><span class="hit">        test = Elements([self.element1])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements([self.element1, self.element2])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_06_fromcontaineredelements1(self):
</span><span class="hit">        test = Elements(Elements([self.element1]))
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements(Elements([self.element1, self.element2]))
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_07_fromcontaineredstrings(self):
</span><span class="hit">        test = Elements([&#39;element1&#39;])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements([&#39;element1&#39;, &#39;element2&#39;])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_07_fromwrongtype(self):
</span><span class="hit">        with self.assertRaises(TypeError):
</span><span class="hit">            Elements(1.)
</span><span class="noop">
</span><span class="hit">class Test06ElementsArithmetic(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.element1 = Element(&#39;element1&#39;)
</span><span class="hit">        self.element2 = Element(&#39;element2&#39;)
</span><span class="hit">        self.element3 = Element(&#39;element3&#39;)
</span><span class="hit">        self.element4 = Element(&#39;element3&#39;)
</span><span class="hit">        self.elements12 = Elements(self.element1, self.element2)
</span><span class="hit">        self.elements34 = Elements(self.element3, self.element4)
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clear_registry()
</span><span class="hit">        Node.clear_registry()
</span><span class="noop">
</span><span class="hit">    def test_01_iadd_element(self):
</span><span class="hit">        self.elements12 += self.element3
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_02_iadd_elements(self):
</span><span class="hit">        self.elements12 += self.elements34
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_03a_iadd_emptylist(self):
</span><span class="hit">        elements12 = self.elements12.copy()
</span><span class="hit">        self.elements12 += []
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertEqual(self.elements12, elements12)
</span><span class="hit">    def test_04a_iadd_elementlist(self):
</span><span class="hit">        self.elements12 += [self.element3]
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_04b_iadd_elementlist(self):
</span><span class="hit">        self.elements12 += [self.element3, self.element4]
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_05a_iadd_stringlist(self):
</span><span class="hit">        self.elements12 += [&#39;element3&#39;]
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_05b_iadd_stringlist(self):
</span><span class="hit">        self.elements12 += [&#39;element3&#39;, &#39;element4&#39;]
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="noop">
</span><span class="hit">    def test_06_isub_element(self):
</span><span class="hit">        self.elements12 -= self.element2
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        with self.assertRaises(AttributeError):
</span><span class="hit">            self.elements12.element2
</span><span class="noop">
</span><span class="hit">    def test_07_add_element(self):
</span><span class="hit">        elements12 = self.elements12.copy()
</span><span class="hit">        elements123 = self.elements12 + self.element3
</span><span class="hit">        self.assertEqual(self.elements12, elements12)
</span><span class="hit">        self.assertIsInstance(elements123, Elements)
</span><span class="hit">        self.assertIs(elements123.element1, self.element1)
</span><span class="hit">        self.assertIs(elements123.element3, self.element3)
</span><span class="noop">
</span><span class="hit">    def test_08_sub_element(self):
</span><span class="hit">        elements12 = self.elements12.copy()
</span><span class="hit">        elements1 = self.elements12 - self.element2
</span><span class="hit">        self.assertEqual(self.elements12, elements12)
</span><span class="hit">        self.assertIsInstance(elements1, Elements)
</span><span class="hit">        self.assertIs(elements1.element1, self.element1)
</span><span class="hit">        with self.assertRaises(AttributeError):
</span><span class="hit">            self.elements1.element2
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test07ElementsComparisons(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clear_registry()
</span><span class="hit">        Node.clear_registry()
</span><span class="noop">
</span><span class="hit">    def test_01_bool(self):
</span><span class="hit">        self.assertFalse(Elements())
</span><span class="hit">        self.assertTrue(Elements(&#39;a&#39;))
</span><span class="hit">        self.assertTrue(Elements(&#39;a&#39;, &#39;b&#39;))</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_05_connectiontools.py">unittests_05_connectiontools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.devicetools import *
</span><span class="hit">from hydpy.core.connectiontools import *
</span><span class="noop">
</span><span class="hit">class Test01Connections(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.test1 = Node(&#39;test1&#39;)
</span><span class="hit">        self.test2 = Node(&#39;test2&#39;)
</span><span class="hit">        self.cons = Connections(None)
</span><span class="hit">        self.cons += self.test1
</span><span class="hit">        self.cons += self.test2
</span><span class="noop">
</span><span class="hit">    def test_01_properties(self):
</span><span class="hit">        self.assertListEqual(sorted(self.cons.names),
</span><span class="noop">                             [&#39;test1&#39;, &#39;test2&#39;])
</span><span class="hit">        self.assertListEqual(sorted(self.cons.slaves),
</span><span class="noop">                             [self.test1, self.test2])
</span><span class="hit">    def test_02_contains(self):
</span><span class="hit">        self.assertTrue(&#39;test1&#39; in self.cons)
</span><span class="hit">        self.assertTrue(&#39;test2&#39; in self.cons)
</span><span class="hit">        self.assertTrue(self.test1 in self.cons)
</span><span class="hit">        self.assertTrue(self.test2 in self.cons)
</span><span class="hit">    def test_03_iterable(self):
</span><span class="hit">        devices = []
</span><span class="hit">        for device in self.cons:
</span><span class="hit">            devices.append(device)
</span><span class="hit">        self.assertListEqual(devices, [self.test1, self.test2])
</span><span class="noop">
</span><span class="hit">class Test01Self2Node(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clear_registry()
</span><span class="noop">
</span><span class="hit">    def test_01_iadd(self):
</span><span class="hit">        test = Connections(None)
</span><span class="hit">        n1 = Node(&#39;n1&#39;, &#39;Q&#39;)
</span><span class="hit">        test += n1
</span><span class="hit">        self.assertIsInstance(test, Connections)
</span><span class="hit">        self.assertIsInstance(test.n1, Node)
</span><span class="hit">        self.assertIs(test.n1, n1)
</span><span class="hit">        test += n1
</span><span class="hit">        self.assertIsInstance(test, Connections)
</span><span class="hit">        self.assertIsInstance(test.n1, Node)
</span><span class="hit">        self.assertIs(test.n1, n1)
</span><span class="hit">        n2 = Node(&#39;n2&#39;, &#39;T&#39;)
</span><span class="hit">        test += n2
</span><span class="hit">        self.assertIs(test.n1, n1)
</span><span class="hit">        self.assertIs(test.n2, n2)
</span><span class="noop">
</span><span class="hit">    def test_02_variables(self):
</span><span class="hit">        test = Connections(None)
</span><span class="hit">        self.assertListEqual(test.variables, [])
</span><span class="hit">        n1 = Node(&#39;n1&#39;, &#39;Q&#39;)
</span><span class="hit">        test += n1
</span><span class="hit">        self.assertListEqual(test.variables, [&#39;Q&#39;])
</span><span class="hit">        n2 = Node(&#39;n2&#39;, &#39;T&#39;)
</span><span class="hit">        test += n2
</span><span class="hit">        self.assertListEqual(sorted(test.variables), [&#39;Q&#39;, &#39;T&#39;])
</span><span class="hit">        with self.assertRaises(AttributeError):
</span><span class="hit">            test.X</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_06_selectiontools.py">unittests_06_selectiontools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.devicetools import *
</span><span class="hit">from hydpy.core.selectiontools import *
</span><span class="noop">
</span><span class="hit">class Test01SelectionInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Node.clear_registry()
</span><span class="hit">        Element.clear_registry()
</span><span class="noop">
</span><span class="hit">    def test_01_empty(self):
</span><span class="hit">        test = Selection(&#39;test&#39;)
</span><span class="hit">        self.assertIsInstance(test, Selection)
</span><span class="hit">        self.assertIsInstance(test.nodes, Nodes)
</span><span class="hit">        self.assertIsInstance(test.elements, Elements)
</span><span class="hit">        self.assertFalse(bool(test))
</span><span class="hit">    def test_02_nonempty(self):
</span><span class="hit">        test = Selection(&#39;test&#39;, nodes=&#39;a&#39;, elements=(&#39;b&#39;, &#39;c&#39;))
</span><span class="hit">        self.assertIsInstance(test, Selection)
</span><span class="hit">        self.assertIsInstance(test.nodes, Nodes)
</span><span class="hit">        self.assertIsInstance(test.elements, Elements)
</span><span class="hit">        self.assertEqual(test.nodes.a.name, &#39;a&#39;)
</span><span class="hit">        self.assertEqual(test.elements.b.name, &#39;b&#39;)
</span><span class="hit">        self.assertEqual(test.elements.c.name, &#39;c&#39;)
</span><span class="hit">        self.assertTrue(bool(test))
</span><span class="hit">    def test_03_copy(self):
</span><span class="hit">        test1 = Selection(&#39;test1&#39;, nodes=&#39;a&#39;, elements=(&#39;b&#39;, &#39;c&#39;))
</span><span class="hit">        test2 = test1.copy(&#39;test2&#39;)
</span><span class="hit">        self.assertIsInstance(test2, Selection)
</span><span class="hit">        self.assertEqual(test2.name, &#39;test2&#39;)
</span><span class="hit">        self.assertIsNot(test1, test2)
</span><span class="hit">        self.assertEqual(test2.nodes, test1.nodes)
</span><span class="hit">        self.assertEqual(test2.elements, test1.elements)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test02SelectionSelect(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="noop">        # e1 + e2 -&gt; n_Q1 -&gt; e3 -&gt; n_Q2 -&gt; e4 + (e7 -&gt; n_Q4 -&gt; e6)-&gt; n_Q3
</span><span class="noop">        # e1 + e2 -&gt; n_T1 -&gt; e3 -&gt; n_T2 -&gt; e5 -&gt; n_T3
</span><span class="hit">        self.n_Q1 = Node(&#39;n_Q1&#39;, &#39;Q&#39;)
</span><span class="hit">        self.n_T1 = Node(&#39;n_T1&#39;, &#39;T&#39;)
</span><span class="hit">        self.e1 = Element(&#39;e1&#39;, outlets=&#39;n_Q1&#39;)
</span><span class="hit">        self.e1 = Element(&#39;e1&#39;, outlets=&#39;n_T1&#39;)
</span><span class="hit">        self.e2 = Element(&#39;e2&#39;, outlets=&#39;n_Q1&#39;)
</span><span class="hit">        self.e2 = Element(&#39;e2&#39;, outlets=&#39;n_T1&#39;)
</span><span class="hit">        self.n_Q2 = Node(&#39;n_Q2&#39;, &#39;Q&#39;)
</span><span class="hit">        self.n_T2 = Node(&#39;n_T2&#39;, &#39;T&#39;)
</span><span class="hit">        self.e3 = Element(&#39;e3&#39;, inlets=&#39;n_Q1&#39;, outlets=&#39;n_Q2&#39;)
</span><span class="hit">        self.e3 = Element(&#39;e3&#39;, inlets=&#39;n_T1&#39;, outlets=&#39;n_T2&#39;)
</span><span class="hit">        self.n_Q3 = Node(&#39;n_Q3&#39;, &#39;Q&#39;)
</span><span class="hit">        self.e4 = Element(&#39;e4&#39;, inlets=&#39;n_Q2&#39;, outlets=&#39;n_Q3&#39;)
</span><span class="hit">        self.n_T3 = Node(&#39;n_T3&#39;, &#39;T&#39;)
</span><span class="hit">        self.e5 = Element(&#39;e5&#39;, inlets=&#39;n_T2&#39;, outlets=&#39;n_T3&#39;)
</span><span class="hit">        self.n_Q4 = Node(&#39;n_Q4&#39;, &#39;Q&#39;)
</span><span class="hit">        self.e6 = Element(&#39;e6&#39;, inlets=&#39;n_Q4&#39;, outlets=&#39;n_Q3&#39;)
</span><span class="hit">        self.e7 = Element(&#39;e7&#39;, outlets=&#39;n_Q4&#39;)
</span><span class="noop">
</span><span class="hit">        self.complete = Selection(&#39;complete&#39;,
</span><span class="noop">                                  nodes=Node.registered_nodes(),
</span><span class="noop">                                  elements=Element.registered_elements())
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Node.clear_registry()
</span><span class="hit">        Element.clear_registry()
</span><span class="noop">
</span><span class="hit">    def test_01_nextelement(self):
</span><span class="hit">        nodes, elements = self.complete._nextelement(self.e1,
</span><span class="noop">                                                  Nodes(), Elements())
</span><span class="hit">        self.assertEqual(nodes, Nodes())
</span><span class="hit">        self.assertEqual(elements, Elements(self.e1))
</span><span class="hit">    def test_02_nextnode(self):
</span><span class="hit">        nodes, elements = self.complete._nextnode(self.n_Q1,
</span><span class="noop">                                                  Nodes(), Elements())
</span><span class="hit">        self.assertEqual(nodes, Nodes(self.n_Q1))
</span><span class="hit">        self.assertEqual(elements, Elements(self.e1, self.e2))
</span><span class="hit">    def test_03_select_upstream(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).select_upstream(self.n_Q3)
</span><span class="hit">        reference = self.complete.copy(&#39;reference&#39;)
</span><span class="hit">        del(reference.elements.e5)
</span><span class="hit">        del(reference.nodes.n_T2)
</span><span class="hit">        del(reference.nodes.n_T3)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">    def test_04_deselect_upstream(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).deselect_upstream(self.n_Q3)
</span><span class="hit">        reference = Selection(&#39;reference&#39;, [&#39;n_T2&#39;, &#39;n_T3&#39;], &#39;e5&#39;)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="noop">
</span><span class="noop">#    def test_05_selectmodelclasses(self):
</span><span class="noop">#        with self.assertRaises(RuntimeError):
</span><span class="noop">#            self.complete.copy(&#39;test&#39;).getby_modelclasses(&#39;HBV96_zone&#39;)
</span><span class="noop">
</span><span class="hit">    def test_06_select_nodenames(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).select_nodenames(&#39;n_Q1&#39;, &#39;n_T&#39;, &#39;NO&#39;)
</span><span class="hit">        reference = self.complete.copy(&#39;test&#39;)
</span><span class="hit">        reference.nodes = Nodes(&#39;n_Q1&#39;, &#39;n_T1&#39;, &#39;n_T2&#39;, &#39;n_T3&#39;)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">    def test_07_deselect_nodenames(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).deselect_nodenames(&#39;n_Q1&#39;, &#39;n_T&#39;,
</span><span class="noop">                                                             &#39;NO&#39;)
</span><span class="hit">        reference = self.complete.copy(&#39;test&#39;)
</span><span class="hit">        del(reference.nodes.n_Q1)
</span><span class="hit">        del(reference.nodes.n_T1)
</span><span class="hit">        del(reference.nodes.n_T2)
</span><span class="hit">        del(reference.nodes.n_T3)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">    def test_08_select_elementnames(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).select_elementnames(&#39;e&#39;)
</span><span class="hit">        self.assertEqual(test.nodes, self.complete.nodes)
</span><span class="hit">        self.assertEqual(test.elements, self.complete.elements)
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).select_elementnames(&#39;2&#39;)
</span><span class="hit">        reference = self.complete.copy(&#39;test&#39;)
</span><span class="hit">        reference.elements = Elements(&#39;e2&#39;)
</span><span class="hit">    def test_09_deselect_elementnames(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).deselect_elementnames(&#39;e&#39;)
</span><span class="hit">        self.assertEqual(test.nodes, self.complete.nodes)
</span><span class="hit">        self.assertEqual(test.elements, Elements())
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).deselect_elementnames(&#39;2&#39;)
</span><span class="hit">        reference = self.complete.copy(&#39;test&#39;)
</span><span class="hit">        del(reference.elements.e2)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test03SelectionMagic(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Node.clear_registry()
</span><span class="hit">        Element.clear_registry()
</span><span class="noop">
</span><span class="hit">    def test_01_len(self):
</span><span class="hit">        test1 = Selection(&#39;test1&#39;, [&#39;n1&#39;, &#39;n2&#39;], [])
</span><span class="hit">        self.assertEqual(len(test1), 2)
</span><span class="hit">        test2 = Selection(&#39;test2&#39;, [], [&#39;e1&#39;])
</span><span class="hit">        self.assertEqual(len(test2), 1)
</span><span class="noop">
</span><span class="hit">    def test_02_iadd(self):
</span><span class="hit">        test = Selection(&#39;sel&#39;,
</span><span class="noop">                         [&#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;],
</span><span class="noop">                         [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        test += Selection(&#39;add&#39;, [&#39;n3&#39;, &#39;n4&#39;], [])
</span><span class="hit">        reference = Selection(&#39;sel&#39;,
</span><span class="noop">                              [&#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;, &#39;n4&#39;],
</span><span class="noop">                              [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">        test += Selection(&#39;add&#39;, [], [&#39;e4&#39;, &#39;e5&#39;])
</span><span class="hit">        reference = Selection(&#39;sel&#39;,
</span><span class="noop">                              [&#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;, &#39;n4&#39;],
</span><span class="noop">                              [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;, &#39;e4&#39;, &#39;e5&#39;])
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">    def test_03_isub(self):
</span><span class="hit">        test = Selection(&#39;sel&#39;,
</span><span class="noop">                         [&#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;],
</span><span class="noop">                         [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        test -= Selection(&#39;sub&#39;, [&#39;n3&#39;, &#39;n4&#39;], [])
</span><span class="hit">        reference = Selection(&#39;sel&#39;,
</span><span class="noop">                              [&#39;n1&#39;, &#39;n2&#39;],
</span><span class="noop">                              [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        test -= Selection(&#39;sub&#39;, [], [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        reference = Selection(&#39;sel&#39;,
</span><span class="noop">                              [&#39;n1&#39;, &#39;n2&#39;],
</span><span class="noop">                              [])
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_07_parametertools.py">unittests_07_parametertools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Created on Thu Dec 01 10:53:44 2016
</span><span class="noop">
</span><span class="noop">@author: tyralla
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_08_indextools.py">unittests_08_indextools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import indextools
</span><span class="hit">from hydpy.core import timetools
</span><span class="noop">
</span><span class="hit">class Test01MonthOfYear(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.indexer = indextools.Indexer()
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        pub.timegrids = None
</span><span class="noop">
</span><span class="hit">    def test_01_manual_mode(self):
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.monthofyear = &#39;a&#39;
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.monthofyear = [&#39;a&#39;, &#39;b&#39;]
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.monthofyear = [[1, 2], [3, 4]]
</span><span class="hit">        self.indexer.monthofyear = [1,2]
</span><span class="hit">        self.assertIsInstance(self.indexer.monthofyear, numpy.ndarray)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.monthofyear), (1, 2))
</span><span class="hit">        del(self.indexer.monthofyear)
</span><span class="hit">        self.assertIsNone(self.indexer._monthofyear)
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.monthofyear = [1,2]
</span><span class="noop">
</span><span class="hit">    def test_02_automatic_mode(self):
</span><span class="hit">        with self.assertRaises(RuntimeError):
</span><span class="hit">            self.indexer.monthofyear
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        self.assertIsInstance(self.indexer.monthofyear, numpy.ndarray)
</span><span class="hit">        self.assertEqual(len(self.indexer.monthofyear), 366)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.monthofyear),
</span><span class="noop">                              tuple(31*[0]+29*[1]+31*[2]+30*[3]+
</span><span class="noop">                                    31*[4]+30*[5]+31*[6]+31*[7]+
</span><span class="noop">                                    30*[8]+31*[9]+30*[10]+31*[11]))
</span><span class="hit">        self.assertIs(self.indexer.monthofyear, self.indexer.monthofyear)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test02DayOfYear(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.indexer = indextools.Indexer()
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        pub.timegrids = None
</span><span class="noop">
</span><span class="hit">    def test_01_manual_mode(self):
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.dayofyear = &#39;a&#39;
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.dayofyear = [&#39;a&#39;, &#39;b&#39;]
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.dayofyear = [[1, 2], [3, 4]]
</span><span class="hit">        self.indexer.dayofyear = [1,2]
</span><span class="hit">        self.assertIsInstance(self.indexer.dayofyear, numpy.ndarray)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.dayofyear), (1, 2))
</span><span class="hit">        del self.indexer.dayofyear
</span><span class="hit">        self.assertIsNone(self.indexer._dayofyear)
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.dayofyear = [1,2]
</span><span class="noop">
</span><span class="hit">    def test_02_automatic_mode(self):
</span><span class="hit">        with self.assertRaises(RuntimeError):
</span><span class="hit">            self.indexer.dayofyear
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        self.assertIsInstance(self.indexer.dayofyear, numpy.ndarray)
</span><span class="hit">        self.assertEqual(len(self.indexer.dayofyear), 366)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.dayofyear),
</span><span class="noop">                              tuple(range(366)))
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2005&#39;,
</span><span class="noop">                                                               &#39;1.01.2006&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        del self.indexer.dayofyear
</span><span class="hit">        self.assertIsInstance(self.indexer.dayofyear, numpy.ndarray)
</span><span class="hit">        self.assertEqual(len(self.indexer.dayofyear), 365)
</span><span class="hit">        self.assertTupleEqual(
</span><span class="noop">           tuple(self.indexer.dayofyear),
</span><span class="noop">           tuple(list(range(31+28))+list(range(31+28+1, 366)))
</span><span class="noop">           )
</span><span class="hit">        self.assertIs(self.indexer.dayofyear, self.indexer.dayofyear)
</span><span class="noop">
</span><span class="hit">class Test03TimeOfYear(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.indexer = indextools.Indexer()
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        pub.timegrids = None
</span><span class="noop">
</span><span class="hit">    def test_01_manual_mode(self):
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.timeofyear = &#39;a&#39;
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.timeofyear = [&#39;a&#39;, &#39;b&#39;]
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.timeofyear = [[1, 2], [3, 4]]
</span><span class="hit">        self.indexer.timeofyear = [1, 2]
</span><span class="hit">        self.assertIsInstance(self.indexer.timeofyear, numpy.ndarray)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.timeofyear), (1, 2))
</span><span class="hit">        del self.indexer.timeofyear
</span><span class="hit">        self.assertIsNone(self.indexer._timeofyear)
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.timeofyear = [1, 2]
</span><span class="noop">
</span><span class="hit">    def test_02_automatic_mode(self):
</span><span class="hit">        with self.assertRaises(RuntimeError):
</span><span class="hit">            self.indexer.timeofyear
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        self.assertIsInstance(self.indexer.timeofyear, numpy.ndarray)
</span><span class="hit">        self.assertEqual(len(self.indexer.timeofyear), 366)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.timeofyear),
</span><span class="noop">                              tuple(range(366)))
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2005&#39;,
</span><span class="noop">                                                               &#39;1.01.2006&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        del self.indexer.timeofyear
</span><span class="hit">        self.assertIsInstance(self.indexer.timeofyear, numpy.ndarray)
</span><span class="hit">        self.assertEqual(len(self.indexer.timeofyear), 365)
</span><span class="hit">        self.assertTupleEqual(
</span><span class="noop">           tuple(self.indexer.timeofyear),
</span><span class="noop">           tuple(list(range(31+28))+list(range(31+28+1, 366)))
</span><span class="noop">           )
</span><span class="hit">        self.assertIs(self.indexer.timeofyear, self.indexer.timeofyear)</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">&#34;&#34;&#34;
</span><span class="noop">HydPy
</span><span class="noop">
</span><span class="noop">An interactive framework for the developement and a application of
</span><span class="noop">hydrological models.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">from hydpy.core.hydpytools import HydPy
</span><span class="hit">from hydpy.core.timetools import Date
</span><span class="hit">from hydpy.core.timetools import Period
</span><span class="hit">from hydpy.core.timetools import Timegrid
</span><span class="hit">from hydpy.core.timetools import Timegrids
</span><span class="hit">from hydpy.core.filetools import MainManager
</span><span class="hit">from hydpy.core.filetools import NetworkManager
</span><span class="hit">from hydpy.core.filetools import ControlManager
</span><span class="hit">from hydpy.core.filetools import SequenceManager
</span><span class="hit">from hydpy.core.filetools import ConditionManager
</span><span class="hit">from hydpy.core.devicetools import Node
</span><span class="hit">from hydpy.core.devicetools import Nodes
</span><span class="hit">from hydpy.core.devicetools import Element
</span><span class="hit">from hydpy.core.devicetools import Elements
</span><span class="hit">from hydpy.core.selectiontools import Selection
</span><span class="hit">from hydpy.core.selectiontools import Selections
</span><span class="hit">from hydpy.core.objecttools import HydPyDeprecationWarning
</span><span class="noop">
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import optiontools as __optiontools
</span><span class="hit">from hydpy.core import indextools as __indextools
</span><span class="hit">from hydpy.cythons import configutils as __configutils
</span><span class="hit">pub.options = __optiontools.Options()
</span><span class="hit">pub.indexer = __indextools.Indexer()
</span><span class="hit">pub.config = __configutils.Config()
</span><span class="noop">
</span><span class="hit">from hydpy.core import dummytools as __dummytools
</span><span class="hit">dummies = __dummytools.Dummies()
</span><span class="noop">
</span><span class="hit">import sys
</span><span class="hit">import warnings
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def customwarn(message, category, filename, lineno, file=None, line=None):
</span><span class="miss">    sys.stdout.write(warnings.formatwarning(
</span><span class="noop">                                    message, category, filename, lineno))
</span><span class="hit">warnings.showwarning = customwarn
</span><span class="hit">warnings.filterwarnings(&#39;always&#39;, category=HydPyDeprecationWarning)
</span><span class="hit">warnings.filterwarnings(&#39;ignore&#39;, r&#39;All-NaN (slice|axis) encountered&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">__all__ = [&#39;HydPy&#39;, &#39;pub&#39;,
</span><span class="noop">           &#39;Date&#39;, &#39;Period&#39;, &#39;Timegrid&#39;, &#39;Timegrids&#39;,
</span><span class="noop">           &#39;MainManager&#39;, &#39;NetworkManager&#39;, &#39;ControlManager&#39;,
</span><span class="noop">           &#39;SequenceManager&#39;, &#39;ConditionManager&#39;,
</span><span class="noop">           &#39;Node&#39;, &#39;Nodes&#39;, &#39;Element&#39;, &#39;Elements&#39;, &#39;Selection&#39;, &#39;Selections&#39;]
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/pub.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/pub.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import from...
</span><span class="noop"># ...the standard library
</span><span class="hit">import sys as __sys
</span><span class="noop">
</span><span class="hit">projectname = None
</span><span class="noop">
</span><span class="hit">options = None
</span><span class="hit">indexer = None
</span><span class="hit">networkmanager = None
</span><span class="hit">controlmanager = None
</span><span class="hit">conditionmanager = None
</span><span class="hit">sequencemanager = None
</span><span class="hit">timegrids = None
</span><span class="noop">
</span><span class="hit">pyversion = int(__sys.version[0])
</span><span class="hit">_printprogress_indentation = -4
</span><span class="noop">
</span><span class="hit">_am_i_an_exe = False
</span><span class="hit">&#34;&#34;&#34;This parameter is set `True` within HydPy executables only.
</span><span class="noop">Then different features that do not make much sense within an
</span><span class="noop">executable (e.g. the cythonization of models) are disabled.
</span><span class="noop">&#34;&#34;&#34;
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">#</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/anntools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/anntools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements rudimantary artificial neural network tools,
</span><span class="noop">required for some models implemented in the HydPy framework.
</span><span class="noop">
</span><span class="noop">A note for developers: some of the implemented features are to be applied
</span><span class="noop">during model simulations are in some other way performance-critical.  Hence,
</span><span class="noop">the actual calculations are defined in the Cython extension module
</span><span class="noop">:mod:`~hydpy.cythons.annutils`.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="hit">from matplotlib import pyplot
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="hit">from hydpy.cythons import annutils
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ANN(object):
</span><span class="noop">    &#34;&#34;&#34;Multi-layer feed forward artificial neural network.
</span><span class="noop">
</span><span class="noop">    The applied activation function is the logistic function:
</span><span class="noop">
</span><span class="noop">      :math:`f(x) = \\frac{1}{1+exp(-x)}`
</span><span class="noop">
</span><span class="noop">    Class :class:`ANN` is intended to be subclassed for the derivation of
</span><span class="noop">    very complex control parameters.  Its original purpose was to allow for
</span><span class="noop">    defining arbitrary continuous relationsships between the water stored
</span><span class="noop">    in a dam and the associated water stage (see model ...).  However,
</span><span class="noop">    class :class:`ANN` can also be applied directly, as shown in the
</span><span class="noop">    following examples.  But if you are looking for a flexible stand-alone
</span><span class="noop">    artifical neural network implementation in Python, you will find much
</span><span class="noop">    more general tools easily.
</span><span class="noop">
</span><span class="noop">    Firstly, define the most single artificial neural network consisting of
</span><span class="noop">    only one input node, neuron, and output node respectively, and pass
</span><span class="noop">    some arbitrary network parameters:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.anntools import ANN
</span><span class="noop">    &gt;&gt;&gt; ann = ANN()
</span><span class="noop">    &gt;&gt;&gt; ann(nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,
</span><span class="noop">    ...     weights_input=4.0, weights_output=3.0,
</span><span class="noop">    ...     intercepts_hidden=-16.0, intercepts_output=-1.0)
</span><span class="noop">
</span><span class="noop">    The following loop subsequently sets the values 0 to 8 as input values,
</span><span class="noop">    performs the calculateion, and prints out the final output.  As to be
</span><span class="noop">    expected, the results show the shape of the logistic function:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; for input_ in range(9):
</span><span class="noop">    ...     ann.inputs[0] = input_
</span><span class="noop">    ...     ann.process_actual_input()
</span><span class="noop">    ...     round_([input_, ann.outputs[0]])
</span><span class="noop">    0, -1.0
</span><span class="noop">    1, -0.999982
</span><span class="noop">    2, -0.998994
</span><span class="noop">    3, -0.946041
</span><span class="noop">    4, 0.5
</span><span class="noop">    5, 1.946041
</span><span class="noop">    6, 1.998994
</span><span class="noop">    7, 1.999982
</span><span class="noop">    8, 2.0
</span><span class="noop">
</span><span class="noop">    One can also directly plot the resulting graph:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; ann.plot(0.0, 8.0)
</span><span class="noop">
</span><span class="noop">    You can close the plotting window manually or by writing:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from matplotlib import pyplot
</span><span class="noop">    &gt;&gt;&gt; pyplot.close()
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    The following example shows that everything works well for more complex
</span><span class="noop">    single layer networks also (manual tests have been performed in a
</span><span class="noop">    spreadsheet program):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; ann.nmb_inputs = 3
</span><span class="noop">    &gt;&gt;&gt; ann.nmb_neurons = (4,)
</span><span class="noop">    &gt;&gt;&gt; ann.nmb_outputs = 2
</span><span class="noop">    &gt;&gt;&gt; ann.weights_input = [[ 0.2, -0.1, -1.7,  0.6],
</span><span class="noop">    ...                      [ 0.9,  0.2,  0.8,  0.0],
</span><span class="noop">    ...                      [-0.5, -1.0,  2.3, -0.4]]
</span><span class="noop">    &gt;&gt;&gt; ann.weights_output = [[ 0.0,  2.0],
</span><span class="noop">    ...                       [-0.5,  1.0],
</span><span class="noop">    ...                       [ 0.4,  2.4],
</span><span class="noop">    ...                       [ 0.8, -0.9]]
</span><span class="noop">    &gt;&gt;&gt; ann.intercepts_hidden = [ 0.9,  0.0, -0.4, -0.2]
</span><span class="noop">    &gt;&gt;&gt; ann.intercepts_output = [ 1.3, -2.0]
</span><span class="noop">    &gt;&gt;&gt; ann.inputs = [-0.1,  1.3,  1.6]
</span><span class="noop">    &gt;&gt;&gt; ann.process_actual_input()
</span><span class="noop">    &gt;&gt;&gt; round_(ann.outputs)
</span><span class="noop">    1.822222, 1.876983
</span><span class="noop">
</span><span class="noop">    A example for a multi layer networks is still missing...
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM = 0
</span><span class="hit">    TYPE = &#39;annutils.ANN&#39;
</span><span class="hit">    TIME = None
</span><span class="hit">    SPAN = (None, None)
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.subpars = None
</span><span class="hit">        self.fastaccess = objecttools.FastAccess()
</span><span class="hit">        self._cann = annutils.ANN()
</span><span class="noop">
</span><span class="hit">    def connect(self, subpars):
</span><span class="hit">        self.subpars = subpars
</span><span class="hit">        self.fastaccess = subpars.fastaccess
</span><span class="hit">        setattr(self.fastaccess, self.name, self._cann)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def name(self):
</span><span class="hit">        return objecttools.classname(self).lower()
</span><span class="noop">
</span><span class="hit">    def __call__(self, nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,
</span><span class="noop">                 weights_input=None, weights_output=None, weights_hidden=None,
</span><span class="noop">                 intercepts_hidden=None, intercepts_output=None):
</span><span class="hit">        self._cann.nmb_inputs = nmb_inputs
</span><span class="hit">        self._cann.nmb_outputs = nmb_outputs
</span><span class="hit">        self.nmb_neurons = nmb_neurons
</span><span class="hit">        self.weights_input = weights_input
</span><span class="hit">        self.weights_hidden = weights_hidden
</span><span class="hit">        self.weights_output = weights_output
</span><span class="hit">        self.intercepts_hidden = intercepts_hidden
</span><span class="hit">        self.intercepts_output = intercepts_output
</span><span class="hit">        del self.inputs
</span><span class="hit">        del self.outputs
</span><span class="hit">        self._update_hidden()
</span><span class="noop">
</span><span class="hit">    def _update_shapes(self):
</span><span class="hit">        del self.weights_input
</span><span class="hit">        del self.weights_hidden
</span><span class="hit">        del self.weights_output
</span><span class="hit">        del self.intercepts_hidden
</span><span class="hit">        del self.intercepts_output
</span><span class="hit">        del self.inputs
</span><span class="hit">        del self.outputs
</span><span class="hit">        self._update_hidden()
</span><span class="noop">
</span><span class="hit">    def _get_nmb_inputs(self):
</span><span class="noop">        &#34;&#34;&#34;Number of input nodes.&#34;&#34;&#34;
</span><span class="hit">        return self._cann.nmb_inputs
</span><span class="noop">
</span><span class="hit">    def _set_nmb_inputs(self, value):
</span><span class="hit">        self._cann.nmb_inputs = int(value)
</span><span class="hit">        self._update_shapes()
</span><span class="noop">
</span><span class="hit">    nmb_inputs = property(_get_nmb_inputs, _set_nmb_inputs)
</span><span class="noop">
</span><span class="hit">    def _get_nmb_outputs(self):
</span><span class="noop">        &#34;&#34;&#34;Number of output nodes.&#34;&#34;&#34;
</span><span class="hit">        return self._cann.nmb_outputs
</span><span class="noop">
</span><span class="hit">    def _set_nmb_outputs(self, value):
</span><span class="hit">        self._cann.nmb_outputs = int(value)
</span><span class="hit">        self._update_shapes()
</span><span class="noop">
</span><span class="hit">    nmb_outputs = property(_get_nmb_outputs, _set_nmb_outputs)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nmb_layers(self):
</span><span class="noop">        &#34;&#34;&#34;Number of hidden layers.&#34;&#34;&#34;
</span><span class="hit">        return self._cann.nmb_layers
</span><span class="noop">
</span><span class="hit">    def _get_nmb_neurons(self):
</span><span class="noop">        &#34;&#34;&#34;Number of neurons of the inner layers.&#34;&#34;&#34;
</span><span class="hit">        return tuple(numpy.asarray(self._cann.nmb_neurons))
</span><span class="noop">
</span><span class="hit">    def _set_nmb_neurons(self, value):
</span><span class="hit">        self._cann.nmb_neurons = numpy.array(value, dtype=int, ndmin=1)
</span><span class="hit">        self._cann.nmb_layers = len(value)
</span><span class="hit">        self._max_nmb_neurons = max(value)
</span><span class="hit">        self._update_shapes()
</span><span class="noop">
</span><span class="hit">    nmb_neurons = property(_get_nmb_neurons, _set_nmb_neurons)
</span><span class="noop">
</span><span class="hit">    def _get_weights_input(self):
</span><span class="noop">        &#34;&#34;&#34;Weights between all input nodes and neurons of the first hidden
</span><span class="noop">        layer.
</span><span class="noop">
</span><span class="noop">        The input nodes and the neurons are varied on the first axis and
</span><span class="noop">        on the second axis of the 2-dimensional array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.anntools import ANN
</span><span class="noop">        &gt;&gt;&gt; ann = ANN()
</span><span class="noop">        &gt;&gt;&gt; ann(nmb_inputs=2, nmb_neurons=(3,))
</span><span class="noop">        &gt;&gt;&gt; ann.weights_input
</span><span class="noop">        array([[ 0.,  0.,  0.],
</span><span class="noop">               [ 0.,  0.,  0.]])
</span><span class="noop">
</span><span class="noop">        It is allowed to set values via slicing:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.weights_input[:, 0] = 1.
</span><span class="noop">        &gt;&gt;&gt; ann.weights_input
</span><span class="noop">        array([[ 1.,  0.,  0.],
</span><span class="noop">               [ 1.,  0.,  0.]])
</span><span class="noop">
</span><span class="noop">        If possible, type conversions are performed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.weights_input = &#39;2&#39;
</span><span class="noop">        &gt;&gt;&gt; ann.weights_input
</span><span class="noop">        array([[ 2.,  2.,  2.],
</span><span class="noop">               [ 2.,  2.,  2.]])
</span><span class="noop">
</span><span class="noop">        One can assign whole matrices directly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; import numpy
</span><span class="noop">        &gt;&gt;&gt; ann.weights_input = numpy.eye(2, 3)
</span><span class="noop">        &gt;&gt;&gt; ann.weights_input
</span><span class="noop">        array([[ 1.,  0.,  0.],
</span><span class="noop">               [ 0.,  1.,  0.]])
</span><span class="noop">
</span><span class="noop">        One can also delete the values contained in the array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; del ann.weights_input
</span><span class="noop">        &gt;&gt;&gt; ann.weights_input
</span><span class="noop">        array([[ 0.,  0.,  0.],
</span><span class="noop">               [ 0.,  0.,  0.]])
</span><span class="noop">
</span><span class="noop">        Errors like wrong shapes (or unconvertible inputs) result in error
</span><span class="noop">        messages:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.weights_input = numpy.eye(3)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: While trying to set the input weights of the artificial neural network `ann` of element `?`, the following error occured: could not broadcast input array from shape (3,3) into shape (2,3)
</span><span class="noop">
</span><span class="noop">        The number of input weights is available as a property:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.nmb_weights_input
</span><span class="noop">        6
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return numpy.asarray(self._cann.weights_input)
</span><span class="noop">
</span><span class="hit">    def _set_weights_input(self, values):
</span><span class="hit">        if values is None:
</span><span class="hit">            self._del_weights_input()
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                self._cann.weights_input = numpy.full(self.shape_weights_input,
</span><span class="noop">                                                      values, dtype=float)
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to set the input weights of the artificial &#39;
</span><span class="noop">                    &#39;neural network `%s` of element `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def _del_weights_input(self):
</span><span class="hit">        self._cann.weights_input = numpy.zeros(self.shape_weights_input)
</span><span class="noop">
</span><span class="hit">    weights_input = property(_get_weights_input,
</span><span class="noop">                             _set_weights_input,
</span><span class="noop">                             _del_weights_input)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def shape_weights_input(self):
</span><span class="noop">        &#34;&#34;&#34;Shape of the array containing the input weights&#34;&#34;&#34;
</span><span class="hit">        return (self.nmb_inputs, self.nmb_neurons[0])
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nmb_weights_input(self):
</span><span class="noop">        &#34;&#34;&#34;Number of input weights.&#34;&#34;&#34;
</span><span class="hit">        return self.nmb_neurons[0]*self.nmb_inputs
</span><span class="noop">
</span><span class="hit">    def _get_weights_output(self):
</span><span class="noop">        &#34;&#34;&#34;Weights between all neurons of the last hidden layer and the output
</span><span class="noop">        nodes.
</span><span class="noop">
</span><span class="noop">        The neurons and the output nodes are varied on the first axis and
</span><span class="noop">        on the second axis of the 2-dimensional array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.anntools import ANN
</span><span class="noop">        &gt;&gt;&gt; ann = ANN()
</span><span class="noop">        &gt;&gt;&gt; ann(nmb_outputs=2, nmb_neurons=(3,))
</span><span class="noop">        &gt;&gt;&gt; ann.weights_output
</span><span class="noop">        array([[ 0.,  0.],
</span><span class="noop">               [ 0.,  0.],
</span><span class="noop">               [ 0.,  0.]])
</span><span class="noop">
</span><span class="noop">        It is allowed to set values via slicing:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.weights_output[:, 0] = 1.
</span><span class="noop">        &gt;&gt;&gt; ann.weights_output
</span><span class="noop">        array([[ 1.,  0.],
</span><span class="noop">               [ 1.,  0.],
</span><span class="noop">               [ 1.,  0.]])
</span><span class="noop">
</span><span class="noop">        If possible, type conversions are performed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.weights_output = &#39;2&#39;
</span><span class="noop">        &gt;&gt;&gt; ann.weights_output
</span><span class="noop">        array([[ 2.,  2.],
</span><span class="noop">               [ 2.,  2.],
</span><span class="noop">               [ 2.,  2.]])
</span><span class="noop">
</span><span class="noop">        One can assign whole matrices directly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; import numpy
</span><span class="noop">        &gt;&gt;&gt; ann.weights_output = numpy.eye(3, 2)
</span><span class="noop">        &gt;&gt;&gt; ann.weights_output
</span><span class="noop">        array([[ 1.,  0.],
</span><span class="noop">               [ 0.,  1.],
</span><span class="noop">               [ 0.,  0.]])
</span><span class="noop">
</span><span class="noop">        One can also delete the values contained in the array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; del ann.weights_output
</span><span class="noop">        &gt;&gt;&gt; ann.weights_output
</span><span class="noop">        array([[ 0.,  0.],
</span><span class="noop">               [ 0.,  0.],
</span><span class="noop">               [ 0.,  0.]])
</span><span class="noop">
</span><span class="noop">        Errors like wrong shapes (or unconvertible inputs) result in error
</span><span class="noop">        messages:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.weights_output = numpy.eye(3)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: While trying to set the output weights of the artificial neural network `ann` of element `?`, the following error occured: could not broadcast input array from shape (3,3) into shape (3,2)
</span><span class="noop">
</span><span class="noop">        The number of output weights is available as a property:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.nmb_weights_output
</span><span class="noop">        6
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return numpy.asarray(self._cann.weights_output)
</span><span class="noop">
</span><span class="hit">    def _set_weights_output(self, values):
</span><span class="hit">        if values is None:
</span><span class="hit">            self._del_weights_output()
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                self._cann.weights_output = numpy.full(
</span><span class="noop">                            self.shape_weights_output, values, dtype=float)
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to set the output weights of the artificial &#39;
</span><span class="noop">                    &#39;neural network `%s` of element `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def _del_weights_output(self):
</span><span class="hit">        self._cann.weights_output = numpy.zeros(self.shape_weights_output)
</span><span class="noop">
</span><span class="hit">    weights_output = property(_get_weights_output,
</span><span class="noop">                              _set_weights_output,
</span><span class="noop">                              _del_weights_output)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def shape_weights_output(self):
</span><span class="noop">        &#34;&#34;&#34;Shape of the array containing the output weights&#34;&#34;&#34;
</span><span class="hit">        return (self.nmb_neurons[-1], self.nmb_outputs)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nmb_weights_output(self):
</span><span class="noop">        &#34;&#34;&#34;Number of output weights.&#34;&#34;&#34;
</span><span class="hit">        return self.nmb_neurons[-1]*self.nmb_outputs
</span><span class="noop">
</span><span class="hit">    def _get_weights_hidden(self):
</span><span class="noop">        &#34;&#34;&#34;Weights between between the neurons of the different hidden layers.
</span><span class="noop">
</span><span class="noop">        The layers are varied on the first axis, the neurons of the respective
</span><span class="noop">        upstream layer on the second axis and the neurons of the respective
</span><span class="noop">        downstream layer on the third axis of a 3-dimensional array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.anntools import ANN
</span><span class="noop">        &gt;&gt;&gt; ann = ANN()
</span><span class="noop">        &gt;&gt;&gt; ann(nmb_neurons=(3, 2, 3))
</span><span class="noop">        &gt;&gt;&gt; ann.weights_hidden
</span><span class="noop">        array([[[  0.,   0.,  nan],
</span><span class="noop">                [  0.,   0.,  nan],
</span><span class="noop">                [  0.,   0.,  nan]],
</span><span class="noop">        &lt;BLANKLINE&gt;
</span><span class="noop">               [[  0.,   0.,   0.],
</span><span class="noop">                [  0.,   0.,   0.],
</span><span class="noop">                [ nan,  nan,  nan]]])
</span><span class="noop">
</span><span class="noop">        It is allowed to set values via slicing:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.weights_hidden[1, :, 0] = 1.
</span><span class="noop">        &gt;&gt;&gt; ann.weights_hidden
</span><span class="noop">        array([[[  0.,   0.,  nan],
</span><span class="noop">                [  0.,   0.,  nan],
</span><span class="noop">                [  0.,   0.,  nan]],
</span><span class="noop">        &lt;BLANKLINE&gt;
</span><span class="noop">               [[  1.,   0.,   0.],
</span><span class="noop">                [  1.,   0.,   0.],
</span><span class="noop">                [  1.,  nan,  nan]]])
</span><span class="noop">
</span><span class="noop">        If possible, type conversions are performed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.weights_hidden = &#39;2&#39;
</span><span class="noop">        &gt;&gt;&gt; ann.weights_hidden
</span><span class="noop">        array([[[ 2.,  2.,  2.],
</span><span class="noop">                [ 2.,  2.,  2.],
</span><span class="noop">                [ 2.,  2.,  2.]],
</span><span class="noop">        &lt;BLANKLINE&gt;
</span><span class="noop">               [[ 2.,  2.,  2.],
</span><span class="noop">                [ 2.,  2.,  2.],
</span><span class="noop">                [ 2.,  2.,  2.]]])
</span><span class="noop">
</span><span class="noop">        One can assign whole matrices directly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; import numpy
</span><span class="noop">        &gt;&gt;&gt; ann.weights_hidden = numpy.eye(3)
</span><span class="noop">        &gt;&gt;&gt; ann.weights_hidden
</span><span class="noop">        array([[[ 1.,  0.,  0.],
</span><span class="noop">                [ 0.,  1.,  0.],
</span><span class="noop">                [ 0.,  0.,  1.]],
</span><span class="noop">        &lt;BLANKLINE&gt;
</span><span class="noop">               [[ 1.,  0.,  0.],
</span><span class="noop">                [ 0.,  1.,  0.],
</span><span class="noop">                [ 0.,  0.,  1.]]])
</span><span class="noop">
</span><span class="noop">        One can also delete the values contained in the array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; del ann.weights_hidden
</span><span class="noop">        &gt;&gt;&gt; ann.weights_hidden
</span><span class="noop">        array([[[  0.,   0.,  nan],
</span><span class="noop">                [  0.,   0.,  nan],
</span><span class="noop">                [  0.,   0.,  nan]],
</span><span class="noop">        &lt;BLANKLINE&gt;
</span><span class="noop">               [[  0.,   0.,   0.],
</span><span class="noop">                [  0.,   0.,   0.],
</span><span class="noop">                [ nan,  nan,  nan]]])
</span><span class="noop">
</span><span class="noop">        Errors like wrong shapes (or unconvertible inputs) result in error
</span><span class="noop">        messages:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.weights_hidden = numpy.eye(3, 2)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: While trying to set the hidden weights of the artificial neural network `ann` of element `?`, the following error occured: could not broadcast input array from shape (3,2) into shape (2,3,3)
</span><span class="noop">
</span><span class="noop">        The number of input weights is available as a property:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.nmb_weights_hidden
</span><span class="noop">        12
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return numpy.asarray(self._cann.weights_hidden)
</span><span class="noop">
</span><span class="hit">    def _set_weights_hidden(self, values):
</span><span class="hit">        if values is None:
</span><span class="hit">            self._del_weights_hidden()
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                self._cann.weights_hidden = numpy.full(
</span><span class="noop">                            self.shape_weights_hidden, values, dtype=float)
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to set the hidden weights of the artificial &#39;
</span><span class="noop">                    &#39;neural network `%s` of element `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def _del_weights_hidden(self):
</span><span class="hit">        self._cann.weights_hidden = numpy.full(self.shape_weights_hidden,
</span><span class="noop">                                               numpy.nan)
</span><span class="hit">        for idx_layer in range(self.nmb_layers-1):
</span><span class="hit">            for idx_neuron1 in range(self.nmb_neurons[idx_layer]):
</span><span class="hit">                for idx_neuron2 in range(self.nmb_neurons[idx_layer+1]):
</span><span class="hit">                    self._cann.weights_hidden[idx_layer,
</span><span class="noop">                                              idx_neuron1,
</span><span class="noop">                                              idx_neuron2] = 0.
</span><span class="noop">
</span><span class="hit">    weights_hidden = property(_get_weights_hidden,
</span><span class="noop">                              _set_weights_hidden,
</span><span class="noop">                              _del_weights_hidden)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def shape_weights_hidden(self):
</span><span class="noop">        &#34;&#34;&#34;Shape of the array containing the activations of the hidden neurons.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self.nmb_layers &gt; 1:
</span><span class="hit">            return (self.nmb_layers-1,
</span><span class="noop">                    self._max_nmb_neurons,
</span><span class="noop">                    self._max_nmb_neurons)
</span><span class="noop">        else:
</span><span class="hit">            return (0, 0, 0)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nmb_weights_hidden(self):
</span><span class="noop">        &#34;&#34;&#34;Number of hidden weights.&#34;&#34;&#34;
</span><span class="hit">        nmb = 0
</span><span class="hit">        for idx_layer in range(self.nmb_layers-1):
</span><span class="hit">            nmb += self.nmb_neurons[idx_layer] * self.nmb_neurons[idx_layer+1]
</span><span class="hit">        return nmb
</span><span class="noop">
</span><span class="hit">    def _get_intercepts_hidden(self):
</span><span class="noop">        &#34;&#34;&#34;Intercepts of all neurons of the hidden layers.
</span><span class="noop">
</span><span class="noop">        All intercepts are handled in a 1-dimensional array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.anntools import ANN
</span><span class="noop">        &gt;&gt;&gt; ann = ANN()
</span><span class="noop">        &gt;&gt;&gt; ann(nmb_neurons=(3, 2))
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_hidden
</span><span class="noop">        array([[  0.,   0.,   0.],
</span><span class="noop">               [  0.,   0.,  nan]])
</span><span class="noop">
</span><span class="noop">        It is allowed to set values via slicing:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_hidden[0, :] = 1.
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_hidden
</span><span class="noop">        array([[  1.,   1.,   1.],
</span><span class="noop">               [  0.,   0.,  nan]])
</span><span class="noop">
</span><span class="noop">        If possible, type conversions are performed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_hidden = &#39;2&#39;
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_hidden
</span><span class="noop">        array([[ 2.,  2.,  2.],
</span><span class="noop">               [ 2.,  2.,  2.]])
</span><span class="noop">
</span><span class="noop">        One can assign whole matrices directly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; import numpy
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_hidden = [1.0, 3.0, 2.0]
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_hidden
</span><span class="noop">        array([[ 1.,  3.,  2.],
</span><span class="noop">               [ 1.,  3.,  2.]])
</span><span class="noop">
</span><span class="noop">        One can also delete the values contained in the array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; del ann.intercepts_hidden
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_hidden
</span><span class="noop">        array([[  0.,   0.,   0.],
</span><span class="noop">               [  0.,   0.,  nan]])
</span><span class="noop">
</span><span class="noop">        Errors like wrong shapes (or unconvertible inputs) result in error
</span><span class="noop">        messages:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_hidden = [1.0, 3.0]
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: While trying to set the neuron related intercepts of the artificial neural network `ann` of element `?`, the following error occured: could not broadcast input array from shape (2) into shape (2,3)
</span><span class="noop">
</span><span class="noop">        The number of input intercepts is available as a property:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.nmb_intercepts_hidden
</span><span class="noop">        5
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return numpy.asarray(self._cann.intercepts_hidden)
</span><span class="noop">
</span><span class="hit">    def _set_intercepts_hidden(self, values):
</span><span class="hit">        if values is None:
</span><span class="hit">            self._del_intercepts_hidden()
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                self._cann.intercepts_hidden = numpy.full(
</span><span class="noop">                        self.shape_intercepts_hidden,  values, dtype=float)
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to set the neuron related intercepts of &#39;
</span><span class="noop">                    &#39;the artificial neural network `%s` of element `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def _del_intercepts_hidden(self):
</span><span class="hit">        self._cann.intercepts_hidden = numpy.full(
</span><span class="noop">                                            self.shape_intercepts_hidden,
</span><span class="noop">                                            numpy.nan)
</span><span class="hit">        for idx_layer in range(self.nmb_layers):
</span><span class="hit">            for idx_neuron in range(self.nmb_neurons[idx_layer]):
</span><span class="hit">                self._cann.intercepts_hidden[idx_layer, idx_neuron] = 0.
</span><span class="noop">
</span><span class="hit">    intercepts_hidden = property(_get_intercepts_hidden,
</span><span class="noop">                                 _set_intercepts_hidden,
</span><span class="noop">                                 _del_intercepts_hidden)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def shape_intercepts_hidden(self):
</span><span class="noop">        &#34;&#34;&#34;Shape if the array containing the intercepts of neurons of
</span><span class="noop">        the hidden layers.&#34;&#34;&#34;
</span><span class="hit">        return (self.nmb_layers, self._max_nmb_neurons)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nmb_intercepts_hidden(self):
</span><span class="noop">        &#34;&#34;&#34;Number of input intercepts.&#34;&#34;&#34;
</span><span class="hit">        return sum(self.nmb_neurons)
</span><span class="noop">
</span><span class="hit">    def _get_intercepts_output(self):
</span><span class="noop">        &#34;&#34;&#34;Intercepts of all output nodes.
</span><span class="noop">
</span><span class="noop">        All intercepts are handled in a 1-dimensional array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.anntools import ANN
</span><span class="noop">        &gt;&gt;&gt; ann = ANN()
</span><span class="noop">        &gt;&gt;&gt; ann(nmb_outputs=3)
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_output
</span><span class="noop">        array([ 0.,  0.,  0.])
</span><span class="noop">
</span><span class="noop">        It is allowed to set values via slicing:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_output[1:] = 1.
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_output
</span><span class="noop">        array([ 0.,  1.,  1.])
</span><span class="noop">
</span><span class="noop">        If possible, type conversions are performed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_output = &#39;2&#39;
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_output
</span><span class="noop">        array([ 2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">        One can assign whole matrices directly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; import numpy
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_output = [1.0, 3.0, 2.0]
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_output
</span><span class="noop">        array([ 1.,  3.,  2.])
</span><span class="noop">
</span><span class="noop">        One can also delete the values contained in the array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; del ann.intercepts_output
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_output
</span><span class="noop">        array([ 0.,  0.,  0.])
</span><span class="noop">
</span><span class="noop">        Errors like wrong shapes (or unconvertible inputs) result in error
</span><span class="noop">        messages:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.intercepts_output = [1.0, 3.0]
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: While trying to set the output node related intercepts of the artificial neural network `ann` of element `?`, the following error occured: could not broadcast input array from shape (2) into shape (3)
</span><span class="noop">
</span><span class="noop">        The number of output intercepts is available as a property:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.nmb_intercepts_output
</span><span class="noop">        3
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return numpy.asarray(self._cann.intercepts_output)
</span><span class="noop">
</span><span class="hit">    def _set_intercepts_output(self, values):
</span><span class="hit">        if values is None:
</span><span class="hit">            self._del_intercepts_output()
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                self._cann.intercepts_output = numpy.full(
</span><span class="noop">                        self.shape_intercepts_output, values, dtype=float)
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to set the output node related intercepts &#39;
</span><span class="noop">                    &#39;of the artificial neural network `%s` of element `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def _del_intercepts_output(self):
</span><span class="hit">        self._cann.intercepts_output = numpy.zeros(
</span><span class="noop">                                            self.shape_intercepts_output)
</span><span class="noop">
</span><span class="hit">    intercepts_output = property(_get_intercepts_output,
</span><span class="noop">                                 _set_intercepts_output,
</span><span class="noop">                                 _del_intercepts_output)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def shape_intercepts_output(self):
</span><span class="noop">        &#34;&#34;&#34;Shape if the array containing the intercepts of neurons of
</span><span class="noop">        the hidden layers.&#34;&#34;&#34;
</span><span class="hit">        return (self.nmb_outputs,)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nmb_intercepts_output(self):
</span><span class="noop">        &#34;&#34;&#34;Number of output intercepts.&#34;&#34;&#34;
</span><span class="hit">        return self.nmb_outputs
</span><span class="noop">
</span><span class="hit">    def _get_inputs(self):
</span><span class="noop">        &#34;&#34;&#34;Values of the input nodes.
</span><span class="noop">
</span><span class="noop">        All input values are handled in a 1-dimensional array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.anntools import ANN
</span><span class="noop">        &gt;&gt;&gt; ann = ANN()
</span><span class="noop">        &gt;&gt;&gt; ann(nmb_inputs=3)
</span><span class="noop">        &gt;&gt;&gt; ann.inputs
</span><span class="noop">        array([ 0.,  0.,  0.])
</span><span class="noop">
</span><span class="noop">        It is allowed to set values via slicing:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.inputs[1:] = 1.
</span><span class="noop">        &gt;&gt;&gt; ann.inputs
</span><span class="noop">        array([ 0.,  1.,  1.])
</span><span class="noop">
</span><span class="noop">        If possible, type conversions are performed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.inputs = &#39;2&#39;
</span><span class="noop">        &gt;&gt;&gt; ann.inputs
</span><span class="noop">        array([ 2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">        One can assign whole matrices directly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; import numpy
</span><span class="noop">        &gt;&gt;&gt; ann.inputs = [1.0, 3.0, 2.0]
</span><span class="noop">        &gt;&gt;&gt; ann.inputs
</span><span class="noop">        array([ 1.,  3.,  2.])
</span><span class="noop">
</span><span class="noop">        One can also delete the values contained in the array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; del ann.inputs
</span><span class="noop">        &gt;&gt;&gt; ann.inputs
</span><span class="noop">        array([ 0.,  0.,  0.])
</span><span class="noop">
</span><span class="noop">        Errors like wrong shapes (or unconvertible inputs) result in error
</span><span class="noop">        messages:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.inputs = [1.0, 3.0]
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: While trying to set the inputs of the artificial neural network `ann` of element `?`, the following error occured: could not broadcast input array from shape (2) into shape (3)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return numpy.asarray(self._cann.inputs)
</span><span class="noop">
</span><span class="hit">    def _set_inputs(self, values):
</span><span class="miss">        if values is None:
</span><span class="miss">            self._del_inputs()
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                self._cann.inputs = numpy.full(self.nmb_inputs,
</span><span class="noop">                                               values, dtype=float)
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to set the inputs of the artificial &#39;
</span><span class="noop">                    &#39;neural network `%s` of element `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def _del_inputs(self):
</span><span class="miss">        self._cann.inputs = numpy.zeros(self.nmb_inputs)
</span><span class="noop">
</span><span class="hit">    inputs = property(_get_inputs, _set_inputs, _del_inputs)
</span><span class="noop">
</span><span class="hit">    def _get_outputs(self):
</span><span class="noop">        &#34;&#34;&#34;Values of the output nodes.
</span><span class="noop">
</span><span class="noop">        All output values are handled in a 1-dimensional array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.anntools import ANN
</span><span class="noop">        &gt;&gt;&gt; ann = ANN()
</span><span class="noop">        &gt;&gt;&gt; ann(nmb_outputs=3)
</span><span class="noop">        &gt;&gt;&gt; ann.outputs
</span><span class="noop">        array([ 0.,  0.,  0.])
</span><span class="noop">
</span><span class="noop">        It is not allowed to change output values manually:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.outputs = 1.0
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        AttributeError: can&#39;t set attribute
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return numpy.asarray(self._cann.outputs)
</span><span class="noop">
</span><span class="hit">    def _del_outputs(self):
</span><span class="hit">        self._cann.outputs = numpy.zeros(self.nmb_outputs)
</span><span class="noop">
</span><span class="hit">    outputs = property(_get_outputs, fdel=_del_outputs)
</span><span class="noop">
</span><span class="hit">    def _get_inputs(self):
</span><span class="noop">        &#34;&#34;&#34;Values of the input nodes.
</span><span class="noop">
</span><span class="noop">        All input values are handled in a 1-dimensional array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.anntools import ANN
</span><span class="noop">        &gt;&gt;&gt; ann = ANN()
</span><span class="noop">        &gt;&gt;&gt; ann(nmb_inputs=3)
</span><span class="noop">        &gt;&gt;&gt; ann.inputs
</span><span class="noop">        array([ 0.,  0.,  0.])
</span><span class="noop">
</span><span class="noop">        It is allowed to set values via slicing:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.inputs[1:] = 1.
</span><span class="noop">        &gt;&gt;&gt; ann.inputs
</span><span class="noop">        array([ 0.,  1.,  1.])
</span><span class="noop">
</span><span class="noop">        If possible, type conversions are performed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.inputs = &#39;2&#39;
</span><span class="noop">        &gt;&gt;&gt; ann.inputs
</span><span class="noop">        array([ 2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">        One can assign whole matrices directly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; import numpy
</span><span class="noop">        &gt;&gt;&gt; ann.inputs = [1.0, 3.0, 2.0]
</span><span class="noop">        &gt;&gt;&gt; ann.inputs
</span><span class="noop">        array([ 1.,  3.,  2.])
</span><span class="noop">
</span><span class="noop">        One can also delete the values contained in the array:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; del ann.inputs
</span><span class="noop">        &gt;&gt;&gt; ann.inputs
</span><span class="noop">        array([ 0.,  0.,  0.])
</span><span class="noop">
</span><span class="noop">        Errors like wrong shapes (or unconvertible inputs) result in error
</span><span class="noop">        messages:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ann.inputs = [1.0, 3.0]
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: While trying to set the inputs of the artificial neural network `ann` of element `?`, the following error occured: could not broadcast input array from shape (2) into shape (3)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return numpy.asarray(self._cann.inputs)
</span><span class="noop">
</span><span class="hit">    def _set_inputs(self, values):
</span><span class="hit">        if values is None:
</span><span class="miss">            self._del_inputs()
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                self._cann.inputs = numpy.full(self.nmb_inputs,
</span><span class="noop">                                               values, dtype=float)
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to set the inputs of the artificial &#39;
</span><span class="noop">                    &#39;neural network `%s` of element `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def _del_inputs(self):
</span><span class="hit">        self._cann.inputs = numpy.zeros(self.nmb_inputs)
</span><span class="noop">
</span><span class="hit">    inputs = property(_get_inputs, _set_inputs, _del_inputs)
</span><span class="noop">
</span><span class="hit">    def _update_hidden(self):
</span><span class="hit">        nmb_neurons = numpy.asarray(self._cann.nmb_neurons)
</span><span class="hit">        self._cann.neurons = numpy.zeros((self.nmb_layers, max(nmb_neurons)))
</span><span class="noop">
</span><span class="hit">    def process_actual_input(self):
</span><span class="noop">        &#34;&#34;&#34;Calculates the network output values based on the input values
</span><span class="noop">        defined previously.
</span><span class="noop">
</span><span class="noop">        For more information see the documentation on class :class:`ANN`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self._cann.process_actual_input()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nmb_weights(self):
</span><span class="miss">        nmb = self.nmb_inputs*self.nmb_neurons[0]
</span><span class="miss">        for idx_layer in range(self.nmb_layers-1):
</span><span class="miss">            nmb += self.nmb_neurons[idx_layer]*self.nmb_neurons[idx_layer+1]
</span><span class="miss">        nmb += self.nmb_neurons[-1]*self.nmb_outputs
</span><span class="miss">        return nmb
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nmb_intercepts(self):
</span><span class="miss">        return (sum(self.nmb_neurons) + self.nmb_outputs)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nmb_parameters(self):
</span><span class="miss">        return self.nmb_weights + self.nmb_intercepts
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        lines = [(objecttools.assignrepr_value(
</span><span class="noop">                self.nmb_inputs, &#39;ann(nmb_inputs=&#39;)+&#39;,&#39;)]
</span><span class="miss">        lines.append(objecttools.assignrepr_tuple(
</span><span class="noop">                self.nmb_neurons, &#39;    nmb_neurons=&#39;)+&#39;,&#39;)
</span><span class="miss">        lines.append(objecttools.assignrepr_value(
</span><span class="noop">                self.nmb_outputs, &#39;    nmb_outputs=&#39;)+&#39;,&#39;)
</span><span class="miss">        lines.append(objecttools.assignrepr_list2(
</span><span class="noop">                self.weights_input, &#39;    weights_input=&#39;)+&#39;,&#39;)
</span><span class="miss">        if self.nmb_layers &gt; 1:
</span><span class="miss">            lines.append(objecttools.assignrepr_list3(
</span><span class="noop">                    self.weights_hidden, &#39;    weights_hidden=&#39;)+&#39;,&#39;)
</span><span class="miss">        lines.append(objecttools.assignrepr_list2(
</span><span class="noop">                self.weights_output, &#39;    weights_output=&#39;)+&#39;,&#39;)
</span><span class="miss">        lines.append(objecttools.assignrepr_list2(
</span><span class="noop">                self.intercepts_hidden, &#39;    intercepts_hidden=&#39;)+&#39;,&#39;)
</span><span class="miss">        lines.append(objecttools.assignrepr_list(
</span><span class="noop">                self.intercepts_output, &#39;    intercepts_output=&#39;)+&#39;)&#39;)
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def plot(self, xmin, xmax, idx_input=0, idx_output=0, points=100,
</span><span class="noop">             **kwargs):
</span><span class="hit">        if (self.nmb_inputs &gt; 1) or (self.nmb_outputs &gt; 1):
</span><span class="miss">            raise NotImplementedError(
</span><span class="noop">                    &#39;At the moment, class `ANN` supports plotting the results &#39;
</span><span class="noop">                    &#39;of networks with one input and one output node only.&#39;)
</span><span class="hit">        xs = numpy.linspace(xmin, xmax, points)
</span><span class="hit">        ys = numpy.zeros(xs.shape)
</span><span class="hit">        for idx, x in enumerate(xs):
</span><span class="hit">            self.inputs[idx_input] = x
</span><span class="hit">            self.process_actual_input()
</span><span class="hit">            ys[idx] = self.outputs[idx_output]
</span><span class="hit">        pyplot.plot(xs, ys, **kwargs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/armatools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/armatools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module provides additional features for module
</span><span class="noop">:mod:`~hydpy.auxs.iuhtools`, related to Autoregressive-Moving Average (ARMA)
</span><span class="noop">models.&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import itertools
</span><span class="hit">import warnings
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="hit">from scipy import integrate
</span><span class="hit">from matplotlib import pyplot
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.auxs import statstools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MA(object):
</span><span class="noop">    &#34;&#34;&#34;Moving Average Model.
</span><span class="noop">
</span><span class="noop">    The MA coefficients can be set manually:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.armatools import MA
</span><span class="noop">    &gt;&gt;&gt; ma = MA(coefs=(.8, .2))
</span><span class="noop">    &gt;&gt;&gt; ma
</span><span class="noop">    MA(coefs=(0.8, 0.2))
</span><span class="noop">    &gt;&gt;&gt; ma.coefs = .2, .8
</span><span class="noop">    &gt;&gt;&gt; ma
</span><span class="noop">    MA(coefs=(0.2, 0.8))
</span><span class="noop">
</span><span class="noop">    Otherwise they are determined by method :func:`~MA.update_coefs`.
</span><span class="noop">    But this requires that a integrable function object is given.
</span><span class="noop">    Usually, this function object is a :class:`~hydpy.auxs.iuhtools.IUH`
</span><span class="noop">    subclass object, but (as in the following example) other function objects
</span><span class="noop">    defining instantaneuous unit hydrographs are accepted.  However, they
</span><span class="noop">    should be well-behaved (e.g. be relatively smooth, unimodal, strictly
</span><span class="noop">    positive, unity integral surface in the positive range).
</span><span class="noop">
</span><span class="noop">    For educational purposes, some discontinuous functions are applied in
</span><span class="noop">    the following. One can suppress the associated warning messages with
</span><span class="noop">    the following commands:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; import warnings
</span><span class="noop">    &gt;&gt;&gt; from scipy import integrate
</span><span class="noop">    &gt;&gt;&gt; warnings.filterwarnings(&#39;ignore&#39;,
</span><span class="noop">    ...                         category=integrate.IntegrationWarning)
</span><span class="noop">
</span><span class="noop">    The first example is a simple rectangle impuls:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; ma = MA(iuh=lambda x: .05 if x &lt; 20. else 0.)
</span><span class="noop">    &gt;&gt;&gt; ma
</span><span class="noop">    MA(coefs=(0.025, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05,
</span><span class="noop">              0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05,
</span><span class="noop">              0.025))
</span><span class="noop">
</span><span class="noop">    The number of the coefficients can be modified by changing the
</span><span class="noop">    class attribute :attr:`~MA.smallest_coeff`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; ma.smallest_coeff = .03
</span><span class="noop">    &gt;&gt;&gt; ma.update_coefs()
</span><span class="noop">    &gt;&gt;&gt; ma
</span><span class="noop">    MA(coefs=(0.025641, 0.051282, 0.051282, 0.051282, 0.051282, 0.051282,
</span><span class="noop">              0.051282, 0.051282, 0.051282, 0.051282, 0.051282, 0.051282,
</span><span class="noop">              0.051282, 0.051282, 0.051282, 0.051282, 0.051282, 0.051282,
</span><span class="noop">              0.051282, 0.051282))
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    The first two central moments of the time delay are a usefull measure for
</span><span class="noop">    describing the operation of a MA model:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; ma = MA(iuh=lambda x: 1. if x &lt; 1. else 0.)
</span><span class="noop">    &gt;&gt;&gt; ma
</span><span class="noop">    MA(coefs=(0.5, 0.5))
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; round_(ma.moments, 6)
</span><span class="noop">    0.5, 0.5
</span><span class="noop">
</span><span class="noop">    The first central moment is the weigthed time delay (mean lag time).
</span><span class="noop">    The second central moment is the weighted mean deviation from the
</span><span class="noop">    mean lag time (diffusion).
</span><span class="noop">
</span><span class="noop">    MA objects can return the turning point in the recession part of their
</span><span class="noop">    MA coefficients.  This can be demonstrated for the right side of the
</span><span class="noop">    probability density function of the normal distribution with zero
</span><span class="noop">    mean and a standard deviation (turning point) of 10:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from scipy import stats
</span><span class="noop">    &gt;&gt;&gt; ma = MA(iuh=lambda x: 2.*stats.norm.pdf(x, 0., 2.))
</span><span class="noop">    &gt;&gt;&gt; ma
</span><span class="noop">    MA(coefs=(0.195417, 0.346659, 0.24189, 0.13277, 0.057318, 0.019458,
</span><span class="noop">              0.005193, 0.001089, 0.00018, 0.000023, 0.000002, 0.0, 0.0))
</span><span class="noop">    &gt;&gt;&gt; round_(ma.turningpoint)
</span><span class="noop">    2, 0.24189
</span><span class="noop">
</span><span class="noop">    Note that the first returned value is the index of the the MA coefficient
</span><span class="noop">    closest to the turning point, and not a high precision estimate of
</span><span class="noop">    the real turning point of the instantaneous unit hydrograph.
</span><span class="noop">
</span><span class="noop">    You can also use the followint ploting command to verify the position of
</span><span class="noop">    the turning point, which is printed as a red dot.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; ma.plot(threshold=0.9)
</span><span class="noop">
</span><span class="noop">    You can close the plotting window manually or by writing:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from matplotlib import pyplot
</span><span class="noop">    &gt;&gt;&gt; pyplot.close()
</span><span class="noop">
</span><span class="noop">    The turning point detection also works for functions which include
</span><span class="noop">    both a rising and a falling limb.  This can be shown shifting the
</span><span class="noop">    normal distribution to the right:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; ma.iuh = lambda x: 2.*stats.norm.pdf(x, 4., 2.)
</span><span class="noop">    &gt;&gt;&gt; ma.update_coefs()
</span><span class="noop">    &gt;&gt;&gt; ma
</span><span class="noop">    MA(coefs=(0.019322, 0.067931, 0.12376, 0.177364, 0.199966, 0.177364,
</span><span class="noop">              0.12376, 0.067931, 0.029326, 0.009956, 0.002657, 0.000557,
</span><span class="noop">              0.000092, 0.000012, 0.000001, 0.0, 0.0))
</span><span class="noop">    &gt;&gt;&gt; round_(ma.turningpoint)
</span><span class="noop">    6, 0.12376
</span><span class="noop">
</span><span class="noop">    When no turning point can be detected, an error is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; ma.coefs = 1., 1., 1
</span><span class="noop">    &gt;&gt;&gt; ma.turningpoint
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    RuntimeError: Not able to detect a turning point in the impulse response defined by the MA coefficients 1.0, 1.0, 1.0.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    smallest_coeff = 1e-9
</span><span class="noop">    &#34;&#34;&#34;Smalles MA coefficient to be determined at the end of the response.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _coefs = None
</span><span class="noop">
</span><span class="hit">    def __init__(self, iuh=None, coefs=None):
</span><span class="hit">        self.iuh = iuh
</span><span class="hit">        if coefs is not None:
</span><span class="hit">            self.coefs = coefs
</span><span class="noop">
</span><span class="hit">    def _get_coefs(self):
</span><span class="noop">        &#34;&#34;&#34;:class:`~numpy.ndarray` containing all MA coefficents.&#34;&#34;&#34;
</span><span class="hit">        if self._coefs is None:
</span><span class="hit">            self.update_coefs()
</span><span class="hit">        return self._coefs
</span><span class="noop">
</span><span class="hit">    def _set_coefs(self, values):
</span><span class="hit">        self._coefs = numpy.array(values, ndmin=1, dtype=float)
</span><span class="noop">
</span><span class="hit">    def _del_coefs(self):
</span><span class="hit">        self._coefs = None
</span><span class="noop">
</span><span class="hit">    coefs = property(_get_coefs, _set_coefs, _del_coefs)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def order(self):
</span><span class="noop">        &#34;&#34;&#34;MA order.&#34;&#34;&#34;
</span><span class="hit">        return len(self.coefs)
</span><span class="noop">
</span><span class="hit">    def quad(self, dt, t):
</span><span class="hit">        return integrate.quad(self.iuh, max(t-1.+dt, 0.), t+dt)[0]
</span><span class="noop">
</span><span class="hit">    def update_coefs(self):
</span><span class="noop">        &#34;&#34;&#34;(Re)calculate the MA coefficients based on the instantaneous
</span><span class="noop">        unit hydrograph.&#34;&#34;&#34;
</span><span class="hit">        coefs = []
</span><span class="hit">        sum_coefs = 0.
</span><span class="hit">        for t in itertools.count(0., 1.):
</span><span class="hit">            coef = integrate.quad(self.quad, 0., 1., args=(t,))[0]
</span><span class="hit">            sum_coefs += coef
</span><span class="hit">            if (sum_coefs &gt; .9) and (coef &lt; self.smallest_coeff):
</span><span class="hit">                coefs = numpy.array(coefs)
</span><span class="hit">                coefs /= numpy.sum(coefs)
</span><span class="hit">                self.coefs = coefs
</span><span class="hit">                break
</span><span class="noop">            else:
</span><span class="hit">                coefs.append(coef)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def turningpoint(self):
</span><span class="noop">        &#34;&#34;&#34;Turning point (index and value tuple) in the recession part of the
</span><span class="noop">        MA approximation of the instantaneous unit hydrograph.&#34;&#34;&#34;
</span><span class="hit">        coefs = self.coefs
</span><span class="hit">        old_dc = coefs[1]-coefs[0]
</span><span class="hit">        for idx in range(self.order-2):
</span><span class="hit">            new_dc = coefs[idx+2]-coefs[idx+1]
</span><span class="hit">            if (old_dc &lt; 0.) and (new_dc &gt; old_dc):
</span><span class="hit">                return idx, coefs[idx]
</span><span class="noop">            else:
</span><span class="hit">                old_dc = new_dc
</span><span class="noop">        else:
</span><span class="hit">            raise RuntimeError(
</span><span class="noop">                &#39;Not able to detect a turning point in the impulse response &#39;
</span><span class="noop">                &#39;defined by the MA coefficients %s.&#39;
</span><span class="noop">                % objecttools.repr_values(coefs))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def delays(self):
</span><span class="noop">        &#34;&#34;&#34;Time delays related to the individual MA coefficients.&#34;&#34;&#34;
</span><span class="hit">        return numpy.arange(self.order, dtype=float)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def moments(self):
</span><span class="noop">        &#34;&#34;&#34;The first two time delay weighted statistical moments of the
</span><span class="noop">        MA coefficients.&#34;&#34;&#34;
</span><span class="hit">        moment1 = statstools.calc_mean_time(self.delays, self.coefs)
</span><span class="hit">        moment2 = statstools.calc_mean_time_deviation(
</span><span class="noop">                                    self.delays, self.coefs, moment1)
</span><span class="hit">        return numpy.array([moment1, moment2])
</span><span class="noop">
</span><span class="hit">    def plot(self, threshold=None, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;Barplot of the MA coefficients.&#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="noop">            # Works under matplotlib 3.
</span><span class="hit">            pyplot.bar(x=self.delays+.5, height=self.coefs,
</span><span class="noop">                       width=1., fill=False, **kwargs)
</span><span class="miss">        except TypeError:
</span><span class="noop">            # Works under matplotlib 2.
</span><span class="miss">            pyplot.bar(left=self.delays+.5, height=self.coefs,
</span><span class="noop">                       width=1., fill=False, **kwargs)
</span><span class="hit">        pyplot.xlabel(&#39;time&#39;)
</span><span class="hit">        pyplot.ylabel(&#39;response&#39;)
</span><span class="hit">        if threshold is not None:
</span><span class="hit">            cumsum = numpy.cumsum(self.coefs)
</span><span class="hit">            idx = numpy.where(cumsum &gt; threshold*cumsum[-1])[0][0]
</span><span class="hit">            pyplot.xlim(0., idx)
</span><span class="hit">        idx, value = self.turningpoint
</span><span class="hit">        pyplot.plot(idx, value, &#39;ro&#39;)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return objecttools.assignrepr_tuple(self.coefs, &#39;MA(coefs=&#39;, 70) + &#39;)&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ARMA(object):
</span><span class="noop">    &#34;&#34;&#34;Autoregressive-Moving Average model.
</span><span class="noop">
</span><span class="noop">    All ARMA coefficients can be set manually:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.armatools import MA, ARMA
</span><span class="noop">    &gt;&gt;&gt; arma = ARMA(ar_coefs=(.5,), ma_coefs=(.3, .2))
</span><span class="noop">    &gt;&gt;&gt; arma.coefs
</span><span class="noop">    (array([ 0.5]), array([ 0.3,  0.2]))
</span><span class="noop">    &gt;&gt;&gt; arma
</span><span class="noop">    ARMA(ar_coefs=(0.5,),
</span><span class="noop">         ma_coefs=(0.3, 0.2))
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; arma.ar_coefs = ()
</span><span class="noop">    &gt;&gt;&gt; arma.ma_coefs = range(20)
</span><span class="noop">    &gt;&gt;&gt; arma
</span><span class="noop">    ARMA(ar_coefs=(),
</span><span class="noop">         ma_coefs=(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0,
</span><span class="noop">                   11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0))
</span><span class="noop">
</span><span class="noop">    Otherwise they are determined by method :func:`~ARMA.update_coefs`.
</span><span class="noop">    But this requires that a :class:`MA` object is given.  Let us use
</span><span class="noop">    the MA model based on the shifted normal distribution of the
</span><span class="noop">    documentation on class :class:`MA` as an example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from scipy import stats
</span><span class="noop">    &gt;&gt;&gt; ma = MA(iuh=lambda x: 2.*stats.norm.pdf(x, 4., 2.))
</span><span class="noop">    &gt;&gt;&gt; arma = ARMA(ma_model=ma)
</span><span class="noop">    &gt;&gt;&gt; arma
</span><span class="noop">    ARMA(ar_coefs=(0.680483, -0.228511, 0.047283, -0.006022, 0.000377),
</span><span class="noop">         ma_coefs=(0.019322, 0.054783, 0.08195, 0.107757, 0.104458,
</span><span class="noop">                   0.07637, 0.041095, 0.01581, 0.004132, 0.000663,
</span><span class="noop">                   0.00005))
</span><span class="noop">
</span><span class="noop">    To verify that the ARMA model approximates the MA model with sufficient
</span><span class="noop">    accuracy, one can check the central moments of their responses to a
</span><span class="noop">    standard delta time impulse:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; round_(ma.moments)
</span><span class="noop">    4.110496, 1.926798
</span><span class="noop">    &gt;&gt;&gt; round_(arma.moments)
</span><span class="noop">    4.110496, 1.926798
</span><span class="noop">
</span><span class="noop">    On can check the accuray of the approximation directly via the property
</span><span class="noop">    :attr:`~ARMA.dev_moments`, which is the sum of the absolute values of
</span><span class="noop">    the deviations of both methods:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; round_(arma.dev_moments)
</span><span class="noop">    0.0
</span><span class="noop">
</span><span class="noop">    For the first six digits, there is no difference.  However, the total
</span><span class="noop">    number of coefficients is only reduced by one:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; ma.order
</span><span class="noop">    17
</span><span class="noop">    &gt;&gt;&gt; arma.order
</span><span class="noop">    (5, 11)
</span><span class="noop">
</span><span class="noop">    To reduce the determined number or AR coefficients, one can set a higher
</span><span class="noop">    AR-related tolerance value:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; arma.max_rel_rmse = 1e-3
</span><span class="noop">    &gt;&gt;&gt; arma.update_coefs()
</span><span class="noop">    &gt;&gt;&gt; arma
</span><span class="noop">    ARMA(ar_coefs=(0.788899, -0.256436, 0.034256),
</span><span class="noop">         ma_coefs=(0.019322, 0.052688, 0.075125, 0.096488, 0.089453,
</span><span class="noop">                   0.060854, 0.029041, 0.008929, 0.001397, 0.000001,
</span><span class="noop">                   -0.000004, 0.00001, -0.000008, -0.000009, -0.000004,
</span><span class="noop">                   -0.000001))
</span><span class="noop">
</span><span class="noop">    The number of AR coeffcients is actually reduced.  However, the are
</span><span class="noop">    now even more MA coefficients, possibly trying to compensate the lower
</span><span class="noop">    accuracy of the AR coefficients, and there is a slight decrease in
</span><span class="noop">    the precision of the moments:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; arma.order
</span><span class="noop">    (3, 16)
</span><span class="noop">    &gt;&gt;&gt; round_(arma.moments)
</span><span class="noop">    4.110497, 1.926804
</span><span class="noop">    &gt;&gt;&gt; round_(arma.dev_moments)
</span><span class="noop">    0.000007
</span><span class="noop">
</span><span class="noop">    To also reduce the number of MA coefficients, one can set a higher
</span><span class="noop">    MA-related tolerance value:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; arma.max_dev_coefs = 1e-3
</span><span class="noop">    &gt;&gt;&gt; arma.update_coefs()
</span><span class="noop">    &gt;&gt;&gt; arma
</span><span class="noop">    ARMA(ar_coefs=(0.788888, -0.256432, 0.034255),
</span><span class="noop">         ma_coefs=(0.019321, 0.052687, 0.075124, 0.096486, 0.089452,
</span><span class="noop">                   0.060853, 0.02904, 0.008929, 0.001397))
</span><span class="noop">
</span><span class="noop">    Now the total number of is in fact decreased, and the loss in accuracy
</span><span class="noop">    is still small:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; arma.order
</span><span class="noop">    (3, 9)
</span><span class="noop">    &gt;&gt;&gt; round_(arma.moments)
</span><span class="noop">    4.110794, 1.927625
</span><span class="noop">    &gt;&gt;&gt; round_(arma.dev_moments)
</span><span class="noop">    0.001125
</span><span class="noop">
</span><span class="noop">    Further relaxing the tolerance values results in even less coefficients,
</span><span class="noop">    but also in some slightly negative responses to a standard impulse:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; arma.max_rel_rmse = 1e-2
</span><span class="noop">    &gt;&gt;&gt; arma.max_dev_coefs = 1e-2
</span><span class="noop">    &gt;&gt;&gt; arma.update_coefs()
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    UserWarning: Note that the smallest response to a standard impulse of the determined ARMA model is negative (`-0.000316`).
</span><span class="noop">    &gt;&gt;&gt; arma
</span><span class="noop">    ARMA(ar_coefs=(0.736954, -0.166457),
</span><span class="noop">         ma_coefs=(0.01946, 0.05418, 0.077804, 0.098741, 0.091295,
</span><span class="noop">                   0.060797, 0.027226))
</span><span class="noop">    &gt;&gt;&gt; arma.order
</span><span class="noop">    (2, 7)
</span><span class="noop">    &gt;&gt;&gt; round_(arma.response)
</span><span class="noop">    0.01946, 0.068521, 0.125062, 0.1795, 0.202761, 0.180343, 0.12638, 0.063117, 0.025477, 0.008269, 0.001853, -0.000011, -0.000316, -0.000231, -0.000118, -0.000048, -0.000016
</span><span class="noop">
</span><span class="noop">    It seems to be hard to find a parameter efficient approximation to the
</span><span class="noop">    MA model in the given example. Generally, approximating ARMA models to MA
</span><span class="noop">    models is more beneficial when functions with long tails are involved.
</span><span class="noop">    The most extreme example would be a simple exponential decline:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; ma = MA(iuh=lambda x: .1*numpy.exp(-.1*x))
</span><span class="noop">    &gt;&gt;&gt; arma = ARMA(ma_model=ma)
</span><span class="noop">
</span><span class="noop">    In the given example a number of 185 MA coefficients can be reduced to a
</span><span class="noop">    total number of three ARMA coefficients with no relevant loss of accuracy:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; ma.order
</span><span class="noop">    185
</span><span class="noop">    &gt;&gt;&gt; arma.order
</span><span class="noop">    (1, 2)
</span><span class="noop">    &gt;&gt;&gt; round_(arma.dev_moments)
</span><span class="noop">    0.0
</span><span class="noop">
</span><span class="noop">    Use the following plotting command to see why 2 MA coeffcients instead of
</span><span class="noop">    one are required in the above example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; arma.plot(threshold=0.9)
</span><span class="noop">
</span><span class="noop">    Decreasing the tolerance values too much results in the following errors:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; arma.max_dev_coefs = 0.
</span><span class="noop">    &gt;&gt;&gt; arma.update_coefs()
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    RuntimeError: Method `update_ma_coefs` is not able to determine the MA coefficients of the ARMA model with the desired accuracy.  You can set the tolerance value ´max_dev_coefs` to a higher value.  An accuracy of `0.000000000925` has been reached using `185` MA coefficients.
</span><span class="noop">    &gt;&gt;&gt; arma.max_rel_rmse = 0.
</span><span class="noop">    &gt;&gt;&gt; arma.update_coefs()
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    RuntimeError: Method `update_ar_coefs` is not able to determine the AR coefficients of the ARMA model with the desired accuracy.  You can either set the tolerance value `max_rel_rmse` to a higher value or increase the allowed `max_ar_order`.  An accuracy of `0.0` has been reached using `10` coefficients.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    max_ar_order = 10
</span><span class="noop">    &#34;&#34;&#34;Maximum number of AR coefficients that are to be determined by method
</span><span class="noop">    :func:`~ARMA.update_coefs`.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    max_rel_rmse = 1e-6
</span><span class="noop">    &#34;&#34;&#34;Maximum relative root mean squared error to be accepted by method
</span><span class="noop">    :func:`~ARMA.update_coefs`.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    max_dev_coefs = 1e-6
</span><span class="noop">    &#34;&#34;&#34;Maximum deviation of the sum of all coefficents from one to be accepted
</span><span class="noop">    by method :func:`~ARMA.update_coefs`.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _ma_coefs = None
</span><span class="hit">    _ar_coefs = None
</span><span class="noop">
</span><span class="hit">    def __init__(self, ma_model=None, ar_coefs=None, ma_coefs=None):
</span><span class="hit">        self.ma = ma_model
</span><span class="hit">        if ar_coefs is not None:
</span><span class="hit">            self.ar_coefs = ar_coefs
</span><span class="hit">        if ma_coefs is not None:
</span><span class="hit">            self.ma_coefs = ma_coefs
</span><span class="hit">        self.rel_rmse = None
</span><span class="noop">
</span><span class="hit">    def _get_ar_coefs(self):
</span><span class="noop">        &#34;&#34;&#34;The AR coefficients of the AR model.&#34;&#34;&#34;
</span><span class="hit">        if self._ar_coefs is None:
</span><span class="hit">            self.update_ar_coefs()
</span><span class="hit">        return self._ar_coefs
</span><span class="noop">
</span><span class="hit">    def _set_ar_coefs(self, values):
</span><span class="hit">        self._ar_coefs = numpy.array(values, ndmin=1, dtype=float)
</span><span class="noop">
</span><span class="hit">    def _del_ar_coefs(self):
</span><span class="hit">        self._ar_coefs = None
</span><span class="noop">
</span><span class="hit">    ar_coefs = property(_get_ar_coefs, _set_ar_coefs, _del_ar_coefs)
</span><span class="noop">
</span><span class="hit">    def _get_ma_coefs(self):
</span><span class="noop">        &#34;&#34;&#34;The MA coefficients of the ARMA model.&#34;&#34;&#34;
</span><span class="hit">        if self._ma_coefs is None:
</span><span class="hit">            self.update_ma_coefs()
</span><span class="hit">        return self._ma_coefs
</span><span class="noop">
</span><span class="hit">    def _set_ma_coefs(self, values):
</span><span class="hit">        self._ma_coefs = numpy.array(values, ndmin=1, dtype=float)
</span><span class="noop">
</span><span class="hit">    def _del_ma_coefs(self):
</span><span class="hit">        self._ma_coefs = None
</span><span class="noop">
</span><span class="hit">    ma_coefs = property(_get_ma_coefs, _set_ma_coefs, _del_ma_coefs)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def coefs(self):
</span><span class="noop">        &#34;&#34;&#34;Tuple containing both the AR and the MA coefficients.&#34;&#34;&#34;
</span><span class="hit">        return (self.ar_coefs, self.ma_coefs)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def ar_order(self):
</span><span class="noop">        &#34;&#34;&#34;Number of AR coefficients.&#34;&#34;&#34;
</span><span class="hit">        return len(self.ar_coefs)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def ma_order(self):
</span><span class="noop">        &#34;&#34;&#34;Number of MA coefficients&#34;&#34;&#34;
</span><span class="hit">        return len(self.ma_coefs)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def order(self):
</span><span class="noop">        &#34;&#34;&#34;Number of both the AR and the MA coefficients.&#34;&#34;&#34;
</span><span class="hit">        return (self.ar_order, self.ma_order)
</span><span class="noop">
</span><span class="hit">    def update_coefs(self):
</span><span class="noop">        &#34;&#34;&#34;Determine both the AR and the MA coefficients.&#34;&#34;&#34;
</span><span class="hit">        self.update_ar_coefs()
</span><span class="hit">        self.update_ma_coefs()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def effective_max_ar_order(self):
</span><span class="noop">        &#34;&#34;&#34;The maximum number of AR coefficients that shall or can be
</span><span class="noop">        determined.
</span><span class="noop">
</span><span class="noop">        It is the minimum of :attr:`~ARMA.max_ar_order` and the number of
</span><span class="noop">        coefficients of the pure :class:`MA` after their turning point.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return min(self.max_ar_order, self.ma.order-self.ma.turningpoint[0]-1)
</span><span class="noop">
</span><span class="hit">    def update_ar_coefs(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the AR coefficients.
</span><span class="noop">
</span><span class="noop">        The number of AR coefficients is subsequently increased until the
</span><span class="noop">        required precision :attr:`~ARMA.max_rel_rmse` is reached.  Otherwise,
</span><span class="noop">        a :class:`~exceptions.RuntimeError` is raised.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        del self.ar_coefs
</span><span class="hit">        for ar_order in range(1, self.effective_max_ar_order+1):
</span><span class="hit">            self.calc_all_ar_coefs(ar_order, self.ma)
</span><span class="hit">            if self.rel_rmse &lt; self.max_rel_rmse:
</span><span class="hit">                break
</span><span class="noop">        else:
</span><span class="hit">            with pub.options.reprdigits(12):
</span><span class="hit">                raise RuntimeError(
</span><span class="noop">                    &#39;Method `update_ar_coefs` is not able to determine &#39;
</span><span class="noop">                    &#39;the AR coefficients of the ARMA model with the desired &#39;
</span><span class="noop">                    &#39;accuracy.  You can either set the tolerance value &#39;
</span><span class="noop">                    &#39;`max_rel_rmse` to a higher value or increase the &#39;
</span><span class="noop">                    &#39;allowed `max_ar_order`.  An accuracy of `%s` has been &#39;
</span><span class="noop">                    &#39;reached using `%d` coefficients.&#39;
</span><span class="noop">                    % (objecttools.repr_(self.rel_rmse), ar_order))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def dev_moments(self):
</span><span class="noop">        &#34;&#34;&#34;Sum of the absolute deviations between the central moments of the
</span><span class="noop">        instantaneous unit hydrograph and the ARMA approximation.&#34;&#34;&#34;
</span><span class="hit">        return numpy.sum(numpy.abs(self.moments-self.ma.moments))
</span><span class="noop">
</span><span class="hit">    def norm_coefs(self):
</span><span class="noop">        &#34;&#34;&#34;Multiply all coefficients by the same factor, so that their sum
</span><span class="noop">        becomes one.&#34;&#34;&#34;
</span><span class="hit">        sum_coefs = self.sum_coefs
</span><span class="hit">        self.ar_coefs /= sum_coefs
</span><span class="hit">        self.ma_coefs /= sum_coefs
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def sum_coefs(self):
</span><span class="noop">        &#34;&#34;&#34;The sum of all AR and MA coefficients&#34;&#34;&#34;
</span><span class="hit">        return numpy.sum(self.ar_coefs) + numpy.sum(self.ma_coefs)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def dev_coefs(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute deviation of :attr:`~ARMA.sum_coefs` from one.&#34;&#34;&#34;
</span><span class="hit">        return abs(self.sum_coefs-1.)
</span><span class="noop">
</span><span class="hit">    def calc_all_ar_coefs(self, ar_order, ma_model):
</span><span class="noop">        &#34;&#34;&#34;Determine the AR coeffcients based on a least squares approach.
</span><span class="noop">
</span><span class="noop">        The argument `ar_order` defines the number of AR coefficients to be
</span><span class="noop">        determined.  The argument `ma_order` defines a pure :class:`MA` model.
</span><span class="noop">        The least squares approach is applied on all those coefficents of the
</span><span class="noop">        pure MA model, which are associated with the part of the recession
</span><span class="noop">        curve behind its turning point.
</span><span class="noop">
</span><span class="noop">        The attribute :attr:`~ARMA.rel_rmse` is updated with the resulting
</span><span class="noop">        relative root mean square error.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        turning_idx, _ = ma_model.turningpoint
</span><span class="hit">        values = ma_model.coefs[turning_idx:]
</span><span class="hit">        self.ar_coefs, residuals = numpy.linalg.lstsq(
</span><span class="noop">                                            self.get_a(values, ar_order),
</span><span class="noop">                                            self.get_b(values, ar_order))[:2]
</span><span class="hit">        if len(residuals) == 1:
</span><span class="hit">            self.rel_rmse = numpy.sqrt(residuals[0])/numpy.sum(values)
</span><span class="noop">        else:
</span><span class="hit">            self.rel_rmse = 0.
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def get_a(values, n):
</span><span class="noop">        &#34;&#34;&#34;Extract the independend variables of the given values and return
</span><span class="noop">        them as a matrix with n columns in a form suitable for the least
</span><span class="noop">        squares approach applied in method :func:`~ARMA.calc_ar_coefs`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        m = len(values)-n
</span><span class="hit">        a = numpy.empty((m, n), dtype=float)
</span><span class="hit">        for i in range(m):
</span><span class="hit">            i0 = i-1 if i &gt; 0 else None
</span><span class="hit">            i1 = i+n-1
</span><span class="hit">            a[i] = values[i1:i0:-1]
</span><span class="hit">        return numpy.array(a)
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def get_b(values, n):
</span><span class="noop">        &#34;&#34;&#34;Extract the dependend variables of the values in a vector with n
</span><span class="noop">        entries in a form suitable for the least squares approach applied in
</span><span class="noop">        method :func:`~ARMA.calc_ar_coefs`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return numpy.array(values[n:])
</span><span class="noop">
</span><span class="hit">    def update_ma_coefs(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the MA coefficients.
</span><span class="noop">
</span><span class="noop">        The number of MA coefficients is subsequently increased until the
</span><span class="noop">        required precision :attr:`~ARMA.max_dev_coefs` is reached.  Otherwise,
</span><span class="noop">        a :class:`~exceptions.RuntimeError` is raised.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.ma_coefs = []
</span><span class="hit">        for ma_order in range(1, self.ma.order+1):
</span><span class="hit">            self.calc_next_ma_coef(ma_order, self.ma)
</span><span class="hit">            if self.dev_coefs &lt; self.max_dev_coefs:
</span><span class="hit">                self.norm_coefs()
</span><span class="hit">                break
</span><span class="noop">        else:
</span><span class="hit">            with pub.options.reprdigits(12):
</span><span class="hit">                raise RuntimeError(
</span><span class="noop">                    &#39;Method `update_ma_coefs` is not able to determine the MA &#39;
</span><span class="noop">                    &#39;coefficients of the ARMA model with the desired accuracy.&#39;
</span><span class="noop">                    &#39;  You can set the tolerance value ´max_dev_coefs` to a &#39;
</span><span class="noop">                    &#39;higher value.  An accuracy of `%s` has been reached &#39;
</span><span class="noop">                    &#39;using `%d` MA coefficients.&#39;
</span><span class="noop">                    % (objecttools.repr_(self.dev_coefs), ma_order))
</span><span class="hit">        if numpy.min(self.response) &lt; 0.:
</span><span class="hit">            warnings.warn(
</span><span class="noop">                &#39;Note that the smallest response to a standard impulse of the &#39;
</span><span class="noop">                &#39;determined ARMA model is negative (`%s`).&#39;
</span><span class="noop">                % objecttools.repr_(numpy.min(self.response)))
</span><span class="noop">
</span><span class="hit">    def calc_next_ma_coef(self, ma_order, ma_model):
</span><span class="noop">        &#34;&#34;&#34;Determine the MA coefficients of the ARMA model based on its
</span><span class="noop">        predetermined AR coefficients and the MA ordinates of the given
</span><span class="noop">        :class:`MA` model.
</span><span class="noop">
</span><span class="noop">        The MA coefficients are determined one at a time, beginning with the
</span><span class="noop">        first one.  Each ARMA MA coefficient in set in a manner that allows
</span><span class="noop">        for the exact reproduction of the equivalent pure MA coefficient with
</span><span class="noop">        all relevant ARMA coefficients.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        idx = ma_order-1
</span><span class="hit">        coef = ma_model.coefs[idx]
</span><span class="hit">        for jdx, ar_coef in enumerate(self.ar_coefs):
</span><span class="hit">            zdx = idx-jdx-1
</span><span class="hit">            if zdx &gt;= 0:
</span><span class="hit">                coef -= ar_coef*ma_model.coefs[zdx]
</span><span class="hit">        self.ma_coefs = numpy.concatenate((self.ma_coefs, [coef]))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def response(self):
</span><span class="noop">        &#34;&#34;&#34;Return the response to a standard dt impulse.&#34;&#34;&#34;
</span><span class="hit">        values = []
</span><span class="hit">        sum_values = 0.
</span><span class="hit">        idx = 0
</span><span class="hit">        ma_coefs = self.ma_coefs
</span><span class="hit">        ar_coefs = self.ar_coefs
</span><span class="hit">        ma_order = self.ma_order
</span><span class="hit">        for idx in range(len(self.ma.delays)):
</span><span class="hit">            value = 0.
</span><span class="hit">            if idx &lt; ma_order:
</span><span class="hit">                value += ma_coefs[idx]
</span><span class="hit">            for jdx, ar_coef in enumerate(ar_coefs):
</span><span class="hit">                zdx = idx-jdx-1
</span><span class="hit">                if zdx &gt;= 0:
</span><span class="hit">                    value += ar_coef*values[zdx]
</span><span class="hit">            values.append(value)
</span><span class="hit">            sum_values += value
</span><span class="hit">        return numpy.array(values)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def moments(self):
</span><span class="noop">        &#34;&#34;&#34;The first two time delay weighted statistical moments of the
</span><span class="noop">        ARMA response.&#34;&#34;&#34;
</span><span class="hit">        timepoints = self.ma.delays
</span><span class="hit">        response = self.response
</span><span class="hit">        moment1 = statstools.calc_mean_time(timepoints, response)
</span><span class="hit">        moment2 = statstools.calc_mean_time_deviation(
</span><span class="noop">                                            timepoints, response, moment1)
</span><span class="hit">        return numpy.array([moment1, moment2])
</span><span class="noop">
</span><span class="hit">    def plot(self, threshold=None, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;Barplot of the ARMA response.&#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="noop">            # Works under matplotlib 3.
</span><span class="hit">            pyplot.bar(x=self.ma.delays+.5, height=self.response,
</span><span class="noop">                       width=1., fill=False, **kwargs)
</span><span class="miss">        except TypeError:
</span><span class="noop">            # Works under matplotlib 2.
</span><span class="miss">            pyplot.bar(left=self.ma.delays+.5, height=self.response,
</span><span class="noop">                       width=1., fill=False, **kwargs)
</span><span class="hit">        pyplot.xlabel(&#39;time&#39;)
</span><span class="hit">        pyplot.ylabel(&#39;response&#39;)
</span><span class="hit">        if threshold is not None:
</span><span class="hit">            cumsum = numpy.cumsum(self.response)
</span><span class="hit">            idx = numpy.where(cumsum &gt; threshold*cumsum[-1])[0][0]
</span><span class="hit">            pyplot.xlim(0., idx)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return &#39;%s,\n%s)&#39; % (objecttools.assignrepr_tuple(self.ar_coefs,
</span><span class="noop">                                                          &#39;ARMA(ar_coefs=&#39;,
</span><span class="noop">                                                          70),
</span><span class="noop">                             objecttools.assignrepr_tuple(self.ma_coefs,
</span><span class="noop">                                                          &#39;     ma_coefs=&#39;,
</span><span class="noop">                                                          70))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/iuhtools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/iuhtools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module supports modelling based on instantaneous unit hydrographs.
</span><span class="noop">
</span><span class="noop">This module implements some abstract descriptor classes, metaclasses and base
</span><span class="noop">classes.  If you are just interested in applying a certain instantaneous
</span><span class="noop">unit hydrograph (iuh) function or if you want to implement an additional
</span><span class="noop">iuh, see the examples or the source code of class
</span><span class="noop">:class:`TranslationDiffusionEquation`.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import itertools
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="hit">from scipy import special
</span><span class="hit">from matplotlib import pyplot
</span><span class="noop"># ...from Hydpy
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.auxs import statstools
</span><span class="hit">from hydpy.auxs import armatools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class IUH_Parameter(object):
</span><span class="noop">    &#34;&#34;&#34;Descriptor base class for :class:`PrimaryParameter` and
</span><span class="noop">    :class:`SecondaryParameter`.
</span><span class="noop">
</span><span class="noop">    The first initialization argument is the parameters name.  Optionally,
</span><span class="noop">    an alternative type (the default type is :class:`float`) and a
</span><span class="noop">    documentation string can be passed.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, name, type_=float, doc=None):
</span><span class="hit">        self.name = name
</span><span class="hit">        self._name = &#39;_&#39;+name
</span><span class="hit">        self.type_ = type_
</span><span class="hit">        self.__doc__ = (&#39;Instantaneous unit hydrograph parameter %s.&#39; % name
</span><span class="noop">                        if doc is None else str(doc))
</span><span class="noop">
</span><span class="hit">    def __get__(self, obj, type_=None):
</span><span class="hit">        return self if obj is None else getattr(obj, self._name, None)
</span><span class="noop">
</span><span class="hit">    def _convert_type(self, value):
</span><span class="hit">        try:
</span><span class="hit">            return self.type_(value)
</span><span class="hit">        except BaseException:
</span><span class="hit">            raise TypeError(
</span><span class="noop">                &#39;The value `%s` of type `%s` could not be converted to type &#39;
</span><span class="noop">                &#39;`%s` of the instantaneous unit hydrograph parameter `%s`.&#39;
</span><span class="noop">                % (value, objecttools.classname(value),
</span><span class="noop">                   objecttools.classname(self.type_), self.name))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PrimaryParameter(IUH_Parameter):
</span><span class="noop">    &#34;&#34;&#34;Descriptor base class for parameters of instantaneous unit hydrograph
</span><span class="noop">    functions to be defined by the user.
</span><span class="noop">
</span><span class="noop">    When a primary parameter value is set or deleted, the master instance is
</span><span class="noop">    instructed to :func:`~IUH.update` all secondary parameter values.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __set__(self, obj, value):
</span><span class="hit">        value = self._convert_type(value)
</span><span class="hit">        setattr(obj, self._name, value)
</span><span class="hit">        obj.update()
</span><span class="noop">
</span><span class="hit">    def __delete__(self, obj):
</span><span class="hit">        setattr(obj, self._name, None)
</span><span class="hit">        obj.update()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SecondaryParameter(IUH_Parameter):
</span><span class="noop">    &#34;&#34;&#34;Descriptor base class for parameters of instantaneous unit hydrograph
</span><span class="noop">    functions which can be determined automatically.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __set__(self, obj, value):
</span><span class="hit">        value = self._convert_type(value)
</span><span class="hit">        setattr(obj, self._name, value)
</span><span class="noop">
</span><span class="hit">    def __delete__(self, obj):
</span><span class="hit">        setattr(obj, self._name, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MetaIUH(type):
</span><span class="noop">    &#34;&#34;&#34;Metaclass for class :class:`IUH`.
</span><span class="noop">
</span><span class="noop">    For storing :class:`PrimaryParameter` and :class:`SecondaryParameter` in
</span><span class="noop">    seperate dictionaries.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __new__(cls, name, parents, dict_):
</span><span class="hit">        primary_parameters = {}
</span><span class="hit">        secondary_parameters = {}
</span><span class="hit">        for key, value in dict_.items():
</span><span class="hit">            if isinstance(value, PrimaryParameter):
</span><span class="hit">                primary_parameters[key] = value
</span><span class="hit">            elif isinstance(value, SecondaryParameter):
</span><span class="hit">                secondary_parameters[key] = value
</span><span class="hit">        dict_[&#39;_primary_parameters&#39;] = primary_parameters
</span><span class="hit">        dict_[&#39;_secondary_parameters&#39;] = secondary_parameters
</span><span class="hit">        return type.__new__(cls, name, parents, dict_)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># Just for making MetaIUH the type of class IUH both in Python 2 and 3:
</span><span class="hit">_MetaIUH = MetaIUH(&#39;_MetaIUH&#39;, (), {})
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class IUH(_MetaIUH):
</span><span class="noop">    &#34;&#34;&#34;Base class for instantaneous unit hydrograph function objects.
</span><span class="noop">
</span><span class="noop">    See class :class:`TranslationDiffusionEquation` for explanations and
</span><span class="noop">    application examples.
</span><span class="noop">
</span><span class="noop">    For developers: The string representation does also work for
</span><span class="noop">    parameter-free :class:`IUH` subclasses:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.iuhtools import IUH
</span><span class="noop">    &gt;&gt;&gt; class Test(IUH):
</span><span class="noop">    ...     pass
</span><span class="noop">    &gt;&gt;&gt; Test()
</span><span class="noop">    Test()
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    dt_response = 1e-2
</span><span class="noop">    &#34;&#34;&#34;Relative stepsize for plotting and analyzing iuh functions.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    smallest_response = 1e-9
</span><span class="noop">    &#34;&#34;&#34;Smallest value taken into account for plotting and analyzing iuh
</span><span class="noop">    functions.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, **kwargs):
</span><span class="hit">        self.ma = armatools.MA(self)
</span><span class="hit">        self.arma = armatools.ARMA(ma_model=self.ma)
</span><span class="hit">        if kwargs:
</span><span class="hit">            self.set_primary_parameters(**kwargs)
</span><span class="noop">
</span><span class="hit">    def set_primary_parameters(self, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;Set all primary parameters at once.&#34;&#34;&#34;
</span><span class="hit">        given = sorted(kwargs.keys())
</span><span class="hit">        required = sorted(self._primary_parameters)
</span><span class="hit">        if given == required:
</span><span class="hit">            for (key, value) in kwargs.items():
</span><span class="hit">                setattr(self, key, value)
</span><span class="noop">        else:
</span><span class="hit">            raise ValueError(
</span><span class="noop">                &#39;When passing primary parameter values as initialization &#39;
</span><span class="noop">                &#39;arguments of the instantaneous unit hydrograph class `%s`, &#39;
</span><span class="noop">                &#39;or when using method `set_primary_parameters, one has to &#39;
</span><span class="noop">                &#39;to define all values at once via keyword arguments.  &#39;
</span><span class="noop">                &#39;But instead of the primary parameter names `%s` the &#39;
</span><span class="noop">                &#39;following keywords were given: %s.&#39;
</span><span class="noop">                % (objecttools.classname(self),
</span><span class="noop">                   &#39;, &#39;.join(required), &#39;, &#39;.join(given)))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def are_primary_parameters_complete(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag that indicates wheter the values of all primary
</span><span class="noop">        parameters are defined or not.&#34;&#34;&#34;
</span><span class="hit">        for primpar in self._primary_parameters.values():
</span><span class="hit">            if primpar.__get__(self) is None:
</span><span class="hit">                return False
</span><span class="hit">        return True
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Delete the coefficients of the pure MA model and also all MA and
</span><span class="noop">        AR coefficients of the ARMA model.  Also calculate or delete the values
</span><span class="noop">        of all secondary iuh parameters, depending on the completeness of the
</span><span class="noop">        values of the primary parameters.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        del self.ma.coefs
</span><span class="hit">        del self.arma.ma_coefs
</span><span class="hit">        del self.arma.ar_coefs
</span><span class="hit">        if self.are_primary_parameters_complete:
</span><span class="hit">            self.calc_secondary_parameters()
</span><span class="noop">        else:
</span><span class="hit">            for secpar in self._secondary_parameters.values():
</span><span class="hit">                secpar.__delete__(self)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def delay_response_series(self):
</span><span class="noop">        &#34;&#34;&#34;A tuple of two numpy arrays, which hold the time delays and the
</span><span class="noop">        associated iuh values respectively.&#34;&#34;&#34;
</span><span class="hit">        delays = []
</span><span class="hit">        responses = []
</span><span class="hit">        sum_responses = 0.
</span><span class="hit">        for t in itertools.count(self.dt_response/2., self.dt_response):
</span><span class="hit">            delays.append(t)
</span><span class="hit">            response = self(t)
</span><span class="hit">            responses.append(response)
</span><span class="hit">            sum_responses += self.dt_response*response
</span><span class="hit">            if (sum_responses &gt; .9) and (response &lt; self.smallest_response):
</span><span class="hit">                break
</span><span class="hit">        return numpy.array(delays), numpy.array(responses)
</span><span class="noop">
</span><span class="hit">    def plot(self, threshold=None, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;Plot the instanteneous unit hydrograph.
</span><span class="noop">
</span><span class="noop">        The optional argument allows for defining a threshold of the cumulative
</span><span class="noop">        sum uf the hydrograph, used to adjust the largest value of the x-axis.
</span><span class="noop">        It must be a value between zero and one.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        delays, responses = self.delay_response_series
</span><span class="hit">        pyplot.plot(delays, responses, **kwargs)
</span><span class="hit">        pyplot.xlabel(&#39;time&#39;)
</span><span class="hit">        pyplot.ylabel(&#39;response&#39;)
</span><span class="hit">        if threshold is not None:
</span><span class="hit">            threshold = numpy.clip(threshold, 0., 1.)
</span><span class="hit">            cumsum = numpy.cumsum(responses)
</span><span class="hit">            idx = numpy.where(cumsum &gt;= threshold*cumsum[-1])[0][0]
</span><span class="hit">            pyplot.xlim(0., delays[idx])
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def moments(self):
</span><span class="noop">        &#34;&#34;&#34;The first two time delay weighted statistical moments of the
</span><span class="noop">        instantaneous unit hydrograph.&#34;&#34;&#34;
</span><span class="hit">        delays, response = self.delay_response_series
</span><span class="hit">        moment1 = statstools.calc_mean_time(delays, response)
</span><span class="hit">        moment2 = statstools.calc_mean_time_deviation(delays, response,
</span><span class="noop">                                                      moment1)
</span><span class="hit">        return numpy.array([moment1, moment2])
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        parts = [objecttools.classname(self), &#39;(&#39;]
</span><span class="hit">        for (name, primpar) in sorted(self._primary_parameters.items()):
</span><span class="hit">            value = primpar.__get__(self)
</span><span class="hit">            if value is not None:
</span><span class="hit">                parts.extend([name, &#39;=&#39;, objecttools.repr_(value), &#39;, &#39;])
</span><span class="hit">        if parts[-1] == &#39;, &#39;:
</span><span class="hit">            parts[-1] = &#39;)&#39;
</span><span class="noop">        else:
</span><span class="hit">            parts.append(&#39;)&#39;)
</span><span class="hit">        return &#39;&#39;.join(parts)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TranslationDiffusionEquation(IUH):
</span><span class="noop">    &#34;&#34;&#34;An instantaneous unit hydrograph based on the `translation diffusion
</span><span class="noop">    equation`.
</span><span class="noop">
</span><span class="noop">    The equation used is a linear approximation of the Saint-Venant
</span><span class="noop">    equations for channel routing:
</span><span class="noop">
</span><span class="noop">      :math:`h(t) = \\frac{a}{t \\cdot \\sqrt{\\pi \\cdot t}} \\cdot
</span><span class="noop">      e^{-t \\cdot (a/t-b)^2}`
</span><span class="noop">
</span><span class="noop">    with:
</span><span class="noop">      :math:`a = \\frac{x}{2 \\cdot \\sqrt{d}}`
</span><span class="noop">
</span><span class="noop">      :math:`b = \\frac{u}{2 \\cdot \\sqrt{d}}`
</span><span class="noop">
</span><span class="noop">    There are three primary parameter whichs values need to be defined by
</span><span class="noop">    the user:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.iuhtools import TranslationDiffusionEquation
</span><span class="noop">    &gt;&gt;&gt; tde = TranslationDiffusionEquation(u=5., d=15., x=50.)
</span><span class="noop">    &gt;&gt;&gt; tde
</span><span class="noop">    TranslationDiffusionEquation(d=15.0, u=5.0, x=50.0)
</span><span class="noop">
</span><span class="noop">    The values of both secondary parameters are determined automatically:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; round_((tde.a, tde.b))
</span><span class="noop">    6.454972, 0.645497
</span><span class="noop">
</span><span class="noop">    The function can be evaluated for time delays larger zero, but not for
</span><span class="noop">    zero time delay:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; round_(tde(numpy.array([5., 10., 15., 20.])))
</span><span class="noop">    0.040559, 0.115165, 0.031303, 0.00507
</span><span class="noop">    &gt;&gt;&gt; tde(0.)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ZeroDivisionError: float division by zero
</span><span class="noop">
</span><span class="noop">    The first delay weighted central moment of the translation diffusion
</span><span class="noop">    equation corresponds to the time lag (`x`/`u`), the second one to
</span><span class="noop">    wave diffusion:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; round_(tde.moments)
</span><span class="noop">    10.0, 3.464101
</span><span class="noop">
</span><span class="noop">    You can also plot the graph corresponding to the actual parameterization:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; tde.plot(threshold=0.9)
</span><span class="noop">
</span><span class="noop">    You can close the plotting window manually or by writing:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from matplotlib import pyplot
</span><span class="noop">    &gt;&gt;&gt; pyplot.close()
</span><span class="noop">
</span><span class="noop">    All instances of the subclasses of :class:`IUH` provide a pure
</span><span class="noop">    Moving Average and an Autoregressive-Moving Average approximation to the
</span><span class="noop">    dt standard impulse of the instantaneous unit hydrograph function.  In
</span><span class="noop">    the given example, the MA approximation involves 57 coefficients, and the
</span><span class="noop">    ARMA approximation invoves 17 coefficients:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; tde.ma.order
</span><span class="noop">    57
</span><span class="noop">    &gt;&gt;&gt; tde.arma.order
</span><span class="noop">    (3, 14)
</span><span class="noop">
</span><span class="noop">    The diffusion of the MA model deviates from the iuh function due to
</span><span class="noop">    aggregation.  For the ARMA model, there is also a slight deviation in
</span><span class="noop">    time delay, as the ARMA model itself is only a approximation of the
</span><span class="noop">    MA model:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; round_(tde.ma.moments)
</span><span class="noop">    10.0, 3.488074
</span><span class="noop">    &gt;&gt;&gt; round_(tde.arma.moments)
</span><span class="noop">    10.000091, 3.488377
</span><span class="noop">
</span><span class="noop">    For further information on using MA and ARMA models, read the
</span><span class="noop">    documentation on module :mod:`~hydpy.auxs.armatools`.
</span><span class="noop">
</span><span class="noop">    Changing a primary parameter results in an updating of the secondary
</span><span class="noop">    parameters as well as the MA and the ARMA model:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; tde.x = 5.
</span><span class="noop">    &gt;&gt;&gt; round_((tde.a, tde.b))
</span><span class="noop">    0.645497, 0.645497
</span><span class="noop">    &gt;&gt;&gt; tde.ma.order
</span><span class="noop">    37
</span><span class="noop">    &gt;&gt;&gt; tde.arma.order
</span><span class="noop">    (4, 5)
</span><span class="noop">
</span><span class="noop">    As long as the primary parameter values are incomplete, no secondary
</span><span class="noop">    parameter values are available:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; del tde.x
</span><span class="noop">    &gt;&gt;&gt; round_((tde.a, tde.b))
</span><span class="noop">    None, None
</span><span class="noop">
</span><span class="noop">    Suitable type conversions are performed when new parameter values are set:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; tde.x = &#39;1.&#39;
</span><span class="noop">    &gt;&gt;&gt; tde.x
</span><span class="noop">    1.0
</span><span class="noop">
</span><span class="noop">    It a new value cannot be converted, an error is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; tde.x = &#39;a&#39;
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    TypeError: The value `a` of type `str` could not be converted to type `float` of the instantaneous unit hydrograph parameter `x`.
</span><span class="noop">
</span><span class="noop">    When passing parameter values as initialization arguments or when using
</span><span class="noop">    method `set_primary_parameters`, tests for completeness are performed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; TranslationDiffusionEquation(u=5.0, d=15.0)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: When passing primary parameter values as initialization arguments of the instantaneous unit hydrograph class `TranslationDiffusionEquation`, or when using method `set_primary_parameters, one has to to define all values at once via keyword arguments.  But instead of the primary parameter names `d, u, x` the following keywords were given: d, u.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    u = PrimaryParameter(&#39;u&#39;, doc=&#39;Wave velocity.&#39;)
</span><span class="hit">    d = PrimaryParameter(&#39;d&#39;, doc=&#39;Diffusion coefficient.&#39;)
</span><span class="hit">    x = PrimaryParameter(&#39;x&#39;, doc=&#39;Routing distance.&#39;)
</span><span class="hit">    a = SecondaryParameter(&#39;a&#39;, doc=&#39;Distance related coefficient.&#39;)
</span><span class="hit">    b = SecondaryParameter(&#39;b&#39;, doc=&#39;Velocity related coefficient.&#39;)
</span><span class="noop">
</span><span class="hit">    def calc_secondary_parameters(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the values of the secondary parameters `a` and `b`.&#34;&#34;&#34;
</span><span class="hit">        self.a = self.x/(2.*self.d**.5)
</span><span class="hit">        self.b = self.u/(2.*self.d**.5)
</span><span class="noop">
</span><span class="hit">    def __call__(self, t):
</span><span class="hit">        return self.a/(t*(numpy.pi*t)**.5)*numpy.exp(-t*(self.a/t-self.b)**2)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LinearStorageCascade(IUH):
</span><span class="noop">    &#34;&#34;&#34;An instantaneous unit hydrograph based on the `linear storage cascade`.
</span><span class="noop">
</span><span class="noop">    The equation involves the gamma function, allowing for a fractional number
</span><span class="noop">    of storages:
</span><span class="noop">
</span><span class="noop">      :math:`h(t) = c \\cdot (t/k)^{n-1} \\cdot e^{-t/k}`
</span><span class="noop">
</span><span class="noop">    with:
</span><span class="noop">      :math:`c = \\frac{1}{k \\cdot \\gamma(n)}`
</span><span class="noop">
</span><span class="noop">    After defining the values of the two primary parameters, the function
</span><span class="noop">    object can be applied:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.iuhtools import LinearStorageCascade
</span><span class="noop">    &gt;&gt;&gt; lsc = LinearStorageCascade(n=2.5, k=2.)
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; round_(lsc.c)
</span><span class="noop">    0.376126
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; round_(lsc(numpy.array([5., 10., 15., 20.])))
</span><span class="noop">    0.122042, 0.028335, 0.004273, 0.00054
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    n = PrimaryParameter(&#39;n&#39;, doc=&#39;Number of linear storages.&#39;)
</span><span class="hit">    k = PrimaryParameter(
</span><span class="noop">        &#39;k&#39;, doc=&#39;Time of concentration of each individual storage.&#39;)
</span><span class="hit">    c = SecondaryParameter(&#39;c&#39;, doc=&#39;Proportionality factor.&#39;)
</span><span class="noop">
</span><span class="hit">    def calc_secondary_parameters(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the value of the secondary parameter `c`.&#34;&#34;&#34;
</span><span class="hit">        self.c = 1./(self.k*special.gamma(self.n))
</span><span class="noop">
</span><span class="hit">    def __call__(self, t):
</span><span class="hit">        return self.c*(t/self.k)**(self.n-1)*numpy.exp(-t/self.k)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/networktools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/networktools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module provides features for preparing HydPy networks based on
</span><span class="noop">different data.&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy.core import selectiontools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RiverBasinNumber(str):
</span><span class="noop">    &#34;&#34;&#34;A single river basin number (Gewässerkennzahl) based on a guideline
</span><span class="noop">    of the German organisation LAWA.
</span><span class="noop">
</span><span class="noop">    See `Länderarbeitsgemeinschaft Wasser: Richtlinie für die
</span><span class="noop">    Gebietsbezeichung und die Verschlüsselung von Fließgewässern (1970)`
</span><span class="noop">
</span><span class="noop">    Note that zero fill numbers are ignored:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; RiverBasinNumber(1230)
</span><span class="noop">    RiverBasinNumber(123)
</span><span class="noop">    &gt;&gt;&gt; RiverBasinNumber(&#39;0123&#39;)
</span><span class="noop">    RiverBasinNumber(123)
</span><span class="noop">
</span><span class="noop">    Numbers that cannot be interpreted as a river basin numbers, result
</span><span class="noop">    in the following error message:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; RiverBasinNumber(&#39;123A&#39;)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: The given value `123A` could not be interpreted as a river basin number.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __new__(cls, value):
</span><span class="hit">        try:
</span><span class="hit">            return str.__new__(cls, str(int(value)).strip(&#39;0&#39;))
</span><span class="hit">        except ValueError:
</span><span class="hit">            raise ValueError(&#39;The given value `%s` could not be interpreted &#39;
</span><span class="noop">                             &#39;as a river basin number.&#39; % value)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def is_rivermouth(self):
</span><span class="noop">        &#34;&#34;&#34;Only true if the river basin number ends with `9`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.networktools import RiverBasinNumber
</span><span class="noop">        &gt;&gt;&gt; RiverBasinNumber(129).is_rivermouth
</span><span class="noop">        True
</span><span class="noop">        &gt;&gt;&gt; RiverBasinNumber(123).is_rivermouth
</span><span class="noop">        False
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self[-1] == &#39;9&#39;
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def is_mainchannel(self):
</span><span class="noop">        &#34;&#34;&#34;Only true if the river basin number ends with an odd number.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.networktools import RiverBasinNumber
</span><span class="noop">        &gt;&gt;&gt; for number in range(120, 130):
</span><span class="noop">        ...     rbn = RiverBasinNumber(number)
</span><span class="noop">        ...     print(number, rbn, rbn.is_mainchannel)
</span><span class="noop">        120 12 False
</span><span class="noop">        121 121 True
</span><span class="noop">        122 122 False
</span><span class="noop">        123 123 True
</span><span class="noop">        124 124 False
</span><span class="noop">        125 125 True
</span><span class="noop">        126 126 False
</span><span class="noop">        127 127 True
</span><span class="noop">        128 128 False
</span><span class="noop">        129 129 True
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return int(self[-1]) % 2 == 1
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def is_tributary(self):
</span><span class="noop">        &#34;&#34;&#34;Only true if the river basin number ends with an even number.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.networktools import RiverBasinNumber
</span><span class="noop">        &gt;&gt;&gt; for number in range(120, 130):
</span><span class="noop">        ...     rbn = RiverBasinNumber(number)
</span><span class="noop">        ...     print(number, rbn, rbn.is_tributary)
</span><span class="noop">        120 12 True
</span><span class="noop">        121 121 False
</span><span class="noop">        122 122 True
</span><span class="noop">        123 123 False
</span><span class="noop">        124 124 True
</span><span class="noop">        125 125 False
</span><span class="noop">        126 126 True
</span><span class="noop">        127 127 False
</span><span class="noop">        128 128 True
</span><span class="noop">        129 129 False
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return int(self[-1]) % 2 == 0
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def _possible_next_last_initial_digits(self):
</span><span class="hit">        return (digit for digit in (&#39;3&#39;, &#39;5&#39;, &#39;7&#39;, &#39;9&#39;) if
</span><span class="noop">                digit &gt; self.rstrip(&#39;9&#39;)[-1])
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def possible_next_initial_digits(self):
</span><span class="noop">        &#34;&#34;&#34;Return a tuple of all potential candidates for the next downstream
</span><span class="noop">        river basin number.
</span><span class="noop">
</span><span class="noop">        I think, only the first and the last returned candidate should be of
</span><span class="noop">        relevance.  But to return all possible intermediate candidates might
</span><span class="noop">        be safer river basin number specifications I am not taking into
</span><span class="noop">        account at the moment.
</span><span class="noop">
</span><span class="noop">        The candidate numbers might be incomplete.  For example, the next
</span><span class="noop">        number downstream of `123` could be `1251` instead of `125`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.networktools import RiverBasinNumber
</span><span class="noop">        &gt;&gt;&gt; for number in range(120, 130):
</span><span class="noop">        ...     rbn = RiverBasinNumber(number)
</span><span class="noop">        ...     print(number, rbn, rbn.possible_next_initial_digits)
</span><span class="noop">        120 12 (&#39;13&#39;, &#39;15&#39;, &#39;17&#39;, &#39;19&#39;)
</span><span class="noop">        121 121 (&#39;123&#39;, &#39;125&#39;, &#39;127&#39;, &#39;129&#39;)
</span><span class="noop">        122 122 (&#39;123&#39;, &#39;125&#39;, &#39;127&#39;, &#39;129&#39;)
</span><span class="noop">        123 123 (&#39;125&#39;, &#39;127&#39;, &#39;129&#39;)
</span><span class="noop">        124 124 (&#39;125&#39;, &#39;127&#39;, &#39;129&#39;)
</span><span class="noop">        125 125 (&#39;127&#39;, &#39;129&#39;)
</span><span class="noop">        126 126 (&#39;127&#39;, &#39;129&#39;)
</span><span class="noop">        127 127 (&#39;129&#39;,)
</span><span class="noop">        128 128 (&#39;129&#39;,)
</span><span class="noop">        129 129 (&#39;13&#39;, &#39;15&#39;, &#39;17&#39;, &#39;19&#39;)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return tuple(self.rstrip(&#39;9&#39;)[:-1]+digit for digit
</span><span class="noop">                     in self._possible_next_last_initial_digits)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nmb_digits(self):
</span><span class="noop">        &#34;&#34;&#34;Number of (significant) digits of a river basin number.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.networktools import RiverBasinNumber
</span><span class="noop">        &gt;&gt;&gt; RiverBasinNumber(120).nmb_digits
</span><span class="noop">        2
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return len(self)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return &#39;RiverBasinNumber(%s)&#39; % str.__repr__(self)[1:-1]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RiverBasinNumbers(tuple):
</span><span class="noop">    &#34;&#34;&#34;A sorted collection of :class:`RiverBasinNumber` objects.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.networktools import RiverBasinNumbers
</span><span class="noop">        &gt;&gt;&gt; RiverBasinNumbers((111, 113, 1129, 11269, 1125, 11261,
</span><span class="noop">        ...                    11262, 1123, 1124, 1122, 1121))
</span><span class="noop">        RiverBasinNumbers((111, 1121, 1122, 1123, 1124, 1125, 11261,
</span><span class="noop">                           11262, 11269, 1129, 113))
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    def __new__(cls, values):
</span><span class="hit">        _values = tuple(RiverBasinNumber(value) for value in values)
</span><span class="hit">        return tuple.__new__(cls, sorted(_values))
</span><span class="noop">
</span><span class="hit">    def _get_next_numbers(self, riverbasinnumber):
</span><span class="hit">        riverbasinnumber = RiverBasinNumber(riverbasinnumber)
</span><span class="hit">        for pdn1 in riverbasinnumber.possible_next_initial_digits:
</span><span class="hit">            neighbours = [rbn for rbn in self if rbn.startswith(pdn1)]
</span><span class="hit">            if neighbours:
</span><span class="hit">                return min(neighbours)
</span><span class="noop">        else:
</span><span class="hit">            return None
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def next_numbers(self):
</span><span class="noop">        &#34;&#34;&#34;A tuple of the next downstream river basin numbers.
</span><span class="noop">
</span><span class="noop">        The order of the returned numbers corresponds to the order of the
</span><span class="noop">        numbers contained by the :class:`RiverBasinNumbers` object.
</span><span class="noop">
</span><span class="noop">        The number of the subcatchment immediately downstream of the outlet
</span><span class="noop">        subcatchment is not known.  The tuple contains a :class:`None` object
</span><span class="noop">        instead (or multiple :class:`None` objects in case of multiple
</span><span class="noop">        outlets).
</span><span class="noop">
</span><span class="noop">        Eventually, not all possible combinations of river basin numbers
</span><span class="noop">        are covered.  Please keep us informed if you notices a problem
</span><span class="noop">        when applying this algorithm on your data.  At least, the algorithm
</span><span class="noop">        works properly on the following test case provided by Michael
</span><span class="noop">        Wagner (TU Dresden):
</span><span class="noop">
</span><span class="noop">        .. image:: LAWA_river-basin-bumbers.png
</span><span class="noop">
</span><span class="noop">        At first, only the black arrows are considered, exemplifying the basic
</span><span class="noop">        definition of river basin numbers:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.networktools import RiverBasinNumbers
</span><span class="noop">        &gt;&gt;&gt; rbns = RiverBasinNumbers((111, 113, 1129, 11269, 1125, 11261,
</span><span class="noop">        ...                           11262, 1123, 1124, 1122, 1121))
</span><span class="noop">        &gt;&gt;&gt; for this_rbn, next_rbn in zip(rbns, rbns.next_numbers):
</span><span class="noop">        ...    print(this_rbn.ljust(6), next_rbn)
</span><span class="noop">        111    113
</span><span class="noop">        1121   1123
</span><span class="noop">        1122   1123
</span><span class="noop">        1123   1125
</span><span class="noop">        1124   1125
</span><span class="noop">        1125   1129
</span><span class="noop">        11261  11269
</span><span class="noop">        11262  11269
</span><span class="noop">        11269  1129
</span><span class="noop">        1129   113
</span><span class="noop">        113    None
</span><span class="noop">
</span><span class="noop">        The coloured arrows exemplify the situation, where some additional
</span><span class="noop">        subdivisions become necessary:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.networktools import RiverBasinNumbers
</span><span class="noop">        &gt;&gt;&gt; rbns = RiverBasinNumbers((1111, 1119, 113, 1129, 1127,
</span><span class="noop">        ...                           11269, 1125, 11261, 11262, 11239,
</span><span class="noop">        ...                           11231, 1124, 1122, 1121))
</span><span class="noop">        &gt;&gt;&gt; for this_rbn, next_rbn in zip(rbns, rbns.next_numbers):
</span><span class="noop">        ...    print(this_rbn.ljust(6), next_rbn)
</span><span class="noop">        1111   1119
</span><span class="noop">        1119   113
</span><span class="noop">        1121   11231
</span><span class="noop">        1122   11231
</span><span class="noop">        11231  11239
</span><span class="noop">        11239  1125
</span><span class="noop">        1124   1125
</span><span class="noop">        1125   1127
</span><span class="noop">        11261  11269
</span><span class="noop">        11262  11269
</span><span class="noop">        11269  1127
</span><span class="noop">        1127   1129
</span><span class="noop">        1129   113
</span><span class="noop">        113    None
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return tuple(self._get_next_numbers(rbn) for rbn in self)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return objecttools.assignrepr_tuple(self,
</span><span class="noop">                                            &#39;RiverBasinNumbers(&#39;,
</span><span class="noop">                                            60) + &#39;)&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RiverBasinNumbers2Selection(object):
</span><span class="noop">    &#34;&#34;&#34;Class for defining a :class:`~hydpy.core.selectiontools.Selection`
</span><span class="noop">    object (consisting of connected nodes and elements) based on given
</span><span class="noop">    :class:`RiverBasinNumber` objects.
</span><span class="noop">
</span><span class="noop">    Note that this class is not intended to cover all possible HydPy
</span><span class="noop">    networks.  So it might be necessary to make some adjustments on
</span><span class="noop">    the returned selection, e.g. to define special names for specific
</span><span class="noop">    elements or nodes.
</span><span class="noop">
</span><span class="noop">    All examples of the methods and propertys of
</span><span class="noop">    :class:`RiverBasinNumbers2Selection` are based on the river basin numbers
</span><span class="noop">    defined in the documentation on class :class:`RiverBasinNumbers`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, numbers):
</span><span class="hit">        self.supplier_prefix = &#39;land_&#39;
</span><span class="hit">        self.router_prefix = &#39;stream_&#39;
</span><span class="hit">        self.node_prefix = &#39;node_&#39;
</span><span class="hit">        self.last_node = &#39;node_outlet&#39;
</span><span class="hit">        self.selection_name = &#39;complete&#39;
</span><span class="hit">        rbns = RiverBasinNumbers(numbers)
</span><span class="hit">        self._up2down = dict(tuple_ for tuple_ in zip(rbns, rbns.next_numbers))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def _supplier_numbers(self):
</span><span class="noop">        &#34;&#34;&#34;A tuple of the numbers of all &#34;supplying&#34; basins.&#34;&#34;&#34;
</span><span class="hit">        return tuple(self._up2down.keys())
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def _router_numbers(self):
</span><span class="noop">        &#34;&#34;&#34;A tuple of the numbers of all &#34;routing&#34; basins.&#34;&#34;&#34;
</span><span class="hit">        return tuple(up for up in self._up2down.keys()
</span><span class="noop">                     if up in self._up2down.values())
</span><span class="noop">
</span><span class="hit">    def _get_nodename(self, string):
</span><span class="hit">        return self.node_prefix + string
</span><span class="noop">
</span><span class="hit">    def _get_suppliername(self, string):
</span><span class="hit">        return self.supplier_prefix + string
</span><span class="noop">
</span><span class="hit">    def _get_routername(self, string):
</span><span class="hit">        return self.router_prefix + string
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def supplier_elements(self):
</span><span class="noop">        &#34;&#34;&#34;A :class:`~hydpy.core.devicetools.Elements` collection of all
</span><span class="noop">        &#34;supplying&#34; basins.
</span><span class="noop">
</span><span class="noop">        (All river basins are assumed to supply something to the downstream
</span><span class="noop">        basin.)
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.networktools import RiverBasinNumbers2Selection
</span><span class="noop">        &gt;&gt;&gt; rbns2s = RiverBasinNumbers2Selection(
</span><span class="noop">        ...                            (111, 113, 1129, 11269, 1125, 11261,
</span><span class="noop">        ...                             11262, 1123, 1124, 1122, 1121))
</span><span class="noop">
</span><span class="noop">        The following elements are properly connected to the required
</span><span class="noop">        outlet nodes already:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; for element in rbns2s.supplier_elements:
</span><span class="noop">        ...     print(repr(element))
</span><span class="noop">        Element(&#34;land_111&#34;,
</span><span class="noop">                outlets=&#34;node_113&#34;)
</span><span class="noop">        Element(&#34;land_1121&#34;,
</span><span class="noop">                outlets=&#34;node_1123&#34;)
</span><span class="noop">        Element(&#34;land_1122&#34;,
</span><span class="noop">                outlets=&#34;node_1123&#34;)
</span><span class="noop">        Element(&#34;land_1123&#34;,
</span><span class="noop">                outlets=&#34;node_1125&#34;)
</span><span class="noop">        Element(&#34;land_1124&#34;,
</span><span class="noop">                outlets=&#34;node_1125&#34;)
</span><span class="noop">        Element(&#34;land_1125&#34;,
</span><span class="noop">                outlets=&#34;node_1129&#34;)
</span><span class="noop">        Element(&#34;land_11261&#34;,
</span><span class="noop">                outlets=&#34;node_11269&#34;)
</span><span class="noop">        Element(&#34;land_11262&#34;,
</span><span class="noop">                outlets=&#34;node_11269&#34;)
</span><span class="noop">        Element(&#34;land_11269&#34;,
</span><span class="noop">                outlets=&#34;node_1129&#34;)
</span><span class="noop">        Element(&#34;land_1129&#34;,
</span><span class="noop">                outlets=&#34;node_113&#34;)
</span><span class="noop">        Element(&#34;land_113&#34;,
</span><span class="noop">                outlets=&#34;node_outlet&#34;)
</span><span class="noop">
</span><span class="noop">        It is both possible to change the prefix names of the elements
</span><span class="noop">        and nodes, as long as it results in a valid variable name (e.g.
</span><span class="noop">        does not start with a number):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; rbns2s.supplier_prefix = &#39;a_&#39;
</span><span class="noop">        &gt;&gt;&gt; rbns2s.node_prefix = &#39;b_&#39;
</span><span class="noop">        &gt;&gt;&gt; rbns2s.supplier_elements
</span><span class="noop">        Elements(&#34;a_111&#34;, &#34;a_1121&#34;, &#34;a_1122&#34;, &#34;a_1123&#34;, &#34;a_1124&#34;, &#34;a_1125&#34;,
</span><span class="noop">                 &#34;a_11261&#34;, &#34;a_11262&#34;, &#34;a_11269&#34;, &#34;a_1129&#34;, &#34;a_113&#34;)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        elements = devicetools.Elements()
</span><span class="hit">        for supplier in self._supplier_numbers:
</span><span class="hit">            element = self._get_suppliername(supplier)
</span><span class="hit">            try:
</span><span class="hit">                outlet = self._get_nodename(self._up2down[supplier])
</span><span class="hit">            except TypeError:
</span><span class="hit">                outlet = self.last_node
</span><span class="hit">            elements += devicetools.Element(element, outlets=outlet)
</span><span class="hit">        return elements
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def router_elements(self):
</span><span class="noop">        &#34;&#34;&#34;A :class:`~hydpy.core.devicetools.Elements` collection of all
</span><span class="noop">        &#34;routing&#34; basins.
</span><span class="noop">
</span><span class="noop">        (Only river basins with a upstream basin are assumed to route
</span><span class="noop">        something to the downstream basin.)
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.networktools import RiverBasinNumbers2Selection
</span><span class="noop">        &gt;&gt;&gt; rbns2s = RiverBasinNumbers2Selection(
</span><span class="noop">        ...                            (111, 113, 1129, 11269, 1125, 11261,
</span><span class="noop">        ...                             11262, 1123, 1124, 1122, 1121))
</span><span class="noop">
</span><span class="noop">        The following elements are properly connected to the required
</span><span class="noop">        inlet and outlet nodes already:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; for element in rbns2s.router_elements:
</span><span class="noop">        ...     print(repr(element))
</span><span class="noop">        Element(&#34;stream_1123&#34;,
</span><span class="noop">                inlets=&#34;node_1123&#34;,
</span><span class="noop">                outlets=&#34;node_1125&#34;)
</span><span class="noop">        Element(&#34;stream_1125&#34;,
</span><span class="noop">                inlets=&#34;node_1125&#34;,
</span><span class="noop">                outlets=&#34;node_1129&#34;)
</span><span class="noop">        Element(&#34;stream_11269&#34;,
</span><span class="noop">                inlets=&#34;node_11269&#34;,
</span><span class="noop">                outlets=&#34;node_1129&#34;)
</span><span class="noop">        Element(&#34;stream_1129&#34;,
</span><span class="noop">                inlets=&#34;node_1129&#34;,
</span><span class="noop">                outlets=&#34;node_113&#34;)
</span><span class="noop">        Element(&#34;stream_113&#34;,
</span><span class="noop">                inlets=&#34;node_113&#34;,
</span><span class="noop">                outlets=&#34;node_outlet&#34;)
</span><span class="noop">
</span><span class="noop">        It is both possible to change the prefix names of the elements
</span><span class="noop">        and nodes, as long as it results in a valid variable name (e.g.
</span><span class="noop">        does not start with a number):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; rbns2s.router_prefix = &#39;c_&#39;
</span><span class="noop">        &gt;&gt;&gt; rbns2s.node_prefix = &#39;d_&#39;
</span><span class="noop">        &gt;&gt;&gt; rbns2s.router_elements
</span><span class="noop">        Elements(&#34;c_1123&#34;, &#34;c_1125&#34;, &#34;c_11269&#34;, &#34;c_1129&#34;, &#34;c_113&#34;)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        elements = devicetools.Elements()
</span><span class="hit">        for router in self._router_numbers:
</span><span class="hit">            element = self._get_routername(router)
</span><span class="hit">            inlet = self._get_nodename(router)
</span><span class="hit">            try:
</span><span class="hit">                outlet = self._get_nodename(self._up2down[router])
</span><span class="hit">            except TypeError:
</span><span class="hit">                outlet = self.last_node
</span><span class="hit">            elements += devicetools.Element(
</span><span class="noop">                            element, inlets=inlet, outlets=outlet)
</span><span class="hit">        return elements
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def elements(self):
</span><span class="noop">        &#34;&#34;&#34;Both the &#34;supplying&#34; and the &#34;routing&#34; elements.&#34;&#34;&#34;
</span><span class="hit">        return self.supplier_elements + self.router_elements
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nodes(self):
</span><span class="noop">        &#34;&#34;&#34;A :class:`~hydpy.core.devicetools.Nodes` collection of all
</span><span class="noop">        required nodes.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.networktools import RiverBasinNumbers2Selection
</span><span class="noop">        &gt;&gt;&gt; rbns2s = RiverBasinNumbers2Selection(
</span><span class="noop">        ...                            (111, 113, 1129, 11269, 1125, 11261,
</span><span class="noop">        ...                             11262, 1123, 1124, 1122, 1121))
</span><span class="noop">
</span><span class="noop">        Note that the required outlet node is added:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; rbns2s.nodes
</span><span class="noop">        Nodes(&#34;node_1123&#34;, &#34;node_1125&#34;, &#34;node_11269&#34;, &#34;node_1129&#34;, &#34;node_113&#34;,
</span><span class="noop">              &#34;node_outlet&#34;)
</span><span class="noop">
</span><span class="noop">        It is both possible to change the prefix names of the nodes and
</span><span class="noop">        the name of the outlet node seperately:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; rbns2s.node_prefix = &#39;b_&#39;
</span><span class="noop">        &gt;&gt;&gt; rbns2s.last_node = &#39;l_node&#39;
</span><span class="noop">        &gt;&gt;&gt; rbns2s.nodes
</span><span class="noop">        Nodes(&#34;b_1123&#34;, &#34;b_1125&#34;, &#34;b_11269&#34;, &#34;b_1129&#34;, &#34;b_113&#34;, &#34;l_node&#34;)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return (devicetools.Nodes(self.node_prefix+routers for
</span><span class="noop">                                  routers in self._router_numbers) +
</span><span class="noop">                devicetools.Node(self.last_node))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def selection(self):
</span><span class="noop">        &#34;&#34;&#34;A complete :class:`~hydpy.core.selectiontools.Selection` object
</span><span class="noop">        of all &#34;supplying&#34; and &#34;routing&#34; elements and required nodes.
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.auxs.networktools import RiverBasinNumbers2Selection
</span><span class="noop">        &gt;&gt;&gt; rbns2s = RiverBasinNumbers2Selection(
</span><span class="noop">        ...                            (111, 113, 1129, 11269, 1125, 11261,
</span><span class="noop">        ...                             11262, 1123, 1124, 1122, 1121))
</span><span class="noop">        &gt;&gt;&gt; rbns2s.selection
</span><span class="noop">        Selection(&#34;complete&#34;,
</span><span class="noop">                  elements=(&#34;land_111&#34;, &#34;land_1121&#34;, &#34;land_1122&#34;, &#34;land_1123&#34;,
</span><span class="noop">                            &#34;land_1124&#34;, &#34;land_1125&#34;, &#34;land_11261&#34;,
</span><span class="noop">                            &#34;land_11262&#34;, &#34;land_11269&#34;, &#34;land_1129&#34;,
</span><span class="noop">                            &#34;land_113&#34;, &#34;stream_1123&#34;, &#34;stream_1125&#34;,
</span><span class="noop">                            &#34;stream_11269&#34;, &#34;stream_1129&#34;, &#34;stream_113&#34;),
</span><span class="noop">                  nodes=(&#34;node_1123&#34;, &#34;node_1125&#34;, &#34;node_11269&#34;, &#34;node_1129&#34;,
</span><span class="noop">                         &#34;node_113&#34;, &#34;node_outlet&#34;))
</span><span class="noop">
</span><span class="noop">        Besides the possible modifications on the names of the different
</span><span class="noop">        nodes and elements, the name of the selection can be set differently:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; rbns2s.selection_name = &#39;sel&#39;
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; with pub.options.ellipsis(1):
</span><span class="noop">        ...     print(repr(rbns2s.selection))
</span><span class="noop">        Selection(&#34;sel&#34;,
</span><span class="noop">                  elements=(&#34;land_111&#34;, ...,&#34;stream_113&#34;),
</span><span class="noop">                  nodes=(&#34;node_1123&#34;, ...,&#34;node_outlet&#34;))
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return selectiontools.Selection(
</span><span class="noop">                            self.selection_name, self.nodes, self.elements)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/smoothtools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/smoothtools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements features which help to regularize discontinuous
</span><span class="noop">process equations.
</span><span class="noop">
</span><span class="noop">.. _Tyralla (2016): http://www.hydrology.ruhr-uni-bochum.de/hydrolgy/mam/download/schriftenreihe_29.pdf
</span><span class="noop">
</span><span class="noop">Many hydrological models rely heavily on discontinous equations describing
</span><span class="noop">hydrological processes.  The related &#34;if-else&#34; blocks are often not
</span><span class="noop">theoretically motivated.  Instead, they are thought to ease implementing
</span><span class="noop">ad hoc solutions of different (parts of) process equations without taking
</span><span class="noop">care of the total set of process equations.
</span><span class="noop">
</span><span class="noop">There are some reasons to ground new model concepts on mainly continuous
</span><span class="noop">process descriptions. See e.g. `Tyralla (2016)`_ for more a more exhaustive
</span><span class="noop">discussion of this topic.  Nevertheless, one might often want -- least as
</span><span class="noop">a starting point -- to pick single discontinuous but well-established
</span><span class="noop">equations of old model concepts for a new model concept.  The tools
</span><span class="noop">provided by this module can be used to regularize the discontinuities of
</span><span class="noop">such equations.  More concrete, the tools are thought for replacing
</span><span class="noop">discontinous process equations by continuous approximations.
</span><span class="noop">
</span><span class="noop">Some of the implemented features are to be applied during model simulations
</span><span class="noop">and are in some other way performance-critical.  These features are defined
</span><span class="noop">in the Cython extension module :mod:`~hydpy.cythons.smoothutils`.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="hit">from scipy import optimize
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.cythons import smoothutils
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_smoothpar_logistic1(metapar):
</span><span class="noop">    &#34;&#34;&#34;Return the smoothing parameter corresponding to the given meta
</span><span class="noop">    parameter when using :func:`~hydpy.cythons.smoothutils.smooth_logistic1`.
</span><span class="noop">
</span><span class="noop">    Calculate the smoothing parameter value corresponding the meta parameter
</span><span class="noop">    value 2.5:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.smoothtools import calc_smoothpar_logistic1
</span><span class="noop">    &gt;&gt;&gt; smoothpar = calc_smoothpar_logistic1(2.5)
</span><span class="noop">
</span><span class="noop">    Using this smoothing parameter value, the output of function
</span><span class="noop">    :func:`~hydpy.cythons.smoothutils.smooth_logistic1` differs by
</span><span class="noop">    1 % from the related `true` discontinuous step function for the
</span><span class="noop">    input values -2.5 and 2.5 (which are located at a distance of 2.5
</span><span class="noop">    from the position of the discontinuity):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.cythons import smoothutils
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; round_(smoothutils.smooth_logistic1(-2.5, smoothpar))
</span><span class="noop">    0.01
</span><span class="noop">    &gt;&gt;&gt; round_(smoothutils.smooth_logistic1(2.5, smoothpar))
</span><span class="noop">    0.99
</span><span class="noop">
</span><span class="noop">    For zero or negative meta parameter values, a zero smoothing parameter
</span><span class="noop">    value is returned:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; round_(calc_smoothpar_logistic1(0.0))
</span><span class="noop">    0.0
</span><span class="noop">    &gt;&gt;&gt; round_(calc_smoothpar_logistic1(-1.0))
</span><span class="noop">    0.0
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return max(metapar/numpy.log(99.), 0.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _error_smoothpar_logistic2(par, metapar):
</span><span class="hit">    return smoothutils.smooth_logistic2(-metapar, par) - .01
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _smooth_logistic2_derivative(par, metapar):
</span><span class="hit">    return smoothutils.smooth_logistic2_derivative(metapar, par)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_smoothpar_logistic2(metapar):
</span><span class="noop">    &#34;&#34;&#34;Return the smoothing parameter corresponding to the given meta
</span><span class="noop">    parameter when using :func:`~hydpy.cythons.smoothutils.smooth_logistic2`.
</span><span class="noop">
</span><span class="noop">    Calculate the smoothing parameter value corresponding the meta parameter
</span><span class="noop">    value 2.5:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.smoothtools import calc_smoothpar_logistic2
</span><span class="noop">    &gt;&gt;&gt; smoothpar = calc_smoothpar_logistic2(2.5)
</span><span class="noop">
</span><span class="noop">    Using this smoothing parameter value, the output of function
</span><span class="noop">    :func:`~hydpy.cythons.smoothutils.smooth_logistic2` differs by
</span><span class="noop">    1 % from the related `true` discontinuous step function for the
</span><span class="noop">    input values -2.5 and 2.5 (which are located at a distance of 2.5
</span><span class="noop">    from the position of the discontinuity):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.cythons import smoothutils
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; round_(smoothutils.smooth_logistic2(-2.5, smoothpar))
</span><span class="noop">    0.01
</span><span class="noop">    &gt;&gt;&gt; round_(smoothutils.smooth_logistic2(2.5, smoothpar))
</span><span class="noop">    2.51
</span><span class="noop">
</span><span class="noop">    For zero or negative meta parameter values, a zero smoothing parameter
</span><span class="noop">    value is returned:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; round_(calc_smoothpar_logistic2(0.0))
</span><span class="noop">    0.0
</span><span class="noop">    &gt;&gt;&gt; round_(calc_smoothpar_logistic2(-1.0))
</span><span class="noop">    0.0
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if metapar &lt;= 0.:
</span><span class="hit">        return 0.
</span><span class="noop">    else:
</span><span class="hit">        return optimize.newton(_error_smoothpar_logistic2,
</span><span class="noop">                               .3 * metapar**.84,
</span><span class="noop">                               _smooth_logistic2_derivative,
</span><span class="noop">                               args=(metapar,))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">calc_smoothpar_logistic3 = calc_smoothpar_logistic2
</span><span class="noop">&#34;&#34;&#34;Return the smoothing parameter corresponding to the given meta
</span><span class="noop">parameter when using :func:`~hydpy.cythons.smoothutils.smooth_logistic3`.
</span><span class="noop">
</span><span class="noop">:func:`~hydpy.cythons.smoothutils.smooth_logistic3` is only an alias for
</span><span class="noop">:func:`~hydpy.cythons.smoothutils.smooth_logistic2`.
</span><span class="noop">
</span><span class="noop">Calculate the smoothing parameter value corresponding the meta parameter
</span><span class="noop">value 2.5:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.auxs.smoothtools import calc_smoothpar_logistic3
</span><span class="noop">&gt;&gt;&gt; smoothpar = calc_smoothpar_logistic3(2.5)
</span><span class="noop">
</span><span class="noop">Using this smoothing parameter value, the output of function
</span><span class="noop">:func:`~hydpy.cythons.smoothutils.smooth_logistic3` would ideally
</span><span class="noop">differs by 1 % from the related `true` discontinuous step function
</span><span class="noop">for the input values -2.5 and 3.5 (which are located at a distance
</span><span class="noop">of 2.5 from the position of the nearest discontinuity):
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.cythons import smoothutils
</span><span class="noop">&gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">&gt;&gt;&gt; round_(smoothutils.smooth_logistic3(-2., smoothpar))
</span><span class="noop">0.009876
</span><span class="noop">&gt;&gt;&gt; round_(smoothutils.smooth_logistic3(3., smoothpar))
</span><span class="noop">0.990124
</span><span class="noop">
</span><span class="noop">In contrast to the examples shown for functions
</span><span class="noop">:func:`~hydpy.cythons.smoothutils.smooth_logistic1` and
</span><span class="noop">:func:`~hydpy.cythons.smoothutils.smooth_logistic2`, the smoothing
</span><span class="noop">parameter determined for function
</span><span class="noop">:func:`~hydpy.cythons.smoothutils.smooth_logistic3` is not in perfect
</span><span class="noop">agreement with the given meta parameter.  For most purpuses, the
</span><span class="noop">resulting error is negligible.  If one needs a higher accuracy, some
</span><span class="noop">iterative refinement should be implemented.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">calc_smoothpar_max1 = calc_smoothpar_logistic2
</span><span class="noop">&#34;&#34;&#34;Return the smoothing parameter corresponding to the given meta
</span><span class="noop">parameter when using :func:`~hydpy.cythons.smoothutils.smooth_max1`.
</span><span class="noop">
</span><span class="noop">:func:`~hydpy.cythons.smoothutils.smooth_min1` is only an alias for
</span><span class="noop">:func:`~hydpy.cythons.smoothutils.smooth_logistic2`.
</span><span class="noop">
</span><span class="noop">Calculate the smoothing parameter value corresponding the meta parameter
</span><span class="noop">value 2.5:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.auxs.smoothtools import calc_smoothpar_max1
</span><span class="noop">&gt;&gt;&gt; smoothpar = calc_smoothpar_max1(2.5)
</span><span class="noop">
</span><span class="noop">Using this smoothing parameter value, the output of function
</span><span class="noop">:func:`~hydpy.cythons.smoothutils.smooth_max1` is 0.01 above the usual
</span><span class="noop">discontinuous maximum function result, if the absolute value of the
</span><span class="noop">difference between the x and the y value is 2.5:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.cythons import smoothutils
</span><span class="noop">&gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">&gt;&gt;&gt; round_(smoothutils.smooth_max1(4.0, 1.5, smoothpar))
</span><span class="noop">4.01
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">calc_smoothpar_min1 = calc_smoothpar_logistic2
</span><span class="noop">&#34;&#34;&#34;Return the smoothing parameter corresponding to the given meta
</span><span class="noop">parameter when using :func:`~hydpy.cythons.smoothutils.smooth_min1`.
</span><span class="noop">
</span><span class="noop">:func:`~hydpy.cythons.smoothutils.smooth_min1` is only an alias for
</span><span class="noop">:func:`~hydpy.cythons.smoothutils.smooth_logistic2`.
</span><span class="noop">
</span><span class="noop">Calculate the smoothing parameter value corresponding the meta parameter
</span><span class="noop">value 2.5:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.auxs.smoothtools import calc_smoothpar_min1
</span><span class="noop">&gt;&gt;&gt; smoothpar = calc_smoothpar_min1(2.5)
</span><span class="noop">
</span><span class="noop">Using this smoothing parameter value, the output of function
</span><span class="noop">:func:`~hydpy.cythons.smoothutils.smooth_min1` is 0.01 below the usual
</span><span class="noop">discontinuous minimum function result, if the absolute value of the
</span><span class="noop">difference between the x and the y value is 2.5:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.cythons import smoothutils
</span><span class="noop">&gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">&gt;&gt;&gt; round_(smoothutils.smooth_min1(-4.0, -1.5, smoothpar))
</span><span class="noop">-4.01
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/statstools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/statstools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements statistical functionalities frequently used in
</span><span class="noop">hydrological modelling.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.auxs import validtools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_mean_time(timepoints, weights):
</span><span class="noop">    &#34;&#34;&#34;Return the weighted mean of the given timepoints.
</span><span class="noop">
</span><span class="noop">    With equal given weights, the result is simply the mean of the given
</span><span class="noop">    time points:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.statstools import calc_mean_time
</span><span class="noop">    &gt;&gt;&gt; calc_mean_time(timepoints=[3., 7.],
</span><span class="noop">    ...                weights=[2., 2.])
</span><span class="noop">    5.0
</span><span class="noop">
</span><span class="noop">    With different weights, the resulting mean time is shifted to the larger
</span><span class="noop">    ones:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; calc_mean_time(timepoints=[3., 7.],
</span><span class="noop">    ...                weights=[1., 3.])
</span><span class="noop">    6.0
</span><span class="noop">
</span><span class="noop">    Or, in the most extreme case:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; calc_mean_time(timepoints=[3., 7.],
</span><span class="noop">    ...                weights=[0., 4.])
</span><span class="noop">    7.0
</span><span class="noop">
</span><span class="noop">    There will be some checks for input plausibility perfomed, e.g.:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; calc_mean_time(timepoints=[3., 7.],
</span><span class="noop">    ...                weights=[-2., 2.])
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: While trying to calculate the weighted mean time, the following error occured: For the following objects, at least one value is negative: weights.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    try:
</span><span class="hit">        timepoints = numpy.array(timepoints)
</span><span class="hit">        weights = numpy.array(weights)
</span><span class="hit">        validtools.test_equal_shape(timepoints=timepoints, weights=weights)
</span><span class="hit">        validtools.test_non_negative(weights=weights)
</span><span class="hit">        return numpy.dot(timepoints, weights)/numpy.sum(weights)
</span><span class="hit">    except BaseException:
</span><span class="hit">        objecttools.augmentexcmessage(
</span><span class="noop">                &#39;While trying to calculate the weighted mean time&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_mean_time_deviation(timepoints, weights, mean_time=None):
</span><span class="noop">    &#34;&#34;&#34;Return the weighted deviation of the given timepoints from their mean
</span><span class="noop">    time.
</span><span class="noop">
</span><span class="noop">    With equal given weights, the is simply the standard deviation of the
</span><span class="noop">    given time points:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.statstools import calc_mean_time_deviation
</span><span class="noop">    &gt;&gt;&gt; calc_mean_time_deviation(timepoints=[3., 7.],
</span><span class="noop">    ...                          weights=[2., 2.])
</span><span class="noop">    2.0
</span><span class="noop">
</span><span class="noop">    One can pass a precalculated or alternate mean time:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; round_(calc_mean_time_deviation(timepoints=[3., 7.],
</span><span class="noop">    ...                                 weights=[2., 2.],
</span><span class="noop">    ...                                 mean_time=4.))
</span><span class="noop">    2.236068
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; round_(calc_mean_time_deviation(timepoints=[3., 7.],
</span><span class="noop">    ...                                 weights=[1., 3.]))
</span><span class="noop">    1.732051
</span><span class="noop">
</span><span class="noop">    Or, in the most extreme case:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; calc_mean_time_deviation(timepoints=[3., 7.],
</span><span class="noop">    ...                          weights=[0., 4.])
</span><span class="noop">    0.0
</span><span class="noop">
</span><span class="noop">    There will be some checks for input plausibility perfomed, e.g.:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; calc_mean_time_deviation(timepoints=[3., 7.],
</span><span class="noop">    ...                          weights=[-2., 2.])
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: While trying to calculate the weighted time deviation from mean time, the following error occured: For the following objects, at least one value is negative: weights.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    try:
</span><span class="hit">        timepoints = numpy.array(timepoints)
</span><span class="hit">        weights = numpy.array(weights)
</span><span class="hit">        validtools.test_equal_shape(timepoints=timepoints, weights=weights)
</span><span class="hit">        validtools.test_non_negative(weights=weights)
</span><span class="hit">        if mean_time is None:
</span><span class="hit">            mean_time = calc_mean_time(timepoints, weights)
</span><span class="hit">        return (numpy.sqrt(numpy.dot(weights, (timepoints-mean_time)**2) /
</span><span class="noop">                           numpy.sum(weights)))
</span><span class="hit">    except BaseException:
</span><span class="hit">        objecttools.augmentexcmessage(&#39;While trying to calculate the weighted &#39;
</span><span class="noop">                                      &#39;time deviation from mean time&#39;)
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/validtools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/auxs/validtools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># import...
</span><span class="hit">&#34;&#34;&#34;This module implements features for the validation of (numerical) input
</span><span class="noop">data.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def test_equal_shape(**kwargs):
</span><span class="noop">    &#34;&#34;&#34;Raise a ValueError if the shapes of the objects given as keywords
</span><span class="noop">    are not equal.
</span><span class="noop">
</span><span class="noop">    If all shapes are equal, nothing happens:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.validtools import test_equal_shape
</span><span class="noop">    &gt;&gt;&gt; test_equal_shape(arr1=numpy.array([1., 2.]),
</span><span class="noop">    ...                  arr2=numpy.array([3., 4.]),
</span><span class="noop">    ...                  arr3=numpy.array([5., 6.]))
</span><span class="noop">
</span><span class="noop">    If at least one shape differs, the following error is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test_equal_shape(arr1=numpy.array([1., 2.]),
</span><span class="noop">    ...                  arr2=numpy.array([3.]),
</span><span class="noop">    ...                  arr3=numpy.array([5., 6.]))
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: The shapes of the following objects are not equal: arr1 (2,), arr2 (1,), arr3 (2,).
</span><span class="noop">
</span><span class="noop">    For flexibility in the functions application, it is allowed to pass only
</span><span class="noop">    one array or no arrays at all:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test_equal_shape(arr1=numpy.array([1., 2.]))
</span><span class="noop">    &gt;&gt;&gt; test_equal_shape()
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    names = list(kwargs.keys())
</span><span class="hit">    shapes = numpy.array([numpy.array(array).shape
</span><span class="noop">                          for array in kwargs.values()])
</span><span class="hit">    if any(shapes[:-1] != shapes[1:]):
</span><span class="hit">        raise ValueError(
</span><span class="noop">            &#39;The shapes of the following objects are not equal: %s.&#39;
</span><span class="noop">            % &#39;, &#39;.join(&#39;%s %s&#39; % (name, tuple(shape)) for (name, shape)
</span><span class="noop">                        in sorted(zip(names, shapes))))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def test_non_negative(**kwargs):
</span><span class="noop">    &#34;&#34;&#34;Raise a ValueError if at least one value of the objects given as
</span><span class="noop">    keywords is negative.
</span><span class="noop">
</span><span class="noop">    If all values are non negative, nothing happens:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.validtools import test_non_negative
</span><span class="noop">    &gt;&gt;&gt; test_non_negative(arr1=numpy.array([1., 2.]),
</span><span class="noop">    ...                   arr2=numpy.array([3., 4.]),
</span><span class="noop">    ...                   arr3=numpy.array([5., 6.]))
</span><span class="noop">
</span><span class="noop">    If at least one value is negative, the following error is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test_non_negative(arr1=numpy.array([1., 2.]),
</span><span class="noop">    ...                   arr2=numpy.array([-3., 4.]),
</span><span class="noop">    ...                   arr3=numpy.array([5., 6.]))
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: For the following objects, at least one value is negative: arr2.
</span><span class="noop">
</span><span class="noop">    For flexibility in the functions application, it is allowed to pass
</span><span class="noop">    no arrays at all:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test_non_negative()
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    names = list(kwargs.keys())
</span><span class="hit">    negs = [numpy.nanmin(array) &lt; 0. for array in kwargs.values()]
</span><span class="hit">    if any(negs):
</span><span class="hit">        raise ValueError(
</span><span class="noop">            &#39;For the following objects, at least one value is negative: %s.&#39;
</span><span class="noop">            % &#39;, &#39;.join(name for name, neg in sorted(zip(names, negs)) if neg))
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/conf/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/conf/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre></pre>
      </td>
      <td class="source">
        <pre></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre></pre>
      </td>
      <td class="source">
        <pre></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/autodoctools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/autodoctools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements tools for increasing the level of automation and
</span><span class="noop">standardisation of the online documentation generated with Sphinx.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from the Python standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import inspect
</span><span class="hit">import types
</span><span class="hit">import collections
</span><span class="noop"># ...from HydPy
</span><span class="noop"># from hydpy.core import objecttools (actual import commands moved to
</span><span class="noop"># different functions below to avoid circular dependencies)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def description(self):
</span><span class="noop">    &#34;&#34;&#34;Returns the first &#34;paragraph&#34; of the docstring of the given object.
</span><span class="noop">
</span><span class="noop">    Note that ugly things like multiple whitespaces and newline characters
</span><span class="noop">    are removed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core import autodoctools, objecttools
</span><span class="noop">    &gt;&gt;&gt; autodoctools.description(objecttools.augmentexcmessage)
</span><span class="noop">    &#39;Augment an exception message with additional information while keeping the original traceback.&#39;
</span><span class="noop">
</span><span class="noop">    In case the given object does not define a docstring, the following
</span><span class="noop">    is returned:
</span><span class="noop">    &gt;&gt;&gt; autodoctools.description(type(&#39;Test&#39;, (), {}))
</span><span class="noop">    &#39;no description available&#39;
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if self.__doc__ in (None, &#39;&#39;):
</span><span class="hit">        return &#39;no description available&#39;
</span><span class="noop">    else:
</span><span class="hit">        return &#39; &#39;.join(self.__doc__.split(&#39;\n\n&#39;)[0].split())
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">_PAR_SPEC2CAPT = collections.OrderedDict(((&#39;parameters&#39;, &#39;Parameter tools&#39;),
</span><span class="noop">                                          (&#39;constants&#39;, &#39;Constants&#39;),
</span><span class="noop">                                          (&#39;control&#39;, &#39;Control parameters&#39;),
</span><span class="noop">                                          (&#39;derived&#39;, &#39;Derived parameters&#39;)))
</span><span class="noop">
</span><span class="hit">_SEQ_SPEC2CAPT = collections.OrderedDict(((&#39;sequences&#39;, &#39;Sequence tools&#39;),
</span><span class="noop">                                          (&#39;inputs&#39;, &#39;Input sequences&#39;),
</span><span class="noop">                                          (&#39;fluxes&#39;, &#39;Flux sequences&#39;),
</span><span class="noop">                                          (&#39;states&#39;, &#39;State sequences&#39;),
</span><span class="noop">                                          (&#39;logs&#39;, &#39;Log sequences&#39;),
</span><span class="noop">                                          (&#39;inlets&#39;, &#39;Inlet sequences&#39;),
</span><span class="noop">                                          (&#39;outlets&#39;, &#39;Outlet sequences&#39;),
</span><span class="noop">                                          (&#39;receivers&#39;, &#39;Receiver sequences&#39;),
</span><span class="noop">                                          (&#39;senders&#39;, &#39;Sender sequences&#39;),
</span><span class="noop">                                          (&#39;aides&#39;, &#39;Aide sequences&#39;)))
</span><span class="noop">
</span><span class="hit">_all_spec2capt = _PAR_SPEC2CAPT.copy()
</span><span class="hit">_all_spec2capt.update(_SEQ_SPEC2CAPT)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _add_title(title, marker):
</span><span class="noop">    &#34;&#34;&#34;Return a title for a basemodels docstring.&#34;&#34;&#34;
</span><span class="hit">    return [&#39;&#39;, title, marker*len(title)]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _add_lines(specification, module):
</span><span class="noop">    &#34;&#34;&#34;Return autodoc commands for a basemodels docstring.
</span><span class="noop">
</span><span class="noop">    Note that `collection classes` (e.g. `Model`, `ControlParameters`,
</span><span class="noop">    `InputSequences` are placed on top of the respective section and the
</span><span class="noop">    `contained classes` (e.g. model methods, `ControlParameter` instances,
</span><span class="noop">    `InputSequence` instances at the bottom.  This differs from the order
</span><span class="noop">    of their definition in the respective modules, but results in a better
</span><span class="noop">    documentation structure.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    caption = _all_spec2capt.get(specification, &#39;dummy&#39;)
</span><span class="hit">    if caption.split()[-1] in (&#39;parameters&#39;, &#39;sequences&#39;):
</span><span class="hit">        exists_collectionclass = True
</span><span class="hit">        name_collectionclass = caption.title().replace(&#39; &#39;, &#39;&#39;)
</span><span class="noop">    else:
</span><span class="hit">        exists_collectionclass = False
</span><span class="hit">    lines = []
</span><span class="hit">    if specification == &#39;model&#39;:
</span><span class="hit">        lines += [&#39;&#39;,
</span><span class="noop">                  &#39;.. autoclass:: &#39; + module.__name__ + &#39;.Model&#39;,
</span><span class="noop">                  &#39;    :members:&#39;,
</span><span class="noop">                  &#39;    :show-inheritance:&#39;]
</span><span class="hit">    elif exists_collectionclass:
</span><span class="hit">        lines += [&#39;&#39;,
</span><span class="noop">                  &#39;.. autoclass:: %s.%s&#39; % (module.__name__,
</span><span class="noop">                                            name_collectionclass),
</span><span class="noop">                  &#39;    :members:&#39;,
</span><span class="noop">                  &#39;    :show-inheritance:&#39;]
</span><span class="hit">    lines += [&#39;&#39;,
</span><span class="noop">              &#39;.. automodule:: &#39; + module.__name__,
</span><span class="noop">              &#39;    :members:&#39;,
</span><span class="noop">              &#39;    :show-inheritance:&#39;]
</span><span class="hit">    if specification == &#39;model&#39;:
</span><span class="hit">        lines += [&#39;    :exclude-members: Model&#39;]
</span><span class="hit">    elif exists_collectionclass:
</span><span class="hit">        lines += [&#39;    :exclude-members: &#39; + name_collectionclass]
</span><span class="hit">    return lines
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def autodoc_basemodel():
</span><span class="noop">    &#34;&#34;&#34;Add an exhaustive docstring to the `__init__` module of a basemodel.
</span><span class="noop">
</span><span class="noop">    One just has to write `autodoc_basemodel()` at the bottom of an `__init__`
</span><span class="noop">    module of a basemodel, and all model, parameter and sequence information
</span><span class="noop">    are appended to the modules docstring.  The resulting docstring is suitable
</span><span class="noop">    automatic documentation generation via `Sphinx` and `autodoc`.  Hence
</span><span class="noop">    it helps in constructing HydPy&#39;s online documentation and supports the
</span><span class="noop">    embeded help feature of `Spyder` (to see the result, import the package
</span><span class="noop">    of an arbitrary basemodel, e.g. `from hydpy.models import lland` and
</span><span class="noop">    press `cntr+i` with the cursor placed on `lland` written in the IPython
</span><span class="noop">    console afterwards).
</span><span class="noop">
</span><span class="noop">    Note that the resulting documentation will be complete only when the
</span><span class="noop">    modules of the basemodel are named in the standard way, e.g. `lland_model`,
</span><span class="noop">    `lland_control`, `lland_inputs`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    namespace = inspect.currentframe().f_back.f_locals
</span><span class="hit">    doc = namespace.get(&#39;__doc__&#39;)
</span><span class="hit">    if doc is None:
</span><span class="miss">        doc = &#39;&#39;
</span><span class="hit">    basemodulename = namespace[&#39;__name__&#39;].split(&#39;.&#39;)[-1]
</span><span class="hit">    modules = {key: value for key, value in namespace.items()
</span><span class="noop">               if (isinstance(value, types.ModuleType) and
</span><span class="noop">                   key.startswith(basemodulename+&#39;_&#39;))}
</span><span class="hit">    lines = []
</span><span class="hit">    specification = &#39;model&#39;
</span><span class="hit">    modulename = basemodulename+&#39;_&#39;+specification
</span><span class="hit">    if modulename in modules:
</span><span class="hit">        module = modules[modulename]
</span><span class="hit">        lines += _add_title(&#39;Model features&#39;, &#39;-&#39;)
</span><span class="hit">        lines += _add_lines(specification, module)
</span><span class="hit">    for (spec2capt, title) in zip((_PAR_SPEC2CAPT, _SEQ_SPEC2CAPT),
</span><span class="noop">                                  (&#39;Parameter features&#39;, &#39;Sequence features&#39;)):
</span><span class="hit">        new_lines = _add_title(title, &#39;-&#39;)
</span><span class="hit">        found_module = False
</span><span class="hit">        for (specification, caption) in spec2capt.items():
</span><span class="hit">            modulename = basemodulename+&#39;_&#39;+specification
</span><span class="hit">            module = modules.get(modulename)
</span><span class="hit">            if module:
</span><span class="hit">                found_module = True
</span><span class="hit">                new_lines += _add_title(caption, &#39;.&#39;)
</span><span class="hit">                new_lines += _add_lines(specification, module)
</span><span class="hit">        if found_module:
</span><span class="hit">            lines += new_lines
</span><span class="hit">    doc += &#39;\n&#39;.join(lines)
</span><span class="hit">    namespace[&#39;__doc__&#39;] = doc
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _number_of_line(member):
</span><span class="noop">    &#34;&#34;&#34;Try to return the number of the first line of the definition of a
</span><span class="noop">    member of a module.&#34;&#34;&#34;
</span><span class="hit">    if isinstance(member, tuple):
</span><span class="hit">        member = member[1]
</span><span class="hit">    try:
</span><span class="hit">        return member.__code__.co_firstlineno
</span><span class="hit">    except AttributeError:
</span><span class="hit">        pass
</span><span class="hit">    try:
</span><span class="hit">        return inspect.findsource(member)[1]
</span><span class="hit">    except BaseException:
</span><span class="hit">        pass
</span><span class="hit">    for (key, value) in vars(member).items():
</span><span class="hit">        try:
</span><span class="hit">            return value.__code__.co_firstlineno
</span><span class="hit">        except AttributeError:
</span><span class="hit">            pass
</span><span class="noop">    else:
</span><span class="hit">        return 0
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def autodoc_module():
</span><span class="noop">    &#34;&#34;&#34;Add a short summary of all implemented members to a modules docstring.
</span><span class="noop">
</span><span class="noop">    Just write `autodoctools.autodoc_module()` at the very bottom of the
</span><span class="noop">    module.
</span><span class="noop">
</span><span class="noop">    Note that function :func:`autodoc_module` is not thought to be used for
</span><span class="noop">    modules defining models.  For base models, see function
</span><span class="noop">    :func:`autodoc_basemodel` instead.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    module = inspect.getmodule(inspect.currentframe().f_back)
</span><span class="hit">    if module is None:
</span><span class="noop">        # Happens when HydPy has been freezed with PyInstaller.
</span><span class="noop">        # But then it is not necessary to extend the docstring anyway.
</span><span class="miss">        return
</span><span class="noop">    else:
</span><span class="hit">        doc = module.__doc__
</span><span class="hit">        if doc is None:
</span><span class="miss">            doc = &#39;&#39;
</span><span class="hit">        lines = [&#39;\n\nModule :mod:`~%s` implements the following members:\n&#39;
</span><span class="noop">                 % module.__name__]
</span><span class="hit">        members = []
</span><span class="hit">        for (name, member) in inspect.getmembers(module):
</span><span class="hit">            if ((not name.startswith(&#39;_&#39;)) and
</span><span class="noop">                    (inspect.getmodule(member) is module)):
</span><span class="hit">                members.append((name, member))
</span><span class="hit">        members = sorted(members, key=_number_of_line)
</span><span class="hit">        for (name, member) in members:
</span><span class="hit">            if inspect.isfunction(member):
</span><span class="hit">                type_ = &#39;func&#39;
</span><span class="hit">            elif inspect.isclass(member):
</span><span class="hit">                type_ = &#39;class&#39;
</span><span class="noop">            else:
</span><span class="hit">                type_ = &#39;obj&#39;
</span><span class="hit">            lines.append(&#39;      * :%s:`~%s` %s&#39;
</span><span class="noop">                         % (type_, name, description(member)))
</span><span class="hit">        module.__doc__ = doc + &#39;\n\n&#39; + &#39;\n&#39;.join(lines) + &#39;\n\n&#39; + 80*&#39;_&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/connectiontools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/connectiontools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This modules implements tools for handling connections between
</span><span class="noop">:class:`~hydpy.core.devicetools.Node` and
</span><span class="noop">:class:`~hydpy.core.devicetools.Element` instances.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from Hydpy
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Connections(object):
</span><span class="noop">    &#34;&#34;&#34;Connection between :class:`~hydpy.core.devicetools.Node` and
</span><span class="noop">    :class:`~hydpy.core.devicetools.Element` instances.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    __slots__ = (&#39;master&#39;, &#39;_slaves&#39;)
</span><span class="noop">
</span><span class="hit">    def __init__(self, master, *slaves):
</span><span class="hit">        self.master = master
</span><span class="hit">        self._slaves = set(slaves)
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, slave):
</span><span class="hit">        self._slaves.add(slave)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def names(self):
</span><span class="hit">        return tuple(slave.name for slave in sorted(self._slaves))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def slaves(self):
</span><span class="hit">        return tuple(slave for slave in sorted(self._slaves))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def variables(self):
</span><span class="hit">        variable = getattr(self.master, &#39;variable&#39;, None)
</span><span class="hit">        if variable:
</span><span class="miss">            return [variable]
</span><span class="noop">        else:
</span><span class="hit">            return sorted(set([slave.variable for slave in self]))
</span><span class="noop">
</span><span class="hit">    def __getattr__(self, name):
</span><span class="hit">        for slave in self._slaves:
</span><span class="hit">            if name == slave.name:
</span><span class="hit">                return slave
</span><span class="noop">        else:
</span><span class="hit">            raise AttributeError(
</span><span class="noop">                &#39;The selected connection neither has a attribute nor does &#39;
</span><span class="noop">                &#39;it handle a slave named `%s`.&#39; % name)
</span><span class="noop">
</span><span class="hit">    def __contains__(self, value):
</span><span class="hit">        try:
</span><span class="hit">            value = value.name
</span><span class="hit">        except AttributeError:
</span><span class="hit">            pass
</span><span class="hit">        return value in self.names
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for slave in sorted(self._slaves):
</span><span class="hit">            yield slave
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return len(self._slaves)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return [&#39;names&#39;, &#39;slaves&#39;, &#39;variables&#39;] + list(self.names)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/devicetools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/devicetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
1399 &nbsp;
1400 &nbsp;
1401 &nbsp;
1402 &nbsp;
1403 &nbsp;
1404 &nbsp;
1405 &nbsp;
1406 &nbsp;
1407 &nbsp;
1408 &nbsp;
1409 &nbsp;
1410 &nbsp;
1411 &nbsp;
1412 &nbsp;
1413 &nbsp;
1414 &nbsp;
1415 &nbsp;
1416 &nbsp;
1417 &nbsp;
1418 &nbsp;
1419 &nbsp;
1420 &nbsp;
1421 &nbsp;
1422 &nbsp;
1423 &nbsp;
1424 &nbsp;
1425 &nbsp;
1426 &nbsp;
1427 &nbsp;
1428 &nbsp;
1429 &nbsp;
1430 &nbsp;
1431 &nbsp;
1432 &nbsp;
1433 &nbsp;
1434 &nbsp;
1435 &nbsp;
1436 &nbsp;
1437 &nbsp;
1438 &nbsp;
1439 &nbsp;
1440 &nbsp;
1441 &nbsp;
1442 &nbsp;
1443 &nbsp;
1444 &nbsp;
1445 &nbsp;
1446 &nbsp;
1447 &nbsp;
1448 &nbsp;
1449 &nbsp;
1450 &nbsp;
1451 &nbsp;
1452 &nbsp;
1453 &nbsp;
1454 &nbsp;
1455 &nbsp;
1456 &nbsp;
1457 &nbsp;
1458 &nbsp;
1459 &nbsp;
1460 &nbsp;
1461 &nbsp;
1462 &nbsp;
1463 &nbsp;
1464 &nbsp;
1465 &nbsp;
1466 &nbsp;
1467 &nbsp;
1468 &nbsp;
1469 &nbsp;
1470 &nbsp;
1471 &nbsp;
1472 &nbsp;
1473 &nbsp;
1474 &nbsp;
1475 &nbsp;
1476 &nbsp;
1477 &nbsp;
1478 &nbsp;
1479 &nbsp;
1480 &nbsp;
1481 &nbsp;
1482 &nbsp;
1483 &nbsp;
1484 &nbsp;
1485 &nbsp;
1486 &nbsp;
1487 &nbsp;
1488 &nbsp;
1489 &nbsp;
1490 &nbsp;
1491 &nbsp;
1492 &nbsp;
1493 &nbsp;
1494 &nbsp;
1495 &nbsp;
1496 &nbsp;
1497 &nbsp;
1498 &nbsp;
1499 &nbsp;
1500 &nbsp;
1501 &nbsp;
1502 &nbsp;
1503 &nbsp;
1504 &nbsp;
1505 &nbsp;
1506 &nbsp;
1507 &nbsp;
1508 &nbsp;
1509 &nbsp;
1510 &nbsp;
1511 &nbsp;
1512 &nbsp;
1513 &nbsp;
1514 &nbsp;
1515 &nbsp;
1516 &nbsp;
1517 &nbsp;
1518 &nbsp;
1519 &nbsp;
1520 &nbsp;
1521 &nbsp;
1522 &nbsp;
1523 &nbsp;
1524 &nbsp;
1525 &nbsp;
1526 &nbsp;
1527 &nbsp;
1528 &nbsp;
1529 &nbsp;
1530 &nbsp;
1531 &nbsp;
1532 &nbsp;
1533 &nbsp;
1534 &nbsp;
1535 &nbsp;
1536 &nbsp;
1537 &nbsp;
1538 &nbsp;
1539 &nbsp;
1540 &nbsp;
1541 &nbsp;
1542 &nbsp;
1543 &nbsp;
1544 &nbsp;
1545 &nbsp;
1546 &nbsp;
1547 &nbsp;
1548 &nbsp;
1549 &nbsp;
1550 &nbsp;
1551 &nbsp;
1552 &nbsp;
1553 &nbsp;
1554 &nbsp;
1555 &nbsp;
1556 &nbsp;
1557 &nbsp;
1558 &nbsp;
1559 &nbsp;
1560 &nbsp;
1561 &nbsp;
1562 &nbsp;
1563 &nbsp;
1564 &nbsp;
1565 &nbsp;
1566 &nbsp;
1567 &nbsp;
1568 &nbsp;
1569 &nbsp;
1570 &nbsp;
1571 &nbsp;
1572 &nbsp;
1573 &nbsp;
1574 &nbsp;
1575 &nbsp;
1576 &nbsp;
1577 &nbsp;
1578 &nbsp;
1579 &nbsp;
1580 &nbsp;
1581 &nbsp;
1582 &nbsp;
1583 &nbsp;
1584 &nbsp;
1585 &nbsp;
1586 &nbsp;
1587 &nbsp;
1588 &nbsp;
1589 &nbsp;
1590 &nbsp;
1591 &nbsp;
1592 &nbsp;
1593 &nbsp;
1594 &nbsp;
1595 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This modules implements features related to two types of `devices`,
</span><span class="noop">called `nodes` and `elements` which are the most fundamental means to
</span><span class="noop">structure HydPy projects.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import copy
</span><span class="hit">import struct
</span><span class="hit">import weakref
</span><span class="noop"># ...from site-packages
</span><span class="hit">from matplotlib import pyplot
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import connectiontools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="hit">from hydpy.cythons import pointerutils
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Keywords(set):
</span><span class="noop">    &#34;&#34;&#34;Set of keyword arguments used to describe and search for element and
</span><span class="noop">    node objects.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.devicetools import Keywords
</span><span class="noop">    &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">    &gt;&gt;&gt; dummies.keywords = Keywords([&#39;first_keyword&#39;, &#39;second_keyword&#39;,
</span><span class="noop">    ...                              &#39;keyword_3&#39;, &#39;keyword_4&#39;,
</span><span class="noop">    ...                              &#39;keyboard&#39;])
</span><span class="noop">    &gt;&gt;&gt; dummies.keywords
</span><span class="noop">    Keywords([&#34;first_keyword&#34;, &#34;keyboard&#34;, &#34;keyword_3&#34;, &#34;keyword_4&#34;,
</span><span class="noop">              &#34;second_keyword&#34;])
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, names=None):
</span><span class="hit">        if names is None:
</span><span class="hit">            names = []
</span><span class="hit">        self.device = None
</span><span class="hit">        self._check_keywords(names)
</span><span class="hit">        super(Keywords, self).__init__(names)
</span><span class="noop">
</span><span class="hit">    def startswith(self, name):
</span><span class="noop">        &#34;&#34;&#34;Returns a list of all keywords starting with the given string.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">        &gt;&gt;&gt; dummies.keywords.startswith(&#39;keyword&#39;)
</span><span class="noop">        [&#39;keyword_3&#39;, &#39;keyword_4&#39;]
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return sorted(keyword for keyword in self if keyword.startswith(name))
</span><span class="noop">
</span><span class="hit">    def endswith(self, name):
</span><span class="noop">        &#34;&#34;&#34;Returns a list of all keywords ending with the given string.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">        &gt;&gt;&gt; dummies.keywords.endswith(&#39;keyword&#39;)
</span><span class="noop">        [&#39;first_keyword&#39;, &#39;second_keyword&#39;]
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return sorted(keyword for keyword in self if keyword.endswith(name))
</span><span class="noop">
</span><span class="hit">    def contains(self, name):
</span><span class="noop">        &#34;&#34;&#34;Returns a list of all keywords containing the given string.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">        &gt;&gt;&gt; dummies.keywords.contains(&#39;keyword&#39;)
</span><span class="noop">        [&#39;first_keyword&#39;, &#39;keyword_3&#39;, &#39;keyword_4&#39;, &#39;second_keyword&#39;]
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return sorted(keyword for keyword in self if name in keyword)
</span><span class="noop">
</span><span class="hit">    def _check_keywords(self, names):
</span><span class="hit">        try:
</span><span class="hit">            for name in names:
</span><span class="hit">                objecttools.valid_variable_identifier(name)
</span><span class="hit">        except ValueError:
</span><span class="hit">            objecttools.augmentexcmessage(
</span><span class="noop">                &#39;While trying to add the keyword `%s` to device `%s`&#39;
</span><span class="noop">                % (name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def update(self, names):
</span><span class="noop">        &#34;&#34;&#34;Before updating, names are checked to be valid variable identifiers.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">        &gt;&gt;&gt; keywords = dummies.keywords
</span><span class="noop">        &gt;&gt;&gt; keywords.update([&#39;test_1&#39;, &#39;test 2&#39;])
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: While trying to add the keyword `test 2` to device `?`, \
</span><span class="noop">the following error occured: The given name string `test 2` does not define a \
</span><span class="noop">valid variable identifier.  ...
</span><span class="noop">
</span><span class="noop">        Note that the first string (`test_1`) is not added, as the second
</span><span class="noop">        one (`test 2`) is invalid:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; keywords
</span><span class="noop">        Keywords([&#34;first_keyword&#34;, &#34;keyboard&#34;, &#34;keyword_3&#34;, &#34;keyword_4&#34;,
</span><span class="noop">                  &#34;second_keyword&#34;])
</span><span class="noop">
</span><span class="noop">        If the seconds string is corrected, everything works fine:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; keywords.update([&#39;test_1&#39;, &#39;test_2&#39;])
</span><span class="noop">        &gt;&gt;&gt; keywords
</span><span class="noop">        Keywords([&#34;first_keyword&#34;, &#34;keyboard&#34;, &#34;keyword_3&#34;, &#34;keyword_4&#34;,
</span><span class="noop">                  &#34;second_keyword&#34;, &#34;test_1&#34;, &#34;test_2&#34;])
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self._check_keywords(names)
</span><span class="hit">        super(Keywords, self).update(names)
</span><span class="noop">
</span><span class="hit">    def add(self, name):
</span><span class="noop">        &#34;&#34;&#34;Before adding a new name, it is checked to be valid variable identifiers.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">        &gt;&gt;&gt; keywords = dummies.keywords
</span><span class="noop">        &gt;&gt;&gt; keywords.add(&#39;1_test&#39;)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: While trying to add the keyword `1_test` to device `?`, \
</span><span class="noop">the following error occured: The given name string `1_test` does not define a \
</span><span class="noop">valid variable identifier.  ...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; keywords
</span><span class="noop">        Keywords([&#34;first_keyword&#34;, &#34;keyboard&#34;, &#34;keyword_3&#34;, &#34;keyword_4&#34;,
</span><span class="noop">                  &#34;second_keyword&#34;])
</span><span class="noop">
</span><span class="noop">        If the string is corrected, everything works fine:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; keywords.add(&#39;one_test&#39;)
</span><span class="noop">        &gt;&gt;&gt; keywords
</span><span class="noop">        Keywords([&#34;first_keyword&#34;, &#34;keyboard&#34;, &#34;keyword_3&#34;, &#34;keyword_4&#34;,
</span><span class="noop">                  &#34;one_test&#34;, &#34;second_keyword&#34;])
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self._check_keywords([name])
</span><span class="hit">        super(Keywords, self).add(name)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        with objecttools.repr_.preserve_strings(True):
</span><span class="hit">            return objecttools.assignrepr_list(
</span><span class="noop">                        sorted(self), &#39;Keywords(&#39;, width=70) + &#39;)&#39;
</span><span class="noop">
</span><span class="hit">    __dir__ = objecttools.dir_
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Device(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for class :class:`Element` and class :class:`Node`.
</span><span class="noop">
</span><span class="noop">    For framework programmers it is important to know, that all created
</span><span class="noop">    devices are registered.  Besides some other simplifications for
</span><span class="noop">    framework users, this prevents from defining multiple devices with
</span><span class="noop">    the same name (which is not allowed, at the names are supposed to
</span><span class="noop">    be valid object identifiers).
</span><span class="noop">
</span><span class="noop">    To show how the registry works, we first start with a clear registry:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import Node
</span><span class="noop">    &gt;&gt;&gt; Node.clear_registry()
</span><span class="noop">    &gt;&gt;&gt; sorted(Node.registered_names())
</span><span class="noop">    []
</span><span class="noop">
</span><span class="noop">    Now we initialize two nodes:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; node1 = Node(&#39;n1&#39;)
</span><span class="noop">    &gt;&gt;&gt; node2 = Node(&#39;n2&#39;)
</span><span class="noop">
</span><span class="noop">    Each time we pass the same names to the constructor of class :class:`Node`,
</span><span class="noop">    the same object is returned:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; node1 is Node(&#39;n1&#39;)
</span><span class="noop">    True
</span><span class="noop">    &gt;&gt;&gt; node1 is Node(&#39;n2&#39;)
</span><span class="noop">    False
</span><span class="noop">
</span><span class="noop">    You can access all registed nodes via the following class method:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; Node.registered_nodes()
</span><span class="noop">    Nodes(&#34;n1&#34;, &#34;n2&#34;)
</span><span class="noop">
</span><span class="noop">    The respective names are directly available via:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; sorted(Node.registered_names())
</span><span class="noop">    [&#39;n1&#39;, &#39;n2&#39;]
</span><span class="noop">
</span><span class="noop">    It is not recommended under usual circumstances, but you are allowed
</span><span class="noop">    to clear the registry:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; Node.clear_registry()
</span><span class="noop">    &gt;&gt;&gt; Node.registered_nodes()
</span><span class="noop">    Nodes()
</span><span class="noop">
</span><span class="noop">    But now there is the danger of creating two differnt nodes with the
</span><span class="noop">    same name, which is very likely to result in strange bugs:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; new_node1 = Node(&#39;n1&#39;)
</span><span class="noop">    &gt;&gt;&gt; new_node1 is node1
</span><span class="noop">    False
</span><span class="noop">    &gt;&gt;&gt; new_node1 == node1
</span><span class="noop">    True
</span><span class="noop">
</span><span class="noop">    The examples above also work for class :class:`Element`, except that
</span><span class="noop">    method `registered_nodes` must be exchanged with method
</span><span class="noop">    `registered_elements`, of course:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import Element
</span><span class="noop">    &gt;&gt;&gt; Element.clear_registry()
</span><span class="noop">    &gt;&gt;&gt; Element(&#39;e1&#39;).registered_elements()
</span><span class="noop">    Elements(&#34;e1&#34;)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _registry = {}
</span><span class="hit">    _selection = {}
</span><span class="noop">
</span><span class="hit">    def _get_name(self):
</span><span class="noop">        &#34;&#34;&#34;Name of the actual device (node or element).
</span><span class="noop">
</span><span class="noop">        Names are the identifiers of :class:`Node` and :class:`Element`
</span><span class="noop">        objects.  So define them carefully:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import Node
</span><span class="noop">        &gt;&gt;&gt; node1, node2 = Node(&#39;n1&#39;), Node(&#39;n2&#39;)
</span><span class="noop">        &gt;&gt;&gt; node1 is Node(&#39;n1&#39;)
</span><span class="noop">        True
</span><span class="noop">        &gt;&gt;&gt; node1 is Node(&#39;n2&#39;)
</span><span class="noop">        False
</span><span class="noop">
</span><span class="noop">        Note that each name name must be a valid variable identifier (see
</span><span class="noop">        function :func:`~hydpy.core.objecttools.valid_variable_identifier`),
</span><span class="noop">        to allow for attribute access:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import Nodes
</span><span class="noop">        &gt;&gt;&gt; nodes = Nodes(node1, &#39;n2&#39;)
</span><span class="noop">        &gt;&gt;&gt; nodes.n1
</span><span class="noop">        Node(&#34;n1&#34;, variable=&#34;Q&#34;)
</span><span class="noop">
</span><span class="noop">        Invalid variable identifiers result errors like the following:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; node3 = Node(&#39;n 3&#39;)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: While trying to initialize a `Node` object with value \
</span><span class="noop">`n 3` of type `str`, the following error occured: The given name string `n 3` \
</span><span class="noop">does not define a valid variable identifier.  ...
</span><span class="noop">
</span><span class="noop">        When you change the name of a :class:`Node` and :class:`Element`
</span><span class="noop">        object (only do this for a good reason), the corresponding key of
</span><span class="noop">        all related :class:`Nodes` and :class:`Elements` objects (as well
</span><span class="noop">        as of the internal registry) changes automatically:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; node1.name = &#39;n1a&#39;
</span><span class="noop">        &gt;&gt;&gt; nodes
</span><span class="noop">        Nodes(&#34;n1a&#34;, &#34;n2&#34;)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._name
</span><span class="noop">
</span><span class="hit">    def _set_name(self, name):
</span><span class="hit">        self._check_name(name)
</span><span class="hit">        _handlers = self._handlers.copy()
</span><span class="hit">        for handler in _handlers:
</span><span class="hit">            handler.remove_device(self)
</span><span class="hit">        try:
</span><span class="hit">            del self._registry[self._name]
</span><span class="miss">        except KeyError:
</span><span class="miss">            pass
</span><span class="noop">        else:
</span><span class="hit">            self._registry[name] = self
</span><span class="hit">        self._name = name
</span><span class="hit">        for handler in _handlers:
</span><span class="hit">            handler.add_device(self)
</span><span class="noop">
</span><span class="hit">    name = property(_get_name, _set_name)
</span><span class="noop">
</span><span class="hit">    def _check_name(self, name):
</span><span class="hit">        try:
</span><span class="hit">            objecttools.valid_variable_identifier(name)
</span><span class="hit">        except ValueError:
</span><span class="hit">            objecttools.augmentexcmessage(
</span><span class="noop">                &#39;While trying to initialize a `%s` object with value `%s` &#39;
</span><span class="noop">                &#39;of type `%s`&#39; % (objecttools.classname(self), name,
</span><span class="noop">                                  objecttools.classname(name)))
</span><span class="noop">
</span><span class="hit">    def _get_keywords(self):
</span><span class="noop">        &#34;&#34;&#34;Keywords describing this device.
</span><span class="noop">
</span><span class="noop">        The keywords are contained within a :class:`Keywords` object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import Node
</span><span class="noop">        &gt;&gt;&gt; node = Node(&#39;n&#39;)
</span><span class="noop">        &gt;&gt;&gt; node.keywords
</span><span class="noop">        Keywords([])
</span><span class="noop">
</span><span class="noop">        You are allowed to add then individually...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; node.keywords = &#39;word1&#39;
</span><span class="noop">
</span><span class="noop">        ... or within iterables:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; node.keywords = (&#39;word2&#39;, &#39;word3&#39;)
</span><span class="noop">        &gt;&gt;&gt; node.keywords
</span><span class="noop">        Keywords([&#34;word1&#34;, &#34;word2&#34;, &#34;word3&#34;])
</span><span class="noop">
</span><span class="noop">        You can delete all keywords at once via:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; del node.keywords
</span><span class="noop">        &gt;&gt;&gt; node.keywords
</span><span class="noop">        Keywords([])
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._keywords
</span><span class="noop">
</span><span class="hit">    def _set_keywords(self, keywords):
</span><span class="hit">        keywords = tuple(objecttools.extract(keywords, (str,), True))
</span><span class="hit">        self._keywords.update(keywords)
</span><span class="noop">
</span><span class="hit">    def _del_keywords(self):
</span><span class="hit">        self._keywords.clear()
</span><span class="noop">
</span><span class="hit">    keywords = property(_get_keywords, _set_keywords, _del_keywords)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def clear_registry(cls):
</span><span class="noop">        &#34;&#34;&#34;Clear the registry from all initialized devices.&#34;&#34;&#34;
</span><span class="hit">        cls._selection.clear()
</span><span class="hit">        cls._registry.clear()
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def registered_names(cls):
</span><span class="noop">        &#34;&#34;&#34;Get all names of :class:`Device` objects initialized so far.&#34;&#34;&#34;
</span><span class="hit">        return cls._registry.keys()
</span><span class="noop">
</span><span class="hit">    def add_handler(self, handler):
</span><span class="noop">        &#34;&#34;&#34;Add the given handler (either an :class:`Elements` or
</span><span class="noop">        :class`Nodes` object) to the set of handlers stored internally.&#34;&#34;&#34;
</span><span class="hit">        self._handlers.add(handler)
</span><span class="noop">
</span><span class="hit">    def remove_handler(self, handler):
</span><span class="noop">        &#34;&#34;&#34;Remove the given handler (either an :class:`Elements` or
</span><span class="noop">        :class`Nodes` object) from the set of handlers stored internally.&#34;&#34;&#34;
</span><span class="hit">        self._handlers.remove(handler)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for (key, value) in vars(self).items():
</span><span class="hit">            if isinstance(value, connectiontools.Connections):
</span><span class="hit">                yield (key, value)
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="hit">        return self.name &lt; other.name
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="miss">        return self.name &lt;= other.name
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return self.name == other.name
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="miss">        return self.name != other.name
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="miss">        return self.name &gt;= other.name
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="miss">        return self.name &gt; other.name
</span><span class="noop">
</span><span class="hit">    def __hash__(self):
</span><span class="hit">        return id(self)
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="hit">        return self.name
</span><span class="noop">
</span><span class="hit">    __dir__ = objecttools.dir_
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Node(Device):
</span><span class="noop">    &#34;&#34;&#34;Handles the data flow between :class:`Element` objects.
</span><span class="noop">
</span><span class="noop">    When initializing :class:`Node` objects, values for the optional `variable`
</span><span class="noop">    and `keywords` can be passed, which default to `Q` and &#34;empty:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import Node
</span><span class="noop">    &gt;&gt;&gt; node = Node(&#39;test&#39;)
</span><span class="noop">    &gt;&gt;&gt; node.variable
</span><span class="noop">    &#39;Q&#39;
</span><span class="noop">    &gt;&gt;&gt; node.keywords
</span><span class="noop">    Keywords([])
</span><span class="noop">
</span><span class="noop">    You are allowed to add further keywords by successive constructor calls:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; node = Node(&#39;test&#39;, keywords=&#39;word1&#39;)
</span><span class="noop">    &gt;&gt;&gt; Node(&#39;test&#39;, keywords=(&#39;word2&#39;, &#39;word3&#39;))
</span><span class="noop">    Node(&#34;test&#34;, variable=&#34;Q&#34;,
</span><span class="noop">         keywords=[&#34;word1&#34;, &#34;word2&#34;, &#34;word3&#34;])
</span><span class="noop">
</span><span class="noop">    But you are not allowed to change the variable a node is supposed to
</span><span class="noop">    handle (would be to error-prone):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; Node(&#39;test&#39;, variable=&#39;W&#39;)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: The variable to be represented by a `Node instance cannot \
</span><span class="noop">be changed.  The variable of node `test` is `Q` instead of `W` or `None`.  \
</span><span class="noop">Keep in mind, that `name` is the unique identifier of node objects.
</span><span class="noop">
</span><span class="noop">    If you really want to change a variable without to restart your Python
</span><span class="noop">    process, you have to delete the node from the registry first (again,
</span><span class="noop">    very error-prone unless you are absolutely sure you can delete all
</span><span class="noop">    other relevant references to the node object):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; del node._registry[&#39;test&#39;]
</span><span class="noop">    &gt;&gt;&gt; Node(&#39;test&#39;, variable=&#39;W&#39;)
</span><span class="noop">    Node(&#34;test&#34;, variable=&#34;W&#34;)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    To fully understand the last example, read the technical remarks
</span><span class="noop">    regarding the registry of :class:`Device` objects explained above.
</span><span class="noop">    On top of this persistent registry, there is also a temporal one,
</span><span class="noop">    which helps to identify when certain nodes where created
</span><span class="noop">    (e.g. during the execution of a certain network file).
</span><span class="noop">
</span><span class="noop">    To show how this works, we again start with a clear registry:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; Node.clear_registry()
</span><span class="noop">
</span><span class="noop">    Firstly, create two nodes:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; node1 = Node(&#39;n1&#39;)
</span><span class="noop">    &gt;&gt;&gt; node2 = Node(&#39;n2&#39;)
</span><span class="noop">
</span><span class="noop">    Now &#34;gather&#34; these two nodes:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; Node.gather_new_nodes()
</span><span class="noop">    Nodes(&#34;n1&#34;, &#34;n2&#34;)
</span><span class="noop">
</span><span class="noop">    This automatically removes the gathered nodes from the temporal registry.
</span><span class="noop">    This can be shown by simply calling the method again:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; Node.gather_new_nodes()
</span><span class="noop">    Nodes()
</span><span class="noop">
</span><span class="noop">    Now create a new node (n3) and call the constructor of an already existing
</span><span class="noop">    node again:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; node3 = Node(&#39;n3&#39;)
</span><span class="noop">    &gt;&gt;&gt; node1 = Node(&#39;n1&#39;)
</span><span class="noop">
</span><span class="noop">    Calling method `gather_new_nodes` again shows that an node is regarded
</span><span class="noop">    as &#34;new&#34;, if its constructor has been called:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; Node.gather_new_nodes()
</span><span class="noop">    Nodes(&#34;n1&#34;, &#34;n3&#34;)
</span><span class="noop">
</span><span class="noop">    This mechanism allows for redefining the same node in different network
</span><span class="noop">    files while keeping track of all files where it has been defined.
</span><span class="noop">
</span><span class="noop">    The following example is just supposed to clarify that the permanent
</span><span class="noop">    registry has not been altered by calling `gather_new_nodes`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; Node.registered_nodes()
</span><span class="noop">    Nodes(&#34;n1&#34;, &#34;n2&#34;, &#34;n3&#34;)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _registry = {}
</span><span class="hit">    _selection = {}
</span><span class="hit">    _predefinedvariable = &#39;Q&#39;
</span><span class="noop">
</span><span class="hit">    def __new__(cls, value, variable=None, keywords=None):
</span><span class="noop">        &#34;&#34;&#34;Return an already existing :class:`Node` instance or, if such
</span><span class="noop">        an instance does not exist yet, return a newly created one.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        name = str(value)
</span><span class="hit">        if name not in cls._registry:
</span><span class="hit">            self = object.__new__(Node)
</span><span class="hit">            self._check_name(name)
</span><span class="hit">            self._name = name
</span><span class="hit">            if variable is None:
</span><span class="hit">                self._variable = self._predefinedvariable
</span><span class="noop">            else:
</span><span class="hit">                self._variable = variable
</span><span class="hit">            self._keywords = Keywords()
</span><span class="hit">            self._keywords.device = self
</span><span class="hit">            self.entries = connectiontools.Connections(self)
</span><span class="hit">            self.exits = connectiontools.Connections(self)
</span><span class="hit">            self.sequences = sequencetools.NodeSequences(self)
</span><span class="hit">            self.deploy_mode = &#39;newsim&#39;
</span><span class="hit">            self._blackhole = None
</span><span class="hit">            self._handlers = weakref.WeakSet()
</span><span class="hit">            cls._registry[name] = self
</span><span class="hit">        cls._selection[name] = cls._registry[name]
</span><span class="hit">        return cls._registry[name]
</span><span class="noop">
</span><span class="hit">    def __init__(self, name, variable=None, keywords=None):
</span><span class="hit">        if (variable is not None) and (variable != self.variable):
</span><span class="hit">            raise ValueError(
</span><span class="noop">                &#39;The variable to be represented by a `Node instance cannot be &#39;
</span><span class="noop">                &#39;changed.  The variable of node `%s` is `%s` instead of `%s` &#39;
</span><span class="noop">                &#39;or `None`.  Keep in mind, that `name` is the unique &#39;
</span><span class="noop">                &#39;identifier of node objects.&#39;
</span><span class="noop">                % (self.name, self.variable, variable))
</span><span class="hit">        self.keywords = keywords
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def variable(self):
</span><span class="noop">        &#34;&#34;&#34;The variable handled by the respective node instance, e.g. `Q`.&#34;&#34;&#34;
</span><span class="hit">        return self._variable
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def registered_nodes(cls):
</span><span class="noop">        &#34;&#34;&#34;Get all :class:`Node` objects initialized so far.&#34;&#34;&#34;
</span><span class="hit">        return Nodes(cls._registry.values())
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def gather_new_nodes(cls):
</span><span class="noop">        &#34;&#34;&#34;Gather all `new` :class:`Node` objects. :class:`Node` objects
</span><span class="noop">        are deemed to be new if they have been created after the last usage
</span><span class="noop">        of this method.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        nodes = Nodes(cls._selection.values())
</span><span class="hit">        cls._selection.clear()
</span><span class="hit">        return nodes
</span><span class="noop">
</span><span class="hit">    def _get_deploy_mode(self):
</span><span class="noop">        &#34;&#34;&#34;Defines the kind of information a node deploys.
</span><span class="noop">
</span><span class="noop">        The following modes are supported:
</span><span class="noop">
</span><span class="noop">          * newsim: Deploy the simulated values calculated just recently.
</span><span class="noop">            This is the default mode, where a node receives e.g. a discharge
</span><span class="noop">            value from a upstream element and passes it to the downstream
</span><span class="noop">            element directly.
</span><span class="noop">          * obs: Deploy observed values instead of simulated values.  The
</span><span class="noop">            node still receives the simulated values from its upstream
</span><span class="noop">            element(s).  But it deploys values to its downstream nodes which
</span><span class="noop">            are defined externally.  Usually, these values are observations
</span><span class="noop">            made available within an Sequence file. See module
</span><span class="noop">            :mod:`~hydpy.core.sequencetools` for further information on
</span><span class="noop">            file specifications.
</span><span class="noop">          * oldsim: Simular to mode `obs`.  But it is usually applied when
</span><span class="noop">            a node is supposed to deploy simulated values which have been
</span><span class="noop">            calculated in a previous simulation run and stored in a sequence
</span><span class="noop">            file.
</span><span class="noop">
</span><span class="noop">        The technical difference between modes `obs` and `oldsim` is, that
</span><span class="noop">        the external values are either handled by the `obs` or the `sim`
</span><span class="noop">        sequence object.  Hence, if you select the `oldsim` mode, the
</span><span class="noop">        values of the upstream elements calculated within the current
</span><span class="noop">        simulation are not available (e.g. for parameter calibration)
</span><span class="noop">        after the simulation is finished.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._deploy_mode
</span><span class="noop">
</span><span class="hit">    def _set_deploy_mode(self, value):
</span><span class="hit">        if value == &#39;newsim&#39;:
</span><span class="hit">            self.sequences.sim.use_ext = False
</span><span class="hit">        elif value == &#39;obs&#39;:
</span><span class="miss">            self.sequences.sim.use_ext = False
</span><span class="miss">            self.sequences.obs.use_ext = True
</span><span class="hit">        elif value == &#39;oldsim&#39;:
</span><span class="hit">            self.sequences.sim.use_ext = True
</span><span class="hit">            self._blackhole = pointerutils.Double(0.)
</span><span class="noop">        else:
</span><span class="miss">            raise ValueError(
</span><span class="noop">                &#39;When trying to set the routing mode of node %s, the value &#39;
</span><span class="noop">                &#39;`%s` was given, but only the following values are allowed: &#39;
</span><span class="noop">                &#39;`newsim`, `obs` and `oldsim`.&#39; % (self.name, value))
</span><span class="hit">        self._deploy_mode = value
</span><span class="noop">
</span><span class="hit">    deploy_mode = property(_get_deploy_mode, _set_deploy_mode)
</span><span class="noop">
</span><span class="hit">    def get_double_via_exits(self):
</span><span class="noop">        &#34;&#34;&#34;Return the :class:`~hydpy.cythons.pointertools.Double` object that
</span><span class="noop">        is supposed to deploy its value to the downstream elements.&#34;&#34;&#34;
</span><span class="hit">        if self.deploy_mode != &#39;obs&#39;:
</span><span class="hit">            return self.sequences.fastaccess.sim
</span><span class="noop">        else:
</span><span class="miss">            return self.sequences.fastaccess.obs
</span><span class="noop">
</span><span class="hit">    def get_double_via_entries(self):
</span><span class="noop">        &#34;&#34;&#34;Return the :class:`~hydpy.cythons.pointertools.Double` object that
</span><span class="noop">        is supposed to receive the value(s) of the upstream elements.&#34;&#34;&#34;
</span><span class="hit">        if self.deploy_mode != &#39;oldsim&#39;:
</span><span class="hit">            return self.sequences.fastaccess.sim
</span><span class="noop">        else:
</span><span class="miss">            return self._blackhole
</span><span class="noop">
</span><span class="hit">    def reset(self, idx=None):
</span><span class="noop">        &#34;&#34;&#34;Reset the actual value of the simulation sequence to zero.&#34;&#34;&#34;
</span><span class="hit">        self.sequences.fastaccess.sim[0] = 0.
</span><span class="noop">
</span><span class="hit">    def _loaddata_sim(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Load the next sim sequence value (of the given index).
</span><span class="noop">
</span><span class="noop">        Used during simulations in Python mode only.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        fastaccess = self.sequences.fastaccess
</span><span class="hit">        if fastaccess._sim_ramflag:
</span><span class="hit">            fastaccess.sim[0] = fastaccess._sim_array[idx]
</span><span class="miss">        elif fastaccess._sim_diskflag:
</span><span class="miss">            raw = fastaccess._sim_file.read(8)
</span><span class="miss">            fastaccess.sim[0] = struct.unpack(&#39;d&#39;, raw)
</span><span class="noop">
</span><span class="hit">    def _savedata_sim(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Save the last sim sequence value (of the given index).
</span><span class="noop">
</span><span class="noop">        Used during simulations in Python mode only.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        fastaccess = self.sequences.fastaccess
</span><span class="hit">        if fastaccess._sim_ramflag:
</span><span class="hit">            fastaccess._sim_array[idx] = fastaccess.sim[0]
</span><span class="miss">        elif fastaccess._sim_diskflag:
</span><span class="miss">            raw = struct.pack(&#39;d&#39;, fastaccess.sim[0])
</span><span class="miss">            fastaccess._sim_file.write(raw)
</span><span class="noop">
</span><span class="hit">    def _loaddata_obs(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Load the next obs sequence value (of the given index).
</span><span class="noop">
</span><span class="noop">        Used during simulations in Python mode only.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        fastaccess = self.sequences.fastaccess
</span><span class="hit">        if fastaccess._obs_ramflag:
</span><span class="miss">            fastaccess.obs[0] = fastaccess._obs_array[idx]
</span><span class="hit">        elif fastaccess._obs_diskflag:
</span><span class="miss">            raw = fastaccess._obs_file.read(8)
</span><span class="miss">            fastaccess.obs[0] = struct.unpack(&#39;d&#39;, raw)
</span><span class="noop">
</span><span class="hit">    def prepare_allseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Prepare the series objects of both the `sim` and the `obs` sequence.
</span><span class="noop">
</span><span class="noop">        Call this method before a simulation run, if you need access to the
</span><span class="noop">        whole time series of the simulated and the observed series after the
</span><span class="noop">        simulation run is finished.
</span><span class="noop">
</span><span class="noop">        By default, the series are stored in RAM, which is the faster
</span><span class="noop">        option.  If your RAM is limited, pass the `False` for function
</span><span class="noop">        argument `ramflag` to store the series on disk.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.prepare_simseries(ramflag)
</span><span class="miss">        self.prepare_obsseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_simseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Prepare the series object of the `sim` sequence.
</span><span class="noop">
</span><span class="noop">        See method :func:`Node.prepare_allseries` for further information.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self._prepare_nodeseries(&#39;sim&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_obsseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Prepare the series object of the `obs` sequence.
</span><span class="noop">
</span><span class="noop">        See method :func:`Node.prepare_allseries` for further information.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self._prepare_nodeseries(&#39;obs&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def _prepare_nodeseries(self, seqname, ramflag):
</span><span class="miss">        seq = getattr(self.sequences, seqname)
</span><span class="miss">        if ramflag:
</span><span class="miss">            seq.activate_ram()
</span><span class="noop">        else:
</span><span class="miss">            seq.activate_disk()
</span><span class="noop">
</span><span class="hit">    def comparison_plot(self, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;Plot the series of both the `sim` and (if available) the `obs`
</span><span class="noop">        sequence.&#34;&#34;&#34;
</span><span class="miss">        for (name, seq) in self.sequences:
</span><span class="miss">            if pyplot.isinteractive():
</span><span class="miss">                name = &#39; &#39;.join((self.name, name))
</span><span class="miss">            pyplot.plot(seq.series, label=name, **kwargs)
</span><span class="miss">        pyplot.legend()
</span><span class="miss">        variable = self.variable
</span><span class="miss">        if variable == &#39;Q&#39;:
</span><span class="miss">            variable = u&#39;Q [m³/s]&#39;
</span><span class="miss">        pyplot.ylabel(variable)
</span><span class="miss">        if not pyplot.isinteractive():
</span><span class="miss">            pyplot.show()
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return self.assignrepr()
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix=&#39;&#39;):
</span><span class="noop">        &#34;&#34;&#34;Defines the `visual appearence` of :class:`Node` objects.
</span><span class="noop">
</span><span class="noop">        You can pass a string which prefixes the string representation.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        lines = [&#39;%sNode(&#34;%s&#34;, variable=&#34;%s&#34;,&#39;
</span><span class="noop">                 % (prefix, self.name, self.variable)]
</span><span class="hit">        if self.keywords:
</span><span class="hit">            subprefix = &#39;%skeywords=&#39; % (&#39; &#39;*(len(prefix)+5))
</span><span class="hit">            with objecttools.repr_.preserve_strings(True):
</span><span class="hit">                with objecttools.assignrepr_tuple.always_bracketed(False):
</span><span class="hit">                    line = objecttools.assignrepr_list(
</span><span class="noop">                                sorted(self.keywords), subprefix, width=70)
</span><span class="hit">            lines.append(line + &#39;,&#39;)
</span><span class="hit">        lines[-1] = lines[-1][:-1]+&#39;)&#39;
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Element(Device):
</span><span class="noop">    &#34;&#34;&#34;Handles a :class:`~hydpy.core.modeltools.Model` and connects it to
</span><span class="noop">    other models via :class:`Node` objects.
</span><span class="noop">
</span><span class="noop">    You are allowed to pass keywords to the constructor of class
</span><span class="noop">    :class:`Element`, as shown above for class :class:`Node`.
</span><span class="noop">
</span><span class="noop">    Additionally, you are allowed to pass different nodes (or names of
</span><span class="noop">    nodes) by successive constructor calls, e.g.:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import Element, Node
</span><span class="noop">    &gt;&gt;&gt; Element(&#39;test&#39;)
</span><span class="noop">    Element(&#34;test&#34;)
</span><span class="noop">    &gt;&gt;&gt; Element(&#39;test&#39;,
</span><span class="noop">    ...         inlets=&#39;in1&#39;,
</span><span class="noop">    ...         outlets=&#39;out1&#39;,
</span><span class="noop">    ...         receivers=&#39;rec1&#39;,
</span><span class="noop">    ...         senders=&#39;sen1&#39;)
</span><span class="noop">    Element(&#34;test&#34;,
</span><span class="noop">            inlets=&#34;in1&#34;,
</span><span class="noop">            outlets=&#34;out1&#34;,
</span><span class="noop">            receivers=&#34;rec1&#34;,
</span><span class="noop">            senders=&#34;sen1&#34;)
</span><span class="noop">    &gt;&gt;&gt; Element(&#39;test&#39;,
</span><span class="noop">    ...         inlets=(&#39;in2&#39;, Node(&#39;in3&#39;)),
</span><span class="noop">    ...         outlets=(&#39;out2&#39;, Node(&#39;out3&#39;)),
</span><span class="noop">    ...         receivers=(&#39;rec2&#39;, Node(&#39;rec3&#39;)),
</span><span class="noop">    ...         senders=(&#39;sen2&#39;, Node(&#39;sen3&#39;)))
</span><span class="noop">    Element(&#34;test&#34;,
</span><span class="noop">            inlets=[&#34;in1&#34;, &#34;in2&#34;, &#34;in3&#34;],
</span><span class="noop">            outlets=[&#34;out1&#34;, &#34;out2&#34;, &#34;out3&#34;],
</span><span class="noop">            receivers=[&#34;rec1&#34;, &#34;rec2&#34;, &#34;rec3&#34;],
</span><span class="noop">            senders=[&#34;sen1&#34;, &#34;sen2&#34;, &#34;sen3&#34;])
</span><span class="noop">
</span><span class="noop">    Reassigning some nodes does no harm:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; Element(&#39;test&#39;,
</span><span class="noop">    ...         inlets=(&#39;in2&#39;, Node(&#39;in3&#39;), &#39;in4&#39;),
</span><span class="noop">    ...         outlets=(&#39;out2&#39;, Node(&#39;out3&#39;), &#39;out4&#39;),
</span><span class="noop">    ...         receivers=(&#39;rec2&#39;, Node(&#39;rec3&#39;), &#39;rec4&#39;),
</span><span class="noop">    ...         senders=(&#39;sen2&#39;, Node(&#39;sen3&#39;), &#39;sen4&#39;))
</span><span class="noop">    Element(&#34;test&#34;,
</span><span class="noop">            inlets=[&#34;in1&#34;, &#34;in2&#34;, &#34;in3&#34;, &#34;in4&#34;],
</span><span class="noop">            outlets=[&#34;out1&#34;, &#34;out2&#34;, &#34;out3&#34;, &#34;out4&#34;],
</span><span class="noop">            receivers=[&#34;rec1&#34;, &#34;rec2&#34;, &#34;rec3&#34;, &#34;rec4&#34;],
</span><span class="noop">            senders=[&#34;sen1&#34;, &#34;sen2&#34;, &#34;sen3&#34;, &#34;sen4&#34;])
</span><span class="noop">
</span><span class="noop">    But it is verified that an element does not handle the same node as
</span><span class="noop">    an `input` and `output` node or as a `receiver` and a `sender` node:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; Element(&#39;test&#39;, inlets=&#39;out1&#39;)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: For element `test`, the given inlet node `out1` is already \
</span><span class="noop">defined as an outlet node, which is not allowed.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; Element(&#39;test&#39;, outlets=&#39;in1&#39;)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: For element `test`, the given outlet node `in1` is already \
</span><span class="noop">defined as an inlet node, which is not allowed.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; Element(&#39;test&#39;, receivers=&#39;sen1&#39;)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: For element `test`, the given receiver node `sen1` is already \
</span><span class="noop">defined as a sender node, which is not allowed.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; Element(&#39;test&#39;, senders=&#39;rec1&#39;)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: For element `test`, the given sender node `rec1` is already \
</span><span class="noop">defined as a receiver, node which is not allowed.
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Note the technical remarks regarding the permanent registry of
</span><span class="noop">    :class:`Device` objects explained above (which also help to understand
</span><span class="noop">    how the last examples work behind the scenes.)  Additionally, the
</span><span class="noop">    remarks on the temperal registry of :class:`Node` objects also apply
</span><span class="noop">    on :class:`Element` objects.  Without to repeat the whole explanation,
</span><span class="noop">    this can be shown by the following short example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import Elements
</span><span class="noop">    &gt;&gt;&gt; Element.clear_registry()
</span><span class="noop">    &gt;&gt;&gt; Elements(&#39;e1&#39;, &#39;e2&#39;).e1.gather_new_elements()
</span><span class="noop">    Elements(&#34;e1&#34;, &#34;e2&#34;)
</span><span class="noop">    &gt;&gt;&gt; Elements(&#39;e3&#39;, &#39;e1&#39;).e1.gather_new_elements()
</span><span class="noop">    Elements(&#34;e1&#34;, &#34;e3&#34;)
</span><span class="noop">    &gt;&gt;&gt; Element.gather_new_elements()
</span><span class="noop">    Elements()
</span><span class="noop">    &gt;&gt;&gt; Element.registered_elements()
</span><span class="noop">    Elements(&#34;e1&#34;, &#34;e2&#34;, &#34;e3&#34;)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _registry = {}
</span><span class="hit">    _selection = {}
</span><span class="noop">
</span><span class="hit">    def __new__(cls, value, inlets=None, outlets=None,
</span><span class="noop">                receivers=None, senders=None, keywords=None):
</span><span class="noop">        &#34;&#34;&#34;Return an already existing :class:`Element` instance or, if such
</span><span class="noop">        an instance does not exist yet, a new newly created one.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        name = str(value)
</span><span class="hit">        if name not in cls._registry:
</span><span class="hit">            self = object.__new__(Element)
</span><span class="hit">            self._check_name(name)
</span><span class="hit">            self._name = name
</span><span class="hit">            self.inlets = connectiontools.Connections(self)
</span><span class="hit">            self.outlets = connectiontools.Connections(self)
</span><span class="hit">            self.receivers = connectiontools.Connections(self)
</span><span class="hit">            self.senders = connectiontools. Connections(self)
</span><span class="hit">            self._keywords = Keywords()
</span><span class="hit">            self._keywords.device = self
</span><span class="hit">            self.model = None
</span><span class="hit">            self._handlers = weakref.WeakSet()
</span><span class="hit">            cls._registry[name] = self
</span><span class="hit">        cls._selection[name] = cls._registry[name]
</span><span class="hit">        return cls._registry[name]
</span><span class="noop">
</span><span class="hit">    def __init__(self, name, inlets=None, outlets=None,
</span><span class="noop">                 receivers=None, senders=None, keywords=None):
</span><span class="noop">        &#34;&#34;&#34;Add the given :class:`Node` objects via the corresponding
</span><span class="noop">        :class:`~hydpy.core.connectiontools.Connection` objects.&#34;&#34;&#34;
</span><span class="hit">        if inlets is not None:
</span><span class="hit">            for inlet in Nodes(inlets):
</span><span class="hit">                if inlet in self.outlets:
</span><span class="hit">                    raise ValueError(
</span><span class="noop">                        &#39;For element `%s`, the given inlet node `%s` is &#39;
</span><span class="noop">                        &#39;already defined as an outlet node, which is not &#39;
</span><span class="noop">                        &#39;allowed.&#39; % (self, inlet))
</span><span class="hit">                self.inlets += inlet
</span><span class="hit">                inlet.exits += self
</span><span class="hit">        if outlets is not None:
</span><span class="hit">            for outlet in Nodes(outlets):
</span><span class="hit">                if outlet in self.inlets:
</span><span class="hit">                    raise ValueError(
</span><span class="noop">                        &#39;For element `%s`, the given outlet node `%s` is &#39;
</span><span class="noop">                        &#39;already defined as an inlet node, which is not &#39;
</span><span class="noop">                        &#39;allowed.&#39; % (self, outlet))
</span><span class="hit">                self.outlets += outlet
</span><span class="hit">                outlet.entries += self
</span><span class="hit">        if receivers is not None:
</span><span class="hit">            for receiver in Nodes(receivers):
</span><span class="hit">                if receiver in self.senders:
</span><span class="hit">                    raise ValueError(
</span><span class="noop">                        &#39;For element `%s`, the given receiver node `%s` is &#39;
</span><span class="noop">                        &#39;already defined as a sender node, which is not &#39;
</span><span class="noop">                        &#39;allowed.&#39; % (self, receiver))
</span><span class="hit">                self.receivers += receiver
</span><span class="hit">                receiver.exits += self
</span><span class="hit">        if senders is not None:
</span><span class="hit">            for sender in Nodes(senders):
</span><span class="hit">                if sender in self.receivers:
</span><span class="hit">                    raise ValueError(
</span><span class="noop">                        &#39;For element `%s`, the given sender node `%s` is &#39;
</span><span class="noop">                        &#39;already defined as a receiver, node which is not &#39;
</span><span class="noop">                        &#39;allowed.&#39; % (self, sender))
</span><span class="hit">                self.senders += sender
</span><span class="hit">                sender.entries += self
</span><span class="hit">        self.keywords = keywords
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def registered_elements(cls):
</span><span class="noop">        &#34;&#34;&#34;Get all :class:`Element` objects initialized so far.&#34;&#34;&#34;
</span><span class="hit">        return Elements(cls._registry.values())
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def gather_new_elements(cls):
</span><span class="noop">        &#34;&#34;&#34;Gather all `new` :class:`Element` objects. :class:`Element` objects
</span><span class="noop">        are deemed to be new if they have been created after the last usage
</span><span class="noop">        of this method.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        elements = Elements(cls._selection.values())
</span><span class="hit">        cls._selection.clear()
</span><span class="hit">        return elements
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def variables(self):
</span><span class="noop">        &#34;&#34;&#34;A set of all different variables of the nodes directly connected
</span><span class="noop">        to this element.
</span><span class="noop">
</span><span class="noop">        Suppose there is a element connected to five nodes, which (partly)
</span><span class="noop">        represent different variables:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import Element, Node
</span><span class="noop">        &gt;&gt;&gt; element = Element(&#39;Test&#39;,
</span><span class="noop">        ...                   inlets=(Node(&#39;N1&#39;, &#39;X&#39;), Node(&#39;N2&#39;, &#39;Y1&#39;)),
</span><span class="noop">        ...                   outlets=(Node(&#39;N3&#39;, &#39;X&#39;), Node(&#39;N4&#39;, &#39;Y2&#39;)),
</span><span class="noop">        ...                   receivers=(Node(&#39;N5&#39;, &#39;X&#39;), Node(&#39;N6&#39;, &#39;Y3&#39;)),
</span><span class="noop">        ...                   senders=(Node(&#39;N7&#39;, &#39;X&#39;), Node(&#39;N8&#39;, &#39;Y4&#39;)))
</span><span class="noop">
</span><span class="noop">        `variables` puts all the different variables of these nodes together:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sorted(element.variables)
</span><span class="noop">        [&#39;X&#39;, &#39;Y1&#39;, &#39;Y2&#39;, &#39;Y3&#39;, &#39;Y4&#39;]
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        variables = set()
</span><span class="hit">        for (name, connections) in self:
</span><span class="hit">            variables.update(connections.variables)
</span><span class="hit">        return variables
</span><span class="noop">
</span><span class="hit">    def init_model(self):
</span><span class="noop">        &#34;&#34;&#34;Initialize the model to be handled by this element and build
</span><span class="noop">        the required connections.&#34;&#34;&#34;
</span><span class="miss">        dict_ = pub.controlmanager.loadfile(element=self)
</span><span class="miss">        self.connect(dict_[&#39;model&#39;])
</span><span class="noop">
</span><span class="hit">    def connect(self, model=None):
</span><span class="noop">        &#34;&#34;&#34;Connect the handled model with this element.
</span><span class="noop">
</span><span class="noop">        The following examples involve an error that is catched cleanly
</span><span class="noop">        only in pure Python mode, hence Cython is disabled:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; pub.options.usecython = False
</span><span class="noop">
</span><span class="noop">        If a model is passed, proper connections with this model are build
</span><span class="noop">        We use the &#34;HBV branch model&#34; :mod:`~hydpy.models.hbranch as an
</span><span class="noop">        example, which branches a single input value (from to node `inp`)
</span><span class="noop">        to multiple outputs (nodes `out1` and `out2`):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import Element, Node
</span><span class="noop">        &gt;&gt;&gt; element = Element(&#39;a_branch&#39;,
</span><span class="noop">        ...                   inlets=&#39;branch_input&#39;,
</span><span class="noop">        ...                   outlets=(&#39;branch_output_1&#39;, &#39;branch_output_2&#39;))
</span><span class="noop">        &gt;&gt;&gt; inp = element.inlets.branch_input
</span><span class="noop">        &gt;&gt;&gt; out1, out2 = element.outlets
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hbranch import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; element.connect(model)
</span><span class="noop">
</span><span class="noop">        To show that the inlet connection is built properly, assign a new
</span><span class="noop">        value to the inlet node and verify that his value can actually be
</span><span class="noop">        picked by the model:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; inp.sequences.sim = 999.0
</span><span class="noop">        &gt;&gt;&gt; model.pick_input()
</span><span class="noop">        &gt;&gt;&gt; fluxes.input
</span><span class="noop">        input(999.0)
</span><span class="noop">
</span><span class="noop">        If no model is passed to method `connect`, the connections with
</span><span class="noop">        the model already handled by this element are refreshed.  In the
</span><span class="noop">        given example, the `hbranch` model could already le to connected
</span><span class="noop">        to its inlet node, but not to its outlet nodes, which requires
</span><span class="noop">        some parameter information on how to allocate the inflow to the
</span><span class="noop">        different outlet nodes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; xpoints(0.0, 3.0)
</span><span class="noop">        &gt;&gt;&gt; ypoints(branch_output_1=[0.0, 1.0], branch_output_2=[0.0, 2.0])
</span><span class="noop">        &gt;&gt;&gt; parameters.update()
</span><span class="noop">        &gt;&gt;&gt; model.doit(0)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        RuntimeError: The pointer of the acutal `PPDouble` instance at \
</span><span class="noop">index 0 requested, but not prepared yet via `setpointer`.
</span><span class="noop">
</span><span class="noop">        The last command resulted in a somewhat strange error message.  The
</span><span class="noop">        reason for the explained error is that the `hbranch` model does now
</span><span class="noop">        know how to connect to the outlet nodes `out1` and `out2`, but has
</span><span class="noop">        not been requested to do so.  When we do so, no error is raised:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; element.connect()
</span><span class="noop">        &gt;&gt;&gt; parameters.update()
</span><span class="noop">        &gt;&gt;&gt; model.doit(0)
</span><span class="noop">
</span><span class="noop">        Now we can prove that both the inlet and the outlet connections are
</span><span class="noop">        build properly by verifying that the expected output values are
</span><span class="noop">        actually passed to the outlet nodes while performing an simulation
</span><span class="noop">        step with method `doit` above:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; out1.sequences.sim
</span><span class="noop">        sim(333.0)
</span><span class="noop">        &gt;&gt;&gt; out2.sequences.sim
</span><span class="noop">        sim(666.0)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        If neither a model is passed nor an model is already handled, an
</span><span class="noop">        erro is raised:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; Element(&#39;empty&#39;).connect()
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        AttributeError: While trying to build the connections of the model \
</span><span class="noop">handled by element `empty`, the following error occured: No model has been \
</span><span class="noop">assigned to the element so far.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if model is not None:
</span><span class="hit">            self.model = model
</span><span class="hit">            model.element = self
</span><span class="hit">        try:
</span><span class="hit">            model = getattr(self, &#39;model&#39;, None)
</span><span class="hit">            if model is None:
</span><span class="hit">                raise AttributeError(
</span><span class="noop">                    &#39;No model has been assigned to the element so far.&#39;)
</span><span class="noop">            else:
</span><span class="hit">                self.model.connect()
</span><span class="hit">        except BaseException:
</span><span class="hit">            objecttools.augmentexcmessage(
</span><span class="noop">                &#39;While trying to build the connections of the model handled &#39;
</span><span class="noop">                &#39;by element `%s`&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    def prepare_allseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Prepare the series objects of all `input`, `flux` and `state`
</span><span class="noop">        sequences of the model handled by this element.
</span><span class="noop">
</span><span class="noop">        Call this method before a simulation run, if you need access to
</span><span class="noop">        (nearly) all simulated series of the handled model after the
</span><span class="noop">        simulation run is finished.
</span><span class="noop">
</span><span class="noop">        By default, the series are stored in RAM, which is the faster
</span><span class="noop">        option.  If your RAM is limited, pass the `False` for function
</span><span class="noop">        argument `ramflag` to store the series on disk.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.prepare_inputseries(ramflag)
</span><span class="miss">        self.prepare_fluxseries(ramflag)
</span><span class="miss">        self.prepare_stateseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_inputseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Prepare the series objects of the `input` sequences of the model
</span><span class="noop">        handled by this element.
</span><span class="noop">
</span><span class="noop">        See method :func:`Element.prepare_allseries` for further information.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self._prepare_series(&#39;inputs&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_fluxseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Prepare the series objects of the `flux` sequences of the model
</span><span class="noop">        handled by this element.
</span><span class="noop">
</span><span class="noop">        See method :func:`Element.prepare_allseries` for further information.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self._prepare_series(&#39;fluxes&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_stateseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Prepare the series objects of the `state` sequences of the model
</span><span class="noop">        handled by this element.
</span><span class="noop">
</span><span class="noop">        See method :func:`Element.prepare_allseries` for further information.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self._prepare_series(&#39;states&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def _prepare_series(self, name_subseqs, ramflag):
</span><span class="hit">        sequences = self.model.sequences
</span><span class="hit">        subseqs = getattr(sequences, name_subseqs, None)
</span><span class="hit">        if subseqs:
</span><span class="hit">            if ramflag:
</span><span class="hit">                subseqs.activate_ram()
</span><span class="noop">            else:
</span><span class="miss">                subseqs.activate_disk()
</span><span class="noop">
</span><span class="hit">    def _plot(self, subseqs, names, kwargs):
</span><span class="miss">        if names is not None:
</span><span class="miss">            subseqs = ((name, getattr(name)) for name in names)
</span><span class="miss">        for seq in subseqs:
</span><span class="miss">            if seq.NDIM == 0:
</span><span class="miss">                label = kwargs.pop(&#39;label&#39;, &#39; &#39;.join((self.name, seq.name)))
</span><span class="miss">                pyplot.plot(seq.series, label=label, **kwargs)
</span><span class="miss">                pyplot.legend()
</span><span class="noop">            else:
</span><span class="miss">                color = kwargs.pop(&#39;color&#39;, kwargs.pop(&#39;c&#39;, &#39;red&#39;))
</span><span class="miss">                pyplot.plot(seq.series, color=color, **kwargs)
</span><span class="miss">        if not pyplot.isinteractive():
</span><span class="miss">            pyplot.show()
</span><span class="noop">
</span><span class="hit">    def input_plot(self, names=None, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;Plot the `input` series of the handled model.
</span><span class="noop">
</span><span class="noop">        To plot the series of a subset of all sequences, pass the respective
</span><span class="noop">        names.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self._plot(self.model.sequences.inputs, names, kwargs)
</span><span class="noop">
</span><span class="hit">    def flux_plot(self, names=None, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;Plot the `flux` series of the handled model.
</span><span class="noop">
</span><span class="noop">        To plot the series of a subset of all sequences, pass the respective
</span><span class="noop">        names.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self._plot(self.model.sequences.fluxes, names, kwargs)
</span><span class="noop">
</span><span class="hit">    def state_plot(self, names=None, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;Plot the `state` series of the handled model.
</span><span class="noop">
</span><span class="noop">        To plot the series of a subset of all sequences, pass the respective
</span><span class="noop">        names.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self._plot(self.model.sequences.states, names, kwargs)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Defines the `visual appearence` of :class:`Element` objects.
</span><span class="noop">
</span><span class="noop">        You can pass a string which prefixes the string representation.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        with objecttools.repr_.preserve_strings(True):
</span><span class="hit">            with objecttools.assignrepr_tuple.always_bracketed(False):
</span><span class="hit">                blanks = &#39; &#39; * (len(prefix) + 8)
</span><span class="hit">                lines = [&#39;%sElement(&#34;%s&#34;,&#39; % (prefix, self.name)]
</span><span class="hit">                for conname in (&#39;inlets&#39;, &#39;outlets&#39;, &#39;receivers&#39;, &#39;senders&#39;):
</span><span class="hit">                    connections = getattr(self, conname, None)
</span><span class="hit">                    if connections:
</span><span class="hit">                        subprefix = &#39;%s%s=&#39; % (blanks, conname)
</span><span class="hit">                        nodes = [str(node) for node in connections.slaves]
</span><span class="hit">                        line = objecttools.assignrepr_list(
</span><span class="noop">                                                nodes, subprefix, width=70)
</span><span class="hit">                        lines.append(line + &#39;,&#39;)
</span><span class="hit">                if self.keywords:
</span><span class="miss">                    subprefix = &#39;%skeywords=&#39; % blanks
</span><span class="miss">                    line = objecttools.assignrepr_list(
</span><span class="noop">                                sorted(self.keywords), subprefix, width=70)
</span><span class="miss">                    lines.append(line + &#39;,&#39;)
</span><span class="hit">                lines[-1] = lines[-1][:-1]+&#39;)&#39;
</span><span class="hit">                return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Devices(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for class :class:`Elements` and class :class:`Nodes`.
</span><span class="noop">
</span><span class="noop">    There are only small differences between class :class:`Elements`
</span><span class="noop">    and class :class:`Nodes`.  We focus our explanations on class
</span><span class="noop">    :class:`Nodes` arbitrarily.
</span><span class="noop">
</span><span class="noop">    The following test objects are used to explain the methods
</span><span class="noop">    and properties of class :class:`Device` (note the different types of
</span><span class="noop">    the initialization arguments):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">    &gt;&gt;&gt; from hydpy import Node, Nodes, Element, Elements
</span><span class="noop">    &gt;&gt;&gt; dummies.nodes = Nodes(&#39;na&#39;,
</span><span class="noop">    ...                       Node(&#39;nb&#39;, variable=&#39;W&#39;),
</span><span class="noop">    ...                       Node(&#39;nc&#39;, keywords=(&#39;group_a&#39;, &#39;group_1&#39;)),
</span><span class="noop">    ...                       Node(&#39;nd&#39;, keywords=(&#39;group_a&#39;, &#39;group_2&#39;)),
</span><span class="noop">    ...                       Node(&#39;ne&#39;, keywords=(&#39;group_b&#39;, &#39;group_1&#39;)))
</span><span class="noop">    &gt;&gt;&gt; dummies.elements = Elements(&#39;ea&#39;, Element(&#39;eb&#39;))
</span><span class="noop">
</span><span class="noop">    In a nutshell, :class:`Devices` instances are containers supporting
</span><span class="noop">    attribute access.  You can access each device directly by its name:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nodes = dummies.nodes
</span><span class="noop">    &gt;&gt;&gt; nodes.na
</span><span class="noop">    Node(&#34;na&#34;, variable=&#34;Q&#34;)
</span><span class="noop">
</span><span class="noop">    Wrong device names result in the following error message:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nodes.na_
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    AttributeError: The selected Nodes object has neither a `na_` \
</span><span class="noop">attribute nor does it handle a Node object with name or keyword `na_`, \
</span><span class="noop">which could be returned.
</span><span class="noop">
</span><span class="noop">    Attribute deleting is supported:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; &#39;na&#39; in nodes
</span><span class="noop">    True
</span><span class="noop">    &gt;&gt;&gt; del nodes.na
</span><span class="noop">    &gt;&gt;&gt; &#39;na&#39; in nodes
</span><span class="noop">    False
</span><span class="noop">    &gt;&gt;&gt; del nodes.na
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    AttributeError: The selected Nodes object has neither a `na` attribute \
</span><span class="noop">nor does it handle a Node object named `na`, which could be deleted.
</span><span class="noop">
</span><span class="noop">    However, exemplified by the next example, setting devices as attributes
</span><span class="noop">    &#34;pythonically&#34; could result in inconsistencies and is not allowed
</span><span class="noop">    (see method :func:`~Devices.add_device` instead):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nodes.NF = Node(&#39;nf&#39;)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    NotImplementedError: Setting attributes of Nodes objects could result \
</span><span class="noop">in confusion whether a new attribute should be handled as a Node object or \
</span><span class="noop">as a &#34;normal&#34; attribute and is thus not support.
</span><span class="noop">
</span><span class="noop">    The operators `+`, `+=`, `-` and `-=` support adding and removing
</span><span class="noop">    groups of devices:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; subgroup = Nodes(&#34;nc&#34;, &#34;ne&#34;)
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nodes
</span><span class="noop">    Nodes(&#34;nb&#34;, &#34;nc&#34;, &#34;nd&#34;, &#34;ne&#34;)
</span><span class="noop">    &gt;&gt;&gt; subgroup
</span><span class="noop">    Nodes(&#34;nc&#34;, &#34;ne&#34;)
</span><span class="noop">    &gt;&gt;&gt; nodes - subgroup
</span><span class="noop">    Nodes(&#34;nb&#34;, &#34;nd&#34;)
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nodes
</span><span class="noop">    Nodes(&#34;nb&#34;, &#34;nc&#34;, &#34;nd&#34;, &#34;ne&#34;)
</span><span class="noop">    &gt;&gt;&gt; nodes -= subgroup
</span><span class="noop">    &gt;&gt;&gt; nodes
</span><span class="noop">    Nodes(&#34;nb&#34;, &#34;nd&#34;)
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nodes + subgroup
</span><span class="noop">    Nodes(&#34;nb&#34;, &#34;nc&#34;, &#34;nd&#34;, &#34;ne&#34;)
</span><span class="noop">    &gt;&gt;&gt; nodes
</span><span class="noop">    Nodes(&#34;nb&#34;, &#34;nd&#34;)
</span><span class="noop">    &gt;&gt;&gt; nodes += subgroup
</span><span class="noop">    &gt;&gt;&gt; nodes
</span><span class="noop">    Nodes(&#34;nb&#34;, &#34;nc&#34;, &#34;nd&#34;, &#34;ne&#34;)
</span><span class="noop">
</span><span class="noop">    Trying to add already existing are to remove non existing devices
</span><span class="noop">    does no harm:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nodes
</span><span class="noop">    Nodes(&#34;nb&#34;, &#34;nc&#34;, &#34;nd&#34;, &#34;ne&#34;)
</span><span class="noop">    &gt;&gt;&gt; nodes + subgroup
</span><span class="noop">    Nodes(&#34;nb&#34;, &#34;nc&#34;, &#34;nd&#34;, &#34;ne&#34;)
</span><span class="noop">    &gt;&gt;&gt; nodes - Node(&#39;na&#39;)
</span><span class="noop">    Nodes(&#34;nb&#34;, &#34;nc&#34;, &#34;nd&#34;, &#34;ne&#34;)
</span><span class="noop">
</span><span class="noop">    Finally, the following &#34;set operators&#34; are supported:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; subgroup &lt; nodes, nodes &lt; subgroup, nodes &lt; nodes
</span><span class="noop">    (True, False, False)
</span><span class="noop">    &gt;&gt;&gt; subgroup &lt;= nodes, nodes &lt;= subgroup, nodes &lt;= nodes
</span><span class="noop">    (True, False, True)
</span><span class="noop">    &gt;&gt;&gt; subgroup == nodes, nodes == subgroup, nodes == nodes
</span><span class="noop">    (False, False, True)
</span><span class="noop">    &gt;&gt;&gt; subgroup != nodes, nodes != subgroup, nodes != nodes
</span><span class="noop">    (True, True, False)
</span><span class="noop">    &gt;&gt;&gt; subgroup &gt;= nodes, nodes &gt;= subgroup, nodes &gt;= nodes
</span><span class="noop">    (False, True, True)
</span><span class="noop">    &gt;&gt;&gt; subgroup &gt; nodes, nodes &gt; subgroup, nodes &gt; nodes
</span><span class="noop">    (False, True, False)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _contentclass = None
</span><span class="noop">
</span><span class="hit">    def __init__(self, *values):
</span><span class="hit">        self.__dict__[&#39;_devices&#39;] = {}
</span><span class="hit">        self.__dict__[&#39;_shadowed_keywords&#39;] = set()
</span><span class="hit">        try:
</span><span class="hit">            self._extract_values(values)
</span><span class="hit">        except BaseException:
</span><span class="hit">            objecttools.augmentexcmessage(
</span><span class="noop">                &#39;While trying to initialize a `%s` object&#39;
</span><span class="noop">                % objecttools.classname(self))
</span><span class="noop">
</span><span class="hit">    def _extract_values(self, values):
</span><span class="hit">        for value in objecttools.extract(
</span><span class="noop">                        values, types=(self._contentclass, str), skip=True):
</span><span class="hit">            self.add_device(value)
</span><span class="noop">
</span><span class="hit">    def add_device(self, device):
</span><span class="noop">        &#34;&#34;&#34;Add the given :class:`Node` or :class:`Element` object.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import Nodes
</span><span class="noop">        &gt;&gt;&gt; nodes = Nodes(&#39;old_node&#39;)
</span><span class="noop">        &gt;&gt;&gt; nodes.add_device(&#39;new_node&#39;)
</span><span class="noop">        &gt;&gt;&gt; nodes
</span><span class="noop">        Nodes(&#34;new_node&#34;, &#34;old_node&#34;)
</span><span class="noop">
</span><span class="noop">        Note the implementation detail, that each new node knows the
</span><span class="noop">        object it was added to:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; nodes in nodes.new_node._handlers
</span><span class="noop">        True
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        device = self._contentclass(device)
</span><span class="hit">        self._devices[device.name] = device
</span><span class="hit">        device.add_handler(self)
</span><span class="noop">
</span><span class="hit">    def remove_device(self, device):
</span><span class="noop">        &#34;&#34;&#34;Remove the given :class:`Node` or :class:`Element` object.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import Node, Nodes
</span><span class="noop">        &gt;&gt;&gt; nodes = Nodes(&#39;node_x&#39;, &#39;node_y&#39;)
</span><span class="noop">        &gt;&gt;&gt; node_x, node_y = nodes
</span><span class="noop">        &gt;&gt;&gt; nodes.remove_device(&#39;node_y&#39;)
</span><span class="noop">        &gt;&gt;&gt; nodes
</span><span class="noop">        Nodes(&#34;node_x&#34;)
</span><span class="noop">
</span><span class="noop">        Note the implementation detail, that a new node forgots its
</span><span class="noop">        container object, after it has been removed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; nodes in node_x._handlers
</span><span class="noop">        True
</span><span class="noop">        &gt;&gt;&gt; nodes in node_y._handlers
</span><span class="noop">        False
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        device = self._contentclass(device)
</span><span class="hit">        try:
</span><span class="hit">            del self._devices[device.name]
</span><span class="hit">        except KeyError:
</span><span class="hit">            raise KeyError(
</span><span class="noop">                &#39;The selected %s object does not handle a %s object named &#39;
</span><span class="noop">                &#39;`%s`, which could be removed.&#39;
</span><span class="noop">                % (objecttools.classname(self),
</span><span class="noop">                   objecttools.classname(self._contentclass), device))
</span><span class="hit">        device.remove_handler(self)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def names(self):
</span><span class="noop">        &#34;&#34;&#34;A sorted tuple of the names of the handled devices.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">        &gt;&gt;&gt; dummies.nodes.names
</span><span class="noop">        (&#39;na&#39;, &#39;nb&#39;, &#39;nc&#39;, &#39;nd&#39;, &#39;ne&#39;)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return tuple(device.name for device in self)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def devices(self):
</span><span class="noop">        &#34;&#34;&#34;A tuple of the handled devices sorted by the device names.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">        &gt;&gt;&gt; tuple(device.name for device in dummies.nodes.devices)
</span><span class="noop">        (&#39;na&#39;, &#39;nb&#39;, &#39;nc&#39;, &#39;nd&#39;, &#39;ne&#39;)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return tuple(device for device in self)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def keywords(self):
</span><span class="noop">        &#34;&#34;&#34;A set of all keywords of all handled devices.
</span><span class="noop">
</span><span class="noop">        In addition to attribute access via device names described above,
</span><span class="noop">        :class:`Device` objects allow for attribute access via keywords.
</span><span class="noop">        This allows for an efficient search of certain groups of devices.
</span><span class="noop">        Lets use the example from above, where the nodes `na` and `nb`
</span><span class="noop">        have no keywords but each of the other three nodes both belongs
</span><span class="noop">        to either `group_a` or `group_b` and `group_1` or `group_2`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">        &gt;&gt;&gt; nodes = dummies.nodes
</span><span class="noop">        &gt;&gt;&gt; nodes
</span><span class="noop">        Nodes(&#34;na&#34;, &#34;nb&#34;, &#34;nc&#34;, &#34;nd&#34;, &#34;ne&#34;)
</span><span class="noop">        &gt;&gt;&gt; sorted(nodes.keywords)
</span><span class="noop">        [&#39;group_1&#39;, &#39;group_2&#39;, &#39;group_a&#39;, &#39;group_b&#39;]
</span><span class="noop">
</span><span class="noop">        If you are interesting in inspecting all nodes belonging to `group_a`,
</span><span class="noop">        build a selection:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; subgroup = nodes.group_1
</span><span class="noop">        &gt;&gt;&gt; subgroup
</span><span class="noop">        Nodes(&#34;nc&#34;, &#34;ne&#34;)
</span><span class="noop">
</span><span class="noop">        You can further restrict the search by also selecting the nodes also
</span><span class="noop">        belonging to `group_b`, which holds true for node `ne` only:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; subsubgroup = subgroup.group_b
</span><span class="noop">        &gt;&gt;&gt; subsubgroup
</span><span class="noop">        Nodes(&#34;ne&#34;)
</span><span class="noop">
</span><span class="noop">        Node that the keywords already used for building a subgroup of nodes
</span><span class="noop">        are no informative anymore (as they hold true for each node) and are
</span><span class="noop">        thus not shown anymore:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sorted(subgroup.keywords)
</span><span class="noop">        [&#39;group_a&#39;, &#39;group_b&#39;]
</span><span class="noop">        &gt;&gt;&gt; sorted(subsubgroup.keywords)
</span><span class="noop">        []
</span><span class="noop">
</span><span class="noop">        The latter might be confusing, if you intend to work with a subgroup
</span><span class="noop">        of nodes for a longer time.  After copying the subgroup, all keywords
</span><span class="noop">        of the contained devices are available again:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; newgroup = subsubgroup.copy()
</span><span class="noop">        &gt;&gt;&gt; sorted(newgroup.keywords)
</span><span class="noop">        [&#39;group_1&#39;, &#39;group_b&#39;]
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return set(keyword for device in self
</span><span class="noop">                   for keyword in device.keywords if
</span><span class="noop">                   keyword not in self._shadowed_keywords)
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Return a shallow copy of the actual :class:`Devices` instance.
</span><span class="noop">
</span><span class="noop">        Make a flat copy of the :class:`Nodes` object defined above:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">        &gt;&gt;&gt; old = dummies.nodes
</span><span class="noop">        &gt;&gt;&gt; import copy
</span><span class="noop">        &gt;&gt;&gt; new = copy.copy(old)
</span><span class="noop">
</span><span class="noop">        Show that the copy is not completely flat:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; new == old
</span><span class="noop">        True
</span><span class="noop">        &gt;&gt;&gt; new is old
</span><span class="noop">        False
</span><span class="noop">        &gt;&gt;&gt; new._devices is old._devices
</span><span class="noop">        False
</span><span class="noop">        &gt;&gt;&gt; new.na is new.na
</span><span class="noop">        True
</span><span class="noop">
</span><span class="noop">        The private variable `_devices` obviously has also been copied,
</span><span class="noop">        but not the device `na`.  Allowing also to copy devices like `na`
</span><span class="noop">        would be in conflict with using their names as identifiers.
</span><span class="noop">        For this reason deep copying :class:`Devices` objects is disabled:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; copy.deepcopy(dummies.nodes)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        NotImplementedError: Deep copying of Nodes objects is not supported, \
</span><span class="noop">as it would require to make deep copies of the Node objects themselves, \
</span><span class="noop">which is in conflict with using their names as identifiers.
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        new = type(self)()
</span><span class="hit">        new.__dict__.update(self.__dict__)
</span><span class="hit">        new.__dict__[&#39;_devices&#39;] = copy.copy(self._devices)
</span><span class="hit">        new.__dict__[&#39;_shadowed_keywords&#39;].clear()
</span><span class="hit">        for device in self:
</span><span class="hit">            device.add_handler(new)
</span><span class="hit">        return new
</span><span class="noop">
</span><span class="hit">    __copy__ = copy
</span><span class="noop">
</span><span class="hit">    def __deepcopy__(self, dict_):
</span><span class="hit">        classname = objecttools.classname(self)
</span><span class="hit">        raise NotImplementedError(
</span><span class="noop">            &#39;Deep copying of %s objects is not supported, as it would &#39;
</span><span class="noop">            &#39;require to make deep copies of the %s objects themselves, &#39;
</span><span class="noop">            &#39;which is in conflict with using their names as identifiers.&#39;
</span><span class="noop">            % (classname, classname[:-1]))
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for (name, device) in sorted(self._devices.items()):
</span><span class="hit">            yield device
</span><span class="noop">
</span><span class="hit">    def _select_devices_by_keyword(self, name):
</span><span class="hit">        devices = self.__class__(device for device in self if
</span><span class="noop">                                 name in device.keywords)
</span><span class="hit">        devices.__dict__[&#39;_shadowed_keywords&#39;] = self._shadowed_keywords.copy()
</span><span class="hit">        devices._shadowed_keywords.add(name)
</span><span class="hit">        return devices
</span><span class="noop">
</span><span class="hit">    def __getattr__(self, name):
</span><span class="hit">        try:
</span><span class="hit">            _devices = super(Devices, self).__getattribute__(&#39;_devices&#39;)
</span><span class="hit">            return _devices[name]
</span><span class="hit">        except KeyError:
</span><span class="hit">            pass
</span><span class="hit">        _devices = self._select_devices_by_keyword(name)
</span><span class="hit">        if len(_devices) &gt; 0:
</span><span class="hit">            return _devices
</span><span class="noop">        else:
</span><span class="hit">            raise AttributeError(
</span><span class="noop">                &#39;The selected %s object has neither a `%s` attribute &#39;
</span><span class="noop">                &#39;nor does it handle a %s object with name or keyword `%s`, &#39;
</span><span class="noop">                &#39;which could be returned.&#39;
</span><span class="noop">                % (objecttools.classname(self), name,
</span><span class="noop">                   objecttools.classname(self._contentclass), name))
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, name, value):
</span><span class="hit">        classname = objecttools.classname(self)
</span><span class="hit">        raise NotImplementedError(
</span><span class="noop">            &#39;Setting attributes of %s objects could result in confusion &#39;
</span><span class="noop">            &#39;whether a new attribute should be handled as a %s object or &#39;
</span><span class="noop">            &#39;as a &#34;normal&#34; attribute and is thus not support.&#39;
</span><span class="noop">            % (classname, classname[:-1]))
</span><span class="noop">
</span><span class="hit">    def __delattr__(self, name):
</span><span class="hit">        deleted_something = False
</span><span class="hit">        if name in vars(self):
</span><span class="miss">            super(Devices, self).__delattr__(name)
</span><span class="miss">            deleted_something = True
</span><span class="hit">        if name in self._devices:
</span><span class="hit">            self.remove_device(name)
</span><span class="hit">            deleted_something = True
</span><span class="hit">        if not deleted_something:
</span><span class="hit">            raise AttributeError(
</span><span class="noop">                &#39;The selected %s object has neither a `%s` attribute nor does &#39;
</span><span class="noop">                &#39;it handle a %s object named `%s`, which could be deleted.&#39;
</span><span class="noop">                % (objecttools.classname(self), name,
</span><span class="noop">                   objecttools.classname(self._contentclass), name))
</span><span class="noop">
</span><span class="hit">    def __contains__(self, device):
</span><span class="hit">        device = self._contentclass(device)
</span><span class="hit">        return device.name in self._devices
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return len(self._devices)
</span><span class="noop">
</span><span class="hit">    def __add__(self, values):
</span><span class="hit">        new = self.copy()
</span><span class="hit">        for device in self.__class__(values):
</span><span class="hit">            new.add_device(device)
</span><span class="hit">        return new
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, values):
</span><span class="hit">        for device in self.__class__(values):
</span><span class="hit">            self.add_device(device)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, values):
</span><span class="hit">        new = self.copy()
</span><span class="hit">        for device in self.__class__(values):
</span><span class="hit">            try:
</span><span class="hit">                new.remove_device(device)
</span><span class="hit">            except KeyError:
</span><span class="hit">                pass
</span><span class="hit">        return new
</span><span class="noop">
</span><span class="hit">    def __isub__(self, values):
</span><span class="hit">        for device in self.__class__(values):
</span><span class="hit">            try:
</span><span class="hit">                self.remove_device(device)
</span><span class="hit">            except KeyError:
</span><span class="hit">                pass
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="hit">        return set(self._devices.keys()) &lt; set(other._devices.keys())
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="hit">        return set(self._devices.keys()) &lt;= set(other._devices.keys())
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return set(self._devices.keys()) == set(other._devices.keys())
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        return set(self._devices.keys()) != set(other._devices.keys())
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="hit">        return set(self._devices.keys()) &gt;= set(other._devices.keys())
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="hit">        return set(self._devices.keys()) &gt; set(other._devices.keys())
</span><span class="noop">
</span><span class="hit">    def __hash__(self):
</span><span class="hit">        return id(self)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="hit">        with objecttools.repr_.preserve_strings(True):
</span><span class="hit">            with pub.options.ellipsis(2, optional=True):
</span><span class="hit">                prefix += &#39;%s(&#39; % objecttools.classname(self)
</span><span class="hit">                repr_ = objecttools.assignrepr_values(
</span><span class="noop">                                        self.names, prefix, width=70)
</span><span class="hit">                return repr_ + &#39;)&#39;
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="noop">        &#34;&#34;&#34;Just a regression test:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import assignrepr_values
</span><span class="noop">        &gt;&gt;&gt; print(assignrepr_values(dir(dummies.nodes), &#39;&#39;, 70))
</span><span class="noop">        add_device, assignrepr, copy, devices, group_1, group_2, group_a,
</span><span class="noop">        group_b, keywords, na, names, nb, nc, nd, ne, prepare_allseries,
</span><span class="noop">        prepare_obsseries, prepare_simseries, remove_device
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return objecttools.dir_(self) + list(self.names) + list(self.keywords)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Nodes(Devices):
</span><span class="noop">    &#34;&#34;&#34;A container for handling :class:`Node` objects.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _contentclass = Node
</span><span class="noop">
</span><span class="hit">    def prepare_allseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Call method :func:`~Node.prepare_allseries` of all handled
</span><span class="noop">        elements.&#34;&#34;&#34;
</span><span class="miss">        self.prepare_simseries(ramflag)
</span><span class="miss">        self.prepare_obsseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_simseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Call method :func:`~Node.prepare_simseries` of all handled
</span><span class="noop">        elements.&#34;&#34;&#34;
</span><span class="miss">        for node in self:
</span><span class="miss">            node.prepare_simseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_obsseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Call method :func:`~Node.prepare_obsseries` of all handled
</span><span class="noop">        elements.&#34;&#34;&#34;
</span><span class="miss">        for node in self:
</span><span class="miss">            node.prepare_obsseries(ramflag)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Elements(Devices):
</span><span class="noop">    &#34;&#34;&#34;A container for handling :class:`Element` objects.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _contentclass = Element
</span><span class="noop">
</span><span class="hit">    def prepare_allseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Call method :func:`~Element.prepare_allseries` of all handled
</span><span class="noop">        elements.&#34;&#34;&#34;
</span><span class="miss">        for element in self:
</span><span class="miss">            element.prepare_allseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_inputseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Call method :func:`~Element.prepare_inputseries` of all handled
</span><span class="noop">        elements.&#34;&#34;&#34;
</span><span class="miss">        for element in self:
</span><span class="miss">            element.prepare_inputseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_fluxseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Call method :func:`~Element.prepare_fluxseries` of all handled
</span><span class="noop">        elements.&#34;&#34;&#34;
</span><span class="miss">        for element in self:
</span><span class="miss">            element.prepare_fluxseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_stateseries(self, ramflag=True):
</span><span class="noop">        &#34;&#34;&#34;Call method :func:`~Element.prepare_stateseries` of all handled
</span><span class="noop">        elements.&#34;&#34;&#34;
</span><span class="miss">        for element in self:
</span><span class="miss">            element.prepare_stateseries(ramflag)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/dummytools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/dummytools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module is thought for easing doctests only.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import copy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Dummies(object):
</span><span class="noop">    &#34;&#34;&#34;Handles &#34;global&#34; doctest data.
</span><span class="noop">
</span><span class="noop">    A typical use pattern is to generated the instance of a class in the
</span><span class="noop">    main docstring of the class and to test the different class methods
</span><span class="noop">    based on this instance in seperate docstrings afterwards.
</span><span class="noop">
</span><span class="noop">    Class :class:`Dummies` tries to ensure that the original objects are
</span><span class="noop">    not altered due to performing different tests.  This protection
</span><span class="noop">    mechanism is successfull for the simple following test class:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; class Test(object):
</span><span class="noop">    ...
</span><span class="noop">    ...     def __init__(self):
</span><span class="noop">    ...         self.name = &#39;some_name&#39;
</span><span class="noop">    ...         self.values = [1, 2, 3]
</span><span class="noop">
</span><span class="noop">    As shown by the following results, neither the name nor the values of
</span><span class="noop">    `dummies.test` can be altered by changing the respective
</span><span class="noop">    attributes of the local object `test`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">    &gt;&gt;&gt; dummies.test = Test()
</span><span class="noop">    &gt;&gt;&gt; test = dummies.test
</span><span class="noop">    &gt;&gt;&gt; test.name = &#39;different_name&#39;
</span><span class="noop">    &gt;&gt;&gt; dummies.test.name
</span><span class="noop">    &#39;some_name&#39;
</span><span class="noop">    &gt;&gt;&gt; test.values[1] = 4
</span><span class="noop">    &gt;&gt;&gt; dummies.test.values
</span><span class="noop">    [1, 2, 3]
</span><span class="noop">
</span><span class="noop">    The show pretection mechanism is implemented via making &#34;deep copies&#34; of
</span><span class="noop">    objects handled by :class:`Dummies` objects.  So lets see what happens
</span><span class="noop">    when we subclass the test class and disable deep copying:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; class Test(Test):
</span><span class="noop">    ...
</span><span class="noop">    ...     def __deepcopy__(self, dict_):
</span><span class="noop">    ...         raise NotImplementedError()
</span><span class="noop">
</span><span class="noop">    Repeating the the above examples still shows that attribute `name` is
</span><span class="noop">    still protected but attribute `values` is not, meaning `test` is only
</span><span class="noop">    a flat copy of `dummies.test`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">    &gt;&gt;&gt; dummies.test = Test()
</span><span class="noop">    &gt;&gt;&gt; test = dummies.test
</span><span class="noop">    &gt;&gt;&gt; test.name = &#39;different_name&#39;
</span><span class="noop">    &gt;&gt;&gt; dummies.test.name
</span><span class="noop">    &#39;some_name&#39;
</span><span class="noop">    &gt;&gt;&gt; test.values[1] = 4
</span><span class="noop">    &gt;&gt;&gt; dummies.test.values
</span><span class="noop">    [1, 4, 3]
</span><span class="noop">
</span><span class="noop">    When we also disable flat copying, neither the name nor the values
</span><span class="noop">    of `dummies.test` are protected:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; class Test(Test):
</span><span class="noop">    ...
</span><span class="noop">    ...     def __copy__(self):
</span><span class="noop">    ...         raise NotImplementedError()
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import dummies
</span><span class="noop">    &gt;&gt;&gt; dummies.test = Test()
</span><span class="noop">    &gt;&gt;&gt; test = dummies.test
</span><span class="noop">    &gt;&gt;&gt; test.name = &#39;different_name&#39;
</span><span class="noop">    &gt;&gt;&gt; dummies.test.name
</span><span class="noop">    &#39;different_name&#39;
</span><span class="noop">    &gt;&gt;&gt; test.values[1] = 4
</span><span class="noop">    &gt;&gt;&gt; dummies.test.values
</span><span class="noop">    [1, 4, 3]
</span><span class="noop">
</span><span class="noop">    After each test of a complete module, the dummy object is empty again
</span><span class="noop">    (except for variable names starting with two underscores).
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def clear(self):
</span><span class="hit">        for name in list(vars(self)):
</span><span class="hit">            delattr(self, name)
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, name, value):
</span><span class="hit">        super(Dummies, self).__setattr__(&#39;_&#39;+name, value)
</span><span class="noop">
</span><span class="hit">    def __getattr__(self, name):
</span><span class="hit">        try:
</span><span class="hit">            obj = super(Dummies, self).__getattribute__(&#39;_&#39;+name)
</span><span class="hit">        except AttributeError:
</span><span class="hit">            raise AttributeError(&#39;Dummies object does not handle an object &#39;
</span><span class="noop">                                 &#39;named `%s` at the moment.&#39; % name)
</span><span class="hit">        try:
</span><span class="hit">            return copy.deepcopy(obj)
</span><span class="hit">        except BaseException:
</span><span class="hit">            pass
</span><span class="hit">        try:
</span><span class="hit">            return copy.copy(obj)
</span><span class="hit">        except BaseException:
</span><span class="hit">            pass
</span><span class="hit">        return obj
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/filetools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/filetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements tools for handling the folder structure
</span><span class="noop">of HydPy projects.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import sys
</span><span class="hit">import warnings
</span><span class="hit">import runpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy.core import selectiontools
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MainManager(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="miss">        self.info = {}
</span><span class="miss">        self.networkfile = None
</span><span class="miss">        self.controlfiles = None
</span><span class="miss">        self.sequencefiles = None
</span><span class="miss">        self.initialvaluefiles = None
</span><span class="miss">        self.parameterfiles = None
</span><span class="miss">        try:
</span><span class="miss">            self.checkpath()
</span><span class="miss">        except IOError:
</span><span class="miss">            pass
</span><span class="noop">        else:
</span><span class="miss">            self.loadinfo()
</span><span class="miss">            self.applyinfo()
</span><span class="miss">            self.clearinfo()
</span><span class="noop">
</span><span class="hit">    def _getpath(self):
</span><span class="miss">        return os.path.abspath(pub.projectname+&#39;.py&#39;)
</span><span class="hit">    path = property(_getpath)
</span><span class="noop">
</span><span class="hit">    def checkpath(self):
</span><span class="miss">        if not os.path.exists(self.path):
</span><span class="miss">            raise IOError(&#39;The required project main file `%s` does not exist.&#39;
</span><span class="noop">                          % self.path)
</span><span class="noop">
</span><span class="hit">    def loadinfo(self):
</span><span class="noop">        &#34;&#34;&#34;Load general information from the project&#39;s main file.&#34;&#34;&#34;
</span><span class="miss">        try:
</span><span class="miss">            with open(self.path) as file_:
</span><span class="miss">                code = compile(file_.read(), self.path, &#39;exec&#39;)
</span><span class="miss">                exec(code, {}, self.info)
</span><span class="miss">        except Exception:
</span><span class="miss">            prefix = (&#39;While trying to load the general project settings &#39;
</span><span class="noop">                      &#39;from `%s`&#39; % self.path)
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span><span class="noop">
</span><span class="hit">    def clearinfo(self):
</span><span class="miss">        self.info = {}
</span><span class="noop">
</span><span class="hit">    def applyinfo(self):
</span><span class="miss">        self.timegrids2pub()
</span><span class="miss">        self.getmanagers()
</span><span class="noop">
</span><span class="hit">    def timegrids2pub(self):
</span><span class="miss">        selection = [value for value in self.info.values()
</span><span class="noop">                     if isinstance(value, timetools.Timegrids)]
</span><span class="miss">        if len(selection) != 1:
</span><span class="miss">            print(self.info)
</span><span class="miss">            raise ImportError(&#39;The main project file `%s` must define exactly &#39;
</span><span class="noop">                              &#39;1 `Timegrids` object; %d objects are defined &#39;
</span><span class="noop">                              &#39;instead.&#39; % (self.path, len(selection)))
</span><span class="noop">        else:
</span><span class="miss">            pub.timegrids = selection[0]
</span><span class="noop">
</span><span class="hit">    def getmanagers(self):
</span><span class="miss">        for FileClass in (NetworkManager, ControlManager,
</span><span class="noop">                          SequenceManager, ConditionManager):
</span><span class="miss">            selection = [value for value in self.info.values()
</span><span class="noop">                         if isinstance(value, FileClass)]
</span><span class="miss">            if len(selection) &gt; 1:
</span><span class="miss">                raise ImportError(&#39;The main project file `%s` must not define &#39;
</span><span class="noop">                                  &#39;more then one `%s` objects but %d objects &#39;
</span><span class="noop">                                  &#39;are defined.&#39;
</span><span class="noop">                                  % (self.path, FileClass.__name__,
</span><span class="noop">                                     len(selection)))
</span><span class="miss">            elif len(selection) == 1:
</span><span class="miss">                setattr(self, FileClass.__name__.lower(), selection[0])
</span><span class="noop">            else:
</span><span class="miss">                setattr(self, FileClass.__name__.lower(), FileClass())
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NetworkManager(object):
</span><span class="noop">    &#34;&#34;&#34;Manager for network files.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="miss">        self._BASEDIRECTORY = &#39;network&#39;
</span><span class="miss">        self.directory = pub.projectname
</span><span class="noop">
</span><span class="hit">    def _getbasepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path pointing to all network directories.&#34;&#34;&#34;
</span><span class="miss">        return os.path.abspath(self._BASEDIRECTORY)
</span><span class="noop">
</span><span class="hit">    basepath = property(_getbasepath)
</span><span class="noop">
</span><span class="hit">    def _getdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;Directory containing the network files.&#34;&#34;&#34;
</span><span class="miss">        return self._subdirectory
</span><span class="noop">
</span><span class="hit">    def _setdirectory(self, subdirectory):
</span><span class="miss">        directory = os.path.join(self.basepath, subdirectory)
</span><span class="miss">        if not os.path.exists(directory):
</span><span class="miss">            raise IOError(&#39;A directory `%s` within the network base path &#39;
</span><span class="noop">                          &#39;`%s` does not exist.&#39;
</span><span class="noop">                          % (subdirectory, self.basepath))
</span><span class="miss">        self._subdirectory = str(subdirectory)
</span><span class="noop">
</span><span class="hit">    directory = property(_getdirectory, _setdirectory)
</span><span class="noop">
</span><span class="hit">    def _getdirpath(self):
</span><span class="noop">        &#34;&#34;&#34;Complete path of the directory containing the network files.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.basepath, self.directory)
</span><span class="noop">
</span><span class="hit">    dirpath = property(_getdirpath)
</span><span class="noop">
</span><span class="hit">    def _getfilenames(self):
</span><span class="noop">        &#34;&#34;&#34;Names of the network files.&#34;&#34;&#34;
</span><span class="miss">        return [fn for fn in os.listdir(self.dirpath)
</span><span class="noop">                if (fn.endswith(&#39;.py&#39;) and not fn.startswith(&#39;_&#39;))]
</span><span class="noop">
</span><span class="hit">    filenames = property(_getfilenames)
</span><span class="noop">
</span><span class="hit">    def _getfilepaths(self):
</span><span class="noop">        &#34;&#34;&#34;Complete paths of the defined networks files.&#34;&#34;&#34;
</span><span class="miss">        root = os.path.join(self.basepath, self.directory)
</span><span class="miss">        return [os.path.join(root, fn) for fn in self.filenames]
</span><span class="noop">
</span><span class="hit">    filepaths = property(_getfilepaths)
</span><span class="noop">
</span><span class="hit">    def load(self):
</span><span class="noop">        &#34;&#34;&#34;Load nodes and elements from all network files and return them in
</span><span class="noop">        a :class:`~hydpy.selectiontools.Selections` instance.  Each single
</span><span class="noop">        network file defines a seperate
</span><span class="noop">        :class:`~hydpy.selectiontools.Selection` instance.  Additionally, all
</span><span class="noop">        elements and nodes are bundled in a selection named `complete`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        selections = selectiontools.Selections()
</span><span class="miss">        for (filename, path) in zip(self.filenames, self.filepaths):
</span><span class="noop">            # Ensure both `Node` and `Element`start with a `fresh` memory.
</span><span class="miss">            devicetools.Node.gather_new_nodes()
</span><span class="miss">            devicetools.Element.gather_new_elements()
</span><span class="miss">            try:
</span><span class="miss">                info = runpy.run_path(path)
</span><span class="miss">            except Exception:
</span><span class="miss">                prefix = &#39;While trying to load the network file `%s`&#39; % path
</span><span class="miss">                objecttools.augmentexcmessage(prefix)
</span><span class="miss">            try:
</span><span class="miss">                selections += selectiontools.Selection(
</span><span class="noop">                                    filename.split(&#39;.&#39;)[0],
</span><span class="noop">                                    info[&#39;Node&#39;].gather_new_nodes(),
</span><span class="noop">                                    info[&#39;Element&#39;].gather_new_elements())
</span><span class="noop">
</span><span class="miss">            except KeyError as exc:
</span><span class="miss">                KeyError(&#39;The class `%s` cannot be loaded from the network &#39;
</span><span class="noop">                         &#39;file `%s`.  Please refer to the HydPy documentation &#39;
</span><span class="noop">                         &#39;on how to prepare network files properly.&#39;
</span><span class="noop">                         % (exc.args[0], filename))
</span><span class="miss">        selections += selectiontools.Selection(
</span><span class="noop">                                    &#39;complete&#39;,
</span><span class="noop">                                    info[&#39;Node&#39;].registered_nodes(),
</span><span class="noop">                                    info[&#39;Element&#39;].registered_elements())
</span><span class="miss">        return selections
</span><span class="noop">
</span><span class="hit">    def save(self, selections, overwrite=False):
</span><span class="noop">        &#34;&#34;&#34;Save the nodes and elements from each
</span><span class="noop">        :class:`~hydpy.selectiontools.Selection` object contained within the
</span><span class="noop">        given :class:`~hydpy.selectiontools.Selections` instance to a seperate
</span><span class="noop">        network file of the same name.  Set `overwrite` to `True`, if you
</span><span class="noop">        want to overwrite already existing network files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        selections = selectiontools.Selections(selections)
</span><span class="miss">        for selection in selections:
</span><span class="miss">            if selection.name == &#39;complete&#39;:
</span><span class="miss">                continue
</span><span class="miss">            path = os.path.join(self.dirpath, selection.name+&#39;.py&#39;)
</span><span class="miss">            if os.path.exists(path) and not overwrite:
</span><span class="miss">                warnings.warn(&#39;The path `%s` does already exist, selection &#39;
</span><span class="noop">                              &#39;`%s` cannot be saved.  Please select another &#39;
</span><span class="noop">                              &#39;network directory or set the `overwrite` flag &#39;
</span><span class="noop">                              &#39;to `True`&#39; % (path, selection.name))
</span><span class="noop">            else:
</span><span class="miss">                selection.save(path)
</span><span class="noop">
</span><span class="hit">    def delete(self, *selections):
</span><span class="noop">        &#34;&#34;&#34;Delete network files.  One or more filenames and/or
</span><span class="noop">        :class:`~hydpy.selectiontools.Selection` instances can serve as
</span><span class="noop">        function arguments.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        for selection in selections:
</span><span class="miss">            name = str(selection)
</span><span class="miss">            if not name.endswith(&#39;.py&#39;):
</span><span class="miss">                name += &#39;.py&#39;
</span><span class="miss">            path = os.path.join(self.dirpath, name)
</span><span class="miss">            try:
</span><span class="miss">                os.remove(path)
</span><span class="miss">            except EnvironmentError:
</span><span class="miss">                exception, message = sys.exc_info()[:2]
</span><span class="miss">                exception = str(exception)[:-2].split(&#39;.&#39;)[-1]
</span><span class="miss">                warnings.warn(&#39;: &#39;.join((exception, str(message))))
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlManager(object):
</span><span class="noop">    &#34;&#34;&#34;Manager for control parameter files.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">    # The following file path to content mapping is used to circumvent reading
</span><span class="noop">    # the same secondary control parameter file from disk multiple times.
</span><span class="hit">    _registry = {}
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="miss">        self._BASEDIRECTORY = &#39;control&#39;
</span><span class="miss">        self._projectdirectory = pub.projectname
</span><span class="miss">        self._controldirectory = None
</span><span class="noop">
</span><span class="hit">    def _getbasepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path pointing to all control directories.&#34;&#34;&#34;
</span><span class="miss">        return os.path.abspath(self._BASEDIRECTORY)
</span><span class="noop">
</span><span class="hit">    basepath = property(_getbasepath)
</span><span class="noop">
</span><span class="hit">    def _getprojectdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;Folder containing the control directories of the current project.&#34;&#34;&#34;
</span><span class="miss">        return self._projectdirectory
</span><span class="noop">
</span><span class="hit">    def _setprojectdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        directory = os.path.join(self.basepath, directory)
</span><span class="miss">        if not os.path.exists(directory):
</span><span class="miss">            raise IOError(&#39;Path `%s` does not contain a control directory &#39;
</span><span class="noop">                          &#39;named `%s`.&#39; % (self.basepath, directory))
</span><span class="miss">        self._projectdirectory = directory
</span><span class="noop">
</span><span class="hit">    projectdirectory = property(_getprojectdirectory, _setprojectdirectory)
</span><span class="noop">
</span><span class="hit">    def _getprojectpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the project directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.basepath, self.projectdirectory)
</span><span class="noop">
</span><span class="hit">    projectpath = property(_getprojectpath)
</span><span class="noop">
</span><span class="hit">    def _getcontroldirectories(self):
</span><span class="noop">        &#34;&#34;&#34;Folders containing the control files of different parameter sets.&#34;&#34;&#34;
</span><span class="miss">        directories = FolderShow()
</span><span class="miss">        for directory in os.listdir(self.projectpath):
</span><span class="miss">            if not directory.startswith(&#39;_&#39;):
</span><span class="miss">                path = os.path.join(self.projectpath, directory)
</span><span class="miss">                if os.path.isdir(path):
</span><span class="miss">                    directories.add(directory)
</span><span class="miss">        return directories
</span><span class="noop">
</span><span class="hit">    controldirectories = property(_getcontroldirectories)
</span><span class="noop">
</span><span class="hit">    def _getcontrolpaths(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the control directories.&#34;&#34;&#34;
</span><span class="miss">        paths = FolderShow()
</span><span class="miss">        for (directory, dummy) in self.controldirectories:
</span><span class="miss">            paths.add(directory, os.path.join(self.projectpath, directory))
</span><span class="miss">        return paths
</span><span class="noop">
</span><span class="hit">    controlpaths = property(_getcontrolpaths)
</span><span class="noop">
</span><span class="hit">    def _getcontroldirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) control directory&#34;&#34;&#34;
</span><span class="miss">        directories = self.controldirectories
</span><span class="miss">        if self._controldirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._controldirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified control directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._controldirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;control directories.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            return directories.default
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple control&#39;
</span><span class="noop">                          &#39;directories, but none is named `default`.  &#39;
</span><span class="noop">                          &#39;Please specify the control directory to be &#39;
</span><span class="noop">                          &#39;worked with manually.&#39; % self.projectpath)
</span><span class="noop">
</span><span class="hit">    def _setcontroldirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._controldirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain a &#39;
</span><span class="noop">                          &#39;control directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _delcontroldirectory(self):
</span><span class="miss">        self._controldirectory = None
</span><span class="noop">
</span><span class="hit">    controldirectory = property(_getcontroldirectory, _setcontroldirectory,
</span><span class="noop">                                _delcontroldirectory)
</span><span class="noop">
</span><span class="hit">    def _getcontrolpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected control directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.controldirectory)
</span><span class="noop">
</span><span class="hit">    controlpath = property(_getcontrolpath)
</span><span class="noop">
</span><span class="hit">    def loadfile(self, element=None, filename=None):
</span><span class="noop">        &#34;&#34;&#34;Return the namespace of the given file (and eventually of its
</span><span class="noop">        subfile) as a :class:`dict`.
</span><span class="noop">
</span><span class="noop">        At least one of the following arguments must be given:
</span><span class="noop">            * element (:class:`~hydpy.core.devicetools.Element`): The element
</span><span class="noop">              one wants the model to be connected with.
</span><span class="noop">            * filename (:class:`str`): Any object returning a valid filename
</span><span class="noop">              with or without extension.  If not given, the element&#39;s name
</span><span class="noop">              is applied.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        workingpath = os.path.abspath(os.curdir)
</span><span class="miss">        try:
</span><span class="miss">            os.chdir(self.controlpath)
</span><span class="miss">        except OSError:
</span><span class="miss">            raise IOError(&#39;The specified control path `%s` does not exist.&#39;
</span><span class="noop">                          % self.controlpath)
</span><span class="noop">        else:
</span><span class="miss">            if element is not None:
</span><span class="miss">                info = {&#39;element&#39;: element}
</span><span class="miss">                if filename is None:
</span><span class="miss">                    filename = element.name
</span><span class="noop">            else:
</span><span class="miss">                info = {}
</span><span class="miss">            self.read2dict(filename, info)
</span><span class="miss">            return info
</span><span class="noop">        finally:
</span><span class="miss">            self._registry.clear()
</span><span class="miss">            os.chdir(workingpath)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def read2dict(cls, path, info):
</span><span class="noop">        &#34;&#34;&#34;Reads the control parameters of the given path (and its subpaths
</span><span class="noop">        where appropriate) and stores it in the given :class:`dict` `info`.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * path (:class:`str`): Any object returning a valid path
</span><span class="noop">              with or without extension.
</span><span class="noop">            * info (:class:`dict`): Target dictionary.
</span><span class="noop">
</span><span class="noop">        Note that the :class:`dict` `info` can be used to feed information
</span><span class="noop">        into the execution of control files.  Use this function only if you
</span><span class="noop">        are completely sure on how the control parameter import of HydPy
</span><span class="noop">        works.  Otherwise, you should most probably prefer to use
</span><span class="noop">        :func:`loadfile` or :func:`loadfiles`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        path = str(path)
</span><span class="miss">        if not path.endswith(&#39;.py&#39;):
</span><span class="miss">            path += &#39;.py&#39;
</span><span class="miss">        try:
</span><span class="miss">            if path not in cls._registry:
</span><span class="miss">                with open(path) as file_:
</span><span class="miss">                    cls._registry[path] = file_.read()
</span><span class="miss">            exec(cls._registry[path], {}, info)
</span><span class="miss">        except BaseException:
</span><span class="miss">            prefix = &#39;While trying to load the control file `%s`&#39; % path
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span><span class="miss">        if &#39;model&#39; not in info:
</span><span class="miss">            raise IOError(&#39;Model parameters cannot be loaded from control &#39;
</span><span class="noop">                          &#39;file `%s`.  Please refer to the HydPy &#39;
</span><span class="noop">                          &#39;documentation on how to prepare control files &#39;
</span><span class="noop">                          &#39;properly.&#39; % path)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FolderShow(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self, *args, **kwargs):
</span><span class="miss">        for arg in args:
</span><span class="miss">            self.add(arg)
</span><span class="miss">        for (key, value) in kwargs.items():
</span><span class="miss">            self.add(key, value)
</span><span class="noop">
</span><span class="hit">    def add(self, directory, path=None):
</span><span class="miss">        if path is None:
</span><span class="miss">            path = directory
</span><span class="miss">        try:
</span><span class="miss">            exec(&#39;self.%s = r&#34;%s&#34;&#39; % (directory, path))
</span><span class="miss">        except BaseException:
</span><span class="miss">            raise IOError(&#39;The directory name `%s` cannot be handled as a &#39;
</span><span class="noop">                          &#39;variable name.  Please avoid arithmetic operators &#39;
</span><span class="noop">                          &#39;like `-`, prefixed numbers...&#39; % directory)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        return vars(self).items()
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="miss">        return sorted(vars(self).values())[key]
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="miss">        return len(vars(self))
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        if not len(self):
</span><span class="miss">            return &#39;Folders()&#39;
</span><span class="noop">        else:
</span><span class="miss">            args, kwargs = [], []
</span><span class="miss">            for (idx, (key, value)) in enumerate(self):
</span><span class="miss">                if key == value:
</span><span class="miss">                    args.append(key)
</span><span class="noop">                else:
</span><span class="miss">                    kwargs.append(&#39;%s=%s&#39; % (key, value))
</span><span class="miss">            lines = [&#39;           %s,&#39; % arg for arg in (args + kwargs)]
</span><span class="miss">            lines[0] = &#39;FolderShow(&#39; + lines[0][11:]
</span><span class="miss">            lines[-1] = lines[-1][:-1] + &#39;)&#39;
</span><span class="miss">            return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SequenceManager(object):
</span><span class="noop">    &#34;&#34;&#34;Manager for sequence files.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _supportedmodes = (&#39;npy&#39;, &#39;asc&#39;)
</span><span class="noop">
</span><span class="hit">    def __init__(self, projectdirectory=None, inputdirectory=None,
</span><span class="noop">                 outputdirectory=None, nodedirectory=None, tempdirectory=None,
</span><span class="noop">                 inputfiletype=None, outputfiletype=None, nodefiletype=None):
</span><span class="hit">        self._BASEDIRECTORY = &#39;sequences&#39;
</span><span class="hit">        if projectdirectory:
</span><span class="miss">            self.projectdirectory = projectdirectory
</span><span class="noop">        else:
</span><span class="hit">            self._projectdirectory = pub.projectname
</span><span class="hit">        if inputdirectory:
</span><span class="miss">            self.inputdirectory = inputdirectory
</span><span class="noop">        else:
</span><span class="hit">            self._inputdirectory = None
</span><span class="hit">        if outputdirectory:
</span><span class="miss">            self.outputdirectory = outputdirectory
</span><span class="noop">        else:
</span><span class="hit">            self._outputdirectory = None
</span><span class="hit">        if nodedirectory:
</span><span class="miss">            self.nodedirectory = nodedirectory
</span><span class="noop">        else:
</span><span class="hit">            self._nodedirectory = None
</span><span class="hit">        if tempdirectory:
</span><span class="miss">            self.tempdirectory = tempdirectory
</span><span class="noop">        else:
</span><span class="hit">            self._tempdirectory = None
</span><span class="hit">        if inputfiletype:
</span><span class="miss">            self.inputfiletype = inputfiletype
</span><span class="noop">        else:
</span><span class="hit">            self._inputfiletype = &#39;npy&#39;
</span><span class="hit">        if outputfiletype:
</span><span class="miss">            self.outputfiletype = outputfiletype
</span><span class="noop">        else:
</span><span class="hit">            self._outputfiletype = &#39;npy&#39;
</span><span class="hit">        if outputfiletype:
</span><span class="miss">            self.outputfiletype = outputfiletype
</span><span class="noop">        else:
</span><span class="hit">            self._outputfiletype = &#39;npy&#39;
</span><span class="hit">        if nodefiletype:
</span><span class="miss">            self.nodefiletype = nodefiletype
</span><span class="noop">        else:
</span><span class="hit">            self._nodefiletype = &#39;npy&#39;
</span><span class="hit">        self._inputoverwrite = False
</span><span class="hit">        self._outputoverwrite = False
</span><span class="hit">        self._simoverwrite = False
</span><span class="hit">        self._obsoverwrite = False
</span><span class="noop">
</span><span class="hit">    def _getbasepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path pointing to all sequence directories.&#34;&#34;&#34;
</span><span class="miss">        return os.path.abspath(self._BASEDIRECTORY)
</span><span class="hit">    basepath = property(_getbasepath)
</span><span class="noop">
</span><span class="hit">    def _getprojectdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;Folder containing the file directories of the current project.&#34;&#34;&#34;
</span><span class="miss">        return self._projectdirectory
</span><span class="noop">
</span><span class="hit">    def _setprojectdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        directory = os.path.join(self.basepath, directory)
</span><span class="miss">        if not os.path.exists(directory):
</span><span class="miss">            raise IOError(&#39;Path `%s` does not contain a directory named `%s`.&#39;
</span><span class="noop">                          % (self.basepath, directory))
</span><span class="miss">        self._projectdirectory = directory
</span><span class="noop">
</span><span class="hit">    projectdirectory = property(_getprojectdirectory, _setprojectdirectory)
</span><span class="noop">
</span><span class="hit">    def _getprojectpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the project directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.basepath, self.projectdirectory)
</span><span class="noop">
</span><span class="hit">    projectpath = property(_getprojectpath)
</span><span class="noop">
</span><span class="hit">    def _getsequencedirectories(self):
</span><span class="noop">        &#34;&#34;&#34;Folders containing the different input/output/temp sequences.&#34;&#34;&#34;
</span><span class="miss">        directories = FolderShow()
</span><span class="miss">        for directory in os.listdir(self.projectpath):
</span><span class="miss">            if not directory.startswith(&#39;_&#39;):
</span><span class="miss">                path = os.path.join(self.projectpath, directory)
</span><span class="miss">                if os.path.isdir(path):
</span><span class="miss">                    directories.add(directory)
</span><span class="miss">        return directories
</span><span class="noop">
</span><span class="hit">    sequencedirectories = property(_getsequencedirectories)
</span><span class="noop">
</span><span class="hit">    def _getsequencepaths(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the sequence directories.&#34;&#34;&#34;
</span><span class="miss">        paths = FolderShow()
</span><span class="miss">        for (key, value) in self.sequencedirectories:
</span><span class="miss">            paths.add(key, os.path.join(self.projectpath, key))
</span><span class="miss">        return paths
</span><span class="noop">
</span><span class="hit">    sequencepaths = property(_getsequencepaths)
</span><span class="noop">
</span><span class="hit">    def _getinputdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) input sequence directory.&#34;&#34;&#34;
</span><span class="miss">        directories = self.sequencedirectories
</span><span class="miss">        if self._inputdirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._inputdirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified input sequence directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._inputdirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;sequence directories.&#39; % self.projectpath)
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return directories.input
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` contains multiple &#39;
</span><span class="noop">                              &#39;sequence directories, but none is named &#39;
</span><span class="noop">                              &#39;`input`.  Please specify the input sequence &#39;
</span><span class="noop">                              &#39;directory to be worked with manually.&#39;
</span><span class="noop">                              % self.projectpath)
</span><span class="noop">
</span><span class="hit">    def _setinputdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._inputdirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain sequence &#39;
</span><span class="noop">                          &#39;directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _delinputdirectory(self):
</span><span class="miss">        self._inputdirectory = None
</span><span class="noop">
</span><span class="hit">    inputdirectory = property(_getinputdirectory, _setinputdirectory,
</span><span class="noop">                              _delinputdirectory)
</span><span class="noop">
</span><span class="hit">    def _getoutputdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) output sequence directory.&#34;&#34;&#34;
</span><span class="miss">        directories = self.sequencedirectories
</span><span class="miss">        if self._outputdirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._outputdirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified output sequence directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._outputdirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;sequence directories.&#39; % self.projectpath)
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return directories.output
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` contains multiple &#39;
</span><span class="noop">                              &#39;sequence directories, but none is named &#39;
</span><span class="noop">                              &#39;`output`.  Please specify the sequence &#39;
</span><span class="noop">                              &#39;directory to be worked with manually.&#39;
</span><span class="noop">                              % self.projectpath)
</span><span class="noop">
</span><span class="hit">    def _setoutputdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._outputdirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain sequence &#39;
</span><span class="noop">                          &#39;directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _deloutputdirectory(self):
</span><span class="miss">        self._outputdirectory = None
</span><span class="noop">
</span><span class="hit">    outputdirectory = property(_getoutputdirectory, _setoutputdirectory,
</span><span class="noop">                               _deloutputdirectory)
</span><span class="noop">
</span><span class="hit">    def _getnodedirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) node sequence directory.&#34;&#34;&#34;
</span><span class="miss">        directories = self.sequencedirectories
</span><span class="miss">        if self._nodedirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._nodedirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified node sequence directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._nodedirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;sequence directories.&#39; % self.projectpath)
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return directories.node
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` contains multiple &#39;
</span><span class="noop">                              &#39;sequence directories, but none is named &#39;
</span><span class="noop">                              &#39;`node`.  Please specify the node sequence &#39;
</span><span class="noop">                              &#39;directory to be worked with manually.&#39;
</span><span class="noop">                              % self.projectpath)
</span><span class="noop">
</span><span class="hit">    def _setnodedirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._nodedirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain sequence &#39;
</span><span class="noop">                          &#39;directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _delnodedirectory(self):
</span><span class="miss">        self._nodedirectory = None
</span><span class="noop">
</span><span class="hit">    nodedirectory = property(_getnodedirectory, _setnodedirectory,
</span><span class="noop">                             _delnodedirectory)
</span><span class="noop">
</span><span class="hit">    def _gettempdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) temporary sequence directory.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        directories = self.sequencedirectories
</span><span class="miss">        if self._tempdirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._tempdirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified temporary sequence directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._tempdirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;sequence directories.&#39; % self.projectpath)
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return directories.temp
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` contains multiple &#39;
</span><span class="noop">                              &#39;sequence directories, but none is named &#39;
</span><span class="noop">                              &#39;`temp`.  Please specify the temporary sequence &#39;
</span><span class="noop">                              &#39;directory to be worked with manually.&#39;
</span><span class="noop">                              % self.projectpath)
</span><span class="noop">
</span><span class="hit">    def _settempdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._tempdirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain sequence &#39;
</span><span class="noop">                          &#39;directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _deltempdirectory(self):
</span><span class="miss">        self._tempdirectory = None
</span><span class="noop">
</span><span class="hit">    tempdirectory = property(_gettempdirectory, _settempdirectory,
</span><span class="noop">                             _deltempdirectory)
</span><span class="noop">
</span><span class="hit">    def _getinputpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected input sequence directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.inputdirectory)
</span><span class="hit">    inputpath = property(_getinputpath)
</span><span class="noop">
</span><span class="hit">    def _getoutputpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected output sequence directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.outputdirectory)
</span><span class="hit">    outputpath = property(_getoutputpath)
</span><span class="noop">
</span><span class="hit">    def _getnodepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected node sequence directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.nodedirectory)
</span><span class="hit">    nodepath = property(_getnodepath)
</span><span class="noop">
</span><span class="hit">    def _gettemppath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected temporary sequence directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.tempdirectory)
</span><span class="noop">
</span><span class="hit">    temppath = property(_gettemppath)
</span><span class="noop">
</span><span class="hit">    def _getinputfiletype(self):
</span><span class="noop">        &#34;&#34;&#34;File type of the external input files.&#34;&#34;&#34;
</span><span class="miss">        return self._inputfiletype
</span><span class="noop">
</span><span class="hit">    def _setinputfiletype(self, inputfiletype):
</span><span class="miss">        inputfiletype = str(inputfiletype)
</span><span class="miss">        if inputfiletype in self._supportedmodes:
</span><span class="miss">            self._inputfiletype = inputfiletype
</span><span class="noop">        else:
</span><span class="miss">            raise NotImplementedError(&#39;The given input file type `%s` is not &#39;
</span><span class="noop">                                      &#39;implemented yet.  Please choose one &#39;
</span><span class="noop">                                      &#39;of the following file types: %s.&#39;
</span><span class="noop">                                      % (inputfiletype, self._supportedmodes))
</span><span class="noop">
</span><span class="hit">    inputfiletype = property(_getinputfiletype, _setinputfiletype)
</span><span class="noop">
</span><span class="hit">    def _getoutputfiletype(self):
</span><span class="noop">        &#34;&#34;&#34;File type of the external output files.&#34;&#34;&#34;
</span><span class="miss">        return self._outputfiletype
</span><span class="noop">
</span><span class="hit">    def _setoutputfiletype(self, outputfiletype):
</span><span class="hit">        outputfiletype = str(outputfiletype)
</span><span class="hit">        if outputfiletype in self._supportedmodes:
</span><span class="miss">            self._outputfiletype = outputfiletype
</span><span class="noop">        else:
</span><span class="hit">            raise NotImplementedError(&#39;The given output file type `%s` is not &#39;
</span><span class="noop">                                      &#39;implemented yet.  Please choose one &#39;
</span><span class="noop">                                      &#39;of the following file types: %s.&#39;
</span><span class="noop">                                      % (outputfiletype, self._supportedmodes))
</span><span class="noop">
</span><span class="hit">    outputfiletype = property(_getoutputfiletype, _setoutputfiletype)
</span><span class="noop">
</span><span class="hit">    def _getnodefiletype(self):
</span><span class="noop">        &#34;&#34;&#34;File type of the external node files.&#34;&#34;&#34;
</span><span class="miss">        return self._nodefiletype
</span><span class="noop">
</span><span class="hit">    def _setnodefiletype(self, nodefiletype):
</span><span class="miss">        nodefiletype = str(nodefiletype)
</span><span class="miss">        if nodefiletype in self._supportedmodes:
</span><span class="miss">            self._nodefiletype = nodefiletype
</span><span class="noop">        else:
</span><span class="miss">            raise NotImplementedError(&#39;The given node file type `%s` is not &#39;
</span><span class="noop">                                      &#39;implemented yet.  Please choose one &#39;
</span><span class="noop">                                      &#39;of the following file types: %s.&#39;
</span><span class="noop">                                      % (nodefiletype, self._supportedmodes))
</span><span class="noop">
</span><span class="hit">    nodefiletype = property(_getnodefiletype, _setnodefiletype)
</span><span class="noop">
</span><span class="hit">    def _getinputoverwrite(self):
</span><span class="miss">        return self._inputoverwrite
</span><span class="noop">
</span><span class="hit">    def _setinputoverwrite(self, value):
</span><span class="miss">        self._inputoverwrite = bool(value)
</span><span class="noop">
</span><span class="hit">    inputoverwrite = property(_getinputoverwrite, _setinputoverwrite)
</span><span class="noop">
</span><span class="hit">    def _getoutputoverwrite(self):
</span><span class="miss">        return self._outputoverwrite
</span><span class="noop">
</span><span class="hit">    def _setoutputoverwrite(self, value):
</span><span class="miss">        self._outputoverwrite = bool(value)
</span><span class="noop">
</span><span class="hit">    outputoverwrite = property(_getoutputoverwrite, _setoutputoverwrite)
</span><span class="noop">
</span><span class="hit">    def _getsimoverwrite(self):
</span><span class="miss">        return self._simoverwrite
</span><span class="noop">
</span><span class="hit">    def _setsimoverwrite(self, value):
</span><span class="miss">        self._simoverwrite = bool(value)
</span><span class="noop">
</span><span class="hit">    simoverwrite = property(_getsimoverwrite, _setsimoverwrite)
</span><span class="noop">
</span><span class="hit">    def _getobsoverwrite(self):
</span><span class="miss">        return self._obsoverwrite
</span><span class="noop">
</span><span class="hit">    def _setobsoverwrite(self, value):
</span><span class="miss">        self._obsoverwrite = bool(value)
</span><span class="noop">
</span><span class="hit">    obsoverwrite = property(_getobsoverwrite, _setobsoverwrite)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ConditionManager(object):
</span><span class="noop">    &#34;&#34;&#34;Manager for condition files.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="miss">        self._BASEDIRECTORY = &#39;conditions&#39;
</span><span class="miss">        self._projectdirectory = pub.projectname
</span><span class="miss">        self._loaddirectory = None
</span><span class="miss">        self._savedirectory = None
</span><span class="noop">
</span><span class="hit">    def _getbasepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path pointing to all condition directories.&#34;&#34;&#34;
</span><span class="miss">        return os.path.abspath(self._BASEDIRECTORY)
</span><span class="noop">
</span><span class="hit">    basepath = property(_getbasepath)
</span><span class="noop">
</span><span class="hit">    def _getprojectdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;Folder containing the condition directories of the current
</span><span class="noop">        project.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return self._projectdirectory
</span><span class="noop">
</span><span class="hit">    def _setprojectdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        directory = os.path.join(self.basepath, directory)
</span><span class="miss">        if not os.path.exists(directory):
</span><span class="miss">            raise IOError(&#39;Path `%s` does not contain a condition directory &#39;
</span><span class="noop">                          &#39;named `%s`.&#39; % (self.basepath, directory))
</span><span class="miss">        self._projectdirectory = directory
</span><span class="noop">
</span><span class="hit">    projectdirectory = property(_getprojectdirectory, _setprojectdirectory)
</span><span class="noop">
</span><span class="hit">    def _getprojectpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the project directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.basepath, self.projectdirectory)
</span><span class="noop">
</span><span class="hit">    projectpath = property(_getprojectpath)
</span><span class="noop">
</span><span class="hit">    def _getconditiondirectories(self):
</span><span class="noop">        &#34;&#34;&#34;Folders containing the condition files of e.g. different time
</span><span class="noop">        points.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        directories = FolderShow()
</span><span class="miss">        for directory in os.listdir(self.projectpath):
</span><span class="miss">            if not directory.startswith(&#39;_&#39;):
</span><span class="miss">                path = os.path.join(self.projectpath, directory)
</span><span class="miss">                if os.path.isdir(path):
</span><span class="miss">                    directories.add(directory)
</span><span class="miss">        return directories
</span><span class="noop">
</span><span class="hit">    conditiondirectories = property(_getconditiondirectories)
</span><span class="noop">
</span><span class="hit">    def _getloaddirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or only selectable) initial conditions directory&#34;&#34;&#34;
</span><span class="miss">        directories = self.conditiondirectories
</span><span class="miss">        if self._loaddirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._loaddirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified conditions directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._loaddirectory))
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;conditions directory.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            string = &#39;init_&#39; + pub.timegrids.sim.firstdate.string(&#39;os&#39;)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple condition&#39;
</span><span class="noop">                          &#39;directories, and no first simulation date is &#39;
</span><span class="noop">                          &#39;available to determine the relevant one.  &#39;
</span><span class="noop">                          &#39;Please specify the condition directory to be &#39;
</span><span class="noop">                          &#39;worked with manually.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            return getattr(directories, string)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains at least one &#39;
</span><span class="noop">                          &#39;directory, but none is in accordance with the &#39;
</span><span class="noop">                          &#39;first simulation date (%s).  Please specify &#39;
</span><span class="noop">                          &#39;the condition directory to be worked with manually.&#39;
</span><span class="noop">                          % (self.projectpath, string))
</span><span class="noop">
</span><span class="hit">    def _setloaddirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._loaddirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain a &#39;
</span><span class="noop">                          &#39;condition directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _delloaddirectory(self):
</span><span class="miss">        self._loaddirectory = None
</span><span class="noop">
</span><span class="hit">    loaddirectory = property(_getloaddirectory, _setloaddirectory,
</span><span class="noop">                             _delloaddirectory)
</span><span class="noop">
</span><span class="hit">    def _getsavedirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or only selectable) final conditions directory&#34;&#34;&#34;
</span><span class="miss">        directories = self.conditiondirectories
</span><span class="miss">        if self._savedirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._savedirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified conditions directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._savedirectory))
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;conditions directories.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            string = &#39;init_&#39; + pub.timegrids.sim.lastdate.string(&#39;os&#39;)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple condition&#39;
</span><span class="noop">                          &#39;directories, and no last simulation date is &#39;
</span><span class="noop">                          &#39;available to determine the relevant one.  &#39;
</span><span class="noop">                          &#39;Please specify the condition directory to be &#39;
</span><span class="noop">                          &#39;worked with manually.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            return getattr(directories, string)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple condition&#39;
</span><span class="noop">                          &#39;directories, but none is in accordance with the  &#39;
</span><span class="noop">                          &#39;last simulation date (%s).  Please specify&#39;
</span><span class="noop">                          &#39;the condition directory to be worked with manually.&#39;
</span><span class="noop">                          % (self.projectpath, string))
</span><span class="noop">
</span><span class="hit">    def _setsavedirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._savedirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain a &#39;
</span><span class="noop">                          &#39;condition directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _delsavedirectory(self):
</span><span class="miss">        self._loaddirectory = None
</span><span class="noop">
</span><span class="hit">    savedirectory = property(_getsavedirectory, _setsavedirectory,
</span><span class="noop">                             _delsavedirectory)
</span><span class="noop">
</span><span class="hit">    def _getloadpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the relevant initial condition directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.loaddirectory)
</span><span class="noop">
</span><span class="hit">    loadpath = property(_getloadpath)
</span><span class="noop">
</span><span class="hit">    def _getsavepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the relevant final condition directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.savedirectory)
</span><span class="noop">
</span><span class="hit">    savepath = property(_getsavepath)
</span><span class="noop">
</span><span class="hit">    def loadfile(self, filename, dirname=None):
</span><span class="miss">        if not filename.endswith(&#39;.py&#39;):
</span><span class="miss">            filename += &#39;.py&#39;
</span><span class="miss">        if dirname is None:
</span><span class="miss">            dirname = os.path.join(pub.conditionmanager.loadpath)
</span><span class="miss">        filepath = os.path.join(dirname, filename)
</span><span class="miss">        try:
</span><span class="miss">            with open(filepath) as file_:
</span><span class="miss">                return file_.read()
</span><span class="miss">        except BaseException:
</span><span class="miss">            prefix = &#39;While trying to read the conditions file `%s`&#39; % filepath
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/hydpytools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/hydpytools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements superordinate tools for handling a HydPy project.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import warnings
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import filetools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy.core import selectiontools
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="hit">from hydpy.core import magictools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HydPy(object):
</span><span class="noop">    &#34;&#34;&#34;Main class for managing HydPy projects.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">    # A counter for the number of HydPy instances.
</span><span class="hit">    nmb_instances = 0
</span><span class="noop">
</span><span class="hit">    def __init__(self, projectname=None):
</span><span class="noop">
</span><span class="noop">        # Increment and check number of HydPy instances.
</span><span class="hit">        HydPy.nmb_instances += 1
</span><span class="hit">        if HydPy.nmb_instances &gt; 1:
</span><span class="miss">            warnings.warn(&#39;Currently %d instances of HydPy are initialized &#39;
</span><span class="noop">                          &#39;within the same process.  It is strongly &#39;
</span><span class="noop">                          &#39;recommended to initialize only one instance at a &#39;
</span><span class="noop">                          &#39;time.  Consider deleting all instances and &#39;
</span><span class="noop">                          &#39;initializing a new one, unless you are fully aware &#39;
</span><span class="noop">                          &#39;in what manner HydPy is relying on some global &#39;
</span><span class="noop">                          &#39;information stored in module `pub`.&#39;
</span><span class="noop">                          % HydPy.nmb_instances)
</span><span class="noop">
</span><span class="noop">        # Store public information in a seperate module.
</span><span class="hit">        if projectname is not None:
</span><span class="miss">            pub.projectname = projectname
</span><span class="miss">            pub.filemanager = filetools.MainManager()
</span><span class="miss">            pub.networkmanager = filetools.NetworkManager()
</span><span class="miss">            pub.controlmanager = filetools.ControlManager()
</span><span class="miss">            pub.sequencemanager = filetools.SequenceManager()
</span><span class="miss">            pub.conditionmanager = filetools.ConditionManager()
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="noop">    def preparenetwork(self):
</span><span class="miss">        pub.selections = selectiontools.Selections()
</span><span class="miss">        pub.selections += pub.networkmanager.load()
</span><span class="miss">        self.updatedevices(pub.selections.complete)
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="noop">    def init_models(self):
</span><span class="miss">        warn = pub.options.warnsimulationstep
</span><span class="miss">        pub.options.warnsimulationstep = False
</span><span class="miss">        try:
</span><span class="miss">            for element in magictools.progressbar(self.elements):
</span><span class="miss">                try:
</span><span class="miss">                    element.init_model()
</span><span class="miss">                except IOError as exc:
</span><span class="miss">                    temp = &#39;While trying to load the control file&#39;
</span><span class="miss">                    if ((temp in str(exc)) and
</span><span class="noop">                            pub.options.warnmissingcontrolfile):
</span><span class="miss">                        warnings.warn(&#39;No model could be initialized for &#39;
</span><span class="noop">                                      &#39;element `%s`&#39; % element)
</span><span class="miss">                        self.model = None
</span><span class="noop">                    else:
</span><span class="miss">                        objecttools.augmentexcmessage(
</span><span class="noop">                            &#39;While trying to initialize the model of &#39;
</span><span class="noop">                            &#39;element `%s`&#39; % element)
</span><span class="noop">                else:
</span><span class="miss">                    element.model.parameters.update()
</span><span class="noop">        finally:
</span><span class="miss">            pub.options.warnsimulationstep = warn
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="hit">    def savecontrols(self, controldirectory=None, projectdirectory=None,
</span><span class="noop">                     parameterstep=None, simulationstep=None):
</span><span class="miss">        _controldirectory = pub.controlmanager._controldirectory
</span><span class="miss">        _projectdirectory = pub.controlmanager._projectdirectory
</span><span class="miss">        try:
</span><span class="miss">            if controldirectory:
</span><span class="miss">                pub.controlmanager.controldirectory = controldirectory
</span><span class="miss">            if projectdirectory:
</span><span class="miss">                pub.controlmanager.projectdirectory = projectdirectory
</span><span class="miss">            for element in magictools.progressbar(self.elements):
</span><span class="miss">                element.model.parameters.savecontrols(parameterstep,
</span><span class="noop">                                                      simulationstep)
</span><span class="noop">        finally:
</span><span class="miss">            pub.controlmanager._controldirectory = _controldirectory
</span><span class="miss">            pub.controlmanager._projectdirectory = _projectdirectory
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="hit">    def loadconditions(self, conditiondirectory=None, controldirectory=None,
</span><span class="noop">                       projectdirectory=None):
</span><span class="miss">        self._ioconditions(conditiondirectory,  controldirectory,
</span><span class="noop">                           projectdirectory, True)
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="hit">    def saveconditions(self, conditiondirectory=None, controldirectory=None,
</span><span class="noop">                       projectdirectory=None):
</span><span class="miss">        self._ioconditions(conditiondirectory,  controldirectory,
</span><span class="noop">                           projectdirectory, False)
</span><span class="noop">
</span><span class="hit">    def _ioconditions(self, conditiondirectory, controldirectory,
</span><span class="noop">                      projectdirectory, loadflag):
</span><span class="miss">        if loadflag:
</span><span class="miss">            _conditiondirectory = pub.conditionmanager._loaddirectory
</span><span class="noop">        else:
</span><span class="miss">            _conditiondirectory = pub.conditionmanager._savedirectory
</span><span class="miss">        _controldirectory = pub.controlmanager._controldirectory
</span><span class="miss">        _projectdirectory = pub.conditionmanager._projectdirectory
</span><span class="miss">        try:
</span><span class="miss">            if projectdirectory:
</span><span class="miss">                pub.conditionmanager.projectdirectory = projectdirectory
</span><span class="miss">            if conditiondirectory:
</span><span class="miss">                if loadflag:
</span><span class="miss">                    pub.conditionmanager.loaddirectory = conditiondirectory
</span><span class="noop">                else:
</span><span class="miss">                    pub.conditionmanager.savedirectory = conditiondirectory
</span><span class="miss">            if controldirectory:
</span><span class="miss">                pub.controlmanager.controldirectory = controldirectory
</span><span class="miss">            for element in magictools.progressbar(self.elements):
</span><span class="miss">                if loadflag:
</span><span class="miss">                    element.model.sequences.loadconditions()
</span><span class="noop">                else:
</span><span class="miss">                    element.model.sequences.saveconditions()
</span><span class="noop">        finally:
</span><span class="miss">            if loadflag:
</span><span class="miss">                pub.conditionmanager._loaddirectory = _conditiondirectory
</span><span class="noop">            else:
</span><span class="miss">                pub.conditionmanager._savedirectory = _conditiondirectory
</span><span class="miss">            pub.controlmanager._controldirectory = _controldirectory
</span><span class="miss">            pub.conditionmanager._projectdirectory = _projectdirectory
</span><span class="noop">
</span><span class="hit">    def trimconditions(self):
</span><span class="miss">        for element in self.elements:
</span><span class="miss">            element.model.sequences.trimconditions()
</span><span class="noop">
</span><span class="hit">    def resetconditions(self):
</span><span class="miss">        for element in self.elements:
</span><span class="miss">            element.model.sequences.reset()
</span><span class="noop">
</span><span class="hit">    def connect(self):
</span><span class="miss">        for element in self.elements:
</span><span class="miss">            element.connect()
</span><span class="miss">            element.model.parameters.update()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def network_properties(self):
</span><span class="miss">        print(&#39;Number of nodes: %d&#39; % len(self.nodes))
</span><span class="miss">        print(&#39;Number of elements: %d&#39; % len(self.elements))
</span><span class="miss">        print(&#39;Number of end nodes: %d&#39; % len(self.endnodes))
</span><span class="miss">        print(&#39;Number of distinct networks: %d&#39; % len(self.distinct_networks))
</span><span class="miss">        print(&#39;Applied node variables: %s&#39; % &#39;, &#39;.join(self.variables))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def distinct_networks(self):
</span><span class="miss">        sels1 = selectiontools.Selections()
</span><span class="miss">        sels2 = selectiontools.Selections()
</span><span class="miss">        complete = selectiontools.Selection(&#39;complete&#39;,
</span><span class="noop">                                            self.nodes, self.elements)
</span><span class="miss">        for node in self.endnodes:
</span><span class="miss">            sel = complete.copy(node.name).select_upstream(node)
</span><span class="miss">            sels1 += sel
</span><span class="miss">            sels2 += sel.copy(node.name)
</span><span class="miss">        for sel1 in sels1:
</span><span class="miss">            for sel2 in sels2:
</span><span class="miss">                if sel1.name != sel2.name:
</span><span class="miss">                    sel1 -= sel2
</span><span class="miss">        for name in list(sels1.names):
</span><span class="miss">            if not sels1[name].elements:
</span><span class="miss">                del sels1[name]
</span><span class="miss">        return sels1
</span><span class="noop">
</span><span class="hit">    def _updatedeviceorder(self):
</span><span class="hit">        self.deviceorder = []
</span><span class="hit">        for node in self.endnodes:
</span><span class="hit">            self._nextnode(node)
</span><span class="hit">        self.deviceorder = self.deviceorder[::-1]
</span><span class="noop">
</span><span class="hit">    def _nextnode(self, node):
</span><span class="hit">        for element in node.exits:
</span><span class="hit">            if ((element in self.elements) and
</span><span class="noop">                    (element not in self.deviceorder)):
</span><span class="hit">                if node not in element.receivers:
</span><span class="miss">                    self._nextelement(element)
</span><span class="hit">        if (node in self.nodes) and (node not in self.deviceorder):
</span><span class="hit">            self.deviceorder.append(node)
</span><span class="hit">            for element in node.entries:
</span><span class="hit">                self._nextelement(element)
</span><span class="noop">
</span><span class="hit">    def _nextelement(self, element):
</span><span class="hit">        for node in element.outlets:
</span><span class="hit">            if ((node in self.nodes) and
</span><span class="noop">                    (node not in self.deviceorder)):
</span><span class="miss">                self._nextnode(node)
</span><span class="hit">        if (element in self.elements) and (element not in self.deviceorder):
</span><span class="hit">            self.deviceorder.append(element)
</span><span class="hit">            for node in element.inlets:
</span><span class="hit">                self._nextnode(node)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def endnodes(self):
</span><span class="hit">        endnodes = devicetools.Nodes()
</span><span class="hit">        for node in self.nodes:
</span><span class="hit">            for element in node.exits:
</span><span class="hit">                if ((element in self.elements) and
</span><span class="noop">                        (node not in element.receivers)):
</span><span class="hit">                    break
</span><span class="noop">            else:
</span><span class="hit">                endnodes += node
</span><span class="hit">        return endnodes
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def variables(self):
</span><span class="miss">        variables = set([])
</span><span class="miss">        for node in self.nodes:
</span><span class="miss">            variables.add(node.variable)
</span><span class="miss">        return sorted(variables)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def simindices(self):
</span><span class="hit">        return (pub.timegrids.init[pub.timegrids.sim.firstdate],
</span><span class="noop">                pub.timegrids.init[pub.timegrids.sim.lastdate])
</span><span class="noop">
</span><span class="hit">    def openfiles(self, idx=0):
</span><span class="hit">        for element in self.elements:
</span><span class="hit">            element.model.sequences.openfiles(idx)
</span><span class="hit">        for node in self.nodes:
</span><span class="hit">            node.sequences.openfiles(idx)
</span><span class="noop">
</span><span class="hit">    def closefiles(self):
</span><span class="hit">        for element in self.elements:
</span><span class="hit">            element.model.sequences.closefiles()
</span><span class="hit">        for node in self.nodes:
</span><span class="hit">            node.sequences.closefiles()
</span><span class="noop">
</span><span class="hit">    def updatedevices(self, selection=None):
</span><span class="hit">        if selection is not None:
</span><span class="hit">            self.nodes = selection.nodes
</span><span class="hit">            self.elements = selection.elements
</span><span class="hit">        self._updatedeviceorder()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def funcorder(self):
</span><span class="hit">        funcs = []
</span><span class="hit">        for node in self.nodes:
</span><span class="hit">            if node.deploy_mode == &#39;oldsim&#39;:
</span><span class="hit">                funcs.append(node._loaddata_sim)
</span><span class="hit">            elif node.sequences.obs.use_ext:
</span><span class="hit">                funcs.append(node._loaddata_obs)
</span><span class="hit">        for node in self.nodes:
</span><span class="hit">            if node.deploy_mode != &#39;oldsim&#39;:
</span><span class="hit">                funcs.append(node.reset)
</span><span class="hit">        for device in self.deviceorder:
</span><span class="hit">            if isinstance(device, devicetools.Element):
</span><span class="hit">                funcs.append(device.model.doit)
</span><span class="hit">        for element in self.elements:
</span><span class="hit">            if element.senders:
</span><span class="miss">                funcs.append(element.model.update_senders)
</span><span class="hit">        for element in self.elements:
</span><span class="hit">            if element.receivers:
</span><span class="hit">                funcs.append(element.model.update_receivers)
</span><span class="hit">        for node in self.nodes:
</span><span class="hit">            if node.deploy_mode != &#39;oldsim&#39;:
</span><span class="hit">                funcs.append(node._savedata_sim)
</span><span class="hit">        return funcs
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="noop">    def doit(self):
</span><span class="hit">        idx_start, idx_end = self.simindices
</span><span class="hit">        self.openfiles(idx_start)
</span><span class="hit">        funcorder = self.funcorder
</span><span class="hit">        for idx in magictools.progressbar(range(idx_start, idx_end)):
</span><span class="hit">            for func in funcorder:
</span><span class="hit">                func(idx)
</span><span class="hit">        self.closefiles()
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="hit">    def prepare_modelseries(self, ramflag=True):
</span><span class="miss">        for element in magictools.progressbar(self.elements):
</span><span class="miss">            element.prepare_allseries(ramflag)
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="hit">    def prepare_inputseries(self, ramflag=True):
</span><span class="miss">        for element in magictools.progressbar(self.elements):
</span><span class="miss">            element.prepare_inputseries(ramflag)
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="hit">    def prepare_fluxseries(self, ramflag=True):
</span><span class="miss">        for element in magictools.progressbar(self.elements):
</span><span class="miss">            element.prepare_fluxseries(ramflag)
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="hit">    def prepare_stateseries(self, ramflag=True):
</span><span class="miss">        for element in magictools.progressbar(self.elements):
</span><span class="miss">            element.prepare_stateseries(ramflag)
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="hit">    def prepare_nodeseries(self, ramflag=True):
</span><span class="miss">        self.prepare_simseries(ramflag)
</span><span class="miss">        self.prepare_obsseries(ramflag)
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="hit">    def prepare_simseries(self, ramflag=True):
</span><span class="miss">        for node in magictools.progressbar(self.nodes):
</span><span class="miss">            node.prepare_simseries(ramflag)
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="hit">    def prepare_obsseries(self, ramflag=True):
</span><span class="miss">        for node in magictools.progressbar(self.nodes):
</span><span class="miss">            node.prepare_obsseries(ramflag)
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="noop">    def save_modelseries(self):
</span><span class="miss">        self.save_inputseries()
</span><span class="miss">        self.save_fluxseries()
</span><span class="miss">        self.save_stateseries()
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="noop">    def save_inputseries(self):
</span><span class="miss">        self._save_modelseries(&#39;inputs&#39;, pub.sequencemanager.inputoverwrite)
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="noop">    def save_fluxseries(self):
</span><span class="miss">        self._save_modelseries(&#39;fluxes&#39;, pub.sequencemanager.outputoverwrite)
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="noop">    def save_stateseries(self):
</span><span class="miss">        self._save_modelseries(&#39;states&#39;, pub.sequencemanager.outputoverwrite)
</span><span class="noop">
</span><span class="hit">    def _save_modelseries(self, name_subseqs, overwrite):
</span><span class="miss">        for element in magictools.progressbar(self.elements):
</span><span class="miss">            sequences = element.model.sequences
</span><span class="miss">            subseqs = getattr(sequences, name_subseqs, ())
</span><span class="miss">            for (name, seq) in subseqs:
</span><span class="miss">                if seq.memoryflag:
</span><span class="miss">                    if overwrite or not os.path.exists(seq.filepath_ext):
</span><span class="miss">                        seq.save_ext()
</span><span class="noop">                    else:
</span><span class="miss">                        warnings.warn(&#39;Due to the argument `overwrite` beeing &#39;
</span><span class="noop">                                      &#39;`False` it is not allowed to overwrite &#39;
</span><span class="noop">                                      &#39;the already existing file `%s`.&#39;
</span><span class="noop">                                      % seq.filepath_ext)
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="noop">    def save_nodeseries(self):
</span><span class="miss">        self.save_simseries()
</span><span class="miss">        self.save_obsseries()
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="hit">    def save_simseries(self, ramflag=True):
</span><span class="miss">        self._save_nodeseries(&#39;sim&#39;, pub.sequencemanager.simoverwrite)
</span><span class="noop">
</span><span class="hit">    @magictools.printprogress
</span><span class="hit">    def save_obsseries(self, ramflag=True):
</span><span class="miss">        self._save_nodeseries(&#39;obs&#39;, pub.sequencemanager.obsoverwrite)
</span><span class="noop">
</span><span class="hit">    def _save_nodeseries(self, seqname, overwrite):
</span><span class="miss">        for node in magictools.progressbar(self.nodes):
</span><span class="miss">            seq = getattr(node.sequences, seqname)
</span><span class="miss">            if seq.memoryflag:
</span><span class="miss">                if overwrite or not os.path.exists(seq.filepath_ext):
</span><span class="miss">                    seq.save_ext()
</span><span class="noop">                else:
</span><span class="miss">                    warnings.warn(&#39;Due to the argument `overwrite` beeing &#39;
</span><span class="noop">                                  &#39;`False` it is not allowed to overwrite &#39;
</span><span class="noop">                                  &#39;the already existing file `%s`.&#39;
</span><span class="noop">                                  % seq.filepath_ext)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/indextools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/indextools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements tools to determine time related indices.&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Indexer(object):
</span><span class="noop">    &#34;&#34;&#34;Handles arrays containing indexes.
</span><span class="noop">
</span><span class="noop">    One can specify the index arrays manually, but usually they are determined
</span><span class="noop">    automatically based on the :class:`~hydpy.core.timetools.Timegrids` object
</span><span class="noop">    made available through module :mod:`~hydpy.pub`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self._monthofyear = None
</span><span class="hit">        self._monthofyear_hash = hash(None)
</span><span class="hit">        self._dayofyear = None
</span><span class="hit">        self._dayofyear_hash = hash(None)
</span><span class="hit">        self._timeofyear = None
</span><span class="hit">        self._timeofyear_hash = hash(None)
</span><span class="noop">
</span><span class="hit">    def _getmonthofyear(self):
</span><span class="noop">        &#34;&#34;&#34;Month of the year index (January = 0...).&#34;&#34;&#34;
</span><span class="hit">        from hydpy.pub import timegrids
</span><span class="hit">        if ((self._monthofyear is None) or
</span><span class="noop">                (hash(timegrids) != self._monthofyear_hash)):
</span><span class="hit">            def monthofyear(date):
</span><span class="hit">                return date.month-1
</span><span class="hit">            self._monthofyear = self._calcidxs(monthofyear)
</span><span class="hit">            self._monthofyear_hash = hash(timegrids)
</span><span class="hit">        return self._monthofyear
</span><span class="noop">
</span><span class="hit">    def _setmonthofyear(self, values):
</span><span class="hit">        from hydpy.pub import timegrids
</span><span class="hit">        self._monthofyear = self._convertandtest(values, &#39;monthofyear&#39;)
</span><span class="hit">        self._monthofyear_hash = hash(timegrids)
</span><span class="noop">
</span><span class="hit">    def _delmonthofyear(self):
</span><span class="hit">        self._monthofyear = None
</span><span class="noop">
</span><span class="hit">    monthofyear = property(_getmonthofyear, _setmonthofyear, _delmonthofyear)
</span><span class="noop">
</span><span class="hit">    def _getdayofyear(self):
</span><span class="noop">        &#34;&#34;&#34;Day of the year index (the first of January = 0...).
</span><span class="noop">
</span><span class="noop">        For reasons of consistency between leap years and non-leap years,
</span><span class="noop">        assuming a daily time step, index 59 is always associated with the
</span><span class="noop">        29th of February.  Hence, it is missing in non-leap years:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.indextools import Indexer
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;27.02.2004&#39;,
</span><span class="noop">        ...                                    &#39;3.03.2004&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">        &gt;&gt;&gt; Indexer().dayofyear
</span><span class="noop">        array([57, 58, 59, 60, 61])
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;27.02.2005&#39;,
</span><span class="noop">        ...                                    &#39;3.03.2005&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">        &gt;&gt;&gt; Indexer().dayofyear
</span><span class="noop">        array([57, 58, 60, 61])
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if ((self._dayofyear is None) or
</span><span class="noop">                (hash(pub.timegrids) != self._dayofyear_hash)):
</span><span class="hit">            def dayofyear(date):
</span><span class="hit">                return (date.dayofyear-1 +
</span><span class="noop">                        ((date.month &gt; 2) and (not date.leapyear)))
</span><span class="hit">            self._dayofyear = self._calcidxs(dayofyear)
</span><span class="hit">            self._dayofyear_hash = hash(pub.timegrids)
</span><span class="hit">        return self._dayofyear
</span><span class="noop">
</span><span class="hit">    def _setdayofyear(self, values):
</span><span class="hit">        self._dayofyear = self._convertandtest(values, &#39;dayofyear&#39;)
</span><span class="hit">        self._dayofyear_hash = hash(pub.timegrids)
</span><span class="noop">
</span><span class="hit">    def _deldayofyear(self):
</span><span class="hit">        self._dayofyear = None
</span><span class="noop">
</span><span class="hit">    dayofyear = property(_getdayofyear, _setdayofyear, _deldayofyear)
</span><span class="noop">
</span><span class="hit">    def _gettimeofyear(self):
</span><span class="noop">        &#34;&#34;&#34;Time of the year index (first simulation step of each year = 0...).
</span><span class="noop">
</span><span class="noop">        The property :attr:`~Indexer.timeofyear` is best explained through
</span><span class="noop">        it with property :attr:`~Indexer.dayofyear`:
</span><span class="noop">
</span><span class="noop">        Let us reconsider one of the examples of the documentation on
</span><span class="noop">        property :attr:`~Indexer.dayofyear`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.indextools import Indexer
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;27.02.2005&#39;,
</span><span class="noop">        ...                                    &#39;3.03.2005&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">        Due to the simulation stepsize beeing one day, the index arrays
</span><span class="noop">        calculated by both properties are identical:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; Indexer().dayofyear
</span><span class="noop">        array([57, 58, 60, 61])
</span><span class="noop">        &gt;&gt;&gt; Indexer().timeofyear
</span><span class="noop">        array([57, 58, 60, 61])
</span><span class="noop">
</span><span class="noop">        In the next example the step size is halved:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;27.02.2005&#39;,
</span><span class="noop">        ...                                    &#39;3.03.2005&#39;,
</span><span class="noop">        ...                                    &#39;12h&#39;))
</span><span class="noop">
</span><span class="noop">        Now the there a generally two subsequent simulation steps associated
</span><span class="noop">        with the same day:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; Indexer().dayofyear
</span><span class="noop">        array([57, 57, 58, 58, 60, 60, 61, 61])
</span><span class="noop">
</span><span class="noop">        However, the `timeofyear` array gives the index of the
</span><span class="noop">        respective simulation steps of the actual year:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; Indexer().timeofyear
</span><span class="noop">        array([114, 115, 116, 117, 120, 121, 122, 123])
</span><span class="noop">
</span><span class="noop">        Note the gap in the returned index array due to 2005 beeing not a
</span><span class="noop">        leap year.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if ((self._timeofyear is None) or
</span><span class="noop">                (hash(pub.timegrids) != self._timeofyear_hash)):
</span><span class="hit">            if pub.timegrids is None:
</span><span class="hit">                refgrid = None
</span><span class="noop">            else:
</span><span class="hit">                refgrid = timetools.Timegrid(timetools.Date(&#39;2000.01.01&#39;),
</span><span class="noop">                                             timetools.Date(&#39;2001.01.01&#39;),
</span><span class="noop">                                             pub.timegrids.stepsize)
</span><span class="noop">
</span><span class="hit">            def timeofyear(date):
</span><span class="hit">                date = date.copy()
</span><span class="hit">                date.year = 2000
</span><span class="hit">                return refgrid[date]
</span><span class="noop">
</span><span class="hit">            self._timeofyear = self._calcidxs(timeofyear)
</span><span class="hit">            self._timeofyear_hash = hash(pub.timegrids)
</span><span class="hit">        return self._timeofyear
</span><span class="noop">
</span><span class="hit">    def _settimeofyear(self, values):
</span><span class="hit">        self._timeofyear = self._convertandtest(values, &#39;timeofyear&#39;)
</span><span class="hit">        self._timeofyear_hash = hash(pub.timegrids)
</span><span class="noop">
</span><span class="hit">    def _deltimeofyear(self):
</span><span class="hit">        self._timeofyear = None
</span><span class="noop">
</span><span class="hit">    timeofyear = property(_gettimeofyear, _settimeofyear, _deltimeofyear)
</span><span class="noop">
</span><span class="hit">    def _convertandtest(self, values, name):
</span><span class="noop">        &#34;&#34;&#34;Try to convert the given values to a :mod:`numpy`
</span><span class="noop">        :class:`~numpy.ndarrray` and check if it is plausible.  If so, return
</span><span class="noop">        the array, other raise a :class:`~exceptions.ValueError` or re-raise a
</span><span class="noop">        :mod:`numpy` specific exception.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            array = numpy.array(values, dtype=int)
</span><span class="hit">        except BaseException:
</span><span class="hit">            objecttools.augmentexcmessage(&#39;While trying to assign a new `%s` &#39;
</span><span class="noop">                                          &#39;index array to an Indexer object&#39;
</span><span class="noop">                                          % name)
</span><span class="hit">        if array.ndim != 1:
</span><span class="hit">            raise ValueError(&#39;The `%s` index array of an Indexer object must &#39;
</span><span class="noop">                             &#39;be 1-dimensional.  However, the given value has &#39;
</span><span class="noop">                             &#39;interpreted as a %d-dimensional object.&#39;
</span><span class="noop">                             % (name, array.ndim))
</span><span class="hit">        if pub.timegrids is not None:
</span><span class="hit">            if len(array) != len(pub.timegrids.init):
</span><span class="hit">                raise ValueError(&#39;The %s` index array of an Indexer object &#39;
</span><span class="noop">                                 &#39;must have a number of entries fitting to &#39;
</span><span class="noop">                                 &#39;the initialization time period precisely.  &#39;
</span><span class="noop">                                 &#39;However, the given value has been &#39;
</span><span class="noop">                                 &#39;interpreted to be of length %d and the &#39;
</span><span class="noop">                                 &#39;length of the Timegrid object representing &#39;
</span><span class="noop">                                 &#39;the actual initialization time period is %d.&#39;
</span><span class="noop">                                 % (name, len(array), len(pub.timegrids.init)))
</span><span class="hit">        return array
</span><span class="noop">
</span><span class="hit">    def _calcidxs(self, func):
</span><span class="noop">        &#34;&#34;&#34;Return the required indexes based on the given lambda function and
</span><span class="noop">        the :class:`~hydpy.core.timetools.Timegrids` object handled by module
</span><span class="noop">        :mod:`~hydpy.pub`.  Raise a :class:`~exceptions.RuntimeError` if the
</span><span class="noop">        latter is not available.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if pub.timegrids is None:
</span><span class="hit">            raise RuntimeError(&#39;An Indexer object has been asked for an &#39;
</span><span class="noop">                               &#39;%s array.  Such an array has neither been &#39;
</span><span class="noop">                               &#39;determined yet nor can it be determined &#39;
</span><span class="noop">                               &#39;automatically at the moment.   Either &#39;
</span><span class="noop">                               &#39;define an %s array manually and pass it to &#39;
</span><span class="noop">                               &#39;the Indexer object, or make a proper &#39;
</span><span class="noop">                               &#39;Timegrids object available within the pub &#39;
</span><span class="noop">                               &#39;module.  In usual HydPy applications, the &#39;
</span><span class="noop">                               &#39;latter is done automatically.&#39;
</span><span class="noop">                               % (func.__name__, func.__name__))
</span><span class="hit">        idxs = numpy.empty(len(pub.timegrids.init), dtype=int)
</span><span class="hit">        for (jdx, date) in enumerate(pub.timegrids.init):
</span><span class="hit">            idxs[jdx] = func(date)
</span><span class="hit">        return idxs
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/magictools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/magictools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements most of those tools, that involve some tricks to
</span><span class="noop">simplify using the HydPy framework.
</span><span class="noop">
</span><span class="noop">These tools are primarily designed for features like hiding model
</span><span class="noop">initialization routines from model users and for allowing readable definitions
</span><span class="noop">of doctests.  Hence, along with some metaclasses defined in other modules and
</span><span class="noop">with the cythonization features of module :mod:`~hydpy.cythons.modelutils` and
</span><span class="noop">the documentation features of module :mod:`~hydpy.cythons.autodoctools`,
</span><span class="noop">module :mod:`~hydpy.core.magictools` somehow modifies the Python API a little
</span><span class="noop">to the advantage of model users and model developers.  Programmers who work
</span><span class="noop">on the core routines of HydPy and encounter unexpected side effects, should
</span><span class="noop">first have a look into this module and the other modules mentioned.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from the Python standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import sys
</span><span class="hit">import inspect
</span><span class="hit">import warnings
</span><span class="hit">import importlib
</span><span class="hit">import doctest
</span><span class="hit">import functools
</span><span class="hit">import tempfile
</span><span class="hit">import itertools
</span><span class="noop"># ...from HydPy
</span><span class="hit">import hydpy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import filetools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Tester(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        frame = inspect.currentframe().f_back
</span><span class="hit">        self.filepath = frame.f_code.co_filename
</span><span class="hit">        self.package = frame.f_locals[&#39;__package__&#39;]
</span><span class="hit">        self.ispackage = os.path.split(self.filepath)[-1] == &#39;__init__.py&#39;
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def filenames(self):
</span><span class="miss">        if self.ispackage:
</span><span class="miss">            return os.listdir(os.path.dirname(self.filepath))
</span><span class="noop">        else:
</span><span class="miss">            return [self.filepath]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def modulenames(self):
</span><span class="miss">        return [os.path.split(fn)[-1].split(&#39;.&#39;)[0] for fn in self.filenames
</span><span class="noop">                if (fn.endswith(&#39;.py&#39;) and not fn.startswith(&#39;_&#39;))]
</span><span class="noop">
</span><span class="hit">    def doit(self):
</span><span class="miss">        opt = pub.options
</span><span class="miss">        with opt.usedefaultvalues(False), \
</span><span class="noop">                opt.usedefaultvalues(False), \
</span><span class="noop">                opt.printprogress(False), \
</span><span class="noop">                opt.printincolor(False), \
</span><span class="noop">                opt.warnsimulationstep(False), \
</span><span class="noop">                opt.reprcomments(False), \
</span><span class="noop">                opt.ellipsis(0), \
</span><span class="noop">                opt.reprdigits(6), \
</span><span class="noop">                opt.warntrim(False):
</span><span class="miss">            timegrids = pub.timegrids
</span><span class="miss">            _simulationstep = parametertools.Parameter._simulationstep
</span><span class="miss">            parametertools.Parameter._simulationstep = None
</span><span class="miss">            pub.timegrids = None
</span><span class="miss">            nodes = devicetools.Node._registry.copy()
</span><span class="miss">            elements = devicetools.Element._registry.copy()
</span><span class="miss">            devicetools.Node.clear_registry()
</span><span class="miss">            devicetools.Element.clear_registry()
</span><span class="miss">            try:
</span><span class="miss">                color = 34 if pub.options.usecython else 36
</span><span class="miss">                with PrintStyle(color=color, font=4):
</span><span class="miss">                    print(
</span><span class="noop">                      &#39;Test %s %s in %sython mode.&#39;
</span><span class="noop">                      % (&#39;package&#39; if self.ispackage else &#39;module&#39;,
</span><span class="noop">                         self.package if self.ispackage else
</span><span class="noop">                         self.modulenames[0],
</span><span class="noop">                         &#39;C&#39; if pub.options.usecython else &#39;P&#39;))
</span><span class="miss">                with PrintStyle(color=color, font=2):
</span><span class="miss">                    for name in self.modulenames:
</span><span class="miss">                        print(&#39;    * %s:&#39; % name, )
</span><span class="miss">                        with StdOutErr(indent=8):
</span><span class="miss">                            modulename = &#39;.&#39;.join((self.package, name))
</span><span class="miss">                            module = importlib.import_module(modulename)
</span><span class="miss">                            warnings.filterwarnings(&#39;error&#39;, module=modulename)
</span><span class="miss">                            warnings.filterwarnings(&#39;ignore&#39;,
</span><span class="noop">                                                    category=ImportWarning)
</span><span class="miss">                            doctest.testmod(
</span><span class="noop">                                    module, extraglobs={&#39;testing&#39;: True},
</span><span class="noop">                                    optionflags=doctest.ELLIPSIS)
</span><span class="miss">                            warnings.resetwarnings()
</span><span class="noop">            finally:
</span><span class="miss">                pub.timegrids = timegrids
</span><span class="miss">                parametertools.Parameter._simulationstep = _simulationstep
</span><span class="miss">                devicetools.Node.clear_registry()
</span><span class="miss">                devicetools.Element.clear_registry()
</span><span class="miss">                devicetools.Node._registry = nodes
</span><span class="miss">                devicetools.Element._registry = elements
</span><span class="miss">                hydpy.dummies.clear()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PrintStyle(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self, color, font, file=None):
</span><span class="hit">        self.color = color
</span><span class="hit">        self.font = font
</span><span class="hit">        self.file = sys.stdout if file is None else file
</span><span class="noop">
</span><span class="hit">    def __enter__(self):
</span><span class="hit">        if pub.options.printincolor:
</span><span class="hit">            print(end=&#39;\x1B[%d;30;%dm&#39; % (self.font, self.color),
</span><span class="noop">                  file=self.file)
</span><span class="noop">
</span><span class="hit">    def __exit__(self, exception, message, traceback_):
</span><span class="hit">        if pub.options.printincolor:
</span><span class="hit">            print(end=&#39;\x1B[0m&#39;, file=self.file)
</span><span class="hit">        if exception:
</span><span class="miss">            objecttools.augmentexcmessage()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StdOutErr(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self, indent=0):
</span><span class="miss">        self.indent = indent
</span><span class="miss">        self.stdout = sys.stdout
</span><span class="miss">        self.stderr = sys.stderr
</span><span class="miss">        self.encoding = sys.stdout.encoding
</span><span class="miss">        self.texts = []
</span><span class="noop">
</span><span class="hit">    def __enter__(self):
</span><span class="miss">        self.encoding = sys.stdout.encoding
</span><span class="miss">        sys.stdout = self
</span><span class="miss">        sys.stderr = self
</span><span class="noop">
</span><span class="hit">    def __exit__(self, exception, message, traceback_):
</span><span class="miss">        if not self.texts:
</span><span class="miss">            self.print_(&#39;no failures occurred&#39;)
</span><span class="noop">        else:
</span><span class="miss">            for text in self.texts:
</span><span class="miss">                self.print_(text)
</span><span class="miss">        sys.stdout = self.stdout
</span><span class="miss">        sys.stderr = self.stderr
</span><span class="miss">        if exception:
</span><span class="miss">            objecttools.augmentexcmessage()
</span><span class="noop">
</span><span class="hit">    def write(self, text):
</span><span class="miss">        self.texts.extend(text.split(&#39;\n&#39;))
</span><span class="noop">
</span><span class="hit">    def print_(self, text):
</span><span class="miss">        if text.strip():
</span><span class="miss">            self.stdout.write(self.indent*&#39; &#39; + text + &#39;\n&#39;)
</span><span class="noop">
</span><span class="hit">    def flush(self):
</span><span class="miss">        pass
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def parameterstep(timestep=None):
</span><span class="noop">    &#34;&#34;&#34;Define a parameter time step size within a parameter control file.
</span><span class="noop">
</span><span class="noop">    Argument:
</span><span class="noop">      * timestep(:class:`~hydpy.core.timetools.Period`): Time step size.
</span><span class="noop">
</span><span class="noop">    Function :func:`parameterstep` should usually be be applied in a line
</span><span class="noop">    immediately behind the model import.  Defining the step size of time
</span><span class="noop">    dependent parameters is a prerequisite to access any model specific
</span><span class="noop">    parameter.
</span><span class="noop">
</span><span class="noop">    Note that :func:`parameterstep` implements some namespace magic by
</span><span class="noop">    means of the module :mod:`inspect`.  This makes things a little
</span><span class="noop">    complicated for framework developers, but it eases the definition of
</span><span class="noop">    parameter control files for framework users.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if timestep is not None:
</span><span class="hit">        parametertools.Parameter._parameterstep = timetools.Period(timestep)
</span><span class="hit">    namespace = inspect.currentframe().f_back.f_locals
</span><span class="hit">    model = namespace.get(&#39;model&#39;)
</span><span class="hit">    if model is None:
</span><span class="hit">        model = namespace[&#39;Model&#39;]()
</span><span class="hit">        namespace[&#39;model&#39;] = model
</span><span class="hit">        if pub.options.usecython and &#39;cythonizer&#39; in namespace:
</span><span class="miss">            cythonizer = namespace[&#39;cythonizer&#39;]
</span><span class="miss">            namespace[&#39;cythonmodule&#39;] = cythonizer.cymodule
</span><span class="miss">            model.cymodel = cythonizer.cymodule.Model()
</span><span class="miss">            namespace[&#39;cymodel&#39;] = model.cymodel
</span><span class="miss">            model.cymodel.parameters = cythonizer.cymodule.Parameters()
</span><span class="miss">            model.cymodel.sequences = cythonizer.cymodule.Sequences()
</span><span class="miss">            for numpars_name in (&#39;NumConsts&#39;, &#39;NumVars&#39;):
</span><span class="miss">                if hasattr(cythonizer.cymodule, numpars_name):
</span><span class="miss">                    numpars_new = getattr(cythonizer.cymodule, numpars_name)()
</span><span class="miss">                    numpars_old = getattr(model, numpars_name.lower())
</span><span class="miss">                    for (name_numpar, numpar) in numpars_old:
</span><span class="miss">                        setattr(numpars_new, name_numpar, numpar)
</span><span class="miss">                    setattr(model.cymodel, numpars_name.lower(), numpars_new)
</span><span class="miss">            for name in dir(model.cymodel):
</span><span class="miss">                if (not name.startswith(&#39;_&#39;)) and hasattr(model, name):
</span><span class="miss">                    setattr(model, name, getattr(model.cymodel, name))
</span><span class="hit">        if &#39;Parameters&#39; not in namespace:
</span><span class="hit">            namespace[&#39;Parameters&#39;] = parametertools.Parameters
</span><span class="hit">        model.parameters = namespace[&#39;Parameters&#39;](namespace)
</span><span class="hit">        if &#39;Sequences&#39; not in namespace:
</span><span class="hit">            namespace[&#39;Sequences&#39;] = sequencetools.Sequences
</span><span class="hit">        model.sequences = namespace[&#39;Sequences&#39;](**namespace)
</span><span class="hit">        namespace[&#39;parameters&#39;] = model.parameters
</span><span class="hit">        for (name, pars) in model.parameters:
</span><span class="hit">            namespace[name] = pars
</span><span class="hit">        namespace[&#39;sequences&#39;] = model.sequences
</span><span class="hit">        for (name, seqs) in model.sequences:
</span><span class="hit">            namespace[name] = seqs
</span><span class="hit">    try:
</span><span class="hit">        namespace.update(namespace[&#39;CONSTANTS&#39;])
</span><span class="hit">    except KeyError:
</span><span class="hit">        pass
</span><span class="hit">    focus = namespace.get(&#39;focus&#39;)
</span><span class="hit">    for (name, par) in model.parameters.control:
</span><span class="hit">        try:
</span><span class="hit">            if (focus is None) or (par is focus):
</span><span class="hit">                namespace[par.name] = par
</span><span class="noop">            else:
</span><span class="miss">                namespace[par.name] = lambda *args, **kwargs: None
</span><span class="miss">        except AttributeError:
</span><span class="miss">            pass
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def reverse_model_wildcard_import():
</span><span class="noop">    &#34;&#34;&#34;Clear the local namespace from a model wildcard import.
</span><span class="noop">
</span><span class="noop">    Calling this method should remove the critical imports into the local
</span><span class="noop">    namespace due the last wildcard import of a certain application model.
</span><span class="noop">    It is thought for securing the successive preperation of different
</span><span class="noop">    types of models via wildcard imports.  See the following example, on
</span><span class="noop">    how it can be applied.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.magictools import reverse_model_wildcard_import
</span><span class="noop">
</span><span class="noop">    Assume you wildcard import the first version of HydPy-L-Land
</span><span class="noop">    (:mod:`~hydpy.models.lland_v1`):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland_v1 import *
</span><span class="noop">
</span><span class="noop">    This for example adds the collection class for handling control
</span><span class="noop">    parameters of `lland_v1` into the local namespace:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; print(ControlParameters(None).name)
</span><span class="noop">    control
</span><span class="noop">
</span><span class="noop">    Calling function :func:`~hydpy.core.magictools.parameterstep` for example
</span><span class="noop">    prepares the control parameter object
</span><span class="noop">    :class:`~hydpy.models.lland.lland_control.nhru`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; nhru
</span><span class="noop">    nhru(-999999)
</span><span class="noop">
</span><span class="noop">    Calling function
</span><span class="noop">    :func:`~hydpy.core.magictools.reverse_model_wildcard_import` removes both
</span><span class="noop">    objects (and many more, but not all) from the local namespace:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; reverse_model_wildcard_import()
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; ControlParameters
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    NameError: name &#39;ControlParameters&#39; is not defined
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nhru
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    NameError: name &#39;nhru&#39; is not defined
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    namespace = inspect.currentframe().f_back.f_locals
</span><span class="hit">    model = namespace.get(&#39;model&#39;)
</span><span class="hit">    if model is not None:
</span><span class="hit">        for (name_subpars, subpars) in model.parameters:
</span><span class="hit">            for (name_par, par) in subpars:
</span><span class="hit">                namespace.pop(name_par, None)
</span><span class="hit">                namespace.pop(objecttools.classname(par), None)
</span><span class="hit">            namespace.pop(name_subpars, None)
</span><span class="hit">            namespace.pop(objecttools.classname(subpars), None)
</span><span class="hit">        for (name_subseqs, subseqs) in model.sequences:
</span><span class="hit">            for (name_seq, seq) in subseqs:
</span><span class="hit">                namespace.pop(name_seq, None)
</span><span class="hit">                namespace.pop(objecttools.classname(seq), None)
</span><span class="hit">            namespace.pop(name_subseqs, None)
</span><span class="hit">            namespace.pop(objecttools.classname(subseqs), None)
</span><span class="hit">        for name in (&#39;parameters&#39;, &#39;sequences&#39;, &#39;model&#39;,
</span><span class="noop">                     &#39;Parameters&#39;, &#39;Sequences&#39;, &#39;Model&#39;,
</span><span class="noop">                     &#39;cythonizer&#39;, &#39;cymodel&#39;, &#39;cythonmodule&#39;):
</span><span class="hit">            namespace.pop(name, None)
</span><span class="hit">        for key in list(namespace.keys()):
</span><span class="hit">            try:
</span><span class="hit">                if namespace[key].__module__ == model.__module__:
</span><span class="miss">                    del namespace[key]
</span><span class="hit">            except AttributeError:
</span><span class="hit">                pass
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def prepare_model(module, timestep=None):
</span><span class="noop">    &#34;&#34;&#34;Prepare and return the model of the given module.
</span><span class="noop">
</span><span class="noop">    In usual HydPy projects, each hydrological model instance is prepared
</span><span class="noop">    in an individual control file.  This allows for &#34;polluting&#34; the
</span><span class="noop">    namespace with different model attributes.  There is no danger of
</span><span class="noop">    name conflicts, as long as no other (wildcard) imports are performed.
</span><span class="noop">
</span><span class="noop">    However, there are situations when different models are to be loaded
</span><span class="noop">    into the same namespace.  Then it is advisable to use function
</span><span class="noop">    :func:`prepare_model`, which just returns a reference to the model
</span><span class="noop">    and nothing else.
</span><span class="noop">
</span><span class="noop">    See the documentation of :mod:`~hydpy.models.dam_v1` on how to apply
</span><span class="noop">    function :func:`prepare_model` properly.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if timestep is not None:
</span><span class="miss">        parametertools.Parameter._parameterstep = timetools.Period(timestep)
</span><span class="hit">    model = module.Model()
</span><span class="hit">    if pub.options.usecython and hasattr(module, &#39;cythonizer&#39;):
</span><span class="miss">        cymodule = module.cythonizer.cymodule
</span><span class="miss">        cymodel = cymodule.Model()
</span><span class="miss">        cymodel.parameters = cymodule.Parameters()
</span><span class="miss">        cymodel.sequences = cymodule.Sequences()
</span><span class="miss">        model.cymodel = cymodel
</span><span class="miss">        for numpars_name in (&#39;NumConsts&#39;, &#39;NumVars&#39;):
</span><span class="miss">            if hasattr(cymodule, numpars_name):
</span><span class="miss">                numpars_new = getattr(cymodule, numpars_name)()
</span><span class="miss">                numpars_old = getattr(model, numpars_name.lower())
</span><span class="miss">                for (name_numpar, numpar) in numpars_old:
</span><span class="miss">                    setattr(numpars_new, name_numpar, numpar)
</span><span class="miss">                setattr(cymodel, numpars_name.lower(), numpars_new)
</span><span class="miss">        for name in dir(cymodel):
</span><span class="miss">            if (not name.startswith(&#39;_&#39;)) and hasattr(model, name):
</span><span class="miss">                setattr(model, name, getattr(cymodel, name))
</span><span class="miss">        dict_ = {&#39;cythonmodule&#39;: cymodule,
</span><span class="noop">                 &#39;cymodel&#39;: cymodel}
</span><span class="noop">    else:
</span><span class="hit">        dict_ = {}
</span><span class="hit">    dict_.update(vars(module))
</span><span class="hit">    dict_[&#39;model&#39;] = model
</span><span class="hit">    if hasattr(module, &#39;Parameters&#39;):
</span><span class="miss">        model.parameters = module.Parameters(dict_)
</span><span class="noop">    else:
</span><span class="hit">        model.parameters = parametertools.Parameters(dict_)
</span><span class="hit">    if hasattr(module, &#39;Sequences&#39;):
</span><span class="miss">        model.sequences = module.Sequences(**dict_)
</span><span class="noop">    else:
</span><span class="hit">        model.sequences = sequencetools.Sequences(**dict_)
</span><span class="hit">    return model
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def simulationstep(timestep):
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">    Define a simulation time step size for testing purposes within a
</span><span class="noop">    parameter control file.
</span><span class="noop">
</span><span class="noop">    Argument:
</span><span class="noop">        * timestep(:class:`~hydpy.core.timetools.Period`): Time step size.
</span><span class="noop">
</span><span class="noop">    Using :func:`simulationstep` only affects the values of time dependent
</span><span class="noop">    parameters, when `pub.timegrids.stepsize` is not defined.  It thus has
</span><span class="noop">    no influence on usual hydpy simulations at all.  Use it just to check
</span><span class="noop">    your parameter control files.  Write it in a line immediately behind
</span><span class="noop">    the one calling :func:`parameterstep`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if pub.options.warnsimulationstep:
</span><span class="miss">        warnings.warn(&#39;Note that the applied function `simulationstep` is &#39;
</span><span class="noop">                      &#39;inteded for testing purposes only.  When doing a &#39;
</span><span class="noop">                      &#39;hydpy simulation, parameter values are initialized &#39;
</span><span class="noop">                      &#39;based on the actual simulation time step as defined &#39;
</span><span class="noop">                      &#39;under `pub.timegrids.stepsize` and the value given &#39;
</span><span class="noop">                      &#39;to `simulationstep` is ignored.&#39;)
</span><span class="hit">    parametertools.Parameter._simulationstep = timetools.Period(timestep)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def controlcheck(controldir=&#39;default&#39;, projectdir=None, controlfile=None):
</span><span class="miss">    namespace = inspect.currentframe().f_back.f_locals
</span><span class="miss">    model = namespace.get(&#39;model&#39;)
</span><span class="miss">    if model is None:
</span><span class="miss">        if projectdir is None:
</span><span class="miss">            projectdir = os.path.dirname(os.path.abspath(os.curdir))
</span><span class="miss">            projectdir = os.path.split(projectdir)[-1]
</span><span class="miss">        os.chdir(os.path.join(&#39;..&#39;, &#39;..&#39;, &#39;..&#39;))
</span><span class="miss">        controlpath = os.path.abspath(os.path.join(&#39;control&#39;,
</span><span class="noop">                                                   projectdir,
</span><span class="noop">                                                   controldir))
</span><span class="miss">        initfile = os.path.split(namespace[&#39;__file__&#39;])[-1]
</span><span class="miss">        if controlfile is None:
</span><span class="miss">            controlfile = initfile
</span><span class="miss">        filepath = os.path.join(controlpath, controlfile)
</span><span class="miss">        if not os.path.exists(filepath):
</span><span class="miss">            raise IOError(&#39;The check of consistency between the control &#39;
</span><span class="noop">                          &#39;parameter file %s and the initial condition file &#39;
</span><span class="noop">                          &#39;%s failed.  The control parameter file does not &#39;
</span><span class="noop">                          &#39;exist in directory %s.&#39;
</span><span class="noop">                          % (controlfile, initfile, controlpath))
</span><span class="miss">        controlmanager = filetools.ControlManager()
</span><span class="miss">        controlmanager.projectdirectory = projectdir
</span><span class="miss">        controlmanager.selecteddirectory = controldir
</span><span class="miss">        model = controlmanager.loadfile(controlfile)[&#39;model&#39;]
</span><span class="miss">        model.parameters.update()
</span><span class="miss">        namespace[&#39;model&#39;] = model
</span><span class="miss">        for name1 in (&#39;states&#39;, &#39;logs&#39;):
</span><span class="miss">            subseqs = getattr(model.sequences, name1, None)
</span><span class="miss">            if subseqs is not None:
</span><span class="miss">                for (name2, seq) in subseqs:
</span><span class="miss">                    namespace[name2] = seq
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">lines_print_progress_wrapper = \
</span><span class="noop">    [&#39;def printprogress_wrapper(*args, **kwargs):&#39;,
</span><span class="noop">     &#39;    &#34;&#34;&#34;Wrapper for HydPy methods to print when they start and end.&#39;,
</span><span class="noop">     &#39;&#39;,
</span><span class="noop">     &#39;    The wrapper is general in its function arguments.  When one uses &#39;,
</span><span class="noop">     &#39;    the decorator :func:`printprogress`, the general arguments are &#39;,
</span><span class="noop">     &#39;    replaced by the specific ones of the method to be wrapped.&#39;,
</span><span class="noop">     &#39;    &#34;&#34;&#34;&#39;,
</span><span class="noop">     &#39;    import sys&#39;,
</span><span class="noop">     &#39;    import time&#39;,
</span><span class="noop">     &#39;    from hydpy import pub&#39;,
</span><span class="noop">     &#39;    from hydpy.core.magictools import PrintStyle&#39;,
</span><span class="noop">     &#39;    pub._printprogress_indentation += 4&#39;,
</span><span class="noop">     &#39;    try:&#39;,
</span><span class="noop">     &#39;        if pub.options.printprogress:&#39;,
</span><span class="noop">     &#39;            with PrintStyle(color=34, font=1):&#39;,
</span><span class="noop">     &#34;                print(&#39;\\n%sHydPy method %s...&#39;&#34;,
</span><span class="noop">     &#34;                      % (&#39; &#39;*pub._printprogress_indentation,&#34;,
</span><span class="noop">     &#39;                         printprogress_wrapped.__name__))&#39;,
</span><span class="noop">     &#39;                print(&#34;%s    ...started at %s.&#34;&#39;,
</span><span class="noop">     &#34;                      % (&#39; &#39;*pub._printprogress_indentation,&#34;,
</span><span class="noop">     &#39;                         time.strftime(&#34;%X&#34;)))&#39;,
</span><span class="noop">     &#39;        printprogress_wrapped()&#39;,
</span><span class="noop">     &#39;        if pub.options.printprogress:&#39;,
</span><span class="noop">     &#39;            with PrintStyle(color=34, font=1):&#39;,
</span><span class="noop">     &#39;                print(&#34;%s    ...ended at %s.&#34;&#39;,
</span><span class="noop">     &#34;                      % (&#39; &#39;*pub._printprogress_indentation,&#34;,
</span><span class="noop">     &#39;                         time.strftime(&#34;%X&#34;)))&#39;,
</span><span class="noop">     &#39;    finally:&#39;,
</span><span class="noop">     &#39;        pub._printprogress_indentation -= 4&#39;]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def zip_longest(*iterables, **kwargs):
</span><span class="noop">    &#34;&#34;&#34;Return the iterator defined by `zip_longest` or `izip_longest` of
</span><span class="noop">    module :mod:`itertools` under Python 2 and 3 respectively.&#34;&#34;&#34;
</span><span class="miss">    if pub.pyversion &lt; 3:
</span><span class="miss">        return itertools.izip_longest(*iterables, **kwargs)
</span><span class="noop">    else:
</span><span class="miss">        return itertools.zip_longest(*iterables, **kwargs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def signature(function):
</span><span class="noop">    &#34;&#34;&#34;Return the signature of the given function (possibly without variable
</span><span class="noop">    positional and keyword arguments) as a string.
</span><span class="noop">
</span><span class="noop">    If available, the result should be determined by function
</span><span class="noop">    :func:`~inspect.signature` of module :mod:`inspect` (Python 3).
</span><span class="noop">    If something wrents wrong, a less general costum made string is
</span><span class="noop">    returned (Python 2).
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    try:
</span><span class="hit">        return str(inspect.signature(function))
</span><span class="miss">    except BaseException:
</span><span class="miss">        argspec = inspect.getargspec(function)
</span><span class="miss">        args = argspec.args if argspec.args else []
</span><span class="miss">        defaults = argspec.defaults if argspec.defaults else []
</span><span class="miss">        strings = []
</span><span class="miss">        for arg, default in zip_longest(reversed(args), reversed(defaults)):
</span><span class="miss">            if default is None:
</span><span class="miss">                strings.insert(0, arg)
</span><span class="noop">            else:
</span><span class="miss">                strings.insert(0, &#39;%s=%s&#39; % (arg, default))
</span><span class="miss">        return &#39;(%s)&#39; % &#39;, &#39;.join(strings)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _signature_without_default_values(signature):
</span><span class="noop">    &#34;&#34;&#34;Return the given signature string without default values.&#34;&#34;&#34;
</span><span class="hit">    return &#39;(%s)&#39; % &#39;, &#39;.join(sig.partition(&#39;=&#39;)[0] for sig in
</span><span class="noop">                              signature[1:-1].split(&#39;, &#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def printprogress(printprogress_wrapped):
</span><span class="noop">    &#34;&#34;&#34;Decorator for wrapping HydPy methods with
</span><span class="noop">    :func:`printprogress_wrapper_generalized`.
</span><span class="noop">
</span><span class="noop">    Hopefully, all relevant attributes of the wrapped method are maintained.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    funcname = printprogress_wrapped.__name__
</span><span class="hit">    lines = lines_print_progress_wrapper[:]
</span><span class="hit">    lines[0] = lines[0].replace(&#39;printprogress_wrapper&#39;, funcname)
</span><span class="hit">    sign = signature(printprogress_wrapped)
</span><span class="hit">    short_sign = _signature_without_default_values(sign)
</span><span class="hit">    lines[0] = lines[0].replace(&#39;(*args, **kwargs)&#39;, sign)
</span><span class="hit">    lines[21] = lines[21].replace(&#39;()&#39;, short_sign)
</span><span class="hit">    exec(&#39;\n&#39;.join(lines), locals(), globals())
</span><span class="hit">    functools.update_wrapper(eval(funcname), printprogress_wrapped)
</span><span class="hit">    return eval(funcname)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def progressbar(iterable, length=23):
</span><span class="noop">    &#34;&#34;&#34;Print a simple progress bar while processing the given iterable.
</span><span class="noop">
</span><span class="noop">    Function :func:`progressbar` does print the progress bar when option
</span><span class="noop">    `printprogress` is activted:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">    &gt;&gt;&gt; pub.options.printprogress = True
</span><span class="noop">
</span><span class="noop">    You can pass an iterable object.  Say you want to calculate the the sum
</span><span class="noop">    of all integer values from 1 to 100 and print the progress of the
</span><span class="noop">    calculation.  Using function :func:`range` (which returns a list in
</span><span class="noop">    Python 2 and an iterator in Python3, but both are fine), one just has
</span><span class="noop">    to  interpose function :func:`progressbar`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.magictools import progressbar
</span><span class="noop">    &gt;&gt;&gt; x_sum = 0
</span><span class="noop">    &gt;&gt;&gt; for x in progressbar(range(1, 101)):
</span><span class="noop">    ...     x_sum += x
</span><span class="noop">        |---------------------|
</span><span class="noop">        ***********************
</span><span class="noop">    &gt;&gt;&gt; x_sum
</span><span class="noop">    5050
</span><span class="noop">
</span><span class="noop">    To prevent possible interim print commands from dismembering the status
</span><span class="noop">    bar, they are delayed until the status bar is complete.  For intermediate
</span><span class="noop">    print outs of each fiftieth calculation, the result looks as follows:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; x_sum = 0
</span><span class="noop">    &gt;&gt;&gt; for x in progressbar(range(1, 101)):
</span><span class="noop">    ...     x_sum += x
</span><span class="noop">    ...     if not x % 50:
</span><span class="noop">    ...         print(x, x_sum)
</span><span class="noop">        |---------------------|
</span><span class="noop">        ***********************
</span><span class="noop">    50 1275
</span><span class="noop">    100 5050
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    The number of characters of the progress bar can be changed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; for i in progressbar(range(100), length=50):
</span><span class="noop">    ...     continue
</span><span class="noop">        |------------------------------------------------|
</span><span class="noop">        **************************************************
</span><span class="noop">
</span><span class="noop">    But its maximum number of characters is restricted by the length of the
</span><span class="noop">    given iterable:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; for i in progressbar(range(10), length=50):
</span><span class="noop">    ...     continue
</span><span class="noop">        |--------|
</span><span class="noop">        **********
</span><span class="noop">
</span><span class="noop">    The smallest possible progress bar has two characters:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; for i in progressbar(range(2)):
</span><span class="noop">    ...     continue
</span><span class="noop">        ||
</span><span class="noop">        **
</span><span class="noop">
</span><span class="noop">    For iterables of length one or zero, no progress bar is plottet:
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; for i in progressbar(range(1)):
</span><span class="noop">    ...     continue
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    The same is True when the `printprogress` option is inactivated:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; pub.options.printprogress = False
</span><span class="noop">    &gt;&gt;&gt; for i in progressbar(range(100)):
</span><span class="noop">    ...     continue
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if pub.options.printprogress and (len(iterable) &gt; 1):
</span><span class="hit">        temp_name = os.path.join(tempfile.gettempdir(),
</span><span class="noop">                                 &#39;HydPy_progressbar_stdout&#39;)
</span><span class="hit">        temp_stdout = open(temp_name, &#39;w&#39;)
</span><span class="hit">        real_stdout = sys.stdout
</span><span class="hit">        try:
</span><span class="hit">            sys.stdout = temp_stdout
</span><span class="hit">            nmbstars = min(len(iterable), length)
</span><span class="hit">            nmbcounts = len(iterable)/nmbstars
</span><span class="hit">            indentation = &#39; &#39;*max(pub._printprogress_indentation, 0)
</span><span class="hit">            with PrintStyle(color=36, font=1, file=real_stdout):
</span><span class="hit">                print(&#39;    %s|%s|\n%s    &#39; % (indentation,
</span><span class="noop">                                              &#39;-&#39;*(nmbstars-2),
</span><span class="noop">                                              indentation),
</span><span class="noop">                      end=&#39;&#39;,
</span><span class="noop">                      file=real_stdout)
</span><span class="hit">                counts = 1.
</span><span class="hit">                for next_ in iterable:
</span><span class="hit">                    counts += 1.
</span><span class="hit">                    if counts &gt;= nmbcounts:
</span><span class="hit">                        print(end=&#39;*&#39;, file=real_stdout)
</span><span class="hit">                        counts -= nmbcounts
</span><span class="hit">                    yield next_
</span><span class="noop">        finally:
</span><span class="hit">            try:
</span><span class="hit">                temp_stdout.close()
</span><span class="miss">            except BaseException:
</span><span class="miss">                pass
</span><span class="hit">            sys.stdout = real_stdout
</span><span class="hit">            print()
</span><span class="hit">            with open(temp_name, &#39;r&#39;) as temp_stdout:
</span><span class="hit">                sys.stdout.write(temp_stdout.read())
</span><span class="noop">    else:
</span><span class="hit">        for next_ in iterable:
</span><span class="hit">            yield next_
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/modelimports.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/modelimports.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">&#34;&#34;&#34;This module bundles imports generally required for implementing nmodels.
</span><span class="noop">
</span><span class="noop">Module :mod:`modelimports` is supposed to shorten the import section
</span><span class="noop">of base and application models implemented.  Just write:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.core.modelimports import *
</span><span class="noop">
</span><span class="noop">Thereafter, the following objects are available:
</span><span class="noop"> * module :mod:`numpy`
</span><span class="noop"> * numpys :obj:`~numpy.nan` and :obj:`~numpy.inf`
</span><span class="noop"> * functions :func:`~hydpy.core.magictools.parameterstep`,
</span><span class="noop">   :func:`~hydpy.core.magictools.simulationstep`,
</span><span class="noop">   :func:`~hydpy.core.autodoctools.autodoc_basemodel`,
</span><span class="noop">   of module :mod:`~hydpy.core.magictools`
</span><span class="noop"> * class :class:`~hydpy.core.magictools.Tester`
</span><span class="noop">   of module :mod:`~hydpy.core.magictools`
</span><span class="noop"> * class :class:`~hydpy.cythons.modelutils.Cythonizer`
</span><span class="noop">   of module :mod:`~hydpy.cythons.modelutils`
</span><span class="noop">
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...third party
</span><span class="hit">import numpy
</span><span class="hit">from numpy import nan
</span><span class="hit">from numpy import inf
</span><span class="noop"># ...HydPy specific
</span><span class="noop"># Load the required `magic` functions into the local namespace.
</span><span class="hit">from hydpy.core.magictools import parameterstep
</span><span class="hit">from hydpy.core.magictools import simulationstep
</span><span class="hit">from hydpy.core.magictools import controlcheck
</span><span class="hit">from hydpy.core.autodoctools import autodoc_basemodel
</span><span class="hit">from hydpy.core.magictools import Tester
</span><span class="hit">from hydpy.cythons.modelutils import Cythonizer
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/modeltools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/modeltools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements tools for the development of hydrological models.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import types
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy import conf
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="hit">from hydpy.cythons import modelutils
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MetaModel(type):
</span><span class="hit">    def __new__(cls, cls_name, cls_parents, dict_):
</span><span class="hit">        _METHOD_GROUPS = (&#39;_RUN_METHODS&#39;, &#39;_ADD_METHODS&#39;,
</span><span class="noop">                          &#39;_INLET_METHODS&#39;, &#39;_OUTLET_METHODS&#39;,
</span><span class="noop">                          &#39;_RECEIVER_METHODS&#39;, &#39;_SENDER_METHODS&#39;,
</span><span class="noop">                          &#39;_PART_ODE_METHODS&#39;, &#39;_FULL_ODE_METHODS&#39;)
</span><span class="hit">        dict_[&#39;_METHOD_GROUPS&#39;] = _METHOD_GROUPS
</span><span class="hit">        for method_name in _METHOD_GROUPS:
</span><span class="hit">            methods = dict_.get(method_name, ())
</span><span class="hit">            if methods:
</span><span class="hit">                if method_name == &#39;_RUN_METHODS&#39;:
</span><span class="hit">                    lst = [&#39;\n\n\n    The following &#34;run methods&#34; are called &#39;
</span><span class="noop">                           &#39;each simulation step run in the given sequence:&#39;]
</span><span class="hit">                elif method_name == &#39;_ADD_METHODS&#39;:
</span><span class="hit">                    lst = [&#39;\n\n\n    The following &#34;additional methods&#34; are &#39;
</span><span class="noop">                           &#39;called by at least one &#34;run method&#34;:&#39;]
</span><span class="hit">                elif method_name == &#39;_INLET_METHODS&#39;:
</span><span class="hit">                    lst = [&#39;\n\n\n    The following &#34;inlet update methods&#34; &#39;
</span><span class="noop">                           &#39;are called in the given sequence immediately  &#39;
</span><span class="noop">                           &#39;before solving the differential equations &#39;
</span><span class="noop">                           &#39;of the respective model:&#39;]
</span><span class="hit">                elif method_name == &#39;_OUTLET_METHODS&#39;:
</span><span class="hit">                    lst = [&#39;\n\n\n    The following &#34;outlet update methods&#34; &#39;
</span><span class="noop">                           &#39;are called in the given sequence immediately  &#39;
</span><span class="noop">                           &#39;after solving the differential equations &#39;
</span><span class="noop">                           &#39;of the respective model:&#39;]
</span><span class="hit">                elif method_name == &#39;_RECEIVER_METHODS&#39;:
</span><span class="hit">                    lst = [&#39;\n\n\n    The following &#34;receiver update methods&#34; &#39;
</span><span class="noop">                           &#39;are called in the given sequence before solving &#39;
</span><span class="noop">                           &#39;the differential equations of any model:&#39;]
</span><span class="hit">                elif method_name == &#39;_SENDER_METHODS&#39;:
</span><span class="miss">                    lst = [&#39;\n\n\n    The following &#34;sender update methods&#34; &#39;
</span><span class="noop">                           &#39;are called in the given sequence after solving &#39;
</span><span class="noop">                           &#39;the differential equations of all models:&#39;]
</span><span class="hit">                elif method_name == &#39;_PART_ODE_METHODS&#39;:
</span><span class="hit">                    lst = [&#39;\n\n\n    The following methods define the &#39;
</span><span class="noop">                           &#39;relevant components of a system of ODE &#39;
</span><span class="noop">                           &#39;equations (e.g. direct runoff):&#39;]
</span><span class="hit">                elif method_name == &#39;_FULL_ODE_METHODS&#39;:
</span><span class="hit">                    lst = [&#39;\n\n\n    The following methods define the &#39;
</span><span class="noop">                           &#39;complete equations of an ODE system &#39;
</span><span class="noop">                           &#39;(e.g. change in storage of `fast water` due to &#39;
</span><span class="noop">                           &#39; effective precipitation and direct runoff):&#39;]
</span><span class="hit">                for method in methods:
</span><span class="hit">                    lst.append(&#39;      * :func:`~%s` `%s`&#39;
</span><span class="noop">                               % (&#39;.&#39;.join((method.__module__,
</span><span class="noop">                                            method.__name__)),
</span><span class="noop">                                  autodoctools.description(method)))
</span><span class="hit">                doc = dict_.get(&#39;__doc__&#39;, &#39;Undocumented model.&#39;)
</span><span class="hit">                dict_[&#39;__doc__&#39;] = doc + &#39;\n&#39;.join(l for l in lst)
</span><span class="noop">
</span><span class="hit">        return type.__new__(cls, cls_name, cls_parents, dict_)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">_MetaModel = MetaModel(&#39;MetaModel&#39;, (), {})
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(_MetaModel):
</span><span class="noop">    &#34;&#34;&#34;Base class for all hydrological models.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    NUMERICAL = False
</span><span class="noop">
</span><span class="hit">    _RUN_METHODS = ()
</span><span class="hit">    _ADD_METHODS = ()
</span><span class="hit">    _INLET_METHODS = ()
</span><span class="hit">    _OUTLET_METHODS = ()
</span><span class="hit">    _RECEIVER_METHODS = ()
</span><span class="hit">    _SENDER_METHODS = ()
</span><span class="hit">    _PART_ODE_METHODS = ()
</span><span class="hit">    _FULL_ODE_METHODS = ()
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.element = None
</span><span class="hit">        self.parameters = None
</span><span class="hit">        self.sequences = None
</span><span class="hit">        self.cymodel = objecttools.FastAccess()
</span><span class="hit">        self.cymodel.idx_sim = -999
</span><span class="hit">        self._init_methods()
</span><span class="noop">
</span><span class="hit">    def _init_methods(self):
</span><span class="noop">        &#34;&#34;&#34;Convert all pure Python calculation functions of the model class to
</span><span class="noop">        methods and assign them to the model instance.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        for name_group in self._METHOD_GROUPS:
</span><span class="hit">            functions = getattr(self, name_group, ())
</span><span class="hit">            uniques = {}
</span><span class="hit">            for func in functions:
</span><span class="hit">                name_func = func.__name__
</span><span class="hit">                method = types.MethodType(func, self)
</span><span class="hit">                setattr(self, name_func, method)
</span><span class="hit">                shortname = &#39;_&#39;.join(name_func.split(&#39;_&#39;)[:-1])
</span><span class="hit">                if shortname in uniques:
</span><span class="hit">                    uniques[shortname] = None
</span><span class="noop">                else:
</span><span class="hit">                    uniques[shortname] = method
</span><span class="hit">            for (shortname, method) in uniques.items():
</span><span class="hit">                if method is not None:
</span><span class="hit">                    setattr(self, shortname, method)
</span><span class="noop">
</span><span class="hit">    def connect(self):
</span><span class="noop">        &#34;&#34;&#34;Connect the link sequences of the actual model.&#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            for group in (&#39;inlets&#39;, &#39;receivers&#39;, &#39;outlets&#39;, &#39;senders&#39;):
</span><span class="hit">                self._connect_subgroup(group)
</span><span class="miss">        except BaseException:
</span><span class="miss">            objecttools.augmentexcmessage(
</span><span class="noop">                &#39;While trying to build the node connection of the `%s` &#39;
</span><span class="noop">                &#39;sequences of the model handled by element `%s`&#39;
</span><span class="noop">                % (group[:-1],  objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def _connect_subgroup(self, group):
</span><span class="hit">        isentry = group in (&#39;inlets&#39;, &#39;receivers&#39;)
</span><span class="hit">        available_nodes = getattr(self.element, group).slaves
</span><span class="hit">        links = getattr(self.sequences, group, ())
</span><span class="hit">        applied_nodes = []
</span><span class="hit">        for (name, seq) in links:
</span><span class="hit">            selected_nodes = [node for node in available_nodes
</span><span class="noop">                              if node.variable.lower() == name]
</span><span class="hit">            if isentry:
</span><span class="hit">                selected_doubles = [node.get_double_via_exits()
</span><span class="noop">                                    for node in selected_nodes]
</span><span class="noop">            else:
</span><span class="hit">                selected_doubles = [node.get_double_via_entries()
</span><span class="noop">                                    for node in selected_nodes]
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                if len(selected_nodes) == 1:
</span><span class="hit">                    applied_nodes.append(selected_nodes[0])
</span><span class="hit">                    seq.setpointer(selected_doubles[0])
</span><span class="miss">                elif len(selected_nodes) == 0:
</span><span class="miss">                    raise RuntimeError(&#39;Sequence `%s` cannot be connected, &#39;
</span><span class="noop">                                       &#39;as no node is available which is &#39;
</span><span class="noop">                                       &#39;handling the variable `%s`.&#39;
</span><span class="noop">                                       % (name, seq.name.upper()))
</span><span class="noop">                else:
</span><span class="miss">                    raise RuntimeError(&#39;Sequence `%s` cannot be connected, &#39;
</span><span class="noop">                                       &#39;as it is 0-dimensional but multiple &#39;
</span><span class="noop">                                       &#39;nodes are available which are &#39;
</span><span class="noop">                                       &#39;handling variable `%s`.&#39;
</span><span class="noop">                                       % (name, seq.name.upper()))
</span><span class="hit">            elif seq.NDIM == 1:
</span><span class="hit">                seq.shape = len(selected_nodes)
</span><span class="hit">                zipped = zip(selected_nodes, selected_doubles)
</span><span class="hit">                for idx, (node, double) in enumerate(zipped):
</span><span class="hit">                    applied_nodes.append(node)
</span><span class="hit">                    seq.setpointer(double, idx)
</span><span class="hit">        if len(applied_nodes) &lt; len(available_nodes):
</span><span class="miss">            remaining_nodes = [node.name for node in available_nodes
</span><span class="noop">                               if node not in applied_nodes]
</span><span class="miss">            raise RuntimeError(&#39;The following nodes have not been connected &#39;
</span><span class="noop">                               &#39;to any sequences: `%s`.&#39;
</span><span class="noop">                               % &#39;, &#39;.join(remaining_nodes))
</span><span class="noop">
</span><span class="hit">    def doit(self, idx):
</span><span class="hit">        self.idx_sim = idx
</span><span class="hit">        self.loaddata()
</span><span class="hit">        self.update_inlets()
</span><span class="hit">        self.run()
</span><span class="hit">        self.new2old()
</span><span class="hit">        self.update_outlets()
</span><span class="hit">        self.savedata()
</span><span class="noop">
</span><span class="hit">    def run(self):
</span><span class="hit">        for method in self._RUN_METHODS:
</span><span class="hit">            method(self)
</span><span class="noop">
</span><span class="hit">    def loaddata(self):
</span><span class="hit">        self.sequences.loaddata(self.idx_sim)
</span><span class="noop">
</span><span class="hit">    def savedata(self):
</span><span class="hit">        self.sequences.savedata(self.idx_sim)
</span><span class="noop">
</span><span class="hit">    def update_inlets(self):
</span><span class="hit">        for method in self._INLET_METHODS:
</span><span class="hit">            method(self)
</span><span class="noop">
</span><span class="hit">    def update_outlets(self):
</span><span class="hit">        for method in self._OUTLET_METHODS:
</span><span class="hit">            method(self)
</span><span class="noop">
</span><span class="hit">    def update_receivers(self, idx):
</span><span class="hit">        self.idx_sim = idx
</span><span class="hit">        for method in self._RECEIVER_METHODS:
</span><span class="hit">            method(self)
</span><span class="noop">
</span><span class="hit">    def update_senders(self, idx):
</span><span class="miss">        self.idx_sim = idx
</span><span class="miss">        for method in self._SENDER_METHODS:
</span><span class="miss">            method(self)
</span><span class="noop">
</span><span class="hit">    def new2old(self):
</span><span class="noop">        &#34;&#34;&#34;Assign the new/final state values of the actual time step to the
</span><span class="noop">        new/initial state values of the next time step.  Needs to be
</span><span class="noop">        overwritten in Cython mode.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            self.sequences.states.new2old()
</span><span class="hit">        except AttributeError:
</span><span class="hit">            pass
</span><span class="noop">
</span><span class="hit">    def _getidx_sim(self):
</span><span class="noop">        &#34;&#34;&#34;Index of the actual simulation time step.&#34;&#34;&#34;
</span><span class="hit">        return self.cymodel.idx_sim
</span><span class="noop">
</span><span class="hit">    def _setidx_sim(self, value):
</span><span class="hit">        self.cymodel.idx_sim = int(value)
</span><span class="noop">
</span><span class="hit">    idx_sim = property(_getidx_sim, _setidx_sim)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NumPars(object):
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        for (name, par) in vars(self).items():
</span><span class="miss">            yield (name, par)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NumConstsELS(NumPars):
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.nmb_methods = 10
</span><span class="hit">        self.nmb_stages = 11
</span><span class="hit">        self.dt_increase = 2.
</span><span class="hit">        self.dt_decrease = 10.
</span><span class="hit">        path = os.path.join(conf.__path__[0],
</span><span class="noop">                            &#39;a_coefficients_explicit_lobatto_sequence.npy&#39;)
</span><span class="hit">        self.a_coefs = numpy.load(path)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NumVarsELS(NumPars):
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.nmb_calls = 0
</span><span class="hit">        self.t0 = 0.
</span><span class="hit">        self.t1 = 0.
</span><span class="hit">        self.dt_est = 1.
</span><span class="hit">        self.dt = 1.
</span><span class="hit">        self.idx_method = 0
</span><span class="hit">        self.idx_stage = 0
</span><span class="hit">        self.error = 0.
</span><span class="hit">        self.last_error = 0.
</span><span class="hit">        self.extrapolated_error = 0.
</span><span class="hit">        self.f0_ready = False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ModelELS(Model):
</span><span class="noop">
</span><span class="hit">    NUMERICAL = True
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        super(ModelELS, self).__init__()
</span><span class="hit">        self.numconsts = NumConstsELS()
</span><span class="hit">        self.numvars = NumVarsELS()
</span><span class="noop">
</span><span class="hit">    def doit(self, idx):
</span><span class="hit">        self.idx_sim = idx
</span><span class="hit">        self.loaddata()
</span><span class="hit">        self.update_inlets()
</span><span class="hit">        self.solve()
</span><span class="hit">        self.update_outlets()
</span><span class="hit">        self.savedata()
</span><span class="noop">
</span><span class="hit">    def solve(self):
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; k(0.0)
</span><span class="noop">        &gt;&gt;&gt; solver.abserrormax = 1e-2
</span><span class="noop">        &gt;&gt;&gt; solver.reldtmin = 1e-4
</span><span class="noop">        &gt;&gt;&gt; states.s(1.0)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">        &gt;&gt;&gt; model.solve()
</span><span class="noop">        &gt;&gt;&gt; states.s
</span><span class="noop">        s(1.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.0)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_method
</span><span class="noop">        2
</span><span class="noop">        &gt;&gt;&gt; model.numvars.dt
</span><span class="noop">        1.0
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">        2
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; k(0.1)
</span><span class="noop">        &gt;&gt;&gt; states.s(1.0)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">        &gt;&gt;&gt; model.solve()
</span><span class="noop">        &gt;&gt;&gt; states.s
</span><span class="noop">        s(0.905)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.095)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_method
</span><span class="noop">        2
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">        2
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; import numpy
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(numpy.exp(-k))
</span><span class="noop">        0.904837
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; solver.abserrormax = 1e-3
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.s(1.0)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">        &gt;&gt;&gt; model.solve()
</span><span class="noop">        &gt;&gt;&gt; states.s
</span><span class="noop">        s(0.904833)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.095167)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_method
</span><span class="noop">        3
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">        4
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; solver.abserrormax = 1e-4
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.s(1.0)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">        &gt;&gt;&gt; model.solve()
</span><span class="noop">        &gt;&gt;&gt; states.s
</span><span class="noop">        s(0.904837)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.095163)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_method
</span><span class="noop">        4
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">        7
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; solver.abserrormax = 1e-12
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.s(1.0)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">        &gt;&gt;&gt; model.solve()
</span><span class="noop">        &gt;&gt;&gt; states.s
</span><span class="noop">        s(0.904837)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.095163)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_method
</span><span class="noop">        8
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">        29
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; solver.abserrormax = 1e-2
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; k(0.5)
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; round_(numpy.exp(-k))
</span><span class="noop">        0.606531
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.s(1.0)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">        &gt;&gt;&gt; model.solve()
</span><span class="noop">        &gt;&gt;&gt; states.s
</span><span class="noop">        s(0.606771)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.393229)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_method
</span><span class="noop">        4
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">        7
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; k(2.0)
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; round_(numpy.exp(-k))
</span><span class="noop">        0.135335
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.s(1.0)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">        &gt;&gt;&gt; model.solve()
</span><span class="noop">        &gt;&gt;&gt; states.s
</span><span class="noop">        s(0.134658)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.865342)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">        22
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">        &gt;&gt;&gt; model.solve()
</span><span class="noop">        &gt;&gt;&gt; states.s
</span><span class="noop">        s(0.018929)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.115728)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">        13
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; k(4.0)
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; round_(numpy.exp(-k))
</span><span class="noop">        0.018316
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.s(1.0)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">        &gt;&gt;&gt; model.solve()
</span><span class="noop">        &gt;&gt;&gt; states.s
</span><span class="noop">        s(0.019774)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.980226)
</span><span class="noop">        &gt;&gt;&gt; round_(model.numvars.dt)
</span><span class="noop">        0.3
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">        44
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.magictools import reverse_model_wildcard_import
</span><span class="noop">        &gt;&gt;&gt; reverse_model_wildcard_import()
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v2 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; k(0.5)
</span><span class="noop">        &gt;&gt;&gt; solver.abserrormax = 1e-2
</span><span class="noop">        &gt;&gt;&gt; solver.reldtmin = 1e-4
</span><span class="noop">        &gt;&gt;&gt; states.s(1.0)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">        &gt;&gt;&gt; model.solve()
</span><span class="noop">        &gt;&gt;&gt; states.s
</span><span class="noop">        s(0.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.5)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_method
</span><span class="noop">        2
</span><span class="noop">        &gt;&gt;&gt; model.numvars.dt
</span><span class="noop">        1.0
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">        2
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; k(2.0)
</span><span class="noop">        &gt;&gt;&gt; states.s(1.0)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">        &gt;&gt;&gt; model.solve()
</span><span class="noop">        &gt;&gt;&gt; states.s
</span><span class="noop">        s(-0.006827)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(1.006827)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">        58
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; k(2.1)
</span><span class="noop">        &gt;&gt;&gt; states.s(1.0)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">        &gt;&gt;&gt; model.solve()
</span><span class="noop">        &gt;&gt;&gt; states.s
</span><span class="noop">        s(-0.00072)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(1.00072)
</span><span class="noop">        &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">        50
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.numvars.t0, self.numvars.t1 = 0., 1.
</span><span class="hit">        self.numvars.dt_est = 1.
</span><span class="hit">        self.numvars.f0_ready = False
</span><span class="hit">        self.reset_sum_fluxes()
</span><span class="hit">        while self.numvars.t0 &lt; self.numvars.t1-1e-14:
</span><span class="hit">            self.numvars.last_error = 999999.
</span><span class="hit">            self.numvars.dt = min(
</span><span class="noop">                    self.numvars.t1-self.numvars.t0,
</span><span class="noop">                    max(self.numvars.dt_est, self.parameters.solver.reldtmin))
</span><span class="hit">            if not self.numvars.f0_ready:
</span><span class="hit">                self.calculate_single_terms()
</span><span class="hit">                self.numvars.idx_method = 0
</span><span class="hit">                self.numvars.idx_stage = 0
</span><span class="hit">                self.set_point_fluxes()
</span><span class="hit">                self.set_point_states()
</span><span class="hit">                self.set_result_states()
</span><span class="hit">            for self.numvars.idx_method in range(
</span><span class="noop">                                        1, self.numconsts.nmb_methods+1):
</span><span class="hit">                for self.numvars.idx_stage in range(
</span><span class="noop">                                            1, self.numvars.idx_method):
</span><span class="hit">                    self.get_point_states()
</span><span class="hit">                    self.calculate_single_terms()
</span><span class="hit">                    self.set_point_fluxes()
</span><span class="hit">                for self.numvars.idx_stage in range(
</span><span class="noop">                                            1, self.numvars.idx_method+1):
</span><span class="hit">                    self.integrate_fluxes()
</span><span class="hit">                    self.calculate_full_terms()
</span><span class="hit">                    self.set_point_states()
</span><span class="hit">                self.set_result_fluxes()
</span><span class="hit">                self.set_result_states()
</span><span class="hit">                self.calculate_error()
</span><span class="hit">                self.extrapolate_error()
</span><span class="hit">                if self.numvars.idx_method == 1:
</span><span class="hit">                    continue
</span><span class="hit">                elif self.numvars.error &lt;= self.parameters.solver.abserrormax:
</span><span class="hit">                    self.numvars.dt_est = (self.numconsts.dt_increase *
</span><span class="noop">                                           self.numvars.dt)
</span><span class="hit">                    self.numvars.f0_ready = False
</span><span class="hit">                    self.addup_fluxes()
</span><span class="hit">                    self.numvars.t0 = self.numvars.t0+self.numvars.dt
</span><span class="hit">                    self.new2old()
</span><span class="hit">                    break
</span><span class="hit">                elif ((self.numvars.extrapolated_error &gt;
</span><span class="noop">                       self.parameters.solver.abserrormax) and
</span><span class="noop">                      (self.numvars.dt &gt; self.parameters.solver.reldtmin)):
</span><span class="hit">                    self.numvars.f0_ready = True
</span><span class="hit">                    self.numvars.dt_est = (self.numvars.dt /
</span><span class="noop">                                           self.numconsts.dt_decrease)
</span><span class="hit">                    break
</span><span class="noop">                else:
</span><span class="hit">                    self.numvars.last_error = self.numvars.error
</span><span class="hit">                    self.numvars.f0_ready = True
</span><span class="hit">                    continue
</span><span class="noop">            else:
</span><span class="miss">                if self.numvars.dt &lt;= self.parameters.solver.reldtmin:
</span><span class="miss">                    self.numvars.f0_ready = False
</span><span class="miss">                    self.addup_fluxes()
</span><span class="miss">                    self.numvars.t0 = self.numvars.t0+self.numvars.dt
</span><span class="miss">                    self.new2old()
</span><span class="noop">                else:
</span><span class="miss">                    self.numvars.f0_ready = True
</span><span class="miss">                    self.numvars.dt_est = (self.numvars.dt /
</span><span class="noop">                                           self.numconsts.dt_decrease)
</span><span class="hit">        self.get_sum_fluxes()
</span><span class="noop">
</span><span class="hit">    def calculate_single_terms(self):
</span><span class="noop">        &#34;&#34;&#34;Apply all methods stored in :attr:`_PART_ODE_METHODS`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; k(0.25)
</span><span class="noop">        &gt;&gt;&gt; states.s = 1.0
</span><span class="noop">        &gt;&gt;&gt; model.calculate_single_terms()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.25)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.numvars.nmb_calls = self.numvars.nmb_calls+1
</span><span class="hit">        for method in self._PART_ODE_METHODS:
</span><span class="hit">            method(self)
</span><span class="noop">
</span><span class="hit">    def calculate_full_terms(self):
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; k(0.25)
</span><span class="noop">        &gt;&gt;&gt; states.s.old = 1.0
</span><span class="noop">        &gt;&gt;&gt; fluxes.q = 0.25
</span><span class="noop">        &gt;&gt;&gt; model.calculate_full_terms()
</span><span class="noop">        &gt;&gt;&gt; states.s.old
</span><span class="noop">        1.0
</span><span class="noop">        &gt;&gt;&gt; states.s.new
</span><span class="noop">        0.75
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        for method in self._FULL_ODE_METHODS:
</span><span class="hit">            method(self)
</span><span class="noop">
</span><span class="hit">    def get_point_states(self):
</span><span class="noop">        &#34;&#34;&#34;Load the states corresponding to the actual stage.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; states.s.old = 2.0
</span><span class="noop">        &gt;&gt;&gt; states.s.new = 2.0
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_stage = 2
</span><span class="noop">        &gt;&gt;&gt; points = numpy.asarray(states.fastaccess._s_points)
</span><span class="noop">        &gt;&gt;&gt; points[:4] = 0.0, 0.0, 1.0, 0.0
</span><span class="noop">        &gt;&gt;&gt; model.get_point_states()
</span><span class="noop">        &gt;&gt;&gt; states.s.old
</span><span class="noop">        2.0
</span><span class="noop">        &gt;&gt;&gt; states.s.new
</span><span class="noop">        1.0
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self._get_states(self.numvars.idx_stage, &#39;points&#39;)
</span><span class="noop">
</span><span class="hit">    def _get_states(self, idx, type_):
</span><span class="hit">        states = self.sequences.states
</span><span class="hit">        for (name, state) in states:
</span><span class="hit">            temp = getattr(states.fastaccess, &#39;_%s_%s&#39; % (name, type_))
</span><span class="hit">            state.new = temp[idx]
</span><span class="noop">
</span><span class="hit">    def set_point_states(self):
</span><span class="noop">        &#34;&#34;&#34;Save the states corresponding to the actual stage.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; states.s.old = 2.0
</span><span class="noop">        &gt;&gt;&gt; states.s.new = 1.0
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_stage = 2
</span><span class="noop">        &gt;&gt;&gt; points = numpy.asarray(states.fastaccess._s_points)
</span><span class="noop">        &gt;&gt;&gt; points[:] = 0.
</span><span class="noop">        &gt;&gt;&gt; model.set_point_states()
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(points[:4])
</span><span class="noop">        0.0, 0.0, 1.0, 0.0
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self._set_states(self.numvars.idx_stage, &#39;points&#39;)
</span><span class="noop">
</span><span class="hit">    def set_result_states(self):
</span><span class="noop">        &#34;&#34;&#34;Save the final states of the actual method.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; states.s.old = 2.0
</span><span class="noop">        &gt;&gt;&gt; states.s.new = 1.0
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_method = 2
</span><span class="noop">        &gt;&gt;&gt; results = numpy.asarray(states.fastaccess._s_results)
</span><span class="noop">        &gt;&gt;&gt; results[:] = 0.0
</span><span class="noop">        &gt;&gt;&gt; model.set_result_states()
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(results[:4])
</span><span class="noop">        0.0, 0.0, 1.0, 0.0
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self._set_states(self.numvars.idx_method, &#39;results&#39;)
</span><span class="noop">
</span><span class="hit">    def _set_states(self, idx, type_):
</span><span class="hit">        states = self.sequences.states
</span><span class="hit">        for (name, state) in states:
</span><span class="hit">            temp = getattr(states.fastaccess, &#39;_%s_%s&#39; % (name, type_))
</span><span class="hit">            temp[idx] = state.new
</span><span class="noop">
</span><span class="hit">    def get_sum_fluxes(self):
</span><span class="noop">        &#34;&#34;&#34;Get the sum of the fluxes calculated so far.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q = 0.0
</span><span class="noop">        &gt;&gt;&gt; fluxes.fastaccess._q_sum = 1.0
</span><span class="noop">        &gt;&gt;&gt; model.get_sum_fluxes()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(1.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        fluxes = self.sequences.fluxes
</span><span class="hit">        for (name, flux) in fluxes.numerics:
</span><span class="hit">            flux(getattr(fluxes.fastaccess, &#39;_%s_sum&#39; % name))
</span><span class="noop">
</span><span class="hit">    def set_point_fluxes(self):
</span><span class="noop">        &#34;&#34;&#34;Save the fluxes corresponding to the actual stage.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q = 1.
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_stage = 2
</span><span class="noop">        &gt;&gt;&gt; points = numpy.asarray(fluxes.fastaccess._q_points)
</span><span class="noop">        &gt;&gt;&gt; points[:] = 0.
</span><span class="noop">        &gt;&gt;&gt; model.set_point_fluxes()
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(points[:4])
</span><span class="noop">        0.0, 0.0, 1.0, 0.0
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self._set_fluxes(self.numvars.idx_stage, &#39;points&#39;)
</span><span class="noop">
</span><span class="hit">    def set_result_fluxes(self):
</span><span class="noop">        &#34;&#34;&#34;Save the final fluxes of the actual method.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q = 1.
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_method = 2
</span><span class="noop">        &gt;&gt;&gt; results = numpy.asarray(fluxes.fastaccess._q_results)
</span><span class="noop">        &gt;&gt;&gt; results[:] = 0.
</span><span class="noop">        &gt;&gt;&gt; model.set_result_fluxes()
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(results[:4])
</span><span class="noop">        0.0, 0.0, 1.0, 0.0
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self._set_fluxes(self.numvars.idx_method, &#39;results&#39;)
</span><span class="noop">
</span><span class="hit">    def _set_fluxes(self, idx, type_):
</span><span class="hit">        fluxes = self.sequences.fluxes
</span><span class="hit">        for (name, flux) in fluxes.numerics:
</span><span class="hit">            temp = getattr(fluxes.fastaccess, &#39;_%s_%s&#39; % (name, type_))
</span><span class="hit">            temp[idx] = flux
</span><span class="noop">
</span><span class="hit">    def integrate_fluxes(self):
</span><span class="noop">        &#34;&#34;&#34;Perform a dot multiplication between the fluxes and the
</span><span class="noop">        A coefficients associated with the different stages of the
</span><span class="noop">        actual method.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_method = 2
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_stage = 1
</span><span class="noop">        &gt;&gt;&gt; model.numvars.dt = 0.5
</span><span class="noop">        &gt;&gt;&gt; points = numpy.asarray(fluxes.fastaccess._q_points)
</span><span class="noop">        &gt;&gt;&gt; points[:4] = 15., 2., -999., 0.
</span><span class="noop">        &gt;&gt;&gt; model.integrate_fluxes()
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; round_(numpy.asarray(model.numconsts.a_coefs)[1, 1, :2])
</span><span class="noop">        0.375, 0.125
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(2.9375)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        fluxes = self.sequences.fluxes
</span><span class="hit">        for (name, flux) in fluxes.numerics:
</span><span class="hit">            points = getattr(fluxes.fastaccess, &#39;_%s_points&#39; % name)
</span><span class="hit">            coefs = self.numconsts.a_coefs[self.numvars.idx_method-1,
</span><span class="noop">                                           self.numvars.idx_stage,
</span><span class="noop">                                           :self.numvars.idx_method]
</span><span class="hit">            flux(self.numvars.dt *
</span><span class="noop">                 numpy.dot(coefs, points[:self.numvars.idx_method]))
</span><span class="noop">
</span><span class="hit">    def reset_sum_fluxes(self):
</span><span class="noop">        &#34;&#34;&#34;Set the sum of the fluxes calculated so far to zero.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; fluxes.fastaccess._q_sum = 5.
</span><span class="noop">        &gt;&gt;&gt; model.reset_sum_fluxes()
</span><span class="noop">        &gt;&gt;&gt; fluxes.fastaccess._q_sum
</span><span class="noop">        0.0
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        fluxes = self.sequences.fluxes
</span><span class="hit">        for (name, flux) in fluxes.numerics:
</span><span class="hit">            if flux.NDIM == 0:
</span><span class="hit">                setattr(fluxes.fastaccess, &#39;_%s_sum&#39; % name, 0.)
</span><span class="noop">            else:
</span><span class="miss">                getattr(fluxes.fastaccess, &#39;_%s_sum&#39; % name)[:] = 0.
</span><span class="noop">
</span><span class="hit">    def addup_fluxes(self):
</span><span class="noop">        &#34;&#34;&#34;Add up the sum of the fluxes calculated so far.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; fluxes.fastaccess._q_sum = 1.0
</span><span class="noop">        &gt;&gt;&gt; fluxes.q(2.0)
</span><span class="noop">        &gt;&gt;&gt; model.addup_fluxes()
</span><span class="noop">        &gt;&gt;&gt; fluxes.fastaccess._q_sum
</span><span class="noop">        3.0
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        fluxes = self.sequences.fluxes
</span><span class="hit">        for (name, flux) in fluxes.numerics:
</span><span class="hit">            sum_ = getattr(fluxes.fastaccess, &#39;_%s_sum&#39; % name)
</span><span class="hit">            sum_ += flux
</span><span class="hit">            if flux.NDIM == 0:
</span><span class="hit">                setattr(fluxes.fastaccess, &#39;_%s_sum&#39; % name, sum_)
</span><span class="noop">
</span><span class="hit">    def calculate_error(self):
</span><span class="noop">        &#34;&#34;&#34;Estimate the numerical error based on the fluxes calculated
</span><span class="noop">        by the current and the last method.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_method = 2
</span><span class="noop">        &gt;&gt;&gt; results = numpy.asarray(fluxes.fastaccess._q_results)
</span><span class="noop">        &gt;&gt;&gt; results[:4] = 0., 3., 4., 0.
</span><span class="noop">        &gt;&gt;&gt; model.calculate_error()
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(model.numvars.error)
</span><span class="noop">        1.0
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.numvars.error = 0.
</span><span class="hit">        fluxes = self.sequences.fluxes
</span><span class="hit">        for (name, flux) in fluxes.numerics:
</span><span class="hit">            results = getattr(fluxes.fastaccess, &#39;_%s_results&#39; % name)
</span><span class="hit">            diff = (results[self.numvars.idx_method] -
</span><span class="noop">                    results[self.numvars.idx_method-1])
</span><span class="hit">            self.numvars.error = max(self.numvars.error,
</span><span class="noop">                                     numpy.max(numpy.abs(diff)))
</span><span class="noop">
</span><span class="hit">    def extrapolate_error(self):
</span><span class="noop">        &#34;&#34;&#34;Estimate the numerical error to be expected when applying all
</span><span class="noop">        methods available based on the results of the current and the
</span><span class="noop">        last method.
</span><span class="noop">
</span><span class="noop">        Note that this expolation strategy cannot be applied on the first
</span><span class="noop">        method.  If the current method is the first one, `-999.9` is returned.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.test_v1 import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; model.numvars.error = 1e-2
</span><span class="noop">        &gt;&gt;&gt; model.numvars.last_error = 1e-1
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_method = 10
</span><span class="noop">        &gt;&gt;&gt; model.extrapolate_error()
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(model.numvars.extrapolated_error)
</span><span class="noop">        0.01
</span><span class="noop">        &gt;&gt;&gt; model.numvars.idx_method = 9
</span><span class="noop">        &gt;&gt;&gt; model.extrapolate_error()
</span><span class="noop">        &gt;&gt;&gt; round_(model.numvars.extrapolated_error)
</span><span class="noop">        0.001
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self.numvars.idx_method &gt; 2:
</span><span class="hit">            self.numvars.extrapolated_error = modelutils.exp(
</span><span class="noop">                modelutils.log(self.numvars.error) +
</span><span class="noop">                (modelutils.log(self.numvars.error) -
</span><span class="noop">                 modelutils.log(self.numvars.last_error)) *
</span><span class="noop">                (self.numconsts.nmb_methods-self.numvars.idx_method))
</span><span class="noop">        else:
</span><span class="hit">            self.numvars.extrapolated_error = -999.9
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/objecttools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/objecttools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements tools to help to standardize the functionality
</span><span class="noop">of the different objects defined by the HydPy framework.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import inspect
</span><span class="hit">import sys
</span><span class="hit">import textwrap
</span><span class="hit">import numbers
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.cythons import pointerutils
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">_INT_NAN = -999999
</span><span class="noop">&#34;&#34;&#34;Surrogate for `nan`, which is available for floating point values
</span><span class="noop">but not for integer values.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def dir_(self):
</span><span class="noop">    &#34;&#34;&#34;The prefered way for HydPy objects to respond to :func:`dir`.
</span><span class="noop">
</span><span class="noop">    Note the depencence on the `pub.options.dirverbose`.  If this option is
</span><span class="noop">    set `True`, all attributes and methods of the given instance and its
</span><span class="noop">    class (including those inherited from the parent classes) are returned:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; options.dirverbose = True
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import dir_
</span><span class="noop">    &gt;&gt;&gt; class Test(object):
</span><span class="noop">    ...     only_public_attribute =  None
</span><span class="noop">    &gt;&gt;&gt; print(len(dir_(Test())) &gt; 1) # Long list, try it yourself...
</span><span class="noop">    True
</span><span class="noop">
</span><span class="noop">    If the option is set to `False`, only the `public` attributes and methods
</span><span class="noop">    (which do need begin with `_`) are returned:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; options.dirverbose = False
</span><span class="noop">    &gt;&gt;&gt; print(dir_(Test())) # Short list with one single entry...
</span><span class="noop">    [&#39;only_public_attribute&#39;]
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    names = set()
</span><span class="hit">    for thing in list(inspect.getmro(type(self))) + [self]:
</span><span class="hit">        for name in vars(thing).keys():
</span><span class="hit">            if pub.options.dirverbose or not name.startswith(&#39;_&#39;):
</span><span class="hit">                names.add(name)
</span><span class="hit">    if names:
</span><span class="hit">        names = list(names)
</span><span class="noop">    else:
</span><span class="miss">        names = [&#39; &#39;]
</span><span class="hit">    return names
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def classname(self):
</span><span class="noop">    &#34;&#34;&#34;Return the class name of the given instance object or class.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import classname
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; print(classname(float))
</span><span class="noop">    float
</span><span class="noop">    &gt;&gt;&gt; print(classname(options))
</span><span class="noop">    Options
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if not inspect.isclass(self):
</span><span class="hit">        self = type(self)
</span><span class="hit">    return str(self).split(&#34;&#39;&#34;)[1].split(&#39;.&#39;)[-1]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def instancename(self):
</span><span class="noop">    &#34;&#34;&#34;Return the class name of the given instance object or class in lower
</span><span class="noop">    case letters.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import instancename
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; print(instancename(options))
</span><span class="noop">    options
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return classname(self).lower()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def name(self):
</span><span class="noop">    &#34;&#34;&#34;Name of the class of the given instance in lower case letters.
</span><span class="noop">
</span><span class="noop">    This function is thought to be implemented as a property.  Otherwise
</span><span class="noop">    it would violate the principle not to access or manipulate private
</span><span class="noop">    attributes (&#34;_name&#34;):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import name
</span><span class="noop">    &gt;&gt;&gt; class Test(object):
</span><span class="noop">    ...     name = property(name)
</span><span class="noop">    &gt;&gt;&gt; test1 = Test()
</span><span class="noop">    &gt;&gt;&gt; test1.name
</span><span class="noop">    &#39;test&#39;
</span><span class="noop">    &gt;&gt;&gt; test1._name
</span><span class="noop">    &#39;test&#39;
</span><span class="noop">
</span><span class="noop">    The private attribute is added for performance reasons only.  Note that
</span><span class="noop">    it is a class attribute:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test2 = Test()
</span><span class="noop">    &gt;&gt;&gt; test2._name
</span><span class="noop">    &#39;test&#39;
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    try:
</span><span class="hit">        return type(self).__dict__[&#39;_name&#39;]
</span><span class="hit">    except KeyError:
</span><span class="hit">        type(self)._name = instancename(self)
</span><span class="hit">        return type(self).__dict__[&#39;_name&#39;]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def modulename(self):
</span><span class="noop">    &#34;&#34;&#34;Return the module name of the given instance object.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import modulename
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; print(modulename(options))
</span><span class="noop">    optiontools
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return self.__module__.split(&#39;.&#39;)[-1]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def devicename(self):
</span><span class="noop">    &#34;&#34;&#34;Try to return the name of the (indirect) master
</span><span class="noop">    :class:`~hydpy.core.devicetools.Node` or
</span><span class="noop">    :class:`~hydpy.core.devicetools.Element` instance,
</span><span class="noop">    otherwise return `?`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    while True:
</span><span class="hit">        device = getattr(self, &#39;element&#39;, getattr(self, &#39;node&#39;, None))
</span><span class="hit">        if device is not None:
</span><span class="hit">            return device.name
</span><span class="hit">        for test in (&#39;model&#39;, &#39;seqs&#39;, &#39;subseqs&#39;, &#39;pars&#39;, &#39;subpars&#39;):
</span><span class="hit">            master = getattr(self, test, None)
</span><span class="hit">            if master is not None:
</span><span class="hit">                self = master
</span><span class="hit">                break
</span><span class="noop">        else:
</span><span class="hit">            return &#39;?&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def valid_variable_identifier(name):
</span><span class="noop">    &#34;&#34;&#34;Raises an :class:`~exceptions.ValueError` if the given name is not
</span><span class="noop">    a valid Python identifier.
</span><span class="noop">
</span><span class="noop">    For example, the string `test_1` (with underscore) is valid...
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import valid_variable_identifier
</span><span class="noop">    &gt;&gt;&gt; valid_variable_identifier(&#39;test_1&#39;)
</span><span class="noop">
</span><span class="noop">    ...but the string `test 1` (with white space) is not:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; valid_variable_identifier(&#39;test 1&#39;)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: The given name string `test 1` does not define a valid variable identifier.  Valid identifiers do not contain signs like `-` or empty spaces, do not start with numbers, cannot be mistaken with Python built-ins like `for`...)
</span><span class="noop">
</span><span class="noop">    Also, names of Python built ins are not allowed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; valid_variable_identifier(&#39;while&#39;)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: The given name string `while` does not define a valid variable identifier.  Valid identifiers do not contain signs like `-` or empty spaces, do not start with numbers, cannot be mistaken with Python built-ins like `for`...)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    string = str(name)
</span><span class="hit">    try:
</span><span class="hit">        exec(&#39;%s = None&#39; % string)
</span><span class="hit">        if name in dir(__builtins__):
</span><span class="miss">            raise SyntaxError()
</span><span class="hit">    except SyntaxError:
</span><span class="hit">        raise ValueError(
</span><span class="noop">            &#39;The given name string `%s` does not define a valid variable &#39;
</span><span class="noop">            &#39;identifier.  Valid identifiers do not contain signs like `-` &#39;
</span><span class="noop">            &#39;or empty spaces, do not start with numbers, cannot be &#39;
</span><span class="noop">            &#39;mistaken with Python built-ins like `for`...)&#39; % name)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def augmentexcmessage(prefix=None, suffix=None):
</span><span class="noop">    &#34;&#34;&#34;Augment an exception message with additional information while keeping
</span><span class="noop">    the original traceback.
</span><span class="noop">
</span><span class="noop">    You can prefix and/or suffix text.  If you prefix something (which happens
</span><span class="noop">    much more often in the HydPy framework), the sub-clause &#39;, the following
</span><span class="noop">    error occured:&#39; is automatically included:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core import objecttools
</span><span class="noop">    &gt;&gt;&gt; import textwrap
</span><span class="noop">    &gt;&gt;&gt; try:
</span><span class="noop">    ...     1 + &#39;1&#39;
</span><span class="noop">    ... except TypeError:
</span><span class="noop">    ...     try:
</span><span class="noop">    ...         prefix = &#39;While showing how prefixing works&#39;
</span><span class="noop">    ...         suffix = &#39;(This is a final remark.)&#39;
</span><span class="noop">    ...         objecttools.augmentexcmessage(prefix, suffix)
</span><span class="noop">    ...     except TypeError as exc:
</span><span class="noop">    ...         for line in textwrap.wrap(exc.args[0], width=76):
</span><span class="noop">    ...             print(line)
</span><span class="noop">    While showing how prefixing works, the following error occured: unsupported
</span><span class="noop">    operand type(s) for +: &#39;int&#39; and &#39;str&#39; (This is a final remark.)
</span><span class="noop">
</span><span class="noop">    Note that the ancillary purpose of function :func:`augmentexcmessage` is
</span><span class="noop">    to make re-raising exceptions compatible with both Python 2 and 3.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    exception, message, traceback_ = sys.exc_info()
</span><span class="hit">    if prefix is not None:
</span><span class="hit">        message = (&#39;%s, the following error occured: %s&#39;
</span><span class="noop">                   % (prefix, message))
</span><span class="hit">    if suffix is not None:
</span><span class="hit">        message = &#39; &#39;.join((message, suffix))
</span><span class="hit">    if pub.pyversion &lt; 3:
</span><span class="miss">        exec(&#39;raise exception, message, traceback_&#39;)
</span><span class="noop">    else:
</span><span class="hit">        raise exception(message).with_traceback(traceback_)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class _PreserveStrings(object):
</span><span class="noop">    &#34;&#34;&#34;Helper class for :class:`_Repr_`.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, preserve_strings):
</span><span class="hit">        self.new_value = preserve_strings
</span><span class="hit">        self.old_value = repr_._preserve_strings
</span><span class="noop">
</span><span class="hit">    def __enter__(self):
</span><span class="hit">        repr_._preserve_strings = self.new_value
</span><span class="hit">        return None
</span><span class="noop">
</span><span class="hit">    def __exit__(self, type_, value, traceback):
</span><span class="hit">        repr_._preserve_strings = self.old_value
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class _Repr_(object):
</span><span class="noop">    &#34;&#34;&#34;Modifies :func:`repr` for strings and floats, mainly for supporting
</span><span class="noop">    clean float representations that are compatible with :mod:`doctest`.
</span><span class="noop">
</span><span class="noop">    When value is a string, it is returned without any modification:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import repr_
</span><span class="noop">    &gt;&gt;&gt; print(&#39;test&#39;)
</span><span class="noop">    test
</span><span class="noop">    &gt;&gt;&gt; print(repr(&#39;test&#39;))
</span><span class="noop">    &#39;test&#39;
</span><span class="noop">    &gt;&gt;&gt; print(repr_(&#39;test&#39;))
</span><span class="noop">    test
</span><span class="noop">
</span><span class="noop">    You can change this behaviour of function object :func:`repr_`,
</span><span class="noop">    when necessary:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; with repr_.preserve_strings(True):
</span><span class="noop">    ...     print(repr_(&#39;test&#39;))
</span><span class="noop">    &#34;test&#34;
</span><span class="noop">
</span><span class="noop">    Behind the with block, :func:`repr_` works as before
</span><span class="noop">    (even in case of an error):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; print(repr_(&#39;test&#39;))
</span><span class="noop">    test
</span><span class="noop">
</span><span class="noop">    When value is a float, the result depends on how the option
</span><span class="noop">    :attr:`~hydpy.core.optiontools.Options.reprdigits` is set. If it is
</span><span class="noop">    to -999, :func:`repr` defines the number of digits in
</span><span class="noop">    the usual, system dependend manner:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; options.reprdigits = -999
</span><span class="noop">    &gt;&gt;&gt; repr(1./3.) == repr_(1./3.)
</span><span class="noop">    True
</span><span class="noop">
</span><span class="noop">    Through setting :attr:`~hydpy.core.optiontools.Options.reprdigits` to a
</span><span class="noop">    positive integer value, one defines the maximum number of decimal places,
</span><span class="noop">    which allows for doctesting across different systems and Python versions:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; options.reprdigits = 6
</span><span class="noop">    &gt;&gt;&gt; repr_(1./3.)
</span><span class="noop">    &#39;0.333333&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(2./3.)
</span><span class="noop">    &#39;0.666667&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(1./2.)
</span><span class="noop">    &#39;0.5&#39;
</span><span class="noop">
</span><span class="noop">    Changing the number of decimal places can be done via a with block:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; with options.reprdigits(3):
</span><span class="noop">    ...     print(repr_(1./3.))
</span><span class="noop">    0.333
</span><span class="noop">
</span><span class="noop">    Such a change is only temporary (even in case of an error):
</span><span class="noop">    &gt;&gt;&gt; repr_(1./3.)
</span><span class="noop">    &#39;0.333333&#39;
</span><span class="noop">
</span><span class="noop">    :func:`repr_` can also be applied on numpy&#39;s float types:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; repr_(numpy.float(1./3.))
</span><span class="noop">    &#39;0.333333&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(numpy.float64(1./3.))
</span><span class="noop">    &#39;0.333333&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(numpy.float32(1./3.))
</span><span class="noop">    &#39;0.333333&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(numpy.float16(1./3.))
</span><span class="noop">    &#39;0.333252&#39;
</span><span class="noop">
</span><span class="noop">    Note that the deviation from the `true` result in the last example is due
</span><span class="noop">    to the low precision of :class:`~numpy.float16`.
</span><span class="noop">
</span><span class="noop">    On all types not mentioned above, the usual :func:`repr` function is
</span><span class="noop">    applied, e.g.:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; repr([1, 2, 3])
</span><span class="noop">    &#39;[1, 2, 3]&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_([1, 2, 3])
</span><span class="noop">    &#39;[1, 2, 3]&#39;
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self._preserve_strings = False
</span><span class="noop">
</span><span class="hit">    def __call__(self, value):
</span><span class="hit">        decimals = pub.options.reprdigits
</span><span class="hit">        if isinstance(value, str):
</span><span class="hit">            if self._preserve_strings:
</span><span class="hit">                return &#39;&#34;%s&#34;&#39; % value
</span><span class="noop">            else:
</span><span class="hit">                return value
</span><span class="hit">        if isinstance(value, (pointerutils.Double, pointerutils.PDouble)):
</span><span class="hit">            value = float(value)
</span><span class="hit">        if ((decimals &gt; -1) and
</span><span class="noop">                isinstance(value, numbers.Real) and
</span><span class="noop">                (not isinstance(value, numbers.Integral))):
</span><span class="hit">            string = &#39;{0:.{1}f}&#39;.format(value, decimals)
</span><span class="hit">            string = string.rstrip(&#39;0&#39;)
</span><span class="hit">            if string.endswith(&#39;.&#39;):
</span><span class="hit">                string += &#39;0&#39;
</span><span class="hit">            return string
</span><span class="noop">        else:
</span><span class="hit">            return repr(value)
</span><span class="noop">
</span><span class="hit">    def preserve_strings(self, preserve_strings):
</span><span class="noop">        &#34;&#34;&#34;Change the `preserve_string` option inside a with block.&#34;&#34;&#34;
</span><span class="hit">        return _PreserveStrings(preserve_strings)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">repr_ = _Repr_()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def repr_values(values):
</span><span class="noop">    &#34;&#34;&#34;Return comma seperated representations of the given values using
</span><span class="noop">    function :func:`repr_`.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import repr_values
</span><span class="noop">    &gt;&gt;&gt; repr_values([1./1., 1./2., 1./3.])
</span><span class="noop">    &#39;1.0, 0.5, 0.333333&#39;
</span><span class="noop">
</span><span class="noop">    Note that the returned string is not wrapped.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return &#39;%s&#39; % &#39;, &#39;.join(repr_(value) for value in values)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def repr_tuple(values):
</span><span class="noop">    &#34;&#34;&#34;Return a tuple representation of the given values using function
</span><span class="noop">    :func:`repr_`.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import repr_tuple
</span><span class="noop">    &gt;&gt;&gt; repr_tuple([1./1., 1./2., 1./3.])
</span><span class="noop">    &#39;(1.0, 0.5, 0.333333)&#39;
</span><span class="noop">
</span><span class="noop">    Note that the returned string is not wrapped.
</span><span class="noop">
</span><span class="noop">    In the special case of an iterable with only one entry, the returned
</span><span class="noop">    string is still a valid tuple:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; repr_tuple([1.])
</span><span class="noop">    &#39;(1.0,)&#39;
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if len(values) == 1:
</span><span class="hit">        return &#39;(%s,)&#39; % repr_values(values)
</span><span class="noop">    else:
</span><span class="hit">        return &#39;(%s)&#39; % repr_values(values)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def repr_list(values):
</span><span class="noop">    &#34;&#34;&#34;Return a list representation of the given values using function
</span><span class="noop">    :func:`repr_`.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import repr_list
</span><span class="noop">    &gt;&gt;&gt; repr_list([1./1., 1./2., 1./3.])
</span><span class="noop">    &#39;[1.0, 0.5, 0.333333]&#39;
</span><span class="noop">
</span><span class="noop">    Note that the returned string is not wrapped.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return &#39;[%s]&#39; % repr_values(values)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def assignrepr_value(value, prefix, width=None):
</span><span class="noop">    &#34;&#34;&#34;Return a prefixed string representation of the given value using
</span><span class="noop">    function :func:`repr_`.
</span><span class="noop">
</span><span class="noop">    Note that the argument has no effect. It is thought for increasing
</span><span class="noop">    usage compatibility with functions like :func:`assignrepr_list` only.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import assignrepr_value
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_value(1./3., &#39;test = &#39;))
</span><span class="noop">    test = 0.333333
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return prefix + repr_(value)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def assignrepr_values(values, prefix, width=None, _fakeend=0):
</span><span class="noop">    &#34;&#34;&#34;Return a prefixed, wrapped and properly aligned string representation
</span><span class="noop">    of the given values using function :func:`repr_`.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import assignrepr_values
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_values(range(1, 13), &#39;test(&#39;, 20) + &#39;)&#39;)
</span><span class="noop">    test(1, 2, 3, 4, 5,
</span><span class="noop">         6, 7, 8, 9, 10,
</span><span class="noop">         11, 12)
</span><span class="noop">
</span><span class="noop">    If no width is given, no wrapping is performed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_values(range(1, 13), &#39;test(&#39;) + &#39;)&#39;)
</span><span class="noop">    test(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    To circumvent defining too long string representations, make use of the
</span><span class="noop">    ellipsis option:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; with options.ellipsis(1):
</span><span class="noop">    ...     print(assignrepr_values(range(1, 13), &#39;test(&#39;, 20) + &#39;)&#39;)
</span><span class="noop">    test(1, ...,12)
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; with options.ellipsis(5):
</span><span class="noop">    ...     print(assignrepr_values(range(1, 13), &#39;test(&#39;, 20) + &#39;)&#39;)
</span><span class="noop">    test(1, 2, 3, 4, 5,
</span><span class="noop">         ...,8, 9, 10,
</span><span class="noop">         11, 12)
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; with options.ellipsis(6):
</span><span class="noop">    ...     print(assignrepr_values(range(1, 13), &#39;test(&#39;, 20) + &#39;)&#39;)
</span><span class="noop">    test(1, 2, 3, 4, 5,
</span><span class="noop">         6, 7, 8, 9, 10,
</span><span class="noop">         11, 12)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    ellipsis = pub.options.ellipsis
</span><span class="hit">    if (ellipsis &gt; 0) and (len(values) &gt; 2*ellipsis):
</span><span class="hit">        string = (repr_values(values[:ellipsis]) +
</span><span class="noop">                  &#39;, ...,&#39; +
</span><span class="noop">                  repr_values(values[-ellipsis:]))
</span><span class="noop">    else:
</span><span class="hit">        string = repr_values(values)
</span><span class="hit">    blanks = &#39; &#39;*len(prefix)
</span><span class="hit">    if width is None:
</span><span class="hit">        wrapped = [string]
</span><span class="hit">        _fakeend = 0
</span><span class="noop">    else:
</span><span class="hit">        width -= len(prefix)
</span><span class="hit">        wrapped = textwrap.wrap(string+&#39;_&#39;*_fakeend, width)
</span><span class="hit">    if not wrapped:
</span><span class="hit">        wrapped = [&#39;&#39;]
</span><span class="hit">    lines = []
</span><span class="hit">    for (idx, line) in enumerate(wrapped):
</span><span class="hit">        if idx == 0:
</span><span class="hit">            lines.append(&#39;%s%s&#39; % (prefix, line))
</span><span class="noop">        else:
</span><span class="hit">            lines.append(&#39;%s%s&#39; % (blanks, line))
</span><span class="hit">    string = &#39;\n&#39;.join(lines)
</span><span class="hit">    return string[:len(string)-_fakeend]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class _AlwaysBracketed(object):
</span><span class="noop">    &#34;&#34;&#34;Helper class for :class:`_AssignReprBracketed`.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, value):
</span><span class="hit">        self.new_value = value
</span><span class="hit">        self.old_value = _AssignReprBracketed._always_bracketed
</span><span class="noop">
</span><span class="hit">    def __enter__(self):
</span><span class="hit">        _AssignReprBracketed._always_bracketed = self.new_value
</span><span class="noop">
</span><span class="hit">    def __exit__(self, type_, value, traceback):
</span><span class="hit">        _AssignReprBracketed._always_bracketed = self.old_value
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class _AssignReprBracketed(object):
</span><span class="noop">    &#34;&#34;&#34;&#34;Double Singleton class&#34;, see the documentation on
</span><span class="noop">    :func:`assignrepr_tuple` and :func:`assignrepr_list`.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _always_bracketed = True
</span><span class="noop">
</span><span class="hit">    def __init__(self, brackets):
</span><span class="hit">        self._brackets = brackets
</span><span class="noop">
</span><span class="hit">    def __call__(self, values, prefix, width=None):
</span><span class="hit">        if (len(values) == 1) and not self._always_bracketed:
</span><span class="hit">            return assignrepr_value(values[0], prefix)
</span><span class="hit">        elif len(values):
</span><span class="hit">            string = assignrepr_values(
</span><span class="noop">                values, prefix+self._brackets[0], width, 1) + self._brackets[1]
</span><span class="hit">            if (len(values) == 1) and (self._brackets[1] == &#39;)&#39;):
</span><span class="hit">                return string[:-1] + &#39;,)&#39;
</span><span class="noop">            else:
</span><span class="hit">                return string
</span><span class="noop">        else:
</span><span class="hit">            return prefix + self._brackets
</span><span class="noop">
</span><span class="hit">    def always_bracketed(self, always_bracketed):
</span><span class="noop">        &#34;&#34;&#34;Change the `always_bracketed` option inside a with block.&#34;&#34;&#34;
</span><span class="hit">        return _AlwaysBracketed(always_bracketed)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">assignrepr_tuple = _AssignReprBracketed(&#39;()&#39;)
</span><span class="noop">&#34;&#34;&#34;Return a prefixed, wrapped and properly aligned tuple string
</span><span class="noop">representation of the given values using function :func:`repr_`.
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.core.objecttools import assignrepr_tuple
</span><span class="noop">&gt;&gt;&gt; print(assignrepr_tuple(range(10), &#39;test = &#39;, 22))
</span><span class="noop">test = (0, 1, 2, 3, 4,
</span><span class="noop">        5, 6, 7, 8, 9)
</span><span class="noop">
</span><span class="noop">If no width is given, no wrapping is performed:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; print(assignrepr_tuple(range(10), &#39;test = &#39;))
</span><span class="noop">test = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
</span><span class="noop">
</span><span class="noop">Functions :func:`assignrepr_tuple` works also on empty iterables and
</span><span class="noop">those which possess only one entry:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; print(assignrepr_tuple([], &#39;test = &#39;))
</span><span class="noop">test = ()
</span><span class="noop">&gt;&gt;&gt; print(assignrepr_tuple([10], &#39;test = &#39;))
</span><span class="noop">test = (10,)
</span><span class="noop">
</span><span class="noop">Optionally, bracketing single values can be prevented:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; with assignrepr_tuple.always_bracketed(False):
</span><span class="noop">...     print(assignrepr_tuple([], &#39;test = &#39;))
</span><span class="noop">...     print(assignrepr_tuple([10], &#39;test = &#39;))
</span><span class="noop">...     print(assignrepr_tuple([10, 10], &#39;test = &#39;))
</span><span class="noop">test = ()
</span><span class="noop">test = 10
</span><span class="noop">test = (10, 10)
</span><span class="noop">
</span><span class="noop">Behind the with block, :func:`assignrepr_tuple` works as before
</span><span class="noop">(even in case of an error):
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; print(assignrepr_tuple([10], &#39;test = &#39;))
</span><span class="noop">test = (10,)
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">assignrepr_list = _AssignReprBracketed(&#39;[]&#39;)
</span><span class="noop">&#34;&#34;&#34;Return a prefixed, wrapped and properly aligned list string
</span><span class="noop">representation of the given values using function :func:`repr_`.
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.core.objecttools import assignrepr_list
</span><span class="noop">&gt;&gt;&gt; print(assignrepr_list(range(10), &#39;test = &#39;, 22))
</span><span class="noop">test = [0, 1, 2, 3, 4,
</span><span class="noop">        5, 6, 7, 8, 9]
</span><span class="noop">
</span><span class="noop">If no width is given, no wrapping is performed:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; print(assignrepr_list(range(10), &#39;test = &#39;))
</span><span class="noop">test = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</span><span class="noop">
</span><span class="noop">Functions :func:`assignrepr_list` works also on empty iterables:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; print(assignrepr_list((), &#39;test = &#39;))
</span><span class="noop">test = []
</span><span class="noop">
</span><span class="noop">Optionally, bracketing single values can be prevented:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; with assignrepr_list.always_bracketed(False):
</span><span class="noop">...     print(assignrepr_list([], &#39;test = &#39;))
</span><span class="noop">...     print(assignrepr_list([10], &#39;test = &#39;))
</span><span class="noop">...     print(assignrepr_list([10, 10], &#39;test = &#39;))
</span><span class="noop">test = []
</span><span class="noop">test = 10
</span><span class="noop">test = [10, 10]
</span><span class="noop">
</span><span class="noop">Behind the with block, :func:`assignrepr_list` works as before
</span><span class="noop">(even in case of an error):
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; print(assignrepr_list([10], &#39;test = &#39;))
</span><span class="noop">test = [10,]
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def assignrepr_values2(values, prefix):
</span><span class="noop">    &#34;&#34;&#34;Return a prefixed and properly aligned string representation
</span><span class="noop">    of the given 2-dimensional value matrix using function :func:`repr_`.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import assignrepr_values2
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_values2(numpy.eye(3), &#39;test(&#39;) + &#39;)&#39;)
</span><span class="noop">    test(1.0, 0.0, 0.0,
</span><span class="noop">         0.0, 1.0, 0.0,
</span><span class="noop">         0.0, 0.0, 1.0)
</span><span class="noop">
</span><span class="noop">    Functions :func:`assignrepr_values2` works also on empty iterables:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_values2([[]], &#39;test(&#39;) + &#39;)&#39;)
</span><span class="noop">    test()
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    lines = []
</span><span class="hit">    blanks = &#39; &#39;*len(prefix)
</span><span class="hit">    for (idx, subvalues) in enumerate(values):
</span><span class="hit">        if idx == 0:
</span><span class="hit">            lines.append(&#39;%s%s,&#39; % (prefix, repr_values(subvalues)))
</span><span class="noop">        else:
</span><span class="hit">            lines.append(&#39;%s%s,&#39; % (blanks, repr_values(subvalues)))
</span><span class="hit">    lines[-1] = lines[-1][:-1]
</span><span class="hit">    return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _assignrepr_bracketed2(assignrepr_bracketed1, values, prefix, width=None):
</span><span class="noop">    &#34;&#34;&#34;Return a prefixed, wrapped and properly aligned bracketed string
</span><span class="noop">    representation of the given 2-dimensional value matrix using function
</span><span class="noop">    :func:`repr_`.&#34;&#34;&#34;
</span><span class="hit">    prefix += assignrepr_bracketed1._brackets[0]
</span><span class="hit">    lines = []
</span><span class="hit">    blanks = &#39; &#39;*len(prefix)
</span><span class="hit">    for (idx, subvalues) in enumerate(values):
</span><span class="hit">        if idx == 0:
</span><span class="hit">            lines.append(assignrepr_bracketed1(subvalues, prefix, width))
</span><span class="noop">        else:
</span><span class="hit">            lines.append(assignrepr_bracketed1(subvalues, blanks, width))
</span><span class="hit">        if (len(subvalues) == 1) and (lines[-1] == &#39;)&#39;):
</span><span class="miss">            lines[-1] = lines[-1].replace(&#39;)&#39;, &#39;,)&#39;)
</span><span class="hit">        lines[-1] += &#39;,&#39;
</span><span class="hit">    lines[-1] = lines[-1][:-1] + assignrepr_bracketed1._brackets[1]
</span><span class="hit">    return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def assignrepr_tuple2(values, prefix, width=None):
</span><span class="noop">    &#34;&#34;&#34;Return a prefixed, wrapped and properly aligned tuple string
</span><span class="noop">    representation of the given 2-dimensional value matrix using function
</span><span class="noop">    :func:`repr_`.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import assignrepr_tuple2
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_tuple2(numpy.eye(3), &#39;test = &#39;, 18))
</span><span class="noop">    test = ((1.0, 0.0,
</span><span class="noop">             0.0),
</span><span class="noop">            (0.0, 1.0,
</span><span class="noop">             0.0),
</span><span class="noop">            (0.0, 0.0,
</span><span class="noop">             1.0))
</span><span class="noop">
</span><span class="noop">    If no width is given, no wrapping is performed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_tuple2(numpy.eye(3), &#39;test = &#39;))
</span><span class="noop">    test = ((1.0, 0.0, 0.0),
</span><span class="noop">            (0.0, 1.0, 0.0),
</span><span class="noop">            (0.0, 0.0, 1.0))
</span><span class="noop">
</span><span class="noop">    Functions :func:`assignrepr_tuple2` works also on empty iterables and
</span><span class="noop">    those which possess only one entry:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_tuple2([[]], &#39;test = &#39;))
</span><span class="noop">    test = (())
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_tuple2([[], [1]], &#39;test = &#39;))
</span><span class="noop">    test = ((),
</span><span class="noop">            (1,))
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return _assignrepr_bracketed2(assignrepr_tuple, values, prefix, width)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def assignrepr_list2(values, prefix, width=None):
</span><span class="noop">    &#34;&#34;&#34;Return a prefixed, wrapped and properly aligned list string
</span><span class="noop">    representation of the given 2-dimensional value matrix using function
</span><span class="noop">    :func:`repr_`.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import assignrepr_list2
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_list2(numpy.eye(3), &#39;test = &#39;, 18))
</span><span class="noop">    test = [[1.0, 0.0,
</span><span class="noop">             0.0],
</span><span class="noop">            [0.0, 1.0,
</span><span class="noop">             0.0],
</span><span class="noop">            [0.0, 0.0,
</span><span class="noop">             1.0]]
</span><span class="noop">
</span><span class="noop">    If no width is given, no wrapping is performed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_list2(numpy.eye(3), &#39;test = &#39;))
</span><span class="noop">    test = [[1.0, 0.0, 0.0],
</span><span class="noop">            [0.0, 1.0, 0.0],
</span><span class="noop">            [0.0, 0.0, 1.0]]
</span><span class="noop">
</span><span class="noop">    Functions :func:`assignrepr_list2` works also on empty iterables:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_list2([[]], &#39;test = &#39;))
</span><span class="noop">    test = [[]]
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_list2([[], [1]], &#39;test = &#39;))
</span><span class="noop">    test = [[],
</span><span class="noop">            [1]]
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return _assignrepr_bracketed2(assignrepr_list, values, prefix, width)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _assignrepr_bracketed3(assignrepr_bracketed1, values, prefix, width=None):
</span><span class="noop">    &#34;&#34;&#34;Return a prefixed, wrapped and properly aligned bracketed string
</span><span class="noop">    representation of the given 3-dimensional value matrix using function
</span><span class="noop">    :func:`repr_`.&#34;&#34;&#34;
</span><span class="hit">    prefix += assignrepr_bracketed1._brackets[0]
</span><span class="hit">    lines = []
</span><span class="hit">    blanks = &#39; &#39;*len(prefix)
</span><span class="hit">    for (idx, subvalues) in enumerate(values):
</span><span class="hit">        if idx == 0:
</span><span class="hit">            lines.append(_assignrepr_bracketed2(
</span><span class="noop">                            assignrepr_bracketed1, subvalues, prefix, width))
</span><span class="noop">        else:
</span><span class="hit">            lines.append(_assignrepr_bracketed2(
</span><span class="noop">                            assignrepr_bracketed1, subvalues, blanks, width))
</span><span class="hit">        if (len(subvalues) &lt;= 1) and (lines[-1][-1] == &#39;)&#39;):
</span><span class="hit">            lines[-1] = lines[-1][:-1] + &#39;,)&#39;
</span><span class="hit">        lines[-1] += &#39;,&#39;
</span><span class="hit">    lines[-1] = lines[-1][:-1] + assignrepr_bracketed1._brackets[1]
</span><span class="hit">    if (len(values) &lt;= 1) and (lines[-1][-1] == &#39;)&#39;):
</span><span class="hit">        lines[-1] = lines[-1][:-1] + &#39;,)&#39;
</span><span class="hit">    return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def assignrepr_tuple3(values, prefix, width=None):
</span><span class="noop">    &#34;&#34;&#34;Return a prefixed, wrapped and properly aligned tuple string
</span><span class="noop">    representation of the given 3-dimensional value matrix using function
</span><span class="noop">    :func:`repr_`.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import assignrepr_tuple3
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; values = [numpy.eye(3), numpy.ones((3, 3))]
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_tuple3(values, &#39;test = &#39;, 18))
</span><span class="noop">    test = (((1.0,
</span><span class="noop">              0.0,
</span><span class="noop">              0.0),
</span><span class="noop">             (0.0,
</span><span class="noop">              1.0,
</span><span class="noop">              0.0),
</span><span class="noop">             (0.0,
</span><span class="noop">              0.0,
</span><span class="noop">              1.0)),
</span><span class="noop">            ((1.0,
</span><span class="noop">              1.0,
</span><span class="noop">              1.0),
</span><span class="noop">             (1.0,
</span><span class="noop">              1.0,
</span><span class="noop">              1.0),
</span><span class="noop">             (1.0,
</span><span class="noop">              1.0,
</span><span class="noop">              1.0)))
</span><span class="noop">
</span><span class="noop">    If no width is given, no wrapping is performed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_tuple3(values, &#39;test = &#39;))
</span><span class="noop">    test = (((1.0, 0.0, 0.0),
</span><span class="noop">             (0.0, 1.0, 0.0),
</span><span class="noop">             (0.0, 0.0, 1.0)),
</span><span class="noop">            ((1.0, 1.0, 1.0),
</span><span class="noop">             (1.0, 1.0, 1.0),
</span><span class="noop">             (1.0, 1.0, 1.0)))
</span><span class="noop">
</span><span class="noop">    Functions :func:`assignrepr_tuple3` works also on empty iterables and
</span><span class="noop">    those which possess only one entry:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_tuple3([[[]]], &#39;test = &#39;))
</span><span class="noop">    test = (((),),)
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_tuple3([[[], [1]]], &#39;test = &#39;))
</span><span class="noop">    test = (((),
</span><span class="noop">             (1,)),)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return _assignrepr_bracketed3(assignrepr_tuple, values, prefix, width)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def assignrepr_list3(values, prefix, width=None):
</span><span class="noop">    &#34;&#34;&#34;Return a prefixed, wrapped and properly aligned list string
</span><span class="noop">    representation of the given 3-dimensional value matrix using function
</span><span class="noop">    :func:`repr_`.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import assignrepr_list3
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; values = [numpy.eye(3), numpy.ones((3, 3))]
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_list3(values, &#39;test = &#39;, 18))
</span><span class="noop">    test = [[[1.0,
</span><span class="noop">              0.0,
</span><span class="noop">              0.0],
</span><span class="noop">             [0.0,
</span><span class="noop">              1.0,
</span><span class="noop">              0.0],
</span><span class="noop">             [0.0,
</span><span class="noop">              0.0,
</span><span class="noop">              1.0]],
</span><span class="noop">            [[1.0,
</span><span class="noop">              1.0,
</span><span class="noop">              1.0],
</span><span class="noop">             [1.0,
</span><span class="noop">              1.0,
</span><span class="noop">              1.0],
</span><span class="noop">             [1.0,
</span><span class="noop">              1.0,
</span><span class="noop">              1.0]]]
</span><span class="noop">
</span><span class="noop">    If no width is given, no wrapping is performed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_list3(values, &#39;test = &#39;))
</span><span class="noop">    test = [[[1.0, 0.0, 0.0],
</span><span class="noop">             [0.0, 1.0, 0.0],
</span><span class="noop">             [0.0, 0.0, 1.0]],
</span><span class="noop">            [[1.0, 1.0, 1.0],
</span><span class="noop">             [1.0, 1.0, 1.0],
</span><span class="noop">             [1.0, 1.0, 1.0]]]
</span><span class="noop">
</span><span class="noop">    Functions :func:`assignrepr_list3` works also on empty iterables and
</span><span class="noop">    those which possess only one entry:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_list3([[[]]], &#39;test = &#39;))
</span><span class="noop">    test = [[[]]]
</span><span class="noop">    &gt;&gt;&gt; print(assignrepr_list3([[[], [1]]], &#39;test = &#39;))
</span><span class="noop">    test = [[[],
</span><span class="noop">             [1]]]
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return _assignrepr_bracketed3(assignrepr_list, values, prefix, width)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def round_(values, decimals=None, width=0,
</span><span class="noop">           lfill=None, rfill=None, **kwargs):
</span><span class="noop">    &#34;&#34;&#34;Prints values with a maximum number of digits in doctests.
</span><span class="noop">
</span><span class="noop">    See the documentation on function :func:`repr_` for more details.  And
</span><span class="noop">    note thate the option keyword arguments are passed to the print function.
</span><span class="noop">
</span><span class="noop">    Usually one would apply function :func:`round_` on a single or a vector
</span><span class="noop">    of numbers:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; round_(1./3., decimals=6)
</span><span class="noop">    0.333333
</span><span class="noop">    &gt;&gt;&gt; round_((1./2., 1./3., 1./4.), decimals=4)
</span><span class="noop">    0.5, 0.3333, 0.25
</span><span class="noop">
</span><span class="noop">    Additionally, one can supply a `width` and a `rfill` argument:
</span><span class="noop">    &gt;&gt;&gt; round_(1.0, width=6, rfill=&#39;0&#39;)
</span><span class="noop">    1.0000
</span><span class="noop">
</span><span class="noop">    Alternatively, one can use the `lfill` arguments, which
</span><span class="noop">    might e.g. be usefull for aligning different strings:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; round_(&#39;test&#39;, width=6, lfill=&#39;_&#39;)
</span><span class="noop">    __test
</span><span class="noop">
</span><span class="noop">    Using both the `lfill` and the `rfill` argument raises an error:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; round_(1.0, lfill=&#39;_&#39;, rfill=&#39;0&#39;)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: For function `round_` values are passed for both arguments `lfill` and `rfill`.  This is not allowed.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if decimals is None:
</span><span class="hit">        decimals = pub.options.reprdigits
</span><span class="hit">    with pub.options.reprdigits(decimals):
</span><span class="hit">        if hasattr(values, &#39;__iter__&#39;) and (not isinstance(values, str)):
</span><span class="hit">            string = repr_values(values)
</span><span class="noop">        else:
</span><span class="hit">            string = repr_(values)
</span><span class="hit">        if (lfill is not None) and (rfill is not None):
</span><span class="hit">            raise ValueError(
</span><span class="noop">                &#39;For function `round_` values are passed for both arguments &#39;
</span><span class="noop">                &#39;`lfill` and `rfill`.  This is not allowed.&#39;)
</span><span class="hit">        if (lfill is not None) or (rfill is not None):
</span><span class="hit">            width = max(width, len(string))
</span><span class="hit">            if lfill is not None:
</span><span class="hit">                string = string.rjust(width, lfill)
</span><span class="noop">            else:
</span><span class="hit">                string = string.ljust(width, rfill)
</span><span class="hit">        print(string, **kwargs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def extract(values, types, skip=False):
</span><span class="noop">    &#34;&#34;&#34;Return a generator that extracts certain objects from `values`.
</span><span class="noop">
</span><span class="noop">    This function is thought for supporting the definition of functios
</span><span class="noop">    with arguments, that can be objects of of contain types or that can
</span><span class="noop">    be iterables containing these objects.
</span><span class="noop">
</span><span class="noop">    The following examples show that function :func:`extract`
</span><span class="noop">    basically implements a type specific flattening mechanism:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import extract
</span><span class="noop">    &gt;&gt;&gt; tuple(extract(&#39;str1&#39;, (str, int)))
</span><span class="noop">    (&#39;str1&#39;,)
</span><span class="noop">    &gt;&gt;&gt; tuple(extract([&#39;str1&#39;, &#39;str2&#39;], (str, int)))
</span><span class="noop">    (&#39;str1&#39;, &#39;str2&#39;)
</span><span class="noop">    &gt;&gt;&gt; tuple(extract(([&#39;str1&#39;, &#39;str2&#39;], [1,]), (str, int)))
</span><span class="noop">    (&#39;str1&#39;, &#39;str2&#39;, 1)
</span><span class="noop">
</span><span class="noop">    If an object is neither iterable nor of the required type, the
</span><span class="noop">    following exception is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; tuple(extract(([&#39;str1&#39;, &#39;str2&#39;], [None, 1]), (str, int)))
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    TypeError: The given value `None` is neither iterable nor an instance of the following classes: str, int.
</span><span class="noop">
</span><span class="noop">    Optionally, :class:`None` values can be skipped:
</span><span class="noop">    &gt;&gt;&gt; tuple(extract(None, (str, int), True))
</span><span class="noop">    ()
</span><span class="noop">    &gt;&gt;&gt; tuple(extract(([&#39;str1&#39;, &#39;str2&#39;], [None, 1]), (str, int), True))
</span><span class="noop">    (&#39;str1&#39;, &#39;str2&#39;, 1)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if isinstance(values, types):
</span><span class="hit">        yield values
</span><span class="hit">    elif skip and (values is None):
</span><span class="hit">        return
</span><span class="noop">    else:
</span><span class="hit">        try:
</span><span class="hit">            for value in values:
</span><span class="hit">                for subvalue in extract(value, types, skip):
</span><span class="hit">                    yield subvalue
</span><span class="hit">        except TypeError as exc:
</span><span class="hit">            if exc.args[0].startswith(&#39;The given value&#39;):
</span><span class="hit">                raise exc
</span><span class="noop">            else:
</span><span class="hit">                raise TypeError(
</span><span class="noop">                    &#39;The given value `%s` is neither iterable nor an &#39;
</span><span class="noop">                    &#39;instance of the following classes: %s.&#39;
</span><span class="noop">                    % (values,
</span><span class="noop">                       &#39;, &#39;.join(instancename(type_) for type_ in types)))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def trim(self, lower=None, upper=None):
</span><span class="noop">    &#34;&#34;&#34;Trim the value(s) of  a :class:`ValueMath` instance.
</span><span class="noop">
</span><span class="noop">    One can pass the lower and/or the upper boundary as a function argument.
</span><span class="noop">    Otherwise, boundary values are taken from the class attribute `SPAN`
</span><span class="noop">    of the given :class:`ValueMath` instance, if available.
</span><span class="noop">
</span><span class="noop">    Note that method :func:`trim` works differently on :class:`ValueMath`
</span><span class="noop">    instances handling values of different types.  For floating point values,
</span><span class="noop">    an actual trimming is performed.  Additionally, a warning message is
</span><span class="noop">    raised if the trimming results in a change in value exceeding the
</span><span class="noop">    threshold value defined by function :func:`_tolerance`.  (This warning
</span><span class="noop">    message can be suppressed by setting the related option flag to False.)
</span><span class="noop">    For integer values, instead of a warning an exception is raised.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    span = getattr(self, &#39;SPAN&#39;, (None, None))
</span><span class="hit">    if lower is None:
</span><span class="hit">        lower = span[0]
</span><span class="hit">    if upper is None:
</span><span class="hit">        upper = span[1]
</span><span class="hit">    type_ = getattr(self, &#39;TYPE&#39;, float)
</span><span class="hit">    if type_ is float:
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            _trim_float_0d(self, lower, upper)
</span><span class="noop">        else:
</span><span class="hit">            _trim_float_nd(self, lower, upper)
</span><span class="hit">    elif type_ in (int, bool):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            _trim_int_0d(self, lower, upper)
</span><span class="noop">        else:
</span><span class="hit">            _trim_int_nd(self, lower, upper)
</span><span class="noop">    else:
</span><span class="miss">        raise NotImplementedError(
</span><span class="noop">            &#39;Method `trim` can only be applied on parameters handling &#39;
</span><span class="noop">            &#39;integer or floating point values, but value type of parameter &#39;
</span><span class="noop">            &#39;`%s` is `%s`.&#39; % (self.name, classname(self.TYPE)))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _trim_float_0d(self, lower, upper):
</span><span class="hit">    if numpy.isnan(self.value):
</span><span class="hit">        return
</span><span class="hit">    if (lower is None) or numpy.isnan(lower):
</span><span class="hit">        lower = -numpy.inf
</span><span class="hit">    if (upper is None) or numpy.isnan(upper):
</span><span class="hit">        upper = numpy.inf
</span><span class="hit">    if self &lt; lower:
</span><span class="hit">        if (self+_tolerance(self)) &lt; (lower-_tolerance(lower)):
</span><span class="hit">            if pub.options.warntrim:
</span><span class="miss">                self.warntrim()
</span><span class="hit">        self.value = lower
</span><span class="hit">    elif self &gt; upper:
</span><span class="hit">        if (self-_tolerance(self)) &gt; (upper+_tolerance(upper)):
</span><span class="hit">            if pub.options.warntrim:
</span><span class="miss">                self.warntrim()
</span><span class="hit">        self.value = upper
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _trim_float_nd(self, lower, upper):
</span><span class="hit">    if lower is None:
</span><span class="hit">        lower = -numpy.inf
</span><span class="hit">    lower = numpy.full(self.shape, lower, dtype=float)
</span><span class="hit">    lower[numpy.where(numpy.isnan(lower))] = -numpy.inf
</span><span class="hit">    if upper is None:
</span><span class="hit">        upper = numpy.inf
</span><span class="hit">    upper = numpy.full(self.shape, upper, dtype=float)
</span><span class="hit">    upper[numpy.where(numpy.isnan(upper))] = numpy.inf
</span><span class="hit">    idxs = numpy.where(numpy.isnan(self.values))
</span><span class="hit">    self[idxs] = lower[idxs]
</span><span class="hit">    if numpy.any(self &lt; lower) or numpy.any(self &gt; upper):
</span><span class="hit">        if (numpy.any((self+_tolerance(self)) &lt;
</span><span class="noop">                      (lower-_tolerance(lower))) or
</span><span class="noop">                numpy.any((self-_tolerance(self)) &gt;
</span><span class="noop">                          (upper+_tolerance(upper)))):
</span><span class="hit">            if pub.options.warntrim:
</span><span class="miss">                self.warntrim()
</span><span class="hit">        self.values = numpy.clip(self.values, lower, upper)
</span><span class="hit">    self[idxs] = numpy.nan
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _trim_int_0d(self, lower, upper):
</span><span class="hit">    if lower is None:
</span><span class="miss">        lower = _INT_NAN
</span><span class="hit">    if upper is None:
</span><span class="hit">        upper = -_INT_NAN
</span><span class="hit">    if (self != _INT_NAN) and ((self &lt; lower) or (self &gt; upper)):
</span><span class="miss">        raise ValueError(
</span><span class="noop">            &#39;The value `%d` of parameter `%s` of element `%s` is not valid.  &#39;
</span><span class="noop">            % (self.value, self.name, devicename(self)))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _trim_int_nd(self, lower, upper):
</span><span class="hit">    if lower is None:
</span><span class="hit">        lower = _INT_NAN
</span><span class="hit">    lower = numpy.full(self.shape, lower, dtype=int)
</span><span class="hit">    if upper is None:
</span><span class="hit">        upper = -_INT_NAN
</span><span class="hit">    upper = numpy.full(self.shape, upper, dtype=int)
</span><span class="hit">    idxs = numpy.where(self == _INT_NAN)
</span><span class="hit">    self[idxs] = lower[idxs]
</span><span class="hit">    if numpy.any(self &lt; lower) or numpy.any(self &gt; upper):
</span><span class="miss">        raise ValueError(
</span><span class="noop">            &#39;At least one value of parameter `%s` of element `%s` is not &#39;
</span><span class="noop">            &#39;valid.&#39; % (self.name, devicename(self)))
</span><span class="hit">    self[idxs] = _INT_NAN
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _tolerance(values):
</span><span class="noop">    &#34;&#34;&#34;Returns some sort of &#34;numerical accuracy&#34; to be expected for the
</span><span class="noop">    given floating point value, see method :func:`trim`.&#34;&#34;&#34;
</span><span class="hit">    return abs(values*1e-15)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ValueMath(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for :class:`~hydpy.core.parametertools.Parameter` and
</span><span class="noop">    :class:`~hydpy.core.sequencetools.Sequence`.  Implements special
</span><span class="noop">    methods for arithmetic calculations, comparisons and type conversions.
</span><span class="noop">
</span><span class="noop">    The subclasses are required to provide the members `NDIM` (usually a
</span><span class="noop">    class attribute) and `value` (usually a property).  But for testing
</span><span class="noop">    purposes, one can simply add them as instance attributes.
</span><span class="noop">
</span><span class="noop">    A few examples for 0-dimensional objects:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import ValueMath
</span><span class="noop">    &gt;&gt;&gt; vm0 = ValueMath()
</span><span class="noop">    &gt;&gt;&gt; vm0.NDIM = 0
</span><span class="noop">    &gt;&gt;&gt; vm0.shape = ()
</span><span class="noop">    &gt;&gt;&gt; vm0.value = 2.
</span><span class="noop">    &gt;&gt;&gt; print(vm0 + vm0)
</span><span class="noop">    4.0
</span><span class="noop">    &gt;&gt;&gt; print(3. - vm0)
</span><span class="noop">    1.0
</span><span class="noop">    &gt;&gt;&gt; vm0 /= 2.
</span><span class="noop">    &gt;&gt;&gt; print(vm0.value)
</span><span class="noop">    1.0
</span><span class="noop">    &gt;&gt;&gt; print(vm0 &gt; vm0)
</span><span class="noop">    False
</span><span class="noop">    &gt;&gt;&gt; print(vm0 != 1.5)
</span><span class="noop">    True
</span><span class="noop">    &gt;&gt;&gt; vm0.length
</span><span class="noop">    1
</span><span class="noop">
</span><span class="noop">    Similar examples for 1-dimensional objects:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; vm1 = ValueMath()
</span><span class="noop">    &gt;&gt;&gt; vm1.NDIM = 1
</span><span class="noop">    &gt;&gt;&gt; vm1.shape = (5,)
</span><span class="noop">    &gt;&gt;&gt; vm1.value = numpy.array([1.,2.,3.])
</span><span class="noop">    &gt;&gt;&gt; print(vm1 + vm1)
</span><span class="noop">    [ 2.  4.  6.]
</span><span class="noop">    &gt;&gt;&gt; print(3. - vm1)
</span><span class="noop">    [ 2.  1.  0.]
</span><span class="noop">    &gt;&gt;&gt; vm1 /= 2.
</span><span class="noop">    &gt;&gt;&gt; print(vm1.value)
</span><span class="noop">    [ 0.5  1.   1.5]
</span><span class="noop">    &gt;&gt;&gt; print(vm1 &gt; vm1)
</span><span class="noop">    [False False False]
</span><span class="noop">    &gt;&gt;&gt; print(vm1 != 1.5)
</span><span class="noop">    [ True  True False]
</span><span class="noop">    &gt;&gt;&gt;
</span><span class="noop">    &gt;&gt;&gt; vm1.length
</span><span class="noop">    5
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">    # Subclasses need to define...
</span><span class="hit">    NDIM = None    # ... e.g. as class attribute (int)
</span><span class="hit">    name = None    # ... e.g. as property (str)
</span><span class="hit">    value = None   # ... e.g. as property (float or ndarray of dtype float)
</span><span class="hit">    shape = None   # ... e.gl as property (tuple of values of type int)
</span><span class="noop">    # ...and optionally...
</span><span class="hit">    INIT = None
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def _arithmetic_conversion(other):
</span><span class="hit">        try:
</span><span class="hit">            return other.value
</span><span class="hit">        except AttributeError:
</span><span class="hit">            return other
</span><span class="noop">
</span><span class="hit">    def _arithmetic_exception(self, verb, other):
</span><span class="miss">        augmentexcmessage(&#39;While trying to %s %s instance `%s` and %s `%s`&#39;
</span><span class="noop">                          % (verb, classname(self), self.name,
</span><span class="noop">                             classname(other), other))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def length(self):
</span><span class="hit">        length = 1
</span><span class="hit">        for idx in range(self.NDIM):
</span><span class="hit">            length *= self.shape[idx]
</span><span class="hit">        return length
</span><span class="noop">
</span><span class="hit">    def __add__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value + self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;add&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __radd__(self, other):
</span><span class="hit">        return self.__add__(other)
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, other):
</span><span class="miss">        self.value = self.__add__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value - self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;subtract&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __rsub__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self._arithmetic_conversion(other) - self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;subtract&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __isub__(self, other):
</span><span class="miss">        self.value = self.__sub__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __mul__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value * self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;multiply&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __rmul__(self, other):
</span><span class="hit">        return self.__mul__(other)
</span><span class="noop">
</span><span class="hit">    def __imul__(self, other):
</span><span class="hit">        self.value = self.__mul__(other)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __truediv__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value / self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;divide&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __rtruediv__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self._arithmetic_conversion(other) / self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;divide&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __itruediv__(self, other):
</span><span class="hit">        self.value = self.__truediv__(other)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __floordiv__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self.value // self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;floor divide&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __rfloordiv__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self._arithmetic_conversion(other) // self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;floor divide&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __ifloordiv__(self, other):
</span><span class="miss">        self.value = self.__floordiv__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __mod__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self.value % self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;mod divide&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __rmod__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self._arithmetic_conversion(other) % self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;mod divide&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __imod__(self, other):
</span><span class="miss">        self.value = self.__mod__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __pow__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self.value**self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;exponentiate&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __rpow__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self._arithmetic_conversion(other)**self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;exponentiate&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __ipow__(self, other):
</span><span class="miss">        self.value = self.__pow__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __neg__(self):
</span><span class="hit">        return -self.value
</span><span class="noop">
</span><span class="hit">    def __pos__(self):
</span><span class="miss">        return +self.value
</span><span class="noop">
</span><span class="hit">    def __abs__(self):
</span><span class="miss">        return abs(self.value)
</span><span class="noop">
</span><span class="hit">    def __invert__(self):
</span><span class="miss">        return 1./self.value
</span><span class="noop">
</span><span class="hit">    def __floor__(self):
</span><span class="miss">        return self.value // 1.
</span><span class="noop">
</span><span class="hit">    def __ceil__(self):
</span><span class="miss">        return numpy.ceil(self.value)
</span><span class="noop">
</span><span class="hit">    def __trunc__(self):
</span><span class="miss">        return numpy.trunc(self.value)
</span><span class="noop">
</span><span class="hit">    def __divmod__(self, other):
</span><span class="miss">        return numpy.divmod(self.value, other)
</span><span class="noop">
</span><span class="hit">    def __rdivmod__(self, other):
</span><span class="miss">        return numpy.divmod(other, self.value)
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value &lt; self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (&lt;)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value &lt;= self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (&lt;=)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value == self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (==)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value != self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (!=)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value &gt;= self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (&gt;=)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value &gt; self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (&gt;)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def _typeconversion(self, type_):
</span><span class="hit">        if not self.NDIM:
</span><span class="hit">            if isinstance(type_, type):
</span><span class="hit">                return type_(self.value)
</span><span class="noop">            else:
</span><span class="miss">                attr = getattr(self.value, type_)
</span><span class="miss">                try:
</span><span class="miss">                    return attr()
</span><span class="miss">                except TypeError:
</span><span class="miss">                    return attr
</span><span class="noop">        else:
</span><span class="miss">            raise TypeError(&#39;The %s instance `%s` is %d-dimensional and thus &#39;
</span><span class="noop">                            &#39;cannot be converted to a scalar %s value.&#39;
</span><span class="noop">                            % (classname(self), self.name, self.NDIM,
</span><span class="noop">                               classname(type_)))
</span><span class="noop">
</span><span class="hit">    def __bool__(self):
</span><span class="miss">        return self._typeconversion(bool)
</span><span class="noop">
</span><span class="hit">    def __float__(self):
</span><span class="hit">        return self._typeconversion(float)
</span><span class="noop">
</span><span class="hit">    def __int__(self):
</span><span class="miss">        return self._typeconversion(int)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def real(self):
</span><span class="miss">        return self._typeconversion(&#39;real&#39;)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def imag(self):
</span><span class="miss">        return self._typeconversion(&#39;imag&#39;)
</span><span class="noop">
</span><span class="hit">    def conjugate(self):
</span><span class="miss">        return self._typeconversion(&#39;conjugate&#39;)
</span><span class="noop">
</span><span class="hit">    def __complex__(self):
</span><span class="miss">        return numpy.complex(self.value)
</span><span class="noop">
</span><span class="hit">    def __round__(self, ndigits=0):
</span><span class="hit">        return numpy.round(self.value, ndigits)
</span><span class="noop">
</span><span class="hit">    def commentrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a list with comments, e.g. for making string representations
</span><span class="noop">        more informative.  When :attr:`pub.options.reprcomments` is set to
</span><span class="noop">        `False`, an empty list is returned.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if pub.options.reprcomments:
</span><span class="hit">            return [&#39;# %s&#39; % line for line in
</span><span class="noop">                    textwrap.wrap(autodoctools.description(self), 78)]
</span><span class="noop">        else:
</span><span class="hit">            return []
</span><span class="noop">
</span><span class="hit">    def _repr(self, values, islong):
</span><span class="hit">        prefix = &#39;%s(&#39; % self.name
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            string = &#39;%s(%s)&#39; % (self.name, repr_(values))
</span><span class="hit">        elif self.NDIM == 1:
</span><span class="hit">            if islong:
</span><span class="miss">                string = assignrepr_list(values, prefix, 75) + &#39;)&#39;
</span><span class="noop">            else:
</span><span class="hit">                string = assignrepr_values(values, prefix, 75) + &#39;)&#39;
</span><span class="hit">        elif self.NDIM == 2:
</span><span class="hit">            if islong:
</span><span class="miss">                string = assignrepr_list2(values, prefix, 75) + &#39;)&#39;
</span><span class="noop">            else:
</span><span class="hit">                string = assignrepr_values2(values, prefix) + &#39;)&#39;
</span><span class="noop">        else:
</span><span class="miss">            raise NotImplementedError(
</span><span class="noop">                &#39;`repr` does not yet support parameters or sequences like `%s`&#39;
</span><span class="noop">                &#39;of element `%s` which handle %d-dimensional matrices.&#39;
</span><span class="noop">                % self.NDIM)
</span><span class="hit">        return &#39;\n&#39;.join(self.commentrepr() + [string])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FastAccess(object):
</span><span class="noop">    &#34;&#34;&#34;Used as a surrogate for typed Cython classes when working in
</span><span class="noop">    pure Python mode.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HydPyDeprecationWarning(DeprecationWarning):
</span><span class="hit">    pass
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/optiontools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/optiontools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements classes that help to manage global HydPy options.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class _Context(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self, option):
</span><span class="hit">        self.option = option
</span><span class="hit">        self.old_value = option.value
</span><span class="noop">
</span><span class="hit">    def __enter__(self):
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __call__(self, value, optional=False):
</span><span class="hit">        if (self.option.value == self.option.nothing) or not optional:
</span><span class="hit">            self.option.value = self.option.type_(value)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __exit__(self, type_, value, traceback):
</span><span class="hit">        self.option.value = self.old_value
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class _IntContext(_Context, int):
</span><span class="noop">
</span><span class="hit">    def __new__(cls, option):
</span><span class="hit">        return super(_Context, cls).__new__(cls, option.value)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class _FloatContext(_Context, float):
</span><span class="noop">
</span><span class="hit">    def __new__(cls, option):
</span><span class="miss">        return super(_Context, cls).__new__(cls, option.value)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class _StrContext(_Context, str):
</span><span class="noop">
</span><span class="hit">    def __new__(cls, option):
</span><span class="miss">        return super(_Context, cls).__new__(cls, option.value)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class _Option(object):
</span><span class="noop">
</span><span class="hit">    TYPE2CONTEXT = {int: _IntContext,
</span><span class="noop">                    bool: _IntContext,
</span><span class="noop">                    float: _FloatContext,
</span><span class="noop">                    str: _StrContext}
</span><span class="noop">
</span><span class="hit">    def __init__(self, default, nothing=None, docstring=&#39;&#39;):
</span><span class="hit">        self.default = default
</span><span class="hit">        self.nothing = nothing
</span><span class="hit">        self.value = default
</span><span class="hit">        self.type_ = type(default)
</span><span class="hit">        self.context = self.TYPE2CONTEXT
</span><span class="hit">        self.__doc__ = docstring
</span><span class="noop">
</span><span class="hit">    def __get__(self, options, type_=None):
</span><span class="hit">        context = self.TYPE2CONTEXT[self.type_](self)
</span><span class="hit">        context.__doc__ = self.__doc__
</span><span class="hit">        context.default = self.default
</span><span class="hit">        context.nothing = self.nothing
</span><span class="hit">        return context
</span><span class="noop">
</span><span class="hit">    def __set__(self, options, value):
</span><span class="hit">        self.value = self.type_(value)
</span><span class="noop">
</span><span class="hit">    def __delete__(self, options):
</span><span class="miss">        self.value = self.default
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Options(object):
</span><span class="noop">    &#34;&#34;&#34;Singleton class for `global` options placed in module :mod:`~hydpy.pub`.
</span><span class="noop">
</span><span class="noop">    Note that Most options are simple True/False or 0/1 flags.
</span><span class="noop">
</span><span class="noop">    You can change all options in two ways.  By using the `with` statement,
</span><span class="noop">    you make sure that the change is undone after leaving the corresponding
</span><span class="noop">    code block (even if an error occurs):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; options.printprogress = 0
</span><span class="noop">    &gt;&gt;&gt; options.printprogress
</span><span class="noop">    0
</span><span class="noop">    &gt;&gt;&gt; with options.printprogress(True):
</span><span class="noop">    ...     print(options.printprogress)
</span><span class="noop">    1
</span><span class="noop">    &gt;&gt;&gt; options.printprogress
</span><span class="noop">    0
</span><span class="noop">
</span><span class="noop">    Alternatively, you can change all options via simple assignements:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; options.printprogress = True
</span><span class="noop">    &gt;&gt;&gt; options.printprogress
</span><span class="noop">    1
</span><span class="noop">
</span><span class="noop">    But then you might have to keep in mind to undo the change later:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; options.printprogress
</span><span class="noop">    1
</span><span class="noop">    &gt;&gt;&gt; options.printprogress = False
</span><span class="noop">    &gt;&gt;&gt; options.printprogress
</span><span class="noop">    0
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    checkseries = _Option(
</span><span class="noop">        True, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether an error shall be raised
</span><span class="noop">        when e.g. an incomplete input time series, not spanning the whole
</span><span class="noop">        initialization time period, is loaded.&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    ellipsis = _Option(
</span><span class="noop">        -999, -999,
</span><span class="noop">        &#34;&#34;&#34;Ellipsis points are used to shorten the string representations
</span><span class="noop">        of iterable HydPy objects containing many entries.  Set a value
</span><span class="noop">        to define the maximum number of entries before and behind ellipsis
</span><span class="noop">        points.  Set it to zero, if no ellipsis points should be drawn at
</span><span class="noop">        all.  Set it to -999 (the default value) to rely on the default
</span><span class="noop">        values of the respective iterables.&#34;&#34;&#34;)
</span><span class="hit">    ellipsis.type_ = int
</span><span class="noop">
</span><span class="hit">    fastcython = _Option(
</span><span class="noop">        True, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether Cythonization shall be
</span><span class="noop">        configured in a fast but unsafe (True) or in a slow but safe (False)
</span><span class="noop">        mode.  The fast mode is the default.  Setting this flag to False
</span><span class="noop">        can be helpful when the implementation of new models or other
</span><span class="noop">        Cython related features introduces errors that do not result in
</span><span class="noop">        informative error messages.&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    printprogress = _Option(
</span><span class="noop">        True, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether information about the progress
</span><span class="noop">        of certain processes shall be printed to the standard output or not.
</span><span class="noop">        The default is `True`.&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    printincolor = _Option(
</span><span class="noop">        True, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether information shall be printed
</span><span class="noop">        in color eventually or not. The default is `True`.&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    reprcomments = _Option(
</span><span class="noop">        True, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicationg whether comments shall be included
</span><span class="noop">        in string representations of some classes of the HydPy framework or
</span><span class="noop">        not.  The default is `True`.&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    reprdigits = _Option(
</span><span class="noop">        -999, -999,
</span><span class="noop">        &#34;&#34;&#34;Required precision of string representations of floating point
</span><span class="noop">        numbers, defined as the minimum number of digits to be reproduced
</span><span class="noop">        by the string representation (see function :func:`repr_`).&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    skipdoctests = _Option(
</span><span class="noop">        False, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether documetation tests shall be
</span><span class="noop">        performed under certain situations.  Applying tests increases
</span><span class="noop">        reliabilty and is thus the default.&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    usecython = _Option(
</span><span class="noop">        True, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether Cython models (True) or pure
</span><span class="noop">        Python models (False) shall be applied if possible.  Using Cython
</span><span class="noop">        models is more time efficient and thus the default.&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    usedefaultvalues = _Option(
</span><span class="noop">        False, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether parameters values shall be
</span><span class="noop">        initialized with standard values or not.&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    dirverbose = _Option(
</span><span class="noop">        False, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicationg whether the listboxes for the member
</span><span class="noop">        selection of the classes of the HydPy framework should be complete
</span><span class="noop">        (True) or restrictive (False).  The latter is more viewable and hence
</span><span class="noop">        the default.&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    warnmissingcontrolfile = _Option(
</span><span class="noop">        False, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether only a warning shall be raised
</span><span class="noop">        when a required control file is missing, or an exception.&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    warnmissingobsfile = _Option(
</span><span class="noop">        True, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether a warning shall be raised
</span><span class="noop">        when a requested observation sequence demanded by a node instance
</span><span class="noop">        is missing.&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    warnmissingsimfile = _Option(
</span><span class="noop">        True, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether a warning shall be raised
</span><span class="noop">        when a requested simulation sequence demanded by a node instance
</span><span class="noop">        is missing.&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    warnsimulationstep = _Option(
</span><span class="noop">        True, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether a warning shall be raised
</span><span class="noop">        when function :func:`~hydpy.core.magictools.simulationstep` is
</span><span class="noop">        called for the first time.&#34;&#34;&#34;)
</span><span class="noop">
</span><span class="hit">    warntrim = _Option(
</span><span class="noop">        True, None,
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether a warning shall be raised
</span><span class="noop">        whenever certain values needed to be trimmed due to violating
</span><span class="noop">        certain boundaries. Such warnings increase savety and are thus
</span><span class="noop">        the default is `True`.  However, to cope with the limited precision
</span><span class="noop">        of floating point numbers only those violations beyond a small
</span><span class="noop">        tolerance value are reported (see :class:`Trimmer`).  Warnings
</span><span class="noop">        with identical information are reported only once.&#34;&#34;&#34;)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/parametertools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/parametertools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
1399 &nbsp;
1400 &nbsp;
1401 &nbsp;
1402 &nbsp;
1403 &nbsp;
1404 &nbsp;
1405 &nbsp;
1406 &nbsp;
1407 &nbsp;
1408 &nbsp;
1409 &nbsp;
1410 &nbsp;
1411 &nbsp;
1412 &nbsp;
1413 &nbsp;
1414 &nbsp;
1415 &nbsp;
1416 &nbsp;
1417 &nbsp;
1418 &nbsp;
1419 &nbsp;
1420 &nbsp;
1421 &nbsp;
1422 &nbsp;
1423 &nbsp;
1424 &nbsp;
1425 &nbsp;
1426 &nbsp;
1427 &nbsp;
1428 &nbsp;
1429 &nbsp;
1430 &nbsp;
1431 &nbsp;
1432 &nbsp;
1433 &nbsp;
1434 &nbsp;
1435 &nbsp;
1436 &nbsp;
1437 &nbsp;
1438 &nbsp;
1439 &nbsp;
1440 &nbsp;
1441 &nbsp;
1442 &nbsp;
1443 &nbsp;
1444 &nbsp;
1445 &nbsp;
1446 &nbsp;
1447 &nbsp;
1448 &nbsp;
1449 &nbsp;
1450 &nbsp;
1451 &nbsp;
1452 &nbsp;
1453 &nbsp;
1454 &nbsp;
1455 &nbsp;
1456 &nbsp;
1457 &nbsp;
1458 &nbsp;
1459 &nbsp;
1460 &nbsp;
1461 &nbsp;
1462 &nbsp;
1463 &nbsp;
1464 &nbsp;
1465 &nbsp;
1466 &nbsp;
1467 &nbsp;
1468 &nbsp;
1469 &nbsp;
1470 &nbsp;
1471 &nbsp;
1472 &nbsp;
1473 &nbsp;
1474 &nbsp;
1475 &nbsp;
1476 &nbsp;
1477 &nbsp;
1478 &nbsp;
1479 &nbsp;
1480 &nbsp;
1481 &nbsp;
1482 &nbsp;
1483 &nbsp;
1484 &nbsp;
1485 &nbsp;
1486 &nbsp;
1487 &nbsp;
1488 &nbsp;
1489 &nbsp;
1490 &nbsp;
1491 &nbsp;
1492 &nbsp;
1493 &nbsp;
1494 &nbsp;
1495 &nbsp;
1496 &nbsp;
1497 &nbsp;
1498 &nbsp;
1499 &nbsp;
1500 &nbsp;
1501 &nbsp;
1502 &nbsp;
1503 &nbsp;
1504 &nbsp;
1505 &nbsp;
1506 &nbsp;
1507 &nbsp;
1508 &nbsp;
1509 &nbsp;
1510 &nbsp;
1511 &nbsp;
1512 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements tools for handling the parameters of
</span><span class="noop">hydrological models.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...standard
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import inspect
</span><span class="hit">import time
</span><span class="hit">import copy
</span><span class="hit">import warnings
</span><span class="noop"># ...third party
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import filetools
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># The import of `_strptime` is not thread save.  The following call of
</span><span class="noop"># `strptime` is supposed to prevent possible problems arising from this bug.
</span><span class="hit">time.strptime(&#39;1999&#39;, &#39;%Y&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Parameters(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling all parameters of a specific model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _names_subpars = (&#39;control&#39;, &#39;derived&#39;, &#39;solver&#39;)
</span><span class="noop">
</span><span class="hit">    def __init__(self, kwargs):
</span><span class="hit">        self.model = kwargs.get(&#39;model&#39;)
</span><span class="hit">        self.control = None
</span><span class="hit">        self.derived = None
</span><span class="hit">        self.solver = None
</span><span class="hit">        cythonmodule = kwargs.get(&#39;cythonmodule&#39;)
</span><span class="hit">        cymodel = kwargs.get(&#39;cymodel&#39;)
</span><span class="hit">        for (name, cls) in kwargs.items():
</span><span class="hit">            if name.endswith(&#39;Parameters&#39;) and issubclass(cls, SubParameters):
</span><span class="hit">                if cythonmodule:
</span><span class="miss">                    cls_fastaccess = getattr(cythonmodule, name)
</span><span class="miss">                    subpars = cls(self, cls_fastaccess, cymodel)
</span><span class="noop">                else:
</span><span class="hit">                    subpars = cls(self, None, None)
</span><span class="hit">                setattr(self, subpars.name, subpars)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Call the update methods of all derived and solver parameters.&#34;&#34;&#34;
</span><span class="hit">        for subpars in self.secondary_subpars:
</span><span class="hit">            for par in subpars._PARCLASSES:
</span><span class="hit">                name = objecttools.instancename(par)
</span><span class="hit">                try:
</span><span class="hit">                    subpars.__dict__[name].update()
</span><span class="miss">                except BaseException:
</span><span class="miss">                    objecttools.augmentexcmessage(
</span><span class="noop">                        &#39;While trying to update the %s parameter `%s` of &#39;
</span><span class="noop">                        &#39;element `%s`&#39;
</span><span class="noop">                        % (name, subpars.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def savecontrols(self, parameterstep=None, simulationstep=None,
</span><span class="noop">                     filename=None, dirname=None):
</span><span class="miss">        if self.control:
</span><span class="miss">            if filename is None:
</span><span class="miss">                filename = self._controldefaultfilename
</span><span class="miss">            if not filename.endswith(&#39;.py&#39;):
</span><span class="miss">                filename += &#39;.py&#39;
</span><span class="miss">            if dirname is None:
</span><span class="miss">                dirname = pub.controlmanager.controlpath
</span><span class="miss">            filepath = os.path.join(dirname, filename)
</span><span class="miss">            with open(filepath, &#39;w&#39;) as file_:
</span><span class="miss">                file_.write(&#39;from hydpy.models.%s import *\n\n&#39;
</span><span class="noop">                            % self.model.__module__.split(&#39;.&#39;)[2])
</span><span class="miss">                if not parameterstep:
</span><span class="miss">                    parameterstep = pub.timegrids.stepsize
</span><span class="miss">                file_.write(&#39;parameterstep(&#34;%s&#34;)\n&#39; % parameterstep)
</span><span class="miss">                if not simulationstep:
</span><span class="miss">                    simulationstep = pub.timegrids.stepsize
</span><span class="miss">                file_.write(&#39;simulationstep(&#34;%s&#34;)\n\n&#39; % simulationstep)
</span><span class="miss">                for (name, par) in self.control:
</span><span class="miss">                    _parameterstep = par._parameterstep
</span><span class="miss">                    try:
</span><span class="miss">                        par.parameterstep = parameterstep
</span><span class="miss">                        file_.write(repr(par) + &#39;\n&#39;)
</span><span class="noop">                    finally:
</span><span class="miss">                        par._parameterstep = _parameterstep
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def _controldefaultfilename(self):
</span><span class="miss">        filename = objecttools.devicename(self)
</span><span class="miss">        if filename == &#39;?&#39;:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;To save the control parameters of a model to a file, its &#39;
</span><span class="noop">                &#39;filename must be known.  This can be done, by passing &#39;
</span><span class="noop">                &#39;filename to function `savecontrols` directly.  &#39;
</span><span class="noop">                &#39;But in complete HydPy applications, it is usally &#39;
</span><span class="noop">                &#39;assumed to be consistent with the name of the element &#39;
</span><span class="noop">                &#39;handling the model.  Actually, neither a filename is given &#39;
</span><span class="noop">                &#39;nor does the model know its master element.&#39;)
</span><span class="noop">        else:
</span><span class="miss">            return filename + &#39;.py&#39;
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;&#34;&#34;&#34;
</span><span class="miss">        for (name, parameter) in self.control:
</span><span class="miss">            parameter.verify()
</span><span class="miss">        for (name, parameter) in self.derived:
</span><span class="miss">            parameter.verify()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def secondary_subpars(self):
</span><span class="hit">        for subpars in (self.derived, self.solver):
</span><span class="hit">            if subpars is not None:
</span><span class="hit">                yield subpars
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for name in self._names_subpars:
</span><span class="hit">            subpars = getattr(self, name)
</span><span class="hit">            if subpars is not None:
</span><span class="hit">                yield name, subpars
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="miss">        return len(dict(self))
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MetaSubParametersType(type):
</span><span class="hit">    def __new__(cls, name, parents, dict_):
</span><span class="hit">        parclasses = dict_.get(&#39;_PARCLASSES&#39;)
</span><span class="hit">        if parclasses is None:
</span><span class="hit">            raise NotImplementedError(
</span><span class="noop">                &#39;For class `%s`, the required tuple `_PARCLASSES` is not &#39;
</span><span class="noop">                &#39;defined.  Please see the documentation of class &#39;
</span><span class="noop">                &#39;`SubParameters` of module `parametertools` for further &#39;
</span><span class="noop">                &#39;information.&#39; % name)
</span><span class="hit">        if parclasses:
</span><span class="hit">            lst = [&#39;\n\n\n    The following parameter classes are selected:&#39;]
</span><span class="hit">            for parclass in parclasses:
</span><span class="hit">                    lst.append(&#39;      * :class:`~%s` `%s`&#39;
</span><span class="noop">                               % (&#39;.&#39;.join((parclass.__module__,
</span><span class="noop">                                            parclass.__name__)),
</span><span class="noop">                                  autodoctools.description(parclass)))
</span><span class="hit">            doc = dict_.get(&#39;__doc__&#39;, None)
</span><span class="hit">            if doc is None:
</span><span class="hit">                doc = &#39;&#39;
</span><span class="hit">            dict_[&#39;__doc__&#39;] = doc + &#39;\n&#39;.join(l for l in lst)
</span><span class="hit">        return type.__new__(cls, name, parents, dict_)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">MetaSubParametersClass = MetaSubParametersType(&#39;MetaSubParametersClass&#39;,
</span><span class="noop">                                               (), {&#39;_PARCLASSES&#39;: ()})
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SubParameters(MetaSubParametersClass):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling subgroups of model parameters.
</span><span class="noop">
</span><span class="noop">    When trying to implement a new model, one has to define its parameter
</span><span class="noop">    classes.  Currently, the HydPy framework  distinguishes between control
</span><span class="noop">    parameters and derived parameters.  These parameter classes should be
</span><span class="noop">    collected by subclasses of class :class:`SubParameters` called
</span><span class="noop">    `ControlParameters` or `DerivedParameters` respectivly.  This should be
</span><span class="noop">    done via the `_PARCLASSES` tuple in the following manner:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.parametertools import SingleParameter, SubParameters
</span><span class="noop">    &gt;&gt;&gt; class Par2(SingleParameter):
</span><span class="noop">    ...     pass
</span><span class="noop">    &gt;&gt;&gt; class Par1(SingleParameter):
</span><span class="noop">    ...     pass
</span><span class="noop">    &gt;&gt;&gt; class ControlParameters(SubParameters):
</span><span class="noop">    ...     _PARCLASSES = (Par2, Par1)
</span><span class="noop">
</span><span class="noop">    The order within the tuple determines the order of iteration, e.g.:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; control = ControlParameters(None) # Assign `None` for brevity.
</span><span class="noop">    &gt;&gt;&gt; control
</span><span class="noop">    par2(nan)
</span><span class="noop">    par1(nan)
</span><span class="noop">
</span><span class="noop">    If one forgets to define a `_PARCLASSES` tuple so (and maybe tries to add
</span><span class="noop">    the parameters in the constructor of the subclass of
</span><span class="noop">    :class:`SubParameters`, the following error is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; class ControlParameters(SubParameters):
</span><span class="noop">    ...     pass
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    NotImplementedError: For class `ControlParameters`, the required tuple `_PARCLASSES` is not defined.  Please see the documentation of class `SubParameters` of module `parametertools` for further information.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def __init__(self, pars, cls_fastaccess=None, cymodel=None):
</span><span class="hit">        self.pars = pars
</span><span class="hit">        if cls_fastaccess is None:
</span><span class="hit">            self.fastaccess = objecttools.FastAccess()
</span><span class="noop">        else:
</span><span class="miss">            self.fastaccess = cls_fastaccess()
</span><span class="miss">            setattr(cymodel.parameters, self.name, self.fastaccess)
</span><span class="hit">        for Par in self._PARCLASSES:
</span><span class="hit">            setattr(self, objecttools.instancename(Par), Par())
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def getname(cls):
</span><span class="hit">        return objecttools.instancename(cls)[:-10]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def name(self):
</span><span class="hit">        return self.getname()
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, name, value):
</span><span class="noop">        &#34;&#34;&#34;Attributes and methods should usually not be replaced.  Existing
</span><span class="noop">        :class:`Parameter` attributes are protected in a way, that only their
</span><span class="noop">        values are changed through assignements.  For new :class:`Parameter`
</span><span class="noop">        attributes, additional `fastaccess` references are defined.  If you
</span><span class="noop">        actually want to replace a parameter, you have to delete it first.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            attr = getattr(self, name)
</span><span class="hit">        except AttributeError:
</span><span class="hit">            object.__setattr__(self, name, value)
</span><span class="hit">            if hasattr(value, &#39;connect&#39;):
</span><span class="hit">                value.connect(self)
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                attr._setvalue(value)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;`%s` instances do not allow the direct&#39;
</span><span class="noop">                                   &#39;replacement of their members.  After &#39;
</span><span class="noop">                                   &#39;initialization you should usually only &#39;
</span><span class="noop">                                   &#39;change parameter values through &#39;
</span><span class="noop">                                   &#39;assignements.  If you really need to &#39;
</span><span class="noop">                                   &#39;replace a object member, delete it &#39;
</span><span class="noop">                                   &#39;beforehand.&#39; % objecttools.classname(self))
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for Par in self._PARCLASSES:
</span><span class="hit">            name = objecttools.instancename(Par)
</span><span class="hit">            yield name, getattr(self, name)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        lines = []
</span><span class="hit">        if pub.options.reprcomments:
</span><span class="miss">            lines.append(&#39;# %s object defined in module %s.&#39;
</span><span class="noop">                         % (objecttools.classname(self),
</span><span class="noop">                            objecttools.modulename(self)))
</span><span class="miss">            lines.append(&#39;# The implemented parameters with their actual &#39;
</span><span class="noop">                         &#39;values are:&#39;)
</span><span class="hit">        for (name, parameter) in self:
</span><span class="hit">            try:
</span><span class="hit">                lines.append(&#39;%s&#39; % repr(parameter))
</span><span class="miss">            except BaseException:
</span><span class="miss">                lines.append(&#39;%s(?)&#39; % name)
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Parameter(objecttools.ValueMath):
</span><span class="noop">    &#34;&#34;&#34;Base class for :class:`SingleParameter` and :class:`MultiParameter`.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _parameterstep = None
</span><span class="hit">    _simulationstep = None
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.subpars = None
</span><span class="hit">        self.fastaccess = objecttools.FastAccess()
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Parameter` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if args and kwargs:
</span><span class="miss">            raise ValueError(&#39;For parameter %s of element %s both positional &#39;
</span><span class="noop">                             &#39;and keyword arguments are given, which is &#39;
</span><span class="noop">                             &#39;ambiguous.&#39;
</span><span class="noop">                             % (self.name, objecttools.devicename(self)))
</span><span class="hit">        elif not args and not kwargs:
</span><span class="miss">            raise ValueError(&#39;For parameter %s of element %s neither a &#39;
</span><span class="noop">                             &#39;positional nor a keyword argument is given.&#39;
</span><span class="noop">                             % (self.name, objecttools.devicename(self)))
</span><span class="hit">        elif &#39;pyfile&#39; in kwargs:
</span><span class="miss">            values = self._getvalues_from_auxiliaryfile(kwargs[&#39;pyfile&#39;])
</span><span class="miss">            self.values = self.applytimefactor(values)
</span><span class="miss">            del(kwargs[&#39;pyfile&#39;])
</span><span class="hit">        elif args:
</span><span class="hit">            self.values = self.applytimefactor(numpy.array(args))
</span><span class="noop">        else:
</span><span class="hit">            raise NotImplementedError(&#39;The value(s) of parameter %s of &#39;
</span><span class="noop">                                      &#39;element %s could not be set based on &#39;
</span><span class="noop">                                      &#39;the given keyword arguments.&#39;
</span><span class="noop">                                      % (self.name,
</span><span class="noop">                                         objecttools.devicename(self)))
</span><span class="hit">        self.trim()
</span><span class="noop">
</span><span class="hit">    def _getvalues_from_auxiliaryfile(self, pyfile):
</span><span class="noop">        &#34;&#34;&#34;Tries to return the parameter values from the auxiliary control file
</span><span class="noop">        with the given name.
</span><span class="noop">
</span><span class="noop">        Things are a little complicated here.  To understand this method, you
</span><span class="noop">        should first take a look at function :func:`parameterstep`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        frame = inspect.currentframe().f_back.f_back
</span><span class="miss">        while frame:
</span><span class="miss">            namespace = frame.f_locals
</span><span class="miss">            try:
</span><span class="miss">                subnamespace = {&#39;model&#39;: namespace[&#39;model&#39;],
</span><span class="noop">                                &#39;focus&#39;: self}
</span><span class="miss">                break
</span><span class="miss">            except KeyError:
</span><span class="miss">                frame = frame.f_back
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;Something has gone wrong when trying to &#39;
</span><span class="noop">                               &#39;read parameter `%s` from file `%s`.&#39;
</span><span class="noop">                               % (self.name, pyfile))
</span><span class="miss">        filetools.ControlManager.read2dict(pyfile, subnamespace)
</span><span class="miss">        try:
</span><span class="miss">            subself = subnamespace[self.name]
</span><span class="miss">        except KeyError:
</span><span class="miss">            raise RuntimeError(&#39;Something has gone wrong when trying to &#39;
</span><span class="noop">                               &#39;read parameter `%s` from file `%s`.&#39;
</span><span class="noop">                               % (self.name, pyfile))
</span><span class="miss">        return subself.values
</span><span class="noop">
</span><span class="hit">    name = property(objecttools.name)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def initvalue(self):
</span><span class="hit">        initvalue = (getattr(self, &#39;INIT&#39;, None) if
</span><span class="noop">                     pub.options.usedefaultvalues else None)
</span><span class="hit">        if initvalue is None:
</span><span class="hit">            type_ = getattr(self, &#39;TYPE&#39;, float)
</span><span class="hit">            if type_ is float:
</span><span class="hit">                initvalue = numpy.nan
</span><span class="hit">            elif type_ is int:
</span><span class="hit">                initvalue = objecttools._INT_NAN
</span><span class="hit">            elif type_ is bool:
</span><span class="hit">                initvalue = False
</span><span class="noop">            else:
</span><span class="miss">                NotImplementedError(
</span><span class="noop">                    &#39;For parameter `%s` no `INIT` class attribute is &#39;
</span><span class="noop">                    &#39;defined, but no standard value for its TYPE `%s`&#39;
</span><span class="noop">                    &#39;is available&#39; % (self.name, objecttools.classname(type_)))
</span><span class="hit">        return initvalue
</span><span class="noop">
</span><span class="hit">    def _getparameterstep(self):
</span><span class="noop">        &#34;&#34;&#34;The parameter time step size new parameter values might be related
</span><span class="noop">        to.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if Parameter._parameterstep is None:
</span><span class="miss">            raise RuntimeError(&#39;The general parameter time step has not been &#39;
</span><span class="noop">                               &#39;defined so far.&#39;)
</span><span class="noop">        else:
</span><span class="hit">            return self._parameterstep
</span><span class="noop">
</span><span class="hit">    def _setparameterstep(self, value):
</span><span class="miss">        try:
</span><span class="miss">            Parameter._parameterstep = timetools.Period(value)
</span><span class="miss">        except Exception:
</span><span class="miss">            objecttools.augmentexcmessage(&#39;While trying to set the general &#39;
</span><span class="noop">                                          &#39;parameter time step&#39;)
</span><span class="noop">
</span><span class="hit">    parameterstep = property(_getparameterstep, _setparameterstep)
</span><span class="noop">
</span><span class="hit">    def _getsimulationstep(self):
</span><span class="noop">        &#34;&#34;&#34;The simulation time step size new parameter values might be related
</span><span class="noop">        to.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return pub.timegrids.stepsize
</span><span class="hit">        except AttributeError:
</span><span class="hit">            return Parameter._simulationstep
</span><span class="noop">
</span><span class="hit">    def _setsimulationstep(self, value):
</span><span class="hit">        try:
</span><span class="hit">            Parameter._simulationstep = timetools.Period(value)
</span><span class="miss">        except Exception:
</span><span class="miss">            objecttools.augmentexcmessage(&#39;While trying to set the general &#39;
</span><span class="noop">                                          &#39;simulation time step&#39;)
</span><span class="noop">
</span><span class="hit">    simulationstep = property(_getsimulationstep, _setsimulationstep)
</span><span class="noop">
</span><span class="hit">    def _gettimefactor(self):
</span><span class="noop">        &#34;&#34;&#34;Factor to adapt a new parameter value related to
</span><span class="noop">        :attr:`parameterstep` to a different simulation time step.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            parfactor = pub.timegrids.parfactor
</span><span class="hit">        except AttributeError:
</span><span class="hit">            if self._simulationstep is None:
</span><span class="miss">                raise RuntimeError(&#39;The calculation of the effective value &#39;
</span><span class="noop">                                   &#39;of parameter `%s` requires a definition &#39;
</span><span class="noop">                                   &#39;of the actual simulation time step.  &#39;
</span><span class="noop">                                   &#39;The simulation time step is project &#39;
</span><span class="noop">                                   &#39;specific.  When initializing the HydPy &#39;
</span><span class="noop">                                   &#39;framework, it is automatically specified &#39;
</span><span class="noop">                                   &#39;under `pub.timegrids.stepsize.  For &#39;
</span><span class="noop">                                   &#39;testing purposes, one can alternatively &#39;
</span><span class="noop">                                   &#39;apply the function `simulationstep`.  &#39;
</span><span class="noop">                                   &#39;Please see the documentation for more &#39;
</span><span class="noop">                                   &#39;details.&#39; % self.name)
</span><span class="noop">            else:
</span><span class="hit">                date1 = timetools.Date(&#39;2000.01.01&#39;)
</span><span class="hit">                date2 = date1 + self._simulationstep
</span><span class="hit">                parfactor = timetools.Timegrids(timetools.Timegrid(
</span><span class="noop">                                 date1, date2, self._simulationstep)).parfactor
</span><span class="hit">        return parfactor(self.parameterstep)
</span><span class="noop">
</span><span class="hit">    timefactor = property(_gettimefactor)
</span><span class="noop">
</span><span class="hit">    trim = objecttools.trim
</span><span class="noop">
</span><span class="hit">    def warntrim(self):
</span><span class="miss">        warnings.warn(&#39;For parameter %s of element %s at least one value &#39;
</span><span class="noop">                      &#39;needed to be trimmed.  Two possible reasons could be &#39;
</span><span class="noop">                      &#39;that the a parameter bound violated or that the values &#39;
</span><span class="noop">                      &#39;of two (or more) different parameters are inconsistent.&#39;
</span><span class="noop">                      % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def applytimefactor(self, values):
</span><span class="noop">        &#34;&#34;&#34;Change the given parameter value/values in accordance with the
</span><span class="noop">        actual parameter simulation time step if necessary, and return it/them.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="noop">        # Note: At least `values /= self.timefactor` is less flexible than
</span><span class="noop">        # `values = values / self.timefactor` regarding the type of `values`.
</span><span class="hit">        if self.TIME is True:
</span><span class="hit">            values = values * self.timefactor
</span><span class="hit">        elif self.TIME is False:
</span><span class="hit">            values = values / self.timefactor
</span><span class="hit">        return values
</span><span class="noop">
</span><span class="hit">    def reverttimefactor(self, values):
</span><span class="noop">        &#34;&#34;&#34;Change the given parameter value/values inversely in accordance
</span><span class="noop">        with the actual parameter simulation time step if necessary, and
</span><span class="noop">        return it/them.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="noop">        # Note: At least `values /= self.timefactor` is less flexible than
</span><span class="noop">        # `values = values / self.timefactor` regarding the type of `values`.
</span><span class="hit">        if self.TIME is True:
</span><span class="hit">            values = values / self.timefactor
</span><span class="hit">        elif self.TIME is False:
</span><span class="hit">            values = values * self.timefactor
</span><span class="hit">        return values
</span><span class="noop">
</span><span class="hit">    def commentrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a list with comments, e.g. for making string representations
</span><span class="noop">        more informative.  When :attr:`pub.options.reprcomments` is set to
</span><span class="noop">        `False`, an empty list is returned.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        lines = super(Parameter, self).commentrepr()
</span><span class="hit">        if (pub.options.reprcomments and
</span><span class="noop">                (getattr(self, &#39;TIME&#39;, None) is not None)):
</span><span class="hit">            lines.append(&#39;# The actual value representation depends on &#39;
</span><span class="noop">                         &#39;the actual parameter step size,&#39;)
</span><span class="hit">            lines.append(&#39;# which is `%s`.&#39; % self.parameterstep)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return str(self.values)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SingleParameter(Parameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for model parameters handling a single value.&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN, INIT = 0, float, None, (None, None), None
</span><span class="noop">
</span><span class="hit">    def connect(self, subpars):
</span><span class="hit">        self.subpars = subpars
</span><span class="hit">        self.fastaccess = subpars.fastaccess
</span><span class="hit">        setattr(self.fastaccess, self.name, self.initvalue)
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="noop">        &#34;&#34;&#34;An empty tuple.  (Only intended for increasing consistent usability
</span><span class="noop">        of :class:`SingleParameter` and :class:`MultiParameter` instances.)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return ()
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="miss">        raise RuntimeError(&#39;The shape information of `SingleParameters` &#39;
</span><span class="noop">                           &#39;as `%s` cannot be changed.&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    shape = property(_getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    def _getvalue(self):
</span><span class="noop">        &#34;&#34;&#34;The actual parameter value handled by the respective
</span><span class="noop">        :class:`SingleParameter` instance.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return getattr(self.fastaccess, self.name, numpy.nan)
</span><span class="noop">
</span><span class="hit">    def _setvalue(self, value):
</span><span class="hit">        try:
</span><span class="hit">            temp = value[0]
</span><span class="hit">            if len(value) &gt; 1:
</span><span class="miss">                raise ValueError(&#39;%d values are assigned to the scalar &#39;
</span><span class="noop">                                 &#39;parameter `%s`, which is ambiguous.&#39;
</span><span class="noop">                                 % (len(value)), self.name)
</span><span class="hit">            value = temp
</span><span class="hit">        except (TypeError, IndexError):
</span><span class="hit">            pass
</span><span class="hit">        try:
</span><span class="hit">            value = self.TYPE(value)
</span><span class="miss">        except (ValueError, TypeError):
</span><span class="miss">            raise TypeError(&#39;When trying to set the value of parameter `%s`, &#39;
</span><span class="noop">                            &#39;it was not possible to convert `%s` to type &#39;
</span><span class="noop">                            &#39;`%s`.&#39; % (self.name, value,
</span><span class="noop">                                       objecttools.classname(self.TYPE)))
</span><span class="hit">        setattr(self.fastaccess, self.name, value)
</span><span class="noop">
</span><span class="hit">    value = property(_getvalue, _setvalue)
</span><span class="hit">    values = value
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raises a :class:`~exceptions.RuntimeError` if the value of the
</span><span class="noop">        instance of the respective subclass of :class:`SingleParameter` is
</span><span class="noop">        `nan`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if numpy.isnan(self.value):
</span><span class="miss">            raise RuntimeError(&#39;The value of parameter `%s` has not been &#39;
</span><span class="noop">                               &#39;set yet.&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="noop">        &#34;&#34;&#34;Returns 1.  (This method is only intended for increasing consistent
</span><span class="noop">        usability of :class:`SingleParameter` and :class:`MultiParameter`
</span><span class="noop">        instances.)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return 1
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="hit">        if key in (0, slice(None, None, None)):
</span><span class="hit">            return self.value
</span><span class="noop">        else:
</span><span class="hit">            raise IndexError(&#39;The only allowed index for scalar parameters &#39;
</span><span class="noop">                             &#39;like `%s` is `0` (or `:`), but `%s` is given.&#39;
</span><span class="noop">                             % (self.name, key))
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, value):
</span><span class="miss">        if key in (0, slice(None, None, None)):
</span><span class="miss">            self.value = value
</span><span class="noop">        else:
</span><span class="miss">            raise IndexError(&#39;The only allowed index for scalar parameters &#39;
</span><span class="noop">                             &#39;like `%s` is `0` (or `:`), but `%s` is given.&#39;
</span><span class="noop">                             % (self.name, key))
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        lines = self.commentrepr()
</span><span class="hit">        lines.append(&#39;%s(%s)&#39;
</span><span class="noop">                     % (self.name,
</span><span class="noop">                        objecttools.repr_(self.reverttimefactor(self.value))))
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameter(Parameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for model parameters handling multiple values.&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">    def connect(self, subpars):
</span><span class="hit">        self.subpars = subpars
</span><span class="hit">        self.fastaccess = subpars.fastaccess
</span><span class="hit">        setattr(self.fastaccess, self.name, None)
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="noop">        &#34;&#34;&#34;A tuple containing the lengths in all dimensions of the parameter
</span><span class="noop">        values.  Note that setting a new shape results in a loss of all values
</span><span class="noop">        of the respective parameter.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            shape = getattr(self.fastaccess, self.name).shape
</span><span class="hit">            return tuple(int(x) for x in shape)
</span><span class="hit">        except AttributeError:
</span><span class="hit">            raise RuntimeError(&#39;Shape information for parameter `%s` &#39;
</span><span class="noop">                               &#39;can only be retrieved after it has been &#39;
</span><span class="noop">                               &#39;defined.&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        try:
</span><span class="hit">            array = numpy.full(shape, self.initvalue, dtype=self.TYPE)
</span><span class="miss">        except Exception:
</span><span class="miss">            objecttools.augmentexcmessage(&#39;While trying create a new numpy &#39;
</span><span class="noop">                                          &#39;ndarray` for parameter `%s`&#39;
</span><span class="noop">                                          % self.name)
</span><span class="hit">        if array.ndim == self.NDIM:
</span><span class="hit">            setattr(self.fastaccess, self.name, array)
</span><span class="noop">        else:
</span><span class="miss">            raise ValueError(&#39;Parameter `%s` is %d-dimensional but the &#39;
</span><span class="noop">                             &#39;given shape indicates %d dimensions.&#39;
</span><span class="noop">                             % (self.name, self.NDIM, array.ndim))
</span><span class="noop">
</span><span class="hit">    shape = property(_getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    def _getvalue(self):
</span><span class="noop">        &#34;&#34;&#34;The actual parameter value(s) handled by the respective
</span><span class="noop">        :class:`Parameter` instance.  For consistency, `value` and `values`
</span><span class="noop">        can always be used interchangeably.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        value = getattr(self.fastaccess, self.name, None)
</span><span class="hit">        if value is None:
</span><span class="miss">            return value
</span><span class="noop">        else:
</span><span class="hit">            return numpy.asarray(value)
</span><span class="noop">
</span><span class="hit">    def _setvalue(self, value):
</span><span class="hit">        try:
</span><span class="hit">            value = value.value
</span><span class="hit">        except AttributeError:
</span><span class="hit">            pass
</span><span class="hit">        try:
</span><span class="hit">            value = numpy.full(self.shape, value, dtype=self.TYPE)
</span><span class="miss">        except ValueError:
</span><span class="miss">            raise ValueError(&#39;The values `%s` cannot be converted to a numpy &#39;
</span><span class="noop">                             &#39;ndarray with shape %s containing entries of &#39;
</span><span class="noop">                             &#39;type %s.&#39; % (value, self.shape,
</span><span class="noop">                                           objecttools.classname(self.TYPE)))
</span><span class="hit">        setattr(self.fastaccess, self.name, value)
</span><span class="noop">
</span><span class="hit">    value = property(_getvalue, _setvalue)
</span><span class="hit">    values = value
</span><span class="noop">
</span><span class="hit">    def _getverifymask(self):
</span><span class="noop">        &#34;&#34;&#34;A numpy array with all entries being `True` of the same
</span><span class="noop">        shape as the values handled by the respective parameter.  All entries
</span><span class="noop">        beeing `True` indicates that the method :func:`~MultiParameter.verify`
</span><span class="noop">        checks all entries of the numpy array storing the parameter values.
</span><span class="noop">        Overwrite :func:`~MultiParameter.verify` for :class:`MultiParameter`
</span><span class="noop">        subclasses, where certain entries do not to be checked.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return numpy.full(self.shape, True, dtype=bool)
</span><span class="noop">
</span><span class="hit">    verifymask = property(_getverifymask)
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raises a :class:`~exceptions.RuntimeError` if at least one of the
</span><span class="noop">        required values of the instance of the respective subclass of
</span><span class="noop">        :class:`MultiParameter` is `None` or `nan`. The property
</span><span class="noop">        :func:`~MultiParameter.verifymask` defines, which values are
</span><span class="noop">        considered to be necessary.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if self.values is None:
</span><span class="miss">            raise RuntimeError(&#39;The values of parameter `%s` have not &#39;
</span><span class="noop">                               &#39;been set yet.&#39; % self.name)
</span><span class="miss">        nmbnan = sum(numpy.isnan(self.values[self.verifymask]))
</span><span class="miss">        if nmbnan:
</span><span class="miss">            raise RuntimeError(&#39;For parameter `%s`, %d required values have &#39;
</span><span class="noop">                               &#39;not been set yet.&#39; % (self.name, nmbnan))
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Return a deep copy of the parameter values.&#34;&#34;&#34;
</span><span class="hit">        return copy.deepcopy(self.values)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="noop">        &#34;&#34;&#34;Returns the number of values handled by the :class:`MultiParameter`
</span><span class="noop">        instance.  It is required, that the `shape` has been set beforehand,
</span><span class="noop">        which specifies the length in each dimension.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return numpy.cumprod(self.shape)[-1]
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="hit">        try:
</span><span class="hit">            return self.values[key]
</span><span class="hit">        except Exception:
</span><span class="hit">            self._raiseitemexception()
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, values):
</span><span class="hit">        try:
</span><span class="hit">            self.values[key] = values
</span><span class="miss">        except Exception:
</span><span class="miss">            self._raiseitemexception()
</span><span class="noop">
</span><span class="hit">    def _raiseitemexception(self):
</span><span class="hit">        if self.values is None:
</span><span class="miss">            raise RuntimeError(&#39;Parameter `%s` has no values so far.&#39;
</span><span class="noop">                               % self.name)
</span><span class="noop">        else:
</span><span class="hit">            objecttools.augmentexcmessage(&#39;While trying to item access the &#39;
</span><span class="noop">                                          &#39;values of parameter `%s`&#39;
</span><span class="noop">                                          % self.name)
</span><span class="noop">
</span><span class="hit">    def compressrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a compressed parameter value string, which is (in
</span><span class="noop">        accordance with :attr:`~MultiParameter.NDIM`) contained in a
</span><span class="noop">        nested list.  If the compression fails, a
</span><span class="noop">        :class:`~exceptions.NotImplementedError` is raised.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self.value is None:
</span><span class="miss">            unique = numpy.array([numpy.nan])
</span><span class="hit">        elif self.length == 0:
</span><span class="hit">            return [&#39;&#39;]
</span><span class="noop">        else:
</span><span class="hit">            unique = numpy.unique(self.values)
</span><span class="hit">        if sum(numpy.isnan(unique)) == len(unique.flatten()):
</span><span class="miss">            unique = numpy.array([numpy.nan])
</span><span class="noop">        else:
</span><span class="hit">            unique = self.reverttimefactor(unique)
</span><span class="hit">        if len(unique) == 1:
</span><span class="hit">            result = objecttools.repr_(unique[0])
</span><span class="hit">            for idx in range(self.NDIM):
</span><span class="hit">                result = [result]
</span><span class="hit">            return result
</span><span class="noop">        else:
</span><span class="hit">            raise NotImplementedError(&#39;For parameter `%s` there is no &#39;
</span><span class="noop">                                      &#39;compression method implemented, &#39;
</span><span class="noop">                                      &#39;working for its actual values.&#39;
</span><span class="noop">                                      % self.name)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        try:
</span><span class="hit">            values = self.compressrepr()
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            islong = self.length &gt; 255
</span><span class="hit">            values = self.reverttimefactor(self.values)
</span><span class="miss">        except BaseException:
</span><span class="miss">            objecttools.augmentexcmessage(&#39;While trying to find a compressed &#39;
</span><span class="noop">                                          &#39;string representation for &#39;
</span><span class="noop">                                          &#39;parameter `%s`&#39; % self.name)
</span><span class="noop">        else:
</span><span class="hit">            islong = False
</span><span class="hit">        return super(Parameter, self)._repr(values, islong)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZipParameter(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for model parameters handling multiple values that offers
</span><span class="noop">    additional keyword zipping fuctionality.
</span><span class="noop">
</span><span class="noop">    When inheriting an actual parameter class from :class:`ZipParameter` one
</span><span class="noop">    needs to define suitable class constants
</span><span class="noop">    :const:`~ZipParameter.REQUIRED_VALUES` (a :class:`tuple`) and
</span><span class="noop">    :const:`~ZipParameter.MODEL_CONSTANTS` (a :class:`dict`).  Additionally,
</span><span class="noop">    a property named `refparameter` must be defined.
</span><span class="noop">
</span><span class="noop">    The implementation and functioning of subclasses of :class:`ZipParameter`
</span><span class="noop">    is best illustrated by an example: see the documentation of the class
</span><span class="noop">    :class:`~hydpy.models.hland.hland_parameters.MultiParameter` of the
</span><span class="noop">    HydPy-H-Land model.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = ()
</span><span class="hit">    MODEL_CONSTANTS = {}
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Parameter` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            Parameter.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError as exc:
</span><span class="hit">            if kwargs:
</span><span class="hit">                refvalues = self.refparameter.values
</span><span class="hit">                if min(refvalues) &lt; 1:
</span><span class="miss">                    raise RuntimeError(&#39;Parameter %s does not seem to &#39;
</span><span class="noop">                                       &#39;be prepared properly for element %s.  &#39;
</span><span class="noop">                                       &#39;Hence, setting values for parameter &#39;
</span><span class="noop">                                       &#39;%s via keyword arguments is not &#39;
</span><span class="noop">                                       &#39;possible.&#39;
</span><span class="noop">                                       % (self.refparameter.name,
</span><span class="noop">                                          objecttools.devicename(self),
</span><span class="noop">                                          self.name))
</span><span class="hit">                self.values = kwargs.pop(&#39;default&#39;, numpy.nan)
</span><span class="hit">                for (key, value) in kwargs.items():
</span><span class="hit">                    sel = self.MODEL_CONSTANTS.get(key.upper())
</span><span class="hit">                    if sel is None:
</span><span class="hit">                        raise exc
</span><span class="noop">                    else:
</span><span class="hit">                        self.values[refvalues == sel] = value
</span><span class="hit">                self.values = self.applytimefactor(self.values)
</span><span class="hit">                self.trim()
</span><span class="noop">            else:
</span><span class="miss">                raise exc
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="noop">        &#34;&#34;&#34;Return a tuple containing the lengths in all dimensions of the
</span><span class="noop">        parameter values.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return MultiParameter._getshape(self)
</span><span class="hit">        except RuntimeError:
</span><span class="hit">            raise RuntimeError(&#39;Shape information for parameter `%s` can &#39;
</span><span class="noop">                               &#39;only be retrieved after it has been defined. &#39;
</span><span class="noop">                               &#39; You can do this manually, but usually it is &#39;
</span><span class="noop">                               &#39;done automatically by defining the value of &#39;
</span><span class="noop">                               &#39;parameter `%s` first in each parameter &#39;
</span><span class="noop">                               &#39;control file.&#39;
</span><span class="noop">                               % (self.name, self.shapeparameter.name))
</span><span class="noop">
</span><span class="hit">    shape = property(_getshape, MultiParameter._setshape)
</span><span class="noop">
</span><span class="hit">    def _getverifymask(self):
</span><span class="noop">        &#34;&#34;&#34;A numpy array of the same shape as the value array handled
</span><span class="noop">        by the respective parameter.  `True` entries indicate that certain
</span><span class="noop">        parameter values are required, which depends on the tuple
</span><span class="noop">        :const:`REQUIRED_VALUES` of the respective subclass.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        mask = numpy.full(self.shape, False, dtype=bool)
</span><span class="hit">        refvalues = self.refparameter.values
</span><span class="hit">        for reqvalue in self.REQUIRED_VALUES:
</span><span class="hit">            mask[refvalues == reqvalue] = True
</span><span class="hit">        return mask
</span><span class="noop">
</span><span class="hit">    verifymask = property(_getverifymask)
</span><span class="noop">
</span><span class="hit">    def compressrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a compressed parameter value string, which is (in
</span><span class="noop">        accordance with :attr:`NDIM`) contained in a nested list.  If the
</span><span class="noop">        compression fails, a :class:`~exceptions.NotImplementedError` is
</span><span class="noop">        raised.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return MultiParameter.compressrepr(self)
</span><span class="hit">        except NotImplementedError as exc:
</span><span class="hit">            results = []
</span><span class="hit">            refvalues = self.refparameter.values
</span><span class="hit">            if min(refvalues) &lt; 1:
</span><span class="hit">                raise NotImplementedError(&#39;Parameter %s is not defined &#39;
</span><span class="noop">                                          &#39;poperly, which circumvents finding &#39;
</span><span class="noop">                                          &#39;a suitable compressed.&#39;)
</span><span class="hit">            for (key, value) in self.MODEL_CONSTANTS.items():
</span><span class="hit">                if value in self.REQUIRED_VALUES:
</span><span class="hit">                    unique = numpy.unique(self.values[refvalues == value])
</span><span class="hit">                    unique = self.reverttimefactor(unique)
</span><span class="hit">                    if len(unique) == 1:
</span><span class="hit">                        results.append(&#39;%s=%s&#39;
</span><span class="noop">                                       % (key.lower(),
</span><span class="noop">                                          objecttools.repr_(unique[0])))
</span><span class="hit">                    elif len(unique) &gt; 1:
</span><span class="hit">                        raise exc
</span><span class="hit">            result = &#39;, &#39;.join(sorted(results))
</span><span class="hit">            for idx in range(self.NDIM):
</span><span class="hit">                result = [result]
</span><span class="hit">            return result
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SeasonalParameter(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Class for the flexible handling of parameters with anual cycles.
</span><span class="noop">
</span><span class="noop">    Let us prepare a 1-dimensional :class:`SeasonalParameter` instance:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.parametertools import SeasonalParameter
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter = SeasonalParameter()
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.NDIM = 1
</span><span class="noop">
</span><span class="noop">    For the following examples, we assume a simulation step size of one day:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.timetools import Period
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.simulationstep = Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="noop">    To define its shape, the first entry of the assigned :class:`tuple`
</span><span class="noop">    object is ignored:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.shape = (None,)
</span><span class="noop">
</span><span class="noop">    Instead it is derived from the `simulationstep` defined above:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.shape
</span><span class="noop">    (366,)
</span><span class="noop">
</span><span class="noop">    The annual pattern of seasonal parameters is defined through pairs of
</span><span class="noop">    :class:`~hydpy.core.timetools.TOY` objects and different values (e.g.
</span><span class="noop">    of type :class:`float`).  One can define them all at once in the
</span><span class="noop">    following manner:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter(_1=2., _7_1=4., _3_1_0_0_0=5.)
</span><span class="noop">
</span><span class="noop">    Note that, as :class:`str` objects, all keywords in the call above would
</span><span class="noop">    be proper :class:`~hydpy.core.timetools.TOY` initialization arguments.
</span><span class="noop">    If they are not properly written, the following exception is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; SeasonalParameter()(_a=1.)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: While trying to define parameter `seasonalparameter` of element `?`, the following error occured: While trying to retrieve the month for TOY (time of year) object based on the string `_a`, the following error occured: For TOY (time of year) objects, all properties must be of type `int`, but the value `a` of type `str` given for property `month` cannot be converted to `int`.
</span><span class="noop">
</span><span class="noop">    As the following string representation shows, are the pairs of each
</span><span class="noop">    :class:`SeasonalParameter` instance automatically sorted:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter
</span><span class="noop">    seasonalparameter(toy_1_1_0_0_0=2.0,
</span><span class="noop">                      toy_3_1_0_0_0=5.0,
</span><span class="noop">                      toy_7_1_0_0_0=4.0)
</span><span class="noop">
</span><span class="noop">    By default, `toy` is used as a prefix string.  Using this prefix string,
</span><span class="noop">    one can change the toy-value pairs via attribute access:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.toy_1_1_0_0_0
</span><span class="noop">    2.0
</span><span class="noop">    &gt;&gt;&gt; del seasonalparameter.toy_1_1_0_0_0
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.toy_2_1_0_0_0 = 2.
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter
</span><span class="noop">    seasonalparameter(toy_2_1_0_0_0=2.0,
</span><span class="noop">                      toy_3_1_0_0_0=5.0,
</span><span class="noop">                      toy_7_1_0_0_0=4.0)
</span><span class="noop">
</span><span class="noop">    On applying function :func:`len` on :class:`SeasonalParameter` objects,
</span><span class="noop">    the number of toy-value pairs is returned:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; len(seasonalparameter)
</span><span class="noop">    3
</span><span class="noop">
</span><span class="noop">    New values are checked to be compatible predefined shape:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.toy_1_1_0_0_0 = [1., 2.]
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    TypeError: While trying to add a new or change an existing toy-value pair for the seasonal parameter `seasonalparameter` of element `?`, the following error occured: float() argument must be a string or a number...
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter = SeasonalParameter()
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.NDIM = 2
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.shape = (None, 3)
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.toy_1_1_0_0_0 = [1., 2.]
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: While trying to add a new or change an existing toy-value pair for the seasonal parameter `seasonalparameter` of element `?`, the following error occured: could not broadcast input array from shape (2) into shape (3)
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.toy_1_1_0_0_0 = [1., 2., 3.]
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter
</span><span class="noop">    seasonalparameter(toy_1_1_0_0_0=[1.0, 2.0, 3.0])
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    def __init__(self):
</span><span class="hit">        MultiParameter.__init__(self)
</span><span class="hit">        self._toy2values = {}
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Parameter` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self._toy2values.clear()
</span><span class="hit">        try:
</span><span class="hit">            MultiParameter.__call__(self, *args, **kwargs)
</span><span class="hit">            self._toy2values[timetools.TOY()] = self[0]
</span><span class="hit">        except BaseException as exc:
</span><span class="hit">            if kwargs:
</span><span class="hit">                for (toystr, values) in kwargs.items():
</span><span class="hit">                    try:
</span><span class="hit">                        setattr(self, str(timetools.TOY(toystr)), values)
</span><span class="hit">                    except BaseException:
</span><span class="hit">                        objecttools.augmentexcmessage(
</span><span class="noop">                            &#39;While trying to define parameter `%s` of element &#39;
</span><span class="noop">                            &#39;`%s`&#39; % (self.name, objecttools.devicename(self)))
</span><span class="hit">                self.refresh()
</span><span class="noop">            else:
</span><span class="miss">                raise exc
</span><span class="noop">
</span><span class="hit">    def refresh(self):
</span><span class="noop">        &#34;&#34;&#34;Update the actual simulation values based on the toy-value pairs.
</span><span class="noop">
</span><span class="noop">        Usually, one does not need to call refresh explicitly, as it is
</span><span class="noop">        called by methods __call__, __setattr__ and __delattr__ automatically,
</span><span class="noop">        when required.
</span><span class="noop">
</span><span class="noop">        Instantiate a 1-dimensional :class:`SeasonalParameter` object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp = SeasonalParameter()
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Period
</span><span class="noop">        &gt;&gt;&gt; sp.simulationstep = Period(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; sp.NDIM = 1
</span><span class="noop">        &gt;&gt;&gt; sp.shape = (None,)
</span><span class="noop">
</span><span class="noop">        When a :class:`SeasonalParameter` object does not contain any
</span><span class="noop">        toy-value pairs yet, the method :func:`SeasonalParameter.refresh`
</span><span class="noop">        sets all actual simulation values to zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp.values = 1.
</span><span class="noop">        &gt;&gt;&gt; sp.refresh()
</span><span class="noop">        &gt;&gt;&gt; sp.values[0]
</span><span class="noop">        0.0
</span><span class="noop">
</span><span class="noop">        When there is only one toy-value pair, its values are taken for
</span><span class="noop">        all actual simulation values:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp.toy_1 = 2. # calls refresh automatically
</span><span class="noop">        &gt;&gt;&gt; sp.values[0]
</span><span class="noop">        2.0
</span><span class="noop">
</span><span class="noop">        Method :func:`SeasonalParameter.refresh` performs a linear
</span><span class="noop">        interpolation for the central time points of each simulation time
</span><span class="noop">        step.  Hence, in the following example the original values of the
</span><span class="noop">        toy-value pairs do not show up:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp.toy_12_31 = 4.
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(sp.values[0])
</span><span class="noop">        2.00274
</span><span class="noop">        &gt;&gt;&gt; round_(sp.values[-2])
</span><span class="noop">        3.99726
</span><span class="noop">        &gt;&gt;&gt; sp.values[-1]
</span><span class="noop">        3.0
</span><span class="noop">
</span><span class="noop">        If one wants to preserve the original values in this example, one
</span><span class="noop">        would have to set the corresponding toy instances in the middle of
</span><span class="noop">        some simulation step intervalls:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; del sp.toy_1
</span><span class="noop">        &gt;&gt;&gt; del sp.toy_12_31
</span><span class="noop">        &gt;&gt;&gt; sp.toy_1_1_12 = 2
</span><span class="noop">        &gt;&gt;&gt; sp.toy_12_31_12 = 4.
</span><span class="noop">        &gt;&gt;&gt; sp.values[0]
</span><span class="noop">        2.0
</span><span class="noop">        &gt;&gt;&gt; round_(sp.values[1])
</span><span class="noop">        2.005479
</span><span class="noop">        &gt;&gt;&gt; round_(sp.values[-2])
</span><span class="noop">        3.994521
</span><span class="noop">        &gt;&gt;&gt; sp.values[-1]
</span><span class="noop">        4.0
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if len(self) == 0:
</span><span class="hit">            self.values[:] = 0.
</span><span class="hit">        elif len(self) == 1:
</span><span class="hit">            values = list(self._toy2values.values())[0]
</span><span class="hit">            self.values[:] = self.applytimefactor(values)
</span><span class="noop">        else:
</span><span class="hit">            tt = timetools
</span><span class="hit">            timegrid = tt.Timegrid(tt.TOY._STARTDATE+self.simulationstep/2,
</span><span class="noop">                                   tt.TOY._ENDDATE+self.simulationstep/2,
</span><span class="noop">                                   self.simulationstep)
</span><span class="hit">            for idx, date in enumerate(timegrid):
</span><span class="hit">                values = self.interp(date)
</span><span class="hit">                self.values[idx] = self.applytimefactor(values)
</span><span class="noop">
</span><span class="hit">    def interp(self, date):
</span><span class="noop">        &#34;&#34;&#34;Perform a linear value interpolation for a date defined by the
</span><span class="noop">        passed :class:`~hydpy.core.timetools.Date` object and return the
</span><span class="noop">        result.
</span><span class="noop">
</span><span class="noop">        Instantiate a 1-dimensional :class:`SeasonalParameter` object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp = SeasonalParameter()
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Date, Period
</span><span class="noop">        &gt;&gt;&gt; sp.simulationstep = Period(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; sp.NDIM = 1
</span><span class="noop">        &gt;&gt;&gt; sp.shape = (None,)
</span><span class="noop">
</span><span class="noop">        Define three toy-value pairs:
</span><span class="noop">        &gt;&gt;&gt; sp(_1=2.0, _2=5.0, _12_31=4.0)
</span><span class="noop">
</span><span class="noop">        Passing a :class:`~hydpy.core.timetools.Date` object excatly matching
</span><span class="noop">        a :class:`~hydpy.core.timetools.TOY` object of course simply returns
</span><span class="noop">        the associated value:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp.interp(Date(&#39;2000.01.01&#39;))
</span><span class="noop">        2.0
</span><span class="noop">        &gt;&gt;&gt; sp.interp(Date(&#39;2000.02.01&#39;))
</span><span class="noop">        5.0
</span><span class="noop">        &gt;&gt;&gt; sp.interp(Date(&#39;2000.12.31&#39;))
</span><span class="noop">        4.0
</span><span class="noop">
</span><span class="noop">        For all intermediate points, a linear interpolation is performed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.01.02&#39;)))
</span><span class="noop">        2.096774
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.01.31&#39;)))
</span><span class="noop">        4.903226
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.02.02&#39;)))
</span><span class="noop">        4.997006
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.12.30&#39;)))
</span><span class="noop">        4.002994
</span><span class="noop">
</span><span class="noop">        Linear interpolation is also allowed between the first and the
</span><span class="noop">        last pair, when they do not capture the end points of the year:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp(_1_2=2.0, _12_30=4.0)
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.12.29&#39;)))
</span><span class="noop">        3.99449
</span><span class="noop">        &gt;&gt;&gt; sp.interp(Date(&#39;2000.12.30&#39;))
</span><span class="noop">        4.0
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.12.31&#39;)))
</span><span class="noop">        3.333333
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.01.01&#39;)))
</span><span class="noop">        2.666667
</span><span class="noop">        &gt;&gt;&gt; sp.interp(Date(&#39;2000.01.02&#39;))
</span><span class="noop">        2.0
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.01.03&#39;)))
</span><span class="noop">        2.00551
</span><span class="noop">
</span><span class="noop">        The following example briefly shows interpolation performed for
</span><span class="noop">        2-dimensional parameter:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp = SeasonalParameter()
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Date, Period
</span><span class="noop">        &gt;&gt;&gt; sp.simulationstep = Period(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; sp.NDIM = 2
</span><span class="noop">        &gt;&gt;&gt; sp.shape = (None, 2)
</span><span class="noop">        &gt;&gt;&gt; sp(_1_1=[1., 2.], _1_3=[-3, 0.])
</span><span class="noop">        &gt;&gt;&gt; result = sp.interp(Date(&#39;2000.01.02&#39;))
</span><span class="noop">        &gt;&gt;&gt; round_(result[0])
</span><span class="noop">        -1.0
</span><span class="noop">        &gt;&gt;&gt; round_(result[1])
</span><span class="noop">        1.0
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">        xnew = timetools.TOY(date)
</span><span class="hit">        xys = list(self)
</span><span class="hit">        for idx, (x1, y1) in enumerate(xys):
</span><span class="hit">            if x1 &gt; xnew:
</span><span class="hit">                x0, y0 = xys[idx-1]
</span><span class="hit">                break
</span><span class="noop">        else:
</span><span class="hit">            x0, y0 = xys[-1]
</span><span class="hit">            x1, y1 = xys[0]
</span><span class="hit">        return y0+(y1-y0)/(x1-x0)*(xnew-x0)
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        try:
</span><span class="hit">            shape = (int(shape),)
</span><span class="hit">        except TypeError:
</span><span class="hit">            pass
</span><span class="hit">        shape = list(shape)
</span><span class="hit">        if self.simulationstep is None:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;It is not possible the set the shape of the seasonal &#39;
</span><span class="noop">                &#39;parameter `%s` of element `%s` at the moment.  You can &#39;
</span><span class="noop">                &#39;define it manually.  In complete HydPy projects it is &#39;
</span><span class="noop">                &#39;indirecty defined via `pub.timegrids.stepsize` automatically.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self)))
</span><span class="hit">        shape[0] = timetools.Period(&#39;366d&#39;)/self.simulationstep
</span><span class="hit">        shape[0] = int(numpy.ceil(round(shape[0], 10)))
</span><span class="hit">        MultiParameter._setshape(self, shape)
</span><span class="hit">    shape = property(MultiParameter._getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for toy in sorted(self._toy2values.keys()):
</span><span class="hit">            yield (toy, self._toy2values[toy])
</span><span class="noop">
</span><span class="hit">    def __getattribute__(self, name):
</span><span class="hit">        if name.startswith(&#39;toy_&#39;):
</span><span class="hit">            try:
</span><span class="hit">                return self._toy2values[timetools.TOY(name)]
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to get an existing toy-value pair for &#39;
</span><span class="noop">                    &#39;the seasonal parameter `%s` of element `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self)))
</span><span class="noop">        else:
</span><span class="hit">            return super(SeasonalParameter, self).__getattribute__(name)
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, name, value):
</span><span class="hit">        if name.startswith(&#39;toy_&#39;):
</span><span class="hit">            try:
</span><span class="hit">                if self.NDIM == 1:
</span><span class="hit">                    value = float(value)
</span><span class="noop">                else:
</span><span class="hit">                    value = numpy.full(self.shape[1:], value)
</span><span class="hit">                self._toy2values[timetools.TOY(name)] = value
</span><span class="hit">                self.refresh()
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to add a new or change an existing &#39;
</span><span class="noop">                    &#39;toy-value pair for the seasonal parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s`&#39; % (self.name, objecttools.devicename(self)))
</span><span class="noop">        else:
</span><span class="hit">            MultiParameter.__setattr__(self, name, value)
</span><span class="noop">
</span><span class="hit">    def __delattr__(self, name):
</span><span class="hit">        if name.startswith(&#39;toy_&#39;):
</span><span class="hit">            try:
</span><span class="hit">                del self._toy2values[timetools.TOY(name)]
</span><span class="hit">                self.refresh()
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to delete an existing toy-value pair for &#39;
</span><span class="noop">                    &#39;the seasonal parameter `%s` of element `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self)))
</span><span class="noop">        else:
</span><span class="miss">            MultiParameter.__delattr__(self, name)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        if self.NDIM == 1:
</span><span class="hit">            assign = objecttools.assignrepr_value
</span><span class="hit">        elif self.NDIM == 2:
</span><span class="hit">            assign = objecttools.assignrepr_list
</span><span class="miss">        elif self.NDIM == 3:
</span><span class="miss">            assign = objecttools.assignrepr_list2
</span><span class="noop">        else:
</span><span class="miss">            def assign(values, prefix):
</span><span class="miss">                return prefix+str(values)
</span><span class="hit">        if len(self) == 0:
</span><span class="miss">            return self.name+&#39;()&#39;
</span><span class="noop">        else:
</span><span class="hit">            lines = []
</span><span class="hit">            blanks = &#39; &#39;*(len(self.name)+1)
</span><span class="hit">            for idx, (toy, value) in enumerate(self):
</span><span class="hit">                if idx == 0:
</span><span class="hit">                    prefix = &#39;%s(%s=&#39; % (self.name, toy)
</span><span class="noop">                else:
</span><span class="hit">                    prefix = &#39;%s%s=&#39; % (blanks, toy)
</span><span class="hit">                lines.append(assign(value, prefix, width=79))
</span><span class="hit">            lines[-1] += &#39;)&#39;
</span><span class="hit">            return &#39;,\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return len(self._toy2values)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self) + [str(toy) for (toy, value) in self]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KeywordParameter2DType(type):
</span><span class="noop">    &#34;&#34;&#34;Add the construction of `_ROWCOLMAPPING` to :class:`type`.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __new__(cls, name, parents, dict_):
</span><span class="hit">        rownames = dict_.get(&#39;ROWNAMES&#39;, getattr(parents[0], &#39;ROWNAMES&#39;, ()))
</span><span class="hit">        colnames = dict_.get(&#39;COLNAMES&#39;, getattr(parents[0], &#39;COLNAMES&#39;, ()))
</span><span class="hit">        rowcolmappings = {}
</span><span class="hit">        for (idx, rowname) in enumerate(rownames):
</span><span class="hit">            for (jdx, colname) in enumerate(colnames):
</span><span class="hit">                rowcolmappings[&#39;_&#39;.join((rowname, colname))] = (idx, jdx)
</span><span class="hit">        dict_[&#39;_ROWCOLMAPPINGS&#39;] = rowcolmappings
</span><span class="hit">        return type.__new__(cls, name, parents, dict_)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">KeywordParameter2DMetaclass = KeywordParameter2DType(
</span><span class="noop">                          &#39;KeywordParameter2DMetaclass&#39;, (MultiParameter,), {})
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KeywordParameter2D(KeywordParameter2DMetaclass):
</span><span class="noop">    &#34;&#34;&#34;Base class for 2-dimensional model parameters which values which depend
</span><span class="noop">    on two factors.
</span><span class="noop">
</span><span class="noop">    When inheriting an actual parameter class from :class:`KeywordParameter2D`
</span><span class="noop">    one needs to define the class attributes
</span><span class="noop">    :const:`~KeywordParameter2D.ROWNAMES` and
</span><span class="noop">    :const:`~KeywordParameter2D.COLNAMES` (both of type :class:`tuple`).
</span><span class="noop">    One usual setting would be that :const:`~KeywordParameter2D.ROWNAMES`
</span><span class="noop">    defines some land use classes and :const:`~KeywordParameter2D.COLNAMES`
</span><span class="noop">    defines seasons, months, or the like.
</span><span class="noop">
</span><span class="noop">    Consider the following example, where the boolean parameter `IsWarm` both
</span><span class="noop">    depends on the half-year period and the hemisphere:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.parametertools import KeywordParameter2D
</span><span class="noop">    &gt;&gt;&gt; class IsWarm(KeywordParameter2D):
</span><span class="noop">    ...     TYPE = bool
</span><span class="noop">    ...     ROWNAMES = (&#39;north&#39;, &#39;south&#39;)
</span><span class="noop">    ...     COLNAMES = (&#39;apr2sep&#39;, &#39;oct2mar&#39;)
</span><span class="noop">
</span><span class="noop">    Instantiate the defined parameter class and define its shape:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm = IsWarm()
</span><span class="noop">    &gt;&gt;&gt; iswarm.shape = (2, 2)
</span><span class="noop">
</span><span class="noop">    :class:`KeywordParameter2D` allows to set the values of all rows via
</span><span class="noop">    keyword arguments:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm(north=[True, False],
</span><span class="noop">    ...        south=[False, True])
</span><span class="noop">    &gt;&gt;&gt; iswarm
</span><span class="noop">    iswarm(north=[True, False],
</span><span class="noop">           south=[False, True])
</span><span class="noop">    &gt;&gt;&gt; iswarm.values
</span><span class="noop">    array([[ True, False],
</span><span class="noop">           [False,  True]], dtype=bool)
</span><span class="noop">
</span><span class="noop">    If a keyword is missing, a :class:`~exceptions.TypeError` is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm(north=[True, False])
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: When setting parameter `iswarm` of element `?` via row related keyword arguments, each string defined in `ROWNAMES` must be used as a keyword, but the following keyword is not: `south`.
</span><span class="noop">
</span><span class="noop">    But one can modify single rows via attribute access:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm.north = False, False
</span><span class="noop">    &gt;&gt;&gt; iswarm.north
</span><span class="noop">    array([False, False], dtype=bool)
</span><span class="noop">
</span><span class="noop">    The same holds true for the columns:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm.apr2sep = True, False
</span><span class="noop">    &gt;&gt;&gt; iswarm.apr2sep
</span><span class="noop">    array([ True, False], dtype=bool)
</span><span class="noop">
</span><span class="noop">    Even a combined row-column access is supported in the following manner:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm.north_apr2sep
</span><span class="noop">    True
</span><span class="noop">    &gt;&gt;&gt; iswarm.north_apr2sep = False
</span><span class="noop">    &gt;&gt;&gt; iswarm.north_apr2sep
</span><span class="noop">    False
</span><span class="noop">
</span><span class="noop">    All three forms of attribute access define augmented exception messages
</span><span class="noop">    in case anything goes wrong:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm.north = True, True, True
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: While trying to assign new values to parameter `iswarm` of element `?` via the row related attribute `north`, the following error occured: cannot copy sequence with size 3 to array axis with dimension 2
</span><span class="noop">    &gt;&gt;&gt; iswarm.apr2sep = True, True, True
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: While trying to assign new values to parameter `iswarm` of element `?` via the column related attribute `apr2sep`, the following error occured: cannot copy sequence with size 3 to array axis with dimension 2
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm.shape = (1, 1)
</span><span class="noop">    &gt;&gt;&gt; iswarm.south_apr2sep = False
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    IndexError: While trying to assign new values to parameter `iswarm` of element `?` via the row and column related attribute `south_apr2sep`, the following error occured: index 1 is out of bounds for axis 0 with size 1
</span><span class="noop">    &gt;&gt;&gt; iswarm.shape = (2, 2)
</span><span class="noop">
</span><span class="noop">    Of course, one can define the parameter values in the common manner, e.g.:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm(True)
</span><span class="noop">    &gt;&gt;&gt; iswarm
</span><span class="noop">    iswarm(north=[True, True],
</span><span class="noop">           south=[True, True])
</span><span class="noop">
</span><span class="noop">    For parameters with many columns, string representations are properly
</span><span class="noop">    wrapped:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm.shape = (2, 10)
</span><span class="noop">    &gt;&gt;&gt; iswarm
</span><span class="noop">    iswarm(north=[False, False, False, False, False, False, False, False,
</span><span class="noop">                  False, False],
</span><span class="noop">           south=[False, False, False, False, False, False, False, False,
</span><span class="noop">                  False, False])
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM = 2
</span><span class="hit">    ROWNAMES = ()
</span><span class="hit">    COLNAMES = ()
</span><span class="noop">
</span><span class="hit">    def connect(self, subpars):
</span><span class="hit">        MultiParameter.connect(self, subpars)
</span><span class="hit">        self.shape = (len(self.ROWNAMES), len(self.COLNAMES))
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        try:
</span><span class="hit">            MultiParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            for (idx, key) in enumerate(self.ROWNAMES):
</span><span class="hit">                try:
</span><span class="hit">                    values = kwargs[key]
</span><span class="hit">                except KeyError:
</span><span class="hit">                    miss = [key for key in self.ROWNAMES if key not in kwargs]
</span><span class="hit">                    raise ValueError(
</span><span class="noop">                        &#39;When setting parameter `%s` of element `%s` via &#39;
</span><span class="noop">                        &#39;row related keyword arguments, each string &#39;
</span><span class="noop">                        &#39;defined in `ROWNAMES` must be used as a keyword, &#39;
</span><span class="noop">                        &#39;but the following keyword%s not: `%s`.&#39;
</span><span class="noop">                        % (self.name, objecttools.devicename(self),
</span><span class="noop">                           &#39; is&#39; if len(miss) == 1 else &#39;s are&#39;,
</span><span class="noop">                           &#39;, &#39;.join(miss)))
</span><span class="hit">                self.values[idx, :] = values
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        lines = self.commentrepr()
</span><span class="hit">        prefix = &#39;%s(&#39; % self.name
</span><span class="hit">        blanks = &#39; &#39;*len(prefix)
</span><span class="hit">        for (idx, key) in enumerate(self.ROWNAMES):
</span><span class="hit">            subprefix = (&#39;%s%s=&#39; % (prefix, key) if idx == 0 else
</span><span class="noop">                         &#39;%s%s=&#39; % (blanks, key))
</span><span class="hit">            lines.append(objecttools.assignrepr_list(self.values[idx, :],
</span><span class="noop">                                                     subprefix, 75) + &#39;,&#39;)
</span><span class="hit">        lines[-1] = lines[-1][:-1] + &#39;)&#39;
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __getattr__(self, key):
</span><span class="hit">        if key in self.ROWNAMES:
</span><span class="hit">            try:
</span><span class="hit">                return self.values[self.ROWNAMES.index(key), :]
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to retrieve values from parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s` via the row related attribute `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self), key))
</span><span class="hit">        elif key in self.COLNAMES:
</span><span class="hit">            try:
</span><span class="hit">                return self.values[:, self.COLNAMES.index(key)]
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to retrieve values from parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s` via the columnd related attribute `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self), key))
</span><span class="hit">        elif key in self._ROWCOLMAPPINGS:
</span><span class="hit">            idx, jdx = self._ROWCOLMAPPINGS[key]
</span><span class="hit">            try:
</span><span class="hit">                return self.values[idx, jdx]
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to retrieve values from parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s` via the row and column related attribute &#39;
</span><span class="noop">                    &#39;`%s`&#39; % (self.name, objecttools.devicename(self), key))
</span><span class="noop">        else:
</span><span class="hit">            return MultiParameter.__getattr__(self, key)
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, key, values):
</span><span class="hit">        if key in self.ROWNAMES:
</span><span class="hit">            try:
</span><span class="hit">                self.values[self.ROWNAMES.index(key), :] = values
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to assign new values to parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s` via the row related attribute `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self), key))
</span><span class="hit">        elif key in self.COLNAMES:
</span><span class="hit">            try:
</span><span class="hit">                self.values[:, self.COLNAMES.index(key)] = values
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to assign new values to parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s` via the column related attribute `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self), key))
</span><span class="hit">        elif key in self._ROWCOLMAPPINGS:
</span><span class="hit">            idx, jdx = self._ROWCOLMAPPINGS[key]
</span><span class="hit">            try:
</span><span class="hit">                self.values[idx, jdx] = values
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to assign new values to parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s` via the row and column related attribute &#39;
</span><span class="noop">                    &#39;`%s`&#39; % (self.name, objecttools.devicename(self), key))
</span><span class="noop">        else:
</span><span class="hit">            MultiParameter.__setattr__(self, key, values)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return (objecttools.dir_(self) + list(self.ROWNAMES) +
</span><span class="noop">                list(self.COLNAMES) + list(self._ROWCOLMAPPINGS.keys()))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LeftRightParameter(MultiParameter):
</span><span class="hit">    NDIM = 1
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        try:
</span><span class="hit">            MultiParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            left = kwargs.get(&#39;left&#39;, kwargs.get(&#39;l&#39;))
</span><span class="hit">            if left is None:
</span><span class="miss">                raise ValueError(&#39;When setting the values of parameter `%s`&#39;
</span><span class="noop">                                 &#39;of element `%s` via keyword arguments, &#39;
</span><span class="noop">                                 &#39;either `left` or `l` for the &#34;left&#34; &#39;
</span><span class="noop">                                 &#39;parameter value must be given, but is not.&#39;
</span><span class="noop">                                 % (self.name, objecttools.devicename(self)))
</span><span class="noop">            else:
</span><span class="hit">                self.left = left
</span><span class="hit">            right = kwargs.get(&#39;right&#39;, kwargs.get(&#39;r&#39;))
</span><span class="hit">            if right is None:
</span><span class="miss">                raise ValueError(&#39;When setting the values of parameter `%s`&#39;
</span><span class="noop">                                 &#39;of element `%s` via keyword arguments, &#39;
</span><span class="noop">                                 &#39;either `right` or `r` for the &#34;right&#34; &#39;
</span><span class="noop">                                 &#39;parameter value must be given, but is not.&#39;
</span><span class="noop">                                 % (self.name, objecttools.devicename(self)))
</span><span class="noop">            else:
</span><span class="hit">                self.right = right
</span><span class="noop">
</span><span class="hit">    def connect(self, subpars):
</span><span class="hit">        MultiParameter.connect(self, subpars)
</span><span class="hit">        self.shape = 2
</span><span class="noop">
</span><span class="hit">    def _getleft(self):
</span><span class="noop">        &#34;&#34;&#34;The &#34;left&#34; value of the actual parameter.&#34;&#34;&#34;
</span><span class="hit">        return self.values[0]
</span><span class="noop">
</span><span class="hit">    def _setleft(self, value):
</span><span class="hit">        self.values[0] = value
</span><span class="noop">
</span><span class="hit">    left = property(_getleft, _setleft)
</span><span class="hit">    l = left
</span><span class="noop">
</span><span class="hit">    def _getright(self):
</span><span class="noop">        &#34;&#34;&#34;The &#34;right&#34; value of the actual parameter.&#34;&#34;&#34;
</span><span class="hit">        return self.values[1]
</span><span class="noop">
</span><span class="hit">    def _setright(self, value):
</span><span class="hit">        self.values[1] = value
</span><span class="noop">
</span><span class="hit">    right = property(_getright, _setright)
</span><span class="hit">    r = right
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class IndexParameter(MultiParameter):
</span><span class="noop">
</span><span class="hit">    def setreference(self, indexarray):
</span><span class="hit">        setattr(self.fastaccess, self.name, indexarray)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SolverParameter(SingleParameter):
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        super(SolverParameter, self).__init__()
</span><span class="hit">        self._alternative_initvalue = None
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        super(SolverParameter, self).__call__(*args, **kwargs)
</span><span class="hit">        self.alternative_initvalue = self.value
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        try:
</span><span class="hit">            self(self.alternative_initvalue)
</span><span class="hit">        except RuntimeError:
</span><span class="hit">            self(self.modify_init())
</span><span class="noop">
</span><span class="hit">    def modify_init(self):
</span><span class="hit">        return self.INIT
</span><span class="noop">
</span><span class="hit">    def _get_alternative_initvalue(self):
</span><span class="hit">        if self._alternative_initvalue is None:
</span><span class="hit">            raise RuntimeError(
</span><span class="noop">                &#39;No alternative initial value for solver parameter `%s` of &#39;
</span><span class="noop">                &#39;element `%s` has been defined so far.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self)))
</span><span class="noop">        else:
</span><span class="hit">            return self._alternative_initvalue
</span><span class="noop">
</span><span class="hit">    def _set_alternative_initvalue(self, value):
</span><span class="hit">        self._alternative_initvalue = value
</span><span class="noop">
</span><span class="hit">    def _del_alternative_initvalue(self):
</span><span class="miss">        self._alternative_initvalue = None
</span><span class="noop">
</span><span class="hit">    alternative_initvalue = property(_get_alternative_initvalue,
</span><span class="noop">                                     _set_alternative_initvalue,
</span><span class="noop">                                     _del_alternative_initvalue)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/selectiontools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/selectiontools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements tools for selecting certain models in large
</span><span class="noop">HydPy projects.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Selections(object):
</span><span class="noop">    &#34;&#34;&#34;Collects :class:`Selection` instances.
</span><span class="noop">
</span><span class="noop">    Attributes:
</span><span class="noop">        * ? (:class:`Selection`): An arbitrary number of :class:`Selection`
</span><span class="noop">          objects, which can be added (and removed) on demand.  Choose
</span><span class="noop">          attribute names that are meaningfull within your specific project.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, *selections):
</span><span class="miss">        for selection in selections:
</span><span class="miss">            self += selection
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def names(self):
</span><span class="noop">        &#34;&#34;&#34;Names of the actual selections.&#34;&#34;&#34;
</span><span class="miss">        return tuple(vars(self).keys())
</span><span class="noop">
</span><span class="hit">    def save(self, path=&#39;&#39;, write_nodes=False):
</span><span class="noop">        &#34;&#34;&#34;Save all selections in seperate network files.&#34;&#34;&#34;
</span><span class="miss">        for selection in self:
</span><span class="miss">            fullpath = os.path.join(path, selection.name+&#39;.py&#39;)
</span><span class="miss">            selection.save(fullpath, write_nodes)
</span><span class="noop">
</span><span class="hit">    def _getselections(self):
</span><span class="noop">        &#34;&#34;&#34;The actual selections themselves.&#34;&#34;&#34;
</span><span class="miss">        return tuple(vars(self).values())
</span><span class="noop">
</span><span class="hit">    selections = property(_getselections)
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, value):
</span><span class="miss">        self.__dict__[key] = value
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="miss">        return self.__dict__[key]
</span><span class="noop">
</span><span class="hit">    def __delitem__(self, key):
</span><span class="miss">        del(self.__dict__[key])
</span><span class="noop">
</span><span class="hit">    def __contains__(self, value):
</span><span class="miss">        if isinstance(value, Selection):
</span><span class="miss">            return value in self.selections
</span><span class="noop">        else:
</span><span class="miss">            return value in self.names
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        for (name, selection) in sorted(vars(self).items()):
</span><span class="miss">            yield selection
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="miss">        return len(self.names)
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def _getiterable(value):
</span><span class="noop">        &#34;&#34;&#34;Tries to convert the given argument to a :class:`list` of
</span><span class="noop">        :class:`Selection` objects and returns it.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * value (:class:`Selection`, :class:`Selections` of a simple
</span><span class="noop">            iterable containing :class:`Selection` objects): The second
</span><span class="noop">            operand applied in an arithmetic operation.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if isinstance(value, Selection):
</span><span class="miss">            return [value]
</span><span class="miss">        elif isinstance(value, Selections):
</span><span class="miss">            return value.selections
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                for selection in value:
</span><span class="miss">                    selection.name
</span><span class="miss">                    break
</span><span class="miss">                return list(value)
</span><span class="miss">            except (KeyError, AttributeError):
</span><span class="miss">                raise TypeError(&#39;Arithmetic operations on `Selections` &#39;
</span><span class="noop">                                &#39;objects are defined for other `Selections` &#39;
</span><span class="noop">                                &#39;objects, single `Selection` objects or &#39;
</span><span class="noop">                                &#39;simple iterables (like `list` objects) &#39;
</span><span class="noop">                                &#39;containing `Selection` objects only.  The &#39;
</span><span class="noop">                                &#39;given arguments type is `%s`.&#39;
</span><span class="noop">                                % type(value))
</span><span class="noop">
</span><span class="hit">    def __add__(self, value):
</span><span class="miss">        selections = self._getiterable(value)
</span><span class="miss">        new = self.copy()
</span><span class="miss">        for selection in selections:
</span><span class="miss">            new[selection.name] = selection
</span><span class="miss">        return new
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, value):
</span><span class="miss">        selections = self._getiterable(value)
</span><span class="miss">        for selection in selections:
</span><span class="miss">            self[selection.name] = selection
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, value):
</span><span class="miss">        selections = self._getiterable(value)
</span><span class="miss">        new = self.copy()
</span><span class="miss">        for selection in selections:
</span><span class="miss">            try:
</span><span class="miss">                del(new[selection.name])
</span><span class="miss">            except KeyError:
</span><span class="miss">                pass
</span><span class="miss">        return new
</span><span class="noop">
</span><span class="hit">    def __isub__(self, value):
</span><span class="miss">        selections = self._getiterable(value)
</span><span class="miss">        for selection in selections:
</span><span class="miss">            try:
</span><span class="miss">                del(self[selection.name])
</span><span class="miss">            except KeyError:
</span><span class="miss">                pass
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        with objecttools.repr_.preserve_strings(True):
</span><span class="miss">            with pub.options.ellipsis(2, optional=True):
</span><span class="miss">                prefix += &#39;%s(&#39; % objecttools.classname(self)
</span><span class="miss">                repr_ = objecttools.assignrepr_values(self.names, prefix, 70)
</span><span class="miss">                return repr_ + &#39;)&#39;
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return [&#39;names&#39;, &#39;selections&#39;, &#39;assignrepr&#39;] + list(self.names)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Selection(object):
</span><span class="noop">    &#34;&#34;&#34;Defines a combination of :class:`~hydpy.core.node.Node` and
</span><span class="noop">    :class:`~hydpy.core.element.Element` objects suitable for a
</span><span class="noop">    specific task.
</span><span class="noop">
</span><span class="noop">    Attributes:
</span><span class="noop">        * name (:class:`str`): Name of the selection.
</span><span class="noop">        * nodes (:class:`~hydpy.core.node.Nodes`):
</span><span class="noop">          Currently selected nodes.
</span><span class="noop">        * elements (:class:`~hydpy.core.element.Elements`):
</span><span class="noop">          Currently selected elements.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, name, nodes=None, elements=None):
</span><span class="hit">        self.name = name
</span><span class="hit">        self.nodes = devicetools.Nodes(nodes)
</span><span class="hit">        self.elements = devicetools.Elements(elements)
</span><span class="noop">
</span><span class="hit">    def select_upstream(self, device):
</span><span class="noop">        &#34;&#34;&#34;Limit the current selection to the network upstream of the given
</span><span class="noop">        starting point, including the starting point itself.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * device (:class:`~hydpy.core.devicetools.Node` or
</span><span class="noop">              :class:`~hydpy.core.devicetools.Element`): Lowest point
</span><span class="noop">              to be selected.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.nodes, self.elements = self.getby_upstream(device)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def deselect_upstream(self, device):
</span><span class="noop">        &#34;&#34;&#34;Remove the network upstream of the given starting point from the
</span><span class="noop">        current selection, including the starting point itself.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * device (:class:`~hydpy.core.devicetools.Node` or
</span><span class="noop">              :class:`~hydpy.core.devicetools.Element`): Highest point
</span><span class="noop">              to be deselected.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        nodes, elements = self.getby_upstream(device)
</span><span class="hit">        self.nodes -= nodes
</span><span class="hit">        self.elements -= elements
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def getby_upstream(self, device):
</span><span class="noop">        &#34;&#34;&#34;Returns the network upstream of the given starting point, including
</span><span class="noop">        the starting point itself.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * device (:class:`~hydpy.core.devicetools.Node` or
</span><span class="noop">              :class:`~hydpy.core.devicetools.Element`): Lowest point
</span><span class="noop">              to be selected.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        nodes = devicetools.Nodes()
</span><span class="hit">        elements = devicetools.Elements()
</span><span class="hit">        if isinstance(device, devicetools.Node):
</span><span class="hit">            nodes, elements = self._nextnode(device, nodes, elements)
</span><span class="miss">        elif isinstance(device, devicetools.Element):
</span><span class="miss">            nodes, elements = self._nextelement(device, nodes, elements)
</span><span class="noop">        else:
</span><span class="miss">            raise AttributeError(&#39;Pass either a `Node` or an `Element` &#39;
</span><span class="noop">                                 &#39;instance to the function.  The given &#39;
</span><span class="noop">                                 &#39;`device` value `%s` is of type `%s`.&#39;
</span><span class="noop">                                 % (device, type(device)))
</span><span class="hit">        return nodes, elements
</span><span class="noop">
</span><span class="hit">    def _nextnode(self, node, nodes, elements):
</span><span class="noop">        &#34;&#34;&#34;First recursion method for :func:`~Selection.getupstreamnetwork`.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * node (:class:`~hydpy.core.devicetools.Node`): The node which
</span><span class="noop">              is selected currently.
</span><span class="noop">            * nodes (:class:`~hydpy.core.devicetools.Nodes`): All nodes
</span><span class="noop">            which have been selected so far.
</span><span class="noop">            * elements (:class:`~hydpy.core.devicetools.Elements`): All
</span><span class="noop">            elements which have been selected so far.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if (node not in nodes) and (node in self.nodes):
</span><span class="hit">            nodes += node
</span><span class="hit">            for element in node.entries:
</span><span class="hit">                nodes, elements = self._nextelement(element, nodes, elements)
</span><span class="hit">        return nodes, elements
</span><span class="noop">
</span><span class="hit">    def _nextelement(self, element, nodes, elements):
</span><span class="noop">        &#34;&#34;&#34;Second recursion method for :func:`~Selection.getupstreamnetwork`.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * element (:class:`~hydpy.core.devicetools.Element`): The
</span><span class="noop">              element which is selected currently.
</span><span class="noop">            * nodes (:class:`~hydpy.core.devicetools.Nodes`): All nodes
</span><span class="noop">            which have been selected so far.
</span><span class="noop">            * elements (:class:`~hydpy.core.devicetools.Elements`): All
</span><span class="noop">            elements which have been selected so far.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if (element not in elements) and (element in self.elements):
</span><span class="hit">            elements += element
</span><span class="hit">            for node in element.inlets:
</span><span class="hit">                nodes, elements = self._nextnode(node, nodes, elements)
</span><span class="hit">        return nodes, elements
</span><span class="noop">
</span><span class="hit">    def select_modelclasses(self, *modelclass):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all elements containing the
</span><span class="noop">        given modelclass(es).  (All nodes are removed.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * modelclass (subclass of :class:`~hydpy.core.models.Model`):
</span><span class="noop">              Model type(s) as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.nodes = devicetools.Nodes()
</span><span class="miss">        self.elements = self.getby_modelclasses(modelclass)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def deselect_modelclasses(self, *modelclasses):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all elements not containing the
</span><span class="noop">        given modelclass(es).  (All nodes are removed.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * modelclass (subclass of :class:`~hydpy.core.models.Model`):
</span><span class="noop">              Model type(s) as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.nodes = devicetools.Nodes()
</span><span class="miss">        self.elements -= self.getby_modelclasses(*modelclasses)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def getby_modelclasses(self, *modelclasses):
</span><span class="noop">        &#34;&#34;&#34;Returns all elements of the current selection containing the given
</span><span class="noop">        modelclass(es).
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * modelclass (subclass of :class:`~hydpy.core.models.Model`):
</span><span class="noop">              Model type(s) as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        elements = devicetools.Elements()
</span><span class="miss">        for element in self.elements:
</span><span class="miss">            if element.model is None:
</span><span class="miss">                raise RuntimeError(&#39;For element `%s` no model object has been &#39;
</span><span class="noop">                                   &#39;initialized so far, which is a necessary &#39;
</span><span class="noop">                                   &#39;condition to perform (de)selections based &#39;
</span><span class="noop">                                   &#39;on model classes.&#39; % element)
</span><span class="miss">            if isinstance(element.model, modelclasses):
</span><span class="miss">                elements += element
</span><span class="miss">        return elements
</span><span class="noop">
</span><span class="hit">    def select_nodenames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all nodes with a name
</span><span class="noop">        containing the given substring(s).  (All elements are unaffected.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the nodes
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.nodes = self.getby_nodenames(*substrings)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def deselect_nodenames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all nodes with a name
</span><span class="noop">        not containing the given substring(s).  (All elements are unaffected.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the nodes
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.nodes -= self.getby_nodenames(*substrings)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def getby_nodenames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Returns all nodes of the current selection with a name
</span><span class="noop">        containing the given substrings(s).
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the nodes
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        nodes = devicetools.Nodes()
</span><span class="hit">        for node in self.nodes:
</span><span class="hit">            for substring in substrings:
</span><span class="hit">                if substring in node.name:
</span><span class="hit">                    nodes += node
</span><span class="hit">                    break
</span><span class="hit">        return nodes
</span><span class="noop">
</span><span class="hit">    def select_elementnames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all elements with a name
</span><span class="noop">        containing the given substring(s).  (All nodes are unaffected.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the elements
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.elements = self.getby_elementnames(*substrings)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def deselect_elementnames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all elements with a name
</span><span class="noop">        not containing the given substring(s).  (All nodes are unaffected.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the elements
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.elements -= self.getby_elementnames(*substrings)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def getby_elementnames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Returns all elements of the current selection with a name
</span><span class="noop">        containing the given substrings(s).
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the elements
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        elements = devicetools.Elements()
</span><span class="hit">        for element in self.elements:
</span><span class="hit">            for substring in substrings:
</span><span class="hit">                if substring in element.name:
</span><span class="hit">                    elements += element
</span><span class="hit">                    break
</span><span class="hit">        return elements
</span><span class="noop">
</span><span class="hit">    def copy(self, name):
</span><span class="noop">        &#34;&#34;&#34;Returns a semi-deep copy of the current selection.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * name (:class:`str`): Name of the new :class:`Selection` instance.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return Selection(name, self.nodes.copy(), self.elements.copy())
</span><span class="noop">
</span><span class="hit">    def save(self, path=None, write_nodes=False):
</span><span class="noop">        &#34;&#34;&#34;Save the selection as a network file.&#34;&#34;&#34;
</span><span class="miss">        if path is None:
</span><span class="miss">            path = self.name + &#39;.py&#39;
</span><span class="miss">        with open(path, &#39;w&#39;) as file_:
</span><span class="miss">            file_.write(&#39;# -*- coding: utf-8 -*-\n&#39;)
</span><span class="miss">            file_.write(&#39;\nfrom hydpy import Node, Element\n\n&#39;)
</span><span class="miss">            if write_nodes:
</span><span class="miss">                for node in self.nodes:
</span><span class="miss">                    file_.write(&#39;\n&#39; + repr(node) + &#39;\n&#39;)
</span><span class="miss">                file_.write(&#39;\n&#39;)
</span><span class="miss">            for element in self.elements:
</span><span class="miss">                file_.write(&#39;\n&#39; + repr(element) + &#39;\n&#39;)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return len(self.nodes) + len(self.elements)
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, other):
</span><span class="hit">        self.nodes += other.nodes
</span><span class="hit">        self.elements += other.elements
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __isub__(self, other):
</span><span class="hit">        self.nodes -= other.nodes
</span><span class="hit">        self.elements -= other.elements
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="miss">        return ((self.nodes &lt; other.nodes) and
</span><span class="noop">                (self.elements &lt; other.elements))
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="miss">        return ((self.nodes &lt;= other.nodes) and
</span><span class="noop">                (self.elements &lt;= other.elements))
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="miss">        return ((self.nodes == other.nodes) and
</span><span class="noop">                (self.elements == other.elements))
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="miss">        return ((self.nodes != other.nodes) or
</span><span class="noop">                (self.elements != other.elements))
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="miss">        return ((self.nodes &gt;= other.nodes) and
</span><span class="noop">                (self.elements &gt;= other.elements))
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="miss">        return ((self.nodes &gt; other.nodes) and
</span><span class="noop">                (self.elements &gt;= other.elements))
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return self.name
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        with objecttools.repr_.preserve_strings(True):
</span><span class="hit">            with pub.options.ellipsis(2, optional=True):
</span><span class="hit">                with objecttools.assignrepr_tuple.always_bracketed(False):
</span><span class="hit">                    prefix = &#39;%sSelection(&#39; % prefix
</span><span class="hit">                    blanks = &#39; &#39; * len(prefix)
</span><span class="hit">                    lines = [&#39;%s&#34;%s&#34;,&#39; % (prefix, self.name)]
</span><span class="hit">                    lines.append(objecttools.assignrepr_tuple(
</span><span class="noop">                            self.elements.names, blanks+&#39;elements=&#39;, 70) + &#39;,&#39;)
</span><span class="hit">                    lines.append(objecttools.assignrepr_tuple(
</span><span class="noop">                            self.nodes.names, blanks+&#39;nodes=&#39;, 70) + &#39;)&#39;)
</span><span class="hit">                    return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return [&#39;copy&#39;, &#39;deselect_elementnames&#39;, &#39;deselect_modelclasses&#39;,
</span><span class="noop">                &#39;deselect_nodenames&#39;, &#39;deselect_upstream&#39;, &#39;elements&#39;,
</span><span class="noop">                &#39;getby_elementnames&#39;, &#39;getby_modelclasses&#39;, &#39;getby_nodenames&#39;,
</span><span class="noop">                &#39;getby_upstream&#39;, &#39;nodes&#39;, &#39;select_elementnames&#39;,
</span><span class="noop">                &#39;select_modelclasses&#39;, &#39;select_nodenames&#39;, &#39;select_upstream&#39;,
</span><span class="noop">                &#39;assignrepr&#39;]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/sequencetools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/sequencetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
1399 &nbsp;
1400 &nbsp;
1401 &nbsp;
1402 &nbsp;
1403 &nbsp;
1404 &nbsp;
1405 &nbsp;
1406 &nbsp;
1407 &nbsp;
1408 &nbsp;
1409 &nbsp;
1410 &nbsp;
1411 &nbsp;
1412 &nbsp;
1413 &nbsp;
1414 &nbsp;
1415 &nbsp;
1416 &nbsp;
1417 &nbsp;
1418 &nbsp;
1419 &nbsp;
1420 &nbsp;
1421 &nbsp;
1422 &nbsp;
1423 &nbsp;
1424 &nbsp;
1425 &nbsp;
1426 &nbsp;
1427 &nbsp;
1428 &nbsp;
1429 &nbsp;
1430 &nbsp;
1431 &nbsp;
1432 &nbsp;
1433 &nbsp;
1434 &nbsp;
1435 &nbsp;
1436 &nbsp;
1437 &nbsp;
1438 &nbsp;
1439 &nbsp;
1440 &nbsp;
1441 &nbsp;
1442 &nbsp;
1443 &nbsp;
1444 &nbsp;
1445 &nbsp;
1446 &nbsp;
1447 &nbsp;
1448 &nbsp;
1449 &nbsp;
1450 &nbsp;
1451 &nbsp;
1452 &nbsp;
1453 &nbsp;
1454 &nbsp;
1455 &nbsp;
1456 &nbsp;
1457 &nbsp;
1458 &nbsp;
1459 &nbsp;
1460 &nbsp;
1461 &nbsp;
1462 &nbsp;
1463 &nbsp;
1464 &nbsp;
1465 &nbsp;
1466 &nbsp;
1467 &nbsp;
1468 &nbsp;
1469 &nbsp;
1470 &nbsp;
1471 &nbsp;
1472 &nbsp;
1473 &nbsp;
1474 &nbsp;
1475 &nbsp;
1476 &nbsp;
1477 &nbsp;
1478 &nbsp;
1479 &nbsp;
1480 &nbsp;
1481 &nbsp;
1482 &nbsp;
1483 &nbsp;
1484 &nbsp;
1485 &nbsp;
1486 &nbsp;
1487 &nbsp;
1488 &nbsp;
1489 &nbsp;
1490 &nbsp;
1491 &nbsp;
1492 &nbsp;
1493 &nbsp;
1494 &nbsp;
1495 &nbsp;
1496 &nbsp;
1497 &nbsp;
1498 &nbsp;
1499 &nbsp;
1500 &nbsp;
1501 &nbsp;
1502 &nbsp;
1503 &nbsp;
1504 &nbsp;
1505 &nbsp;
1506 &nbsp;
1507 &nbsp;
1508 &nbsp;
1509 &nbsp;
1510 &nbsp;
1511 &nbsp;
1512 &nbsp;
1513 &nbsp;
1514 &nbsp;
1515 &nbsp;
1516 &nbsp;
1517 &nbsp;
1518 &nbsp;
1519 &nbsp;
1520 &nbsp;
1521 &nbsp;
1522 &nbsp;
1523 &nbsp;
1524 &nbsp;
1525 &nbsp;
1526 &nbsp;
1527 &nbsp;
1528 &nbsp;
1529 &nbsp;
1530 &nbsp;
1531 &nbsp;
1532 &nbsp;
1533 &nbsp;
1534 &nbsp;
1535 &nbsp;
1536 &nbsp;
1537 &nbsp;
1538 &nbsp;
1539 &nbsp;
1540 &nbsp;
1541 &nbsp;
1542 &nbsp;
1543 &nbsp;
1544 &nbsp;
1545 &nbsp;
1546 &nbsp;
1547 &nbsp;
1548 &nbsp;
1549 &nbsp;
1550 &nbsp;
1551 &nbsp;
1552 &nbsp;
1553 &nbsp;
1554 &nbsp;
1555 &nbsp;
1556 &nbsp;
1557 &nbsp;
1558 &nbsp;
1559 &nbsp;
1560 &nbsp;
1561 &nbsp;
1562 &nbsp;
1563 &nbsp;
1564 &nbsp;
1565 &nbsp;
1566 &nbsp;
1567 &nbsp;
1568 &nbsp;
1569 &nbsp;
1570 &nbsp;
1571 &nbsp;
1572 &nbsp;
1573 &nbsp;
1574 &nbsp;
1575 &nbsp;
1576 &nbsp;
1577 &nbsp;
1578 &nbsp;
1579 &nbsp;
1580 &nbsp;
1581 &nbsp;
1582 &nbsp;
1583 &nbsp;
1584 &nbsp;
1585 &nbsp;
1586 &nbsp;
1587 &nbsp;
1588 &nbsp;
1589 &nbsp;
1590 &nbsp;
1591 &nbsp;
1592 &nbsp;
1593 &nbsp;
1594 &nbsp;
1595 &nbsp;
1596 &nbsp;
1597 &nbsp;
1598 &nbsp;
1599 &nbsp;
1600 &nbsp;
1601 &nbsp;
1602 &nbsp;
1603 &nbsp;
1604 &nbsp;
1605 &nbsp;
1606 &nbsp;
1607 &nbsp;
1608 &nbsp;
1609 &nbsp;
1610 &nbsp;
1611 &nbsp;
1612 &nbsp;
1613 &nbsp;
1614 &nbsp;
1615 &nbsp;
1616 &nbsp;
1617 &nbsp;
1618 &nbsp;
1619 &nbsp;
1620 &nbsp;
1621 &nbsp;
1622 &nbsp;
1623 &nbsp;
1624 &nbsp;
1625 &nbsp;
1626 &nbsp;
1627 &nbsp;
1628 &nbsp;
1629 &nbsp;
1630 &nbsp;
1631 &nbsp;
1632 &nbsp;
1633 &nbsp;
1634 &nbsp;
1635 &nbsp;
1636 &nbsp;
1637 &nbsp;
1638 &nbsp;
1639 &nbsp;
1640 &nbsp;
1641 &nbsp;
1642 &nbsp;
1643 &nbsp;
1644 &nbsp;
1645 &nbsp;
1646 &nbsp;
1647 &nbsp;
1648 &nbsp;
1649 &nbsp;
1650 &nbsp;
1651 &nbsp;
1652 &nbsp;
1653 &nbsp;
1654 &nbsp;
1655 &nbsp;
1656 &nbsp;
1657 &nbsp;
1658 &nbsp;
1659 &nbsp;
1660 &nbsp;
1661 &nbsp;
1662 &nbsp;
1663 &nbsp;
1664 &nbsp;
1665 &nbsp;
1666 &nbsp;
1667 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements tools for handling the sequences (time series)
</span><span class="noop">of hydrological models.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import sys
</span><span class="hit">import copy
</span><span class="hit">import struct
</span><span class="hit">import warnings
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.cythons import pointerutils
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Sequences(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling all sequences of a specific model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _names_subseqs = (&#39;inlets&#39;, &#39;receivers&#39;, &#39;inputs&#39;, &#39;fluxes&#39;, &#39;states&#39;,
</span><span class="noop">                      &#39;logs&#39;, &#39;aides&#39;, &#39;outlets&#39;, &#39;senders&#39;)
</span><span class="noop">
</span><span class="hit">    def __init__(self, **kwargs):
</span><span class="hit">        self.model = kwargs.pop(&#39;model&#39;, None)
</span><span class="hit">        cythonmodule = kwargs.pop(&#39;cythonmodule&#39;, None)
</span><span class="hit">        cymodel = kwargs.pop(&#39;cymodel&#39;, None)
</span><span class="hit">        for (name, cls) in kwargs.items():
</span><span class="hit">            if name.endswith(&#39;Sequences&#39;) and issubclass(cls, SubSequences):
</span><span class="hit">                if cythonmodule:
</span><span class="miss">                    cls_fastaccess = getattr(cythonmodule, name)
</span><span class="miss">                    subseqs = cls(self, cls_fastaccess, cymodel)
</span><span class="noop">                else:
</span><span class="hit">                    subseqs = cls(self, None, None)
</span><span class="hit">                setattr(self, subseqs.name, subseqs)
</span><span class="noop">
</span><span class="hit">    def set_initvals(self, info, idx_date):
</span><span class="miss">        self.states.set_initvals(info, idx_date)
</span><span class="noop">
</span><span class="hit">    def activate_disk(self, names=None):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;activate_disk&#39;):
</span><span class="miss">                subseqs.activate_disk(names)
</span><span class="noop">
</span><span class="hit">    def deactivate_disk(self, names=None):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;deactivate_disk&#39;):
</span><span class="miss">                subseqs.deactivate_disk(names)
</span><span class="noop">
</span><span class="hit">    def activate_ram(self, names=None):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;activate_ram&#39;):
</span><span class="miss">                subseqs.activate_ram(names)
</span><span class="noop">
</span><span class="hit">    def deactivate_ram(self, names=None):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;deactivate_ram&#39;):
</span><span class="miss">                subseqs.deactivate_ram(names)
</span><span class="noop">
</span><span class="hit">    def openfiles(self, idx=0):
</span><span class="hit">        for (name, subseqs) in self:
</span><span class="hit">            if hasattr(subseqs, &#39;openfiles&#39;):
</span><span class="hit">                subseqs.openfiles(idx)
</span><span class="noop">
</span><span class="hit">    def closefiles(self):
</span><span class="hit">        for (name, subseqs) in self:
</span><span class="hit">            if hasattr(subseqs, &#39;closefiles&#39;):
</span><span class="hit">                subseqs.closefiles()
</span><span class="noop">
</span><span class="hit">    def loaddata(self, idx):
</span><span class="hit">        for (name, subseqs) in self:
</span><span class="hit">            if hasattr(subseqs, &#39;loaddata&#39;):
</span><span class="hit">                subseqs.loaddata(idx)
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="hit">        for (name, subseqs) in self:
</span><span class="hit">            if hasattr(subseqs, &#39;savedata&#39;):
</span><span class="hit">                subseqs.savedata(idx)
</span><span class="noop">
</span><span class="hit">    def reset(self):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;reset&#39;):
</span><span class="miss">                subseqs.reset()
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for name in self._names_subseqs:
</span><span class="hit">            subseqs = getattr(self, name, None)
</span><span class="hit">            if subseqs is not None:
</span><span class="hit">                yield name, subseqs
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def conditions(self):
</span><span class="noop">        &#34;&#34;&#34;Generator object yielding all conditions (class:`StateSequence` and
</span><span class="noop">        :class:`LogSequence` objects).
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        for subseqs in (&#39;states&#39;, &#39;logs&#39;):
</span><span class="miss">            for tuple_ in getattr(self, subseqs, ()):
</span><span class="miss">                yield tuple_
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def hasconditions(self):
</span><span class="noop">        &#34;&#34;&#34;True or False, whether the :class:`Sequences` object handles at
</span><span class="noop">        conditions (at least one :class:`StateSequence` or :class:`LogSequence`
</span><span class="noop">        object)  or not.&#34;&#34;&#34;
</span><span class="miss">        for tuple_ in self.conditions:
</span><span class="miss">            return True
</span><span class="miss">        return False
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def _conditiondefaultfilename(self):
</span><span class="miss">        filename = objecttools.devicename(self)
</span><span class="miss">        if filename == &#39;?&#39;:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;To load or save the conditions of a model from or to a file, &#39;
</span><span class="noop">                &#39;its filename must be known.  This can be done, by passing &#39;
</span><span class="noop">                &#39;filename to function `loadconditions` or `saveconditions` &#39;
</span><span class="noop">                &#39;directly.  But in complete HydPy applications, it is usally &#39;
</span><span class="noop">                &#39;assumed to be consistent with the name of the element &#39;
</span><span class="noop">                &#39;handling the model.  Actually, neither a filename is given &#39;
</span><span class="noop">                &#39;nor does the model know its master element.&#39;)
</span><span class="noop">        else:
</span><span class="miss">            return filename + &#39;.py&#39;
</span><span class="noop">
</span><span class="hit">    def loadconditions(self, filename=None, dirname=None):
</span><span class="noop">        &#34;&#34;&#34;Load initial conditions from a file and assign them to the
</span><span class="noop">        respective sequences.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if self.hasconditions:
</span><span class="miss">            if filename is None:
</span><span class="miss">                filename = self._conditiondefaultfilename
</span><span class="miss">            namespace = locals()
</span><span class="miss">            for (name, seq) in self.conditions:
</span><span class="miss">                namespace[name] = seq
</span><span class="miss">            namespace[&#39;model&#39;] = self
</span><span class="miss">            code = pub.conditionmanager.loadfile(filename, dirname)
</span><span class="miss">            try:
</span><span class="miss">                exec(code)
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(&#39;While trying to gather initial &#39;
</span><span class="noop">                                              &#39;conditions of element %s&#39;
</span><span class="noop">                                              % objecttools.devicename(self))
</span><span class="noop">
</span><span class="hit">    def saveconditions(self, filename=None, dirname=None):
</span><span class="miss">        if self.hasconditions:
</span><span class="miss">            if filename is None:
</span><span class="miss">                filename = self._conditiondefaultfilename
</span><span class="miss">            if not filename.endswith(&#39;.py&#39;):
</span><span class="miss">                filename += &#39;.py&#39;
</span><span class="miss">            if dirname is None:
</span><span class="miss">                dirname = pub.conditionmanager.savepath
</span><span class="miss">            filepath = os.path.join(dirname, filename)
</span><span class="miss">            with open(filepath, &#39;w&#39;) as file_:
</span><span class="miss">                file_.write(&#39;from hydpy.models.%s import *\n\n&#39;
</span><span class="noop">                            % self.model.__module__.split(&#39;.&#39;)[2])
</span><span class="miss">                try:
</span><span class="miss">                    line = (&#39;controlcheck(projectdir=&#34;%s&#34;, controldir=&#34;%s&#34;)&#39;
</span><span class="noop">                            % (pub.controlmanager.projectdirectory,
</span><span class="noop">                               pub.controlmanager.controldirectory))
</span><span class="miss">                    file_.write(line + &#39;\n\n&#39;)
</span><span class="miss">                except BaseException:
</span><span class="miss">                    pass
</span><span class="miss">                for (name, seq) in self.conditions:
</span><span class="miss">                    file_.write(repr(seq) + &#39;\n&#39;)
</span><span class="noop">
</span><span class="hit">    def trimconditions(self):
</span><span class="miss">        for (name, seq) in self.conditions:
</span><span class="miss">            seq.trim()
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="miss">        return len(dict(self))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MetaSubSequencesType(type):
</span><span class="hit">    def __new__(cls, name, parents, dict_):
</span><span class="hit">        seqclasses = dict_.get(&#39;_SEQCLASSES&#39;)
</span><span class="hit">        if seqclasses is None:
</span><span class="hit">            raise NotImplementedError(
</span><span class="noop">                &#39;For class `%s`, the required tuple `_SEQCLASSES` is not &#39;
</span><span class="noop">                &#39;defined.  Please see the documentation of class &#39;
</span><span class="noop">                &#39;`SubSequences` of module `sequencetools` for further &#39;
</span><span class="noop">                &#39;information.&#39; % name)
</span><span class="hit">        if seqclasses:
</span><span class="hit">            lst = [&#39;\n\n\n    The following sequence classes are selected:&#39;]
</span><span class="hit">            for seqclass in seqclasses:
</span><span class="hit">                    lst.append(&#39;      * :class:`~%s` `%s`&#39;
</span><span class="noop">                               % (&#39;.&#39;.join((seqclass.__module__,
</span><span class="noop">                                            seqclass.__name__)),
</span><span class="noop">                                  autodoctools.description(seqclass)))
</span><span class="hit">            doc = dict_.get(&#39;__doc__&#39;, None)
</span><span class="hit">            if doc is None:
</span><span class="hit">                doc = &#39;&#39;
</span><span class="hit">            dict_[&#39;__doc__&#39;] = doc + &#39;\n&#39;.join(l for l in lst)
</span><span class="hit">        return type.__new__(cls, name, parents, dict_)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">MetaSubSequencesClass = MetaSubSequencesType(&#39;MetaSubSequencesClass&#39;,
</span><span class="noop">                                             (), {&#39;_SEQCLASSES&#39;: ()})
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SubSequences(MetaSubSequencesClass):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling subgroups of sequences.
</span><span class="noop">
</span><span class="noop">    Attributes:
</span><span class="noop">      * seqs: The parent :class:`Sequences` object.
</span><span class="noop">      * fastaccess: The  :class:`FastAccess` object allowing fast access to
</span><span class="noop">        the sequence values. In `Cython` mode, model specific cdef
</span><span class="noop">        classes are applied.
</span><span class="noop">
</span><span class="noop">    Additional attributes are the actual :class:`Sequence` instances,
</span><span class="noop">    representing the individual time series.  These need to be defined in
</span><span class="noop">    :class:`SubSequences` subclass.  Therefore, one needs to collect the
</span><span class="noop">    appropriate :class:`Sequence` subclasses in the (hidden) class attribute
</span><span class="noop">    :attr:`~SubSequences._SEQCLASSES`, as shown in the following example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.sequencetools import *
</span><span class="noop">    &gt;&gt;&gt; class Temperature(Sequence):
</span><span class="noop">    ...    NDIM, NUMERIC = 0, False
</span><span class="noop">    &gt;&gt;&gt; class Precipitation(Sequence):
</span><span class="noop">    ...    NDIM, NUMERIC = 0, True
</span><span class="noop">    &gt;&gt;&gt; class InputSequences(SubSequences):
</span><span class="noop">    ...     _SEQCLASSES = (Temperature, Precipitation)
</span><span class="noop">    &gt;&gt;&gt; inputs = InputSequences(None) # Assign `None` for brevity.
</span><span class="noop">    &gt;&gt;&gt; inputs
</span><span class="noop">    temperature(nan)
</span><span class="noop">    precipitation(nan)
</span><span class="noop">
</span><span class="noop">    The order within the tuple determines the order of iteration, hence:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; for (name, sequence) in inputs:
</span><span class="noop">    ...     print(sequence)
</span><span class="noop">    temperature(nan)
</span><span class="noop">    precipitation(nan)
</span><span class="noop">
</span><span class="noop">    If one forgets to define a `_SEQCLASSES` tuple so (and maybe tries to add
</span><span class="noop">    the sequences in the constructor of the subclass of
</span><span class="noop">    :class:`SubSequences`, the following error is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; class InputSequences(SubSequences):
</span><span class="noop">    ...     pass
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    NotImplementedError: For class `InputSequences`, the required tuple `_SEQCLASSES` is not defined.  Please see the documentation of class `SubSequences` of module `sequencetools` for further information.
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def __init__(self, seqs, cls_fastaccess=None, cymodel=None):
</span><span class="hit">        self.seqs = seqs
</span><span class="hit">        self._initfastaccess(cls_fastaccess, cymodel)
</span><span class="hit">        self._initsequences()
</span><span class="noop">
</span><span class="hit">    def _initfastaccess(self, cls_fastaccess, cymodel):
</span><span class="hit">        if cls_fastaccess is None:
</span><span class="hit">            self.fastaccess = FastAccess()
</span><span class="noop">        else:
</span><span class="miss">            self.fastaccess = cls_fastaccess()
</span><span class="miss">            setattr(cymodel.sequences, self.name, self.fastaccess)
</span><span class="noop">
</span><span class="hit">    def _initsequences(self):
</span><span class="hit">        for cls_seq in self._SEQCLASSES:
</span><span class="hit">            setattr(self, objecttools.instancename(cls_seq), cls_seq())
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def getname(cls):
</span><span class="hit">        return objecttools.instancename(cls)[:-8]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def name(self):
</span><span class="hit">        return self.getname()
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, name, value):
</span><span class="noop">        &#34;&#34;&#34;Attributes and methods should usually not be replaced.  Existing
</span><span class="noop">        :class:`Sequence` attributes are protected in a way, that only their
</span><span class="noop">        values are changed through assignements.  For new :class:`Sequence`
</span><span class="noop">        attributes, additional `fastaccess` references are defined.  If you
</span><span class="noop">        actually want to replace a sequence, you have to delete it first.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            attr = getattr(self, name)
</span><span class="hit">        except AttributeError:
</span><span class="hit">            object.__setattr__(self, name, value)
</span><span class="hit">            if isinstance(value, Sequence):
</span><span class="hit">                value.connect(self)
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                attr.values = value
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;`%s` instances do not allow the direct&#39;
</span><span class="noop">                                   &#39;replacement of their members.  After &#39;
</span><span class="noop">                                   &#39;initialization you should usually only &#39;
</span><span class="noop">                                   &#39;change parameter values through &#39;
</span><span class="noop">                                   &#39;assignements.  If you really need to &#39;
</span><span class="noop">                                   &#39;replace a object member, delete it &#39;
</span><span class="noop">                                   &#39;beforehand.&#39; % objecttools.classname(self))
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for seqclass in self._SEQCLASSES:
</span><span class="hit">            name = objecttools.instancename(seqclass)
</span><span class="hit">            yield name, getattr(self, name)
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="miss">        return self.__dict__[key]
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        lines = []
</span><span class="hit">        if pub.options.reprcomments:
</span><span class="miss">            lines.append(&#39;#%s object defined in module %s.&#39;
</span><span class="noop">                         % (objecttools.classname(self),
</span><span class="noop">                            objecttools.modulename(self)))
</span><span class="miss">            lines.append(&#39;#The implemented sequences with their actual &#39;
</span><span class="noop">                         &#39;values are:&#39;)
</span><span class="hit">        for (name, sequence) in self:
</span><span class="hit">            try:
</span><span class="hit">                lines.append(&#39;%s&#39; % repr(sequence))
</span><span class="miss">            except BaseException:
</span><span class="miss">                lines.append(&#39;%s(?)&#39; % name)
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class IOSubSequences(SubSequences):
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def openfiles(self, idx=0):
</span><span class="hit">        self.fastaccess.openfiles(idx)
</span><span class="noop">
</span><span class="hit">    def closefiles(self):
</span><span class="hit">        self.fastaccess.closefiles()
</span><span class="noop">
</span><span class="hit">    def activate_ram(self):
</span><span class="hit">        for (name, seq) in self:
</span><span class="hit">            seq.activate_ram()
</span><span class="noop">
</span><span class="hit">    def deactivate_ram(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.deactivate_ram()
</span><span class="noop">
</span><span class="hit">    def activate_disk(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.activate_disk()
</span><span class="noop">
</span><span class="hit">    def deactivate_disk(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.deactivate_disk()
</span><span class="noop">
</span><span class="hit">    def ram2disk(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.ram2disk()
</span><span class="noop">
</span><span class="hit">    def disk2ram(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.disk2ram()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequences(IOSubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling input sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def loaddata(self, idx):
</span><span class="hit">        self.fastaccess.loaddata(idx)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(IOSubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling flux sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def getname(cls):
</span><span class="hit">        return &#39;fluxes&#39;
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="hit">        self.fastaccess.savedata(idx)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def numerics(self):
</span><span class="noop">        &#34;&#34;&#34;Iterator for `numerical` flux sequences.
</span><span class="noop">
</span><span class="noop">        `numerical` means that the class attribute of the respective sequence
</span><span class="noop">        is `True`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        for (name, flux) in self:
</span><span class="hit">            if flux.NUMERIC:
</span><span class="hit">                yield (name, flux)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(IOSubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling state sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def _initfastaccess(self, cls_fastaccess, cymodel):
</span><span class="hit">        SubSequences._initfastaccess(self, cls_fastaccess, cymodel)
</span><span class="hit">        self.fastaccess_new = self.fastaccess
</span><span class="hit">        if cls_fastaccess is None:
</span><span class="hit">            self.fastaccess_old = FastAccess()
</span><span class="noop">        else:
</span><span class="miss">            setattr(cymodel.sequences, &#39;new_states&#39;, self.fastaccess)
</span><span class="miss">            self.fastaccess_old = cls_fastaccess()
</span><span class="miss">            setattr(cymodel.sequences, &#39;old_states&#39;, self.fastaccess_old)
</span><span class="noop">
</span><span class="hit">    def new2old(self):
</span><span class="noop">        &#34;&#34;&#34;Assign the new/final state values of the actual time step to the
</span><span class="noop">        new/initial state values of the next time step.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        for (name, seq) in self:
</span><span class="hit">            seq.new2old()
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="hit">        self.fastaccess.savedata(idx)
</span><span class="noop">
</span><span class="hit">    def reset(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.reset()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequences(SubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling log sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def reset(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.reset()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(SubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling aide sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LinkSequences(SubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling link sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Sequence(objecttools.ValueMath):
</span><span class="noop">    &#34;&#34;&#34;Only for inheritance.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.subseqs = None
</span><span class="hit">        self.fastaccess = objecttools.FastAccess()
</span><span class="noop">
</span><span class="hit">    def connect(self, subseqs):
</span><span class="hit">        self.subseqs = subseqs
</span><span class="hit">        self.fastaccess = subseqs.fastaccess
</span><span class="hit">        self._connect_subattr(&#39;ndim&#39;, self.NDIM)
</span><span class="hit">        self._connect_subattr(&#39;length&#39;, 0)
</span><span class="hit">        for idx in range(self.NDIM):
</span><span class="hit">            self._connect_subattr(&#39;length_%d&#39; % idx, 0)
</span><span class="hit">        self.diskflag = False
</span><span class="hit">        self.ramflag = False
</span><span class="hit">        try:
</span><span class="hit">            self._connect_subattr(&#39;file&#39;, &#39;&#39;)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            pass
</span><span class="hit">        self._initvalues()
</span><span class="noop">
</span><span class="hit">    def _connect_subattr(self, suffix, value):
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_%s&#39; % (self.name, suffix), value)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Sequence` instances
</span><span class="noop">        within initial condition files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.values = args
</span><span class="noop">
</span><span class="hit">    name = property(objecttools.name)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def initvalue(self):
</span><span class="hit">        if pub.options.usedefaultvalues:
</span><span class="hit">            initvalue = getattr(self, &#39;INIT&#39;, None)
</span><span class="hit">            if initvalue is None:
</span><span class="hit">                initvalue = 0.
</span><span class="noop">        else:
</span><span class="hit">            initvalue = numpy.nan
</span><span class="hit">        return initvalue
</span><span class="noop">
</span><span class="hit">    def _initvalues(self):
</span><span class="hit">        value = None if self.NDIM else self.initvalue
</span><span class="hit">        setattr(self.fastaccess, self.name, value)
</span><span class="noop">
</span><span class="hit">    def _getvalue(self):
</span><span class="noop">        &#34;&#34;&#34;The actual time series value(s) handled by the respective
</span><span class="noop">        :class:`Sequence` instance.  For consistency, `value` and `values`
</span><span class="noop">        can always be used interchangeably.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        value = getattr(self.fastaccess, self.name, None)
</span><span class="hit">        if value is None:
</span><span class="miss">            raise RuntimeError(&#39;No value/values of sequence %s of element &#39;
</span><span class="noop">                               &#39;%s has/have been defined so far.&#39;
</span><span class="noop">                               % (self.name, objecttools.devicename(self)))
</span><span class="noop">        else:
</span><span class="hit">            if self.NDIM:
</span><span class="hit">                value = numpy.asarray(value)
</span><span class="hit">            return value
</span><span class="noop">
</span><span class="hit">    def _setvalue(self, value):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            try:
</span><span class="hit">                temp = value[0]
</span><span class="hit">                if len(value) &gt; 1:
</span><span class="miss">                    raise ValueError(&#39;%d values are assigned to the scalar &#39;
</span><span class="noop">                                     &#39;sequence %s of element %s, which is &#39;
</span><span class="noop">                                     &#39;ambiguous.&#39;
</span><span class="noop">                                     % (len(value),
</span><span class="noop">                                        objecttools.devicename(self),
</span><span class="noop">                                        self.name))
</span><span class="hit">                value = temp
</span><span class="hit">            except (TypeError, IndexError):
</span><span class="hit">                pass
</span><span class="hit">            try:
</span><span class="hit">                value = float(value)
</span><span class="miss">            except (ValueError, TypeError):
</span><span class="miss">                raise TypeError(&#39;When trying to set the value of sequence &#39;
</span><span class="noop">                                &#39;%s of element %s, it was not possible to &#39;
</span><span class="noop">                                &#39;convert value `%s` to float .&#39;
</span><span class="noop">                                % (self.name, objecttools.devicename(self),
</span><span class="noop">                                   value))
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                value = value.value
</span><span class="hit">            except AttributeError:
</span><span class="hit">                pass
</span><span class="hit">            try:
</span><span class="hit">                value = numpy.full(self.shape, value, dtype=float)
</span><span class="miss">            except ValueError:
</span><span class="miss">                raise ValueError(&#39;For sequence %s of element %s setting new &#39;
</span><span class="noop">                                 &#39;values failed.  The values `%s` cannot be &#39;
</span><span class="noop">                                 &#39;converted to a numpy ndarray with shape %s &#39;
</span><span class="noop">                                 &#39;containing entries of type float.&#39;
</span><span class="noop">                                 % (self.name, objecttools.devicename(self),
</span><span class="noop">                                    value, self.shape))
</span><span class="hit">        setattr(self.fastaccess, self.name, value)
</span><span class="noop">
</span><span class="hit">    value = property(_getvalue, _setvalue)
</span><span class="hit">    values = value
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="noop">        &#34;&#34;&#34;A tuple containing the lengths in all dimensions of the sequence
</span><span class="noop">        values at a specific time point.  Note that setting a new shape
</span><span class="noop">        results in a loss of the actual values of the respective sequence.
</span><span class="noop">        For 0-dimensional sequences :attr:`shape` is always an empty tuple.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            try:
</span><span class="hit">                shape = self.values.shape
</span><span class="hit">                return tuple(int(x) for x in shape)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;Shape information for sequence %s of &#39;
</span><span class="noop">                                   &#39;element %s can only be retrieved after &#39;
</span><span class="noop">                                   &#39;it has been defined.&#39;
</span><span class="noop">                                   % (self.name,
</span><span class="noop">                                      objecttools.devicename(self)))
</span><span class="noop">        else:
</span><span class="hit">            return ()
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            try:
</span><span class="hit">                array = numpy.full(shape, self.initvalue, dtype=float)
</span><span class="miss">            except Exception:
</span><span class="miss">                prefix = (&#39;While trying create a new numpy ndarray` for &#39;
</span><span class="noop">                          &#39;sequence %s of element %s&#39;
</span><span class="noop">                          % (self.name, objecttools.devicename(self)))
</span><span class="miss">                objecttools.augmentexcmessage(prefix)
</span><span class="hit">            if array.ndim == self.NDIM:
</span><span class="hit">                setattr(self.fastaccess, self.name, array)
</span><span class="noop">            else:
</span><span class="miss">                raise ValueError(&#39;Sequence %s of element %s is %d-dimensional &#39;
</span><span class="noop">                                 &#39;but the given shape indicates %d dimensions.&#39;
</span><span class="noop">                                 % (self.name, objecttools.devicename(self),
</span><span class="noop">                                    self.NDIM, array.ndim))
</span><span class="noop">        else:
</span><span class="miss">            if shape:
</span><span class="miss">                raise ValueError(&#39;The shape information of 0-dimensional &#39;
</span><span class="noop">                                 &#39;sequences as %s of element %s can only be &#39;
</span><span class="noop">                                 &#39;`()`, but `%s` is given.&#39;
</span><span class="noop">                                 % (self.name, objecttools.devicename(self),
</span><span class="noop">                                    shape))
</span><span class="noop">            else:
</span><span class="miss">                self.value = 0.
</span><span class="noop">
</span><span class="hit">    shape = property(_getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="hit">        try:
</span><span class="hit">            return self.values[key]
</span><span class="hit">        except Exception:
</span><span class="hit">            self._raiseitemexception()
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, values):
</span><span class="hit">        try:
</span><span class="hit">            self.values[key] = values
</span><span class="miss">        except Exception:
</span><span class="miss">            self._raiseitemexception()
</span><span class="noop">
</span><span class="hit">    def _raiseitemexception(self):
</span><span class="hit">        if self.values is None:
</span><span class="miss">            raise RuntimeError(&#39;Sequence `%s` has no values so far.&#39;
</span><span class="noop">                               % self.name)
</span><span class="noop">        else:
</span><span class="hit">            objecttools.augmentexcmessage(&#39;While trying to item access the &#39;
</span><span class="noop">                                          &#39;values of sequence `%s`&#39;
</span><span class="noop">                                          % self.name)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        islong = self.length &gt; 255
</span><span class="hit">        return objecttools.ValueMath._repr(self, self.values, islong)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class IOSequence(Sequence):
</span><span class="noop">    &#34;&#34;&#34;Only for inheritance.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        Sequence.__init__(self)
</span><span class="hit">        self._rawfilename = None
</span><span class="hit">        self._filetype_ext = None
</span><span class="hit">        self._filename_ext = None
</span><span class="hit">        self._dirpath_ext = None
</span><span class="hit">        self._dirpath_int = None
</span><span class="hit">        self._filepath_ext = None
</span><span class="hit">        self._filepath_int = None
</span><span class="noop">
</span><span class="hit">    def _getfiletype_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Ending of the external data file.&#34;&#34;&#34;
</span><span class="miss">        if self._filetype_ext:
</span><span class="miss">            return self._filetype_ext
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                if isinstance(self, InputSequence):
</span><span class="miss">                    return pub.sequencemanager.inputfiletype
</span><span class="miss">                elif isinstance(self, NodeSequence):
</span><span class="miss">                    return pub.sequencemanager.nodefiletype
</span><span class="noop">                else:
</span><span class="miss">                    return pub.sequencemanager.outputfiletype
</span><span class="noop">
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence %s of element %s the type &#39;
</span><span class="noop">                                   &#39;of the external data file cannot be &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % (self.name,
</span><span class="noop">                                      objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def _setfiletype_ext(self, name):
</span><span class="miss">        self._filetype_ext = name
</span><span class="noop">
</span><span class="hit">    def _delfiletype_ext(self, name):
</span><span class="miss">        self._filetype_ext = None
</span><span class="noop">
</span><span class="hit">    filetype_ext = property(_getfiletype_ext, _setfiletype_ext,
</span><span class="noop">                            _delfiletype_ext)
</span><span class="noop">
</span><span class="hit">    def _getfilename_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Complete filename of the external data file.&#34;&#34;&#34;
</span><span class="miss">        if self._filename_ext:
</span><span class="miss">            return self._filename_ext
</span><span class="noop">        else:
</span><span class="miss">            return &#39;.&#39;.join((self.rawfilename, self.filetype_ext))
</span><span class="noop">
</span><span class="hit">    def _setfilename_ext(self, name):
</span><span class="miss">        self._filename_ext = name
</span><span class="noop">
</span><span class="hit">    def _delfilename_ext(self):
</span><span class="miss">        self._filename_ext = None
</span><span class="noop">
</span><span class="hit">    filename_ext = property(_getfilename_ext, _setfilename_ext,
</span><span class="noop">                            _delfilename_ext)
</span><span class="noop">
</span><span class="hit">    def _getfilename_int(self):
</span><span class="noop">        &#34;&#34;&#34;Complete filename of the internal data file.&#34;&#34;&#34;
</span><span class="miss">        return self.rawfilename + &#39;.bin&#39;
</span><span class="noop">
</span><span class="hit">    filename_int = property(_getfilename_int)
</span><span class="noop">
</span><span class="hit">    def _getdirpath_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the directory of the external data file.&#34;&#34;&#34;
</span><span class="miss">        if self._dirpath_ext:
</span><span class="miss">            return self._dirpath_ext
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                if isinstance(self, InputSequence):
</span><span class="miss">                    return pub.sequencemanager.inputpath
</span><span class="miss">                elif isinstance(self, NodeSequence):
</span><span class="miss">                    return pub.sequencemanager.nodepath
</span><span class="noop">                else:
</span><span class="miss">                    return pub.sequencemanager.outputpath
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence `%s` the directory of &#39;
</span><span class="noop">                                   &#39;the external data file cannot be &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % self.name)
</span><span class="noop">
</span><span class="hit">    def _setdirpath_ext(self, name):
</span><span class="miss">        self._dirpath_ext = name
</span><span class="noop">
</span><span class="hit">    def _deldirpath_ext(self, name):
</span><span class="miss">        self._dirpath_ext = None
</span><span class="noop">
</span><span class="hit">    dirpath_ext = property(_getdirpath_ext, _setdirpath_ext, _deldirpath_ext)
</span><span class="noop">
</span><span class="hit">    def _getdirpath_int(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the directory of the internal data file.&#34;&#34;&#34;
</span><span class="miss">        if self._dirpath_int:
</span><span class="miss">            return self._dirpath_int
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return pub.sequencemanager.temppath
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence `%s` the directory of &#39;
</span><span class="noop">                                   &#39;the internal data file cannot be &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % self.name)
</span><span class="noop">
</span><span class="hit">    def _setdirpath_int(self, name):
</span><span class="miss">        self._dirpath_int = name
</span><span class="noop">
</span><span class="hit">    def _deldirpath_int(self, name):
</span><span class="miss">        self._dirpath_int = None
</span><span class="hit">    dirpath_int = property(_getdirpath_int, _setdirpath_int, _deldirpath_int)
</span><span class="noop">
</span><span class="hit">    def _getfilepath_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path to the external data file.&#34;&#34;&#34;
</span><span class="miss">        if self._filepath_ext:
</span><span class="miss">            return self._filepath_ext
</span><span class="noop">        else:
</span><span class="miss">            return os.path.join(self.dirpath_ext, self.filename_ext)
</span><span class="noop">
</span><span class="hit">    def _setfilepath_ext(self, name):
</span><span class="miss">        self._filepath_ext = name
</span><span class="noop">
</span><span class="hit">    def _delfilepath_ext(self):
</span><span class="miss">        self._filepath_ext = None
</span><span class="hit">    filepath_ext = property(_getfilepath_ext, _setfilepath_ext,
</span><span class="noop">                            _delfilepath_ext)
</span><span class="noop">
</span><span class="hit">    def _getfilepath_int(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path to the internal data file.&#34;&#34;&#34;
</span><span class="miss">        if self._filepath_int:
</span><span class="miss">            return self._filepath_int
</span><span class="noop">        else:
</span><span class="miss">            return os.path.join(self.dirpath_int, self.filename_int)
</span><span class="noop">
</span><span class="hit">    def _setfilepath_int(self, name):
</span><span class="miss">        self._filepath_int = name
</span><span class="noop">
</span><span class="hit">    def _delfilepath_int(self):
</span><span class="miss">        self._filepath_int = None
</span><span class="noop">
</span><span class="hit">    filepath_int = property(_getfilepath_int, _setfilepath_int,
</span><span class="noop">                            _delfilepath_int)
</span><span class="noop">
</span><span class="hit">    def update_fastaccess(self):
</span><span class="noop">        &#34;&#34;&#34;&#34;&#34;&#34;
</span><span class="hit">        if self.diskflag:
</span><span class="miss">            path = self.filepath_int
</span><span class="noop">        else:
</span><span class="hit">            path = None
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_path&#39; % self.name, path)
</span><span class="hit">        length = 1
</span><span class="hit">        for idx in range(self.NDIM):
</span><span class="hit">            length *= self.shape[idx]
</span><span class="hit">            setattr(self.fastaccess, &#39;_%s_length_%d&#39; % (self.name, idx),
</span><span class="noop">                    self.shape[idx])
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_length&#39; % self.name, length)
</span><span class="noop">
</span><span class="hit">    def _getdiskflag(self):
</span><span class="hit">        diskflag = getattr(self.fastaccess, &#39;_%s_diskflag&#39; % self.name, None)
</span><span class="hit">        if diskflag is not None:
</span><span class="hit">            return diskflag
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;The `diskflag` of sequence `%s` has &#39;
</span><span class="noop">                               &#39;not been set yet.&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    def _setdiskflag(self, value):
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_diskflag&#39; % self.name,  bool(value))
</span><span class="noop">
</span><span class="hit">    diskflag = property(_getdiskflag, _setdiskflag)
</span><span class="noop">
</span><span class="hit">    def _getramflag(self):
</span><span class="hit">        ramflag = getattr(self.fastaccess, &#39;_%s_ramflag&#39; % self.name, None)
</span><span class="hit">        if ramflag is not None:
</span><span class="hit">            return ramflag
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;The `ramflag` of sequence `%s` has &#39;
</span><span class="noop">                               &#39;not been set yet.&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    def _setramflag(self, value):
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_ramflag&#39; % self.name,  bool(value))
</span><span class="noop">
</span><span class="hit">    ramflag = property(_getramflag, _setramflag)
</span><span class="noop">
</span><span class="hit">    def _getmemoryflag(self):
</span><span class="miss">        return self.ramflag or self.diskflag
</span><span class="noop">
</span><span class="hit">    memoryflag = property(_getmemoryflag)
</span><span class="noop">
</span><span class="hit">    def _getarray(self):
</span><span class="hit">        array = getattr(self.fastaccess, &#39;_%s_array&#39; % self.name, None)
</span><span class="hit">        if array is not None:
</span><span class="hit">            return numpy.asarray(array)
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;The `ram array` of sequence `%s` has &#39;
</span><span class="noop">                               &#39;not been set yet.&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    def _setarray(self, values):
</span><span class="hit">        values = numpy.array(values, dtype=float)
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_array&#39; % self.name,  values)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def seriesshape(self):
</span><span class="noop">        &#34;&#34;&#34;Shape of the whole time series (time beeing the first dimension).&#34;&#34;&#34;
</span><span class="hit">        seriesshape = [len(pub.timegrids.init)]
</span><span class="hit">        seriesshape.extend(self.shape)
</span><span class="hit">        return tuple(seriesshape)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def numericshape(self):
</span><span class="noop">        &#34;&#34;&#34;Shape of the array of temporary values required for the numerical
</span><span class="noop">        solver actually beeing selected.&#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            numericshape = [self.subseqs.seqs.model.numconsts.nmb_stages]
</span><span class="miss">        except AttributeError:
</span><span class="miss">            objecttools.augmentexcmessage(
</span><span class="noop">                &#39;The `numericshape` of a sequence like `%s` depends on the &#39;
</span><span class="noop">                &#39;configuration of the actual integration algorithm.  &#39;
</span><span class="noop">                &#39;While trying to query the required configuration data &#39;
</span><span class="noop">                &#39;`nmb_stages` of the model associated with element `%s`&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self)))
</span><span class="hit">        numericshape.extend(self.shape)
</span><span class="hit">        return tuple(numericshape)
</span><span class="noop">
</span><span class="hit">    def _getseries(self):
</span><span class="hit">        if self.diskflag:
</span><span class="miss">            return self._load_int()
</span><span class="hit">        elif self.ramflag:
</span><span class="hit">            return self._getarray()
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;Sequence `%s` of device `%s`is not requested &#39;
</span><span class="noop">                &#39;to make any internal data available to the user.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def _setseries(self, values):
</span><span class="hit">        series = self.series
</span><span class="hit">        series[:] = values
</span><span class="hit">        if self.diskflag:
</span><span class="miss">            self._save_int(series)
</span><span class="hit">        elif self.ramflag:
</span><span class="hit">            self._setarray(series)
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;Sequence `%s` is not requested to make any &#39;
</span><span class="noop">                               &#39;internal data available to the user.&#39;
</span><span class="noop">                               % self.name)
</span><span class="noop">
</span><span class="hit">    def _delseries(self):
</span><span class="miss">        if self.diskflag:
</span><span class="miss">            os.remove(self.filepath_int)
</span><span class="miss">        elif self.ramflag:
</span><span class="miss">            setattr(self.fastaccess, &#39;_%s_array&#39; % self.name, None)
</span><span class="noop">
</span><span class="hit">    series = property(_getseries, _setseries, _delseries)
</span><span class="noop">
</span><span class="hit">    def load_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Load the external data series in accordance with
</span><span class="noop">        :attr:`~IOSequence.timegrid_init` and store it as internal data.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if self.filetype_ext == &#39;npy&#39;:
</span><span class="miss">            timegrid_data, values = self._load_npy()
</span><span class="noop">        else:
</span><span class="miss">            timegrid_data, values = self._load_asc()
</span><span class="miss">        if self.shape != values.shape[1:]:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;The shape of sequence `%s` of element `%s` is `%s`, but &#39;
</span><span class="noop">                &#39;according to the external data file `%s` it should be `%s`.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self), self.shape,
</span><span class="noop">                   self.filepath_ext, values.shape[1:]))
</span><span class="miss">        if pub.timegrids.init.stepsize != timegrid_data.stepsize:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;According to external data file `%s`, the date time step &#39;
</span><span class="noop">                &#39;of sequence `%s` of element `%s` is `%s`, but the actual &#39;
</span><span class="noop">                &#39;simulation time step is `%s`.&#39;
</span><span class="noop">                % (self.filepath_ext, self.name, objecttools.devicename(self),
</span><span class="noop">                   timegrid_data.stepsize, pub.timegrids.init.stepsize))
</span><span class="miss">        elif pub.timegrids.init not in timegrid_data:
</span><span class="miss">            if pub.options.checkseries:
</span><span class="miss">                raise RuntimeError(
</span><span class="noop">                    &#39;For sequence `%s` of element `%s` the initialization &#39;
</span><span class="noop">                    &#39;time grid (%s) does not define a subset of the time &#39;
</span><span class="noop">                    &#39;grid of the external data file %s (%s).&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self),
</span><span class="noop">                       pub.timegrids.init, self.filepath_ext, timegrid_data))
</span><span class="noop">            else:
</span><span class="miss">                values = self.adjust_short_series(timegrid_data, values)
</span><span class="noop">        else:
</span><span class="miss">            idx1 = timegrid_data[pub.timegrids.init.firstdate]
</span><span class="miss">            idx2 = timegrid_data[pub.timegrids.init.lastdate]
</span><span class="miss">            values = values[idx1:idx2]
</span><span class="miss">        if self.diskflag:
</span><span class="miss">            self._save_int(values)
</span><span class="miss">        elif self.ramflag:
</span><span class="miss">            self._setarray(values)
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;Sequence `%s` of element `%s`is not requested to make &#39;
</span><span class="noop">                &#39;any internal data available the the user.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def adjust_short_series(self, timegrid, values):
</span><span class="noop">        &#34;&#34;&#34;Adjust a short time series to a longer timegrid.
</span><span class="noop">
</span><span class="noop">        Normally, time series data to be read from a external data files
</span><span class="noop">        should span (at least) the whole initialization time period of a
</span><span class="noop">        HydPy project.  However, for some variables which are only used
</span><span class="noop">        for comparison (e.g. observed runoff used for calibration),
</span><span class="noop">        incomplete time series might also be helpful.  This method it
</span><span class="noop">        thought for adjusting such incomplete series to the public
</span><span class="noop">        initialization time grid stored in module :mod:`~hydpy.pub`.
</span><span class="noop">        It is automatically called in method
</span><span class="noop">        :func:`~hydpy.core.sequencetools.load_ext` if necessary provided
</span><span class="noop">        that the option
</span><span class="noop">        :attr:`~hydpy.core.objecttools.Options.checkseries` is disabled.
</span><span class="noop">
</span><span class="noop">        Assume the initialization time period of a HydPy project spans
</span><span class="noop">        five day:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub, Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2000.01.10&#39;,
</span><span class="noop">        ...                                    &#39;2000.01.15&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">        Prepare a node series object for observational data:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.sequencetools import Obs
</span><span class="noop">        &gt;&gt;&gt; obs = Obs()
</span><span class="noop">
</span><span class="noop">        Prepare a test function that expects the timegrid of the
</span><span class="noop">        data and the data itself, which returns the ajdusted array by
</span><span class="noop">        means of calling method :func:`adjust_short_series`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; import numpy
</span><span class="noop">        &gt;&gt;&gt; def test(timegrid):
</span><span class="noop">        ...     values = numpy.ones(len(timegrid))
</span><span class="noop">        ...     return obs.adjust_short_series(timegrid, values)
</span><span class="noop">
</span><span class="noop">        The following calls to the test function shows the arrays
</span><span class="noop">        returned for different kinds misalignments:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(Timegrid(&#39;2000.01.05&#39;, &#39;2000.01.20&#39;, &#39;1d&#39;))
</span><span class="noop">        array([ 1.,  1.,  1.,  1.,  1.])
</span><span class="noop">        &gt;&gt;&gt; test(Timegrid(&#39;2000.01.12&#39;, &#39;2000.01.15&#39;, &#39;1d&#39;))
</span><span class="noop">        array([ nan,  nan,   1.,   1.,   1.])
</span><span class="noop">        &gt;&gt;&gt; test(Timegrid(&#39;2000.01.12&#39;, &#39;2000.01.17&#39;, &#39;1d&#39;))
</span><span class="noop">        array([ nan,  nan,   1.,   1.,   1.])
</span><span class="noop">        &gt;&gt;&gt; test(Timegrid(&#39;2000.01.10&#39;, &#39;2000.01.13&#39;, &#39;1d&#39;))
</span><span class="noop">        array([  1.,   1.,   1.,  nan,  nan])
</span><span class="noop">        &gt;&gt;&gt; test(Timegrid(&#39;2000.01.08&#39;, &#39;2000.01.13&#39;, &#39;1d&#39;))
</span><span class="noop">        array([  1.,   1.,   1.,  nan,  nan])
</span><span class="noop">        &gt;&gt;&gt; test(Timegrid(&#39;2000.01.12&#39;, &#39;2000.01.13&#39;, &#39;1d&#39;))
</span><span class="noop">        array([ nan,  nan,   1.,  nan,  nan])
</span><span class="noop">        &gt;&gt;&gt; test(Timegrid(&#39;2000.01.05&#39;, &#39;2000.01.10&#39;, &#39;1d&#39;))
</span><span class="noop">        array([ nan,  nan,  nan,  nan,  nan])
</span><span class="noop">        &gt;&gt;&gt; test(Timegrid(&#39;2000.01.05&#39;, &#39;2000.01.08&#39;, &#39;1d&#39;))
</span><span class="noop">        array([ nan,  nan,  nan,  nan,  nan])
</span><span class="noop">        &gt;&gt;&gt; test(Timegrid(&#39;2000.01.15&#39;, &#39;2000.01.18&#39;, &#39;1d&#39;))
</span><span class="noop">        array([ nan,  nan,  nan,  nan,  nan])
</span><span class="noop">        &gt;&gt;&gt; test(Timegrid(&#39;2000.01.16&#39;, &#39;2000.01.18&#39;, &#39;1d&#39;))
</span><span class="noop">        array([ nan,  nan,  nan,  nan,  nan])
</span><span class="noop">
</span><span class="noop">        Through enabling option
</span><span class="noop">        :attr:`~hydpy.core.objecttools.Options.usedefaultvalues` the missing
</span><span class="noop">        values are initialized with zero instead of nan:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; pub.options.usedefaultvalues = True
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(Timegrid(&#39;2000.01.12&#39;, &#39;2000.01.17&#39;, &#39;1d&#39;))
</span><span class="noop">        array([ 0.,  0.,  1.,  1.,  1.])
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; pub.options.usedefaultvalues = False
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        idxs = [timegrid[pub.timegrids.init.firstdate],
</span><span class="noop">                timegrid[pub.timegrids.init.lastdate]]
</span><span class="hit">        valcopy = values
</span><span class="hit">        values = numpy.full(self.seriesshape, self.initvalue)
</span><span class="hit">        len_ = len(valcopy)
</span><span class="hit">        jdxs = []
</span><span class="hit">        for idx in idxs:
</span><span class="hit">            if idx &lt; 0:
</span><span class="hit">                jdxs.append(0)
</span><span class="hit">            elif idx &lt;= len_:
</span><span class="hit">                jdxs.append(idx)
</span><span class="noop">            else:
</span><span class="hit">                jdxs.append(len_)
</span><span class="hit">        valcopy = valcopy[jdxs[0]:jdxs[1]]
</span><span class="hit">        zdx1 = max(-idxs[0], 0)
</span><span class="hit">        zdx2 = zdx1+jdxs[1]-jdxs[0]
</span><span class="hit">        values[zdx1:zdx2] = valcopy
</span><span class="hit">        return values
</span><span class="noop">
</span><span class="hit">    def save_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Write the internal data into an external data file.&#34;&#34;&#34;
</span><span class="miss">        if self.filetype_ext == &#39;npy&#39;:
</span><span class="miss">            series = pub.timegrids.init.array2series(self.series)
</span><span class="miss">            numpy.save(self.filepath_ext, series)
</span><span class="noop">        else:
</span><span class="miss">            with open(self.filepath_ext, &#39;w&#39;) as file_:
</span><span class="miss">                file_.write(repr(pub.timegrids.init) + &#39;\n&#39;)
</span><span class="miss">                numpy.savetxt(file_, self.series, delimiter=&#39;\t&#39;)
</span><span class="noop">
</span><span class="hit">    def _load_npy(self):
</span><span class="noop">        &#34;&#34;&#34;Return the data timegrid and the complete external data from a
</span><span class="noop">        binary numpy file.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        try:
</span><span class="miss">            data = numpy.load(self.filepath_ext)
</span><span class="miss">        except BaseException:
</span><span class="miss">            prefix = (&#39;While trying to load the external data of sequence &#39;
</span><span class="noop">                      &#39;`%s` from file `%s`&#39; % (self.name, self.filepath_ext))
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span><span class="miss">        try:
</span><span class="miss">            timegrid_data = timetools.Timegrid.fromarray(data)
</span><span class="miss">        except BaseException:
</span><span class="miss">            prefix = (&#39;While trying to retrieve the data timegrid of the &#39;
</span><span class="noop">                      &#39;external data file `%s` of sequence `%s`&#39;
</span><span class="noop">                      % (self.filepath_ext, self.name))
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span><span class="miss">        return timegrid_data, data[13:]
</span><span class="noop">
</span><span class="hit">    def _load_asc(self):
</span><span class="miss">        with open(self.filepath_ext) as file_:
</span><span class="miss">            header = &#39;\n&#39;.join([file_.readline() for idx in range(3)])
</span><span class="miss">        timegrid_data = eval(header, {}, {&#39;Timegrid&#39;: timetools.Timegrid})
</span><span class="miss">        values = numpy.loadtxt(self.filepath_ext, skiprows=3,
</span><span class="noop">                               ndmin=self.NDIM+1)
</span><span class="miss">        return timegrid_data, values
</span><span class="noop">
</span><span class="hit">    def _load_int(self):
</span><span class="noop">        &#34;&#34;&#34;Load internal data from file and return it.&#34;&#34;&#34;
</span><span class="miss">        values = numpy.fromfile(self.filepath_int)
</span><span class="miss">        if self.NDIM &gt; 0:
</span><span class="miss">            values = values.reshape(self.seriesshape)
</span><span class="miss">        return values
</span><span class="noop">
</span><span class="hit">    def zero_int(self):
</span><span class="noop">        &#34;&#34;&#34;Initialize the internal data series with zero values.&#34;&#34;&#34;
</span><span class="hit">        values = numpy.zeros(self.seriesshape)
</span><span class="hit">        if self.diskflag:
</span><span class="miss">            self._save_int(values)
</span><span class="hit">        elif self.ramflag:
</span><span class="hit">            self._setarray(values)
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;Sequence `%s` is not requested to make any &#39;
</span><span class="noop">                               &#39;internal data available to the user.&#39;
</span><span class="noop">                               % self.name)
</span><span class="noop">
</span><span class="hit">    def _save_int(self, values):
</span><span class="miss">        values.tofile(self.filepath_int)
</span><span class="noop">
</span><span class="hit">    def activate_disk(self):
</span><span class="noop">        &#34;&#34;&#34;Demand reading/writing internal data from/to hard disk.&#34;&#34;&#34;
</span><span class="miss">        self.deactivate_ram()
</span><span class="miss">        self.diskflag = True
</span><span class="miss">        if (isinstance(self, InputSequence) or
</span><span class="noop">           (isinstance(self, NodeSequence) and self.use_ext)):
</span><span class="miss">            self.load_ext()
</span><span class="noop">        else:
</span><span class="miss">            self.zero_int()
</span><span class="miss">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    def deactivate_disk(self):
</span><span class="noop">        &#34;&#34;&#34;Prevent from reading/writing internal data from/to hard disk.&#34;&#34;&#34;
</span><span class="hit">        if self.diskflag:
</span><span class="miss">            del self.series
</span><span class="miss">            self.diskflag = False
</span><span class="noop">
</span><span class="hit">    def activate_ram(self):
</span><span class="noop">        &#34;&#34;&#34;Demand reading/writing internal data from/to hard disk.&#34;&#34;&#34;
</span><span class="hit">        self.deactivate_disk()
</span><span class="hit">        self.ramflag = True
</span><span class="hit">        if (isinstance(self, InputSequence) or
</span><span class="noop">                (isinstance(self, NodeSequence) and self.use_ext)):
</span><span class="miss">            self.load_ext()
</span><span class="noop">        else:
</span><span class="hit">            self.zero_int()
</span><span class="hit">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    def deactivate_ram(self):
</span><span class="noop">        &#34;&#34;&#34;Prevent from reading/writing internal data from/to hard disk.&#34;&#34;&#34;
</span><span class="miss">        if self.ramflag:
</span><span class="miss">            del self.series
</span><span class="miss">            self.ramflag = False
</span><span class="noop">
</span><span class="hit">    def disk2ram(self):
</span><span class="noop">        &#34;&#34;&#34;Move internal data from disk to RAM.&#34;&#34;&#34;
</span><span class="miss">        values = self.series
</span><span class="miss">        self.deactivate_disk()
</span><span class="miss">        self.ramflag = True
</span><span class="miss">        self._setarray(values)
</span><span class="miss">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    def ram2disk(self):
</span><span class="noop">        &#34;&#34;&#34;Move internal data from RAM to disk.&#34;&#34;&#34;
</span><span class="miss">        values = self.series
</span><span class="miss">        self.deactivate_ram()
</span><span class="miss">        self.diskflag = True
</span><span class="miss">        self._save_int(values)
</span><span class="miss">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        Sequence._setshape(self, shape)
</span><span class="hit">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    shape = property(Sequence._getshape, _setshape)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ModelIOSequence(IOSequence):
</span><span class="noop">
</span><span class="hit">    def _getrawfilename(self):
</span><span class="noop">        &#34;&#34;&#34;Filename without ending for external and internal date files.&#34;&#34;&#34;
</span><span class="miss">        if self._rawfilename:
</span><span class="miss">            return self._rawfilename
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return &#39;%s_%s_%s&#39; % (
</span><span class="noop">                       self.subseqs.seqs.model.element.name,
</span><span class="noop">                       objecttools.classname(self.subseqs)[:-9].lower(),
</span><span class="noop">                       self.name)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence `%s` the raw filename cannot &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % self.name)
</span><span class="noop">
</span><span class="hit">    def _setrawfilename(self, name):
</span><span class="miss">        self._rawfilename = str(name)
</span><span class="noop">
</span><span class="hit">    def _delrawfilename(self):
</span><span class="miss">        self._rawfilename = None
</span><span class="noop">
</span><span class="hit">    rawfilename = property(_getrawfilename, _setrawfilename, _delrawfilename)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequence(ModelIOSequence):
</span><span class="noop">    &#34;&#34;&#34; &#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequence(ModelIOSequence):
</span><span class="noop">    &#34;&#34;&#34; &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def _initvalues(self):
</span><span class="hit">        super(FluxSequence, self)._initvalues()
</span><span class="hit">        if self.NUMERIC:
</span><span class="hit">            value = None if self.NDIM else numpy.zeros(self.numericshape)
</span><span class="hit">            self._connect_subattr(&#39;points&#39;, value)
</span><span class="hit">            self._connect_subattr(&#39;integrals&#39;, copy.copy(value))
</span><span class="hit">            self._connect_subattr(&#39;results&#39;, copy.copy(value))
</span><span class="hit">            value = None if self.NDIM else 0.
</span><span class="hit">            self._connect_subattr(&#39;sum&#39;, value)
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        super(FluxSequence, self)._setshape(shape)
</span><span class="hit">        if self.NDIM and self.NUMERIC:
</span><span class="miss">            self._connect_subattr(&#39;points&#39;, numpy.zeros(self.numericshape))
</span><span class="miss">            self._connect_subattr(&#39;integrals&#39;, numpy.zeros(self.numericshape))
</span><span class="miss">            self._connect_subattr(&#39;results&#39;, numpy.zeros(self.numericshape))
</span><span class="miss">            self._connect_subattr(&#39;sum&#39;, numpy.zeros(self.shape))
</span><span class="noop">
</span><span class="hit">    shape = property(ModelIOSequence._getshape, _setshape)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LeftRightSequence(ModelIOSequence):
</span><span class="hit">    NDIM = 1
</span><span class="noop">
</span><span class="hit">    def _initvalues(self):
</span><span class="hit">        setattr(self.fastaccess, self.name,
</span><span class="noop">                numpy.full(2, self.initvalue, dtype=float))
</span><span class="noop">
</span><span class="hit">    def _getleft(self):
</span><span class="noop">        &#34;&#34;&#34;The &#34;left&#34; value of the actual parameter.&#34;&#34;&#34;
</span><span class="miss">        return self.values[0]
</span><span class="noop">
</span><span class="hit">    def _setleft(self, value):
</span><span class="miss">        self.values[0] = value
</span><span class="noop">
</span><span class="hit">    left = property(_getleft, _setleft)
</span><span class="hit">    l = left
</span><span class="noop">
</span><span class="hit">    def _getright(self):
</span><span class="noop">        &#34;&#34;&#34;The &#34;right&#34; value of the actual parameter.&#34;&#34;&#34;
</span><span class="miss">        return self.values[1]
</span><span class="noop">
</span><span class="hit">    def _setright(self, value):
</span><span class="miss">        self.values[1] = value
</span><span class="noop">
</span><span class="hit">    right = property(_getright, _setright)
</span><span class="hit">    r = right
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ConditionSequence(object):
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="hit">        self.values = args
</span><span class="hit">        self.trim()
</span><span class="hit">        self._oldargs = copy.deepcopy(args)
</span><span class="noop">
</span><span class="hit">    trim = objecttools.trim
</span><span class="noop">
</span><span class="hit">    def warntrim(self):
</span><span class="miss">        warnings.warn(&#39;For sequence %s of element %s at least one value &#39;
</span><span class="noop">                      &#39;needed to be trimmed.  One possible reason could be &#39;
</span><span class="noop">                      &#39;that the related control parameter and initial &#39;
</span><span class="noop">                      &#39;condition files are inconsistent.&#39;
</span><span class="noop">                      % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def reset(self):
</span><span class="miss">        if self._oldargs:
</span><span class="miss">            self(*self._oldargs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequence(ModelIOSequence, ConditionSequence):
</span><span class="noop">    &#34;&#34;&#34;Handler for state time series.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        ModelIOSequence.__init__(self)
</span><span class="hit">        self.fastaccess_old = None
</span><span class="hit">        self.fastaccess_new = None
</span><span class="hit">        self._oldargs = None
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Sequence` instances
</span><span class="noop">        within initial condition files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        ConditionSequence.__call__(self, *args)
</span><span class="hit">        self.new2old()
</span><span class="noop">
</span><span class="hit">    def connect(self, subseqs):
</span><span class="hit">        ModelIOSequence.connect(self, subseqs)
</span><span class="hit">        self.fastaccess_old = subseqs.fastaccess_old
</span><span class="hit">        self.fastaccess_new = subseqs.fastaccess_new
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            setattr(self.fastaccess_old, self.name, None)
</span><span class="noop">        else:
</span><span class="hit">            setattr(self.fastaccess_old, self.name, 0.)
</span><span class="noop">
</span><span class="hit">    def _initvalues(self):
</span><span class="hit">        super(StateSequence, self)._initvalues()
</span><span class="hit">        if self.NUMERIC:
</span><span class="hit">            value = None if self.NDIM else numpy.zeros(self.numericshape)
</span><span class="hit">            self._connect_subattr(&#39;points&#39;, value)
</span><span class="hit">            self._connect_subattr(&#39;results&#39;, copy.copy(value))
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        super(StateSequence, self)._setshape(shape)
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            setattr(self.fastaccess_old, self.name, self.new.copy())
</span><span class="hit">            if self.NUMERIC:
</span><span class="miss">                self._connect_subattr(&#39;points&#39;,
</span><span class="noop">                                      numpy.zeros(self.numericshape))
</span><span class="miss">                self._connect_subattr(&#39;results&#39;,
</span><span class="noop">                                      numpy.zeros(self.numericshape))
</span><span class="noop">
</span><span class="hit">    shape = property(ModelIOSequence._getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    new = Sequence.values
</span><span class="noop">    &#34;&#34;&#34;Complete access to the state value(s), which will be used in the next
</span><span class="noop">    calculation steps.  Note that :attr:`~StateSequence.new` is a synonym of
</span><span class="noop">    :attr:`~StateSequence.value`.  Use this property to modify the initial
</span><span class="noop">    condition(s) of a single :class:`StateSequence` object.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def _getold(self):
</span><span class="noop">        &#34;&#34;&#34;Assess to the state value(s) at beginning of the time step, which
</span><span class="noop">        has been processed most recently.  When using :ref:`HydPy` in the
</span><span class="noop">        normal manner.  But it can be helpful for demonstration and debugging
</span><span class="noop">        purposes.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        value = getattr(self.fastaccess_old, self.name, None)
</span><span class="hit">        if value is None:
</span><span class="miss">            raise RuntimeError(&#39;No value/values of sequence `%s` has/have &#39;
</span><span class="noop">                               &#39;not been defined so far.&#39; % self.name)
</span><span class="noop">        else:
</span><span class="hit">            if self.NDIM:
</span><span class="hit">                value = numpy.asarray(value)
</span><span class="hit">            return value
</span><span class="noop">
</span><span class="hit">    def _setold(self, value):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            try:
</span><span class="hit">                temp = value[0]
</span><span class="miss">                if len(value) &gt; 1:
</span><span class="miss">                    raise ValueError(&#39;%d values are assigned to the scalar &#39;
</span><span class="noop">                                     &#39;sequence `%s`, which is ambiguous.&#39;
</span><span class="noop">                                     % (len(value)), self.name)
</span><span class="miss">                value = temp
</span><span class="hit">            except (TypeError, IndexError):
</span><span class="hit">                pass
</span><span class="hit">            try:
</span><span class="hit">                value = float(value)
</span><span class="miss">            except (ValueError, TypeError):
</span><span class="miss">                raise TypeError(&#39;When trying to set the value of sequence &#39;
</span><span class="noop">                                &#39;`%s`, it was not possible to convert `%s` &#39;
</span><span class="noop">                                &#39;to float .&#39; % (self.name, value))
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                value = value.value
</span><span class="hit">            except AttributeError:
</span><span class="hit">                pass
</span><span class="hit">            try:
</span><span class="hit">                value = numpy.full(self.shape, value, dtype=float)
</span><span class="miss">            except ValueError:
</span><span class="miss">                raise ValueError(&#39;The values `%s` cannot be converted to a &#39;
</span><span class="noop">                                 &#39;numpy ndarray with shape %s containing &#39;
</span><span class="noop">                                 &#39;entries of type float.&#39;
</span><span class="noop">                                 % (value, self.shape))
</span><span class="hit">        setattr(self.fastaccess_old, self.name, value)
</span><span class="noop">
</span><span class="hit">    old = property(_getold, _setold)
</span><span class="noop">
</span><span class="hit">    def new2old(self):
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            self.old[:] = self.new[:]
</span><span class="noop">        else:
</span><span class="hit">            self.old = self.new
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequence(Sequence, ConditionSequence):
</span><span class="noop">    &#34;&#34;&#34; &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        Sequence.__init__(self)
</span><span class="hit">        self._oldargs = None
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="hit">        self.values = args
</span><span class="hit">        self.trim()
</span><span class="hit">        self._oldargs = copy.deepcopy(args)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequence(Sequence):
</span><span class="noop">    &#34;&#34;&#34; &#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LinkSequence(Sequence):
</span><span class="noop">    &#34;&#34;&#34;2&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def setpointer(self, double, idx=0):
</span><span class="hit">        pdouble = pointerutils.PDouble(double)
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            try:
</span><span class="hit">                self.fastaccess.setpointer0d(self.name, pdouble)
</span><span class="hit">            except AttributeError:
</span><span class="hit">                setattr(self.fastaccess, self.name, pdouble)
</span><span class="hit">        elif self.NDIM == 1:
</span><span class="hit">            try:
</span><span class="hit">                self.fastaccess.setpointer1d(self.name, pdouble, idx)
</span><span class="hit">            except AttributeError:
</span><span class="hit">                ppdouble = getattr(self.fastaccess, self.name)
</span><span class="hit">                ppdouble.setpointer(double, idx)
</span><span class="noop">
</span><span class="hit">    def _initvalues(self):
</span><span class="hit">        value = pointerutils.PPDouble() if self.NDIM else None
</span><span class="hit">        try:
</span><span class="hit">            setattr(self.fastaccess, self.name, value)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            pass
</span><span class="noop">
</span><span class="hit">    def _getvalue(self):
</span><span class="noop">        &#34;&#34;&#34;ToDo&#34;&#34;&#34;
</span><span class="miss">        raise NotImplementedError(&#39;To retrieve a pointer is very likely to &#39;
</span><span class="noop">                                  &#39;result in bugs and is thus not supported &#39;
</span><span class="noop">                                  &#39;at the moment.&#39;)
</span><span class="noop">
</span><span class="hit">    def _setvalue(self, value):
</span><span class="noop">        &#34;&#34;&#34;Could be implemented, but is not important at the moment...&#34;&#34;&#34;
</span><span class="miss">        raise NotImplementedError(&#39;To change a pointer is very likely to &#39;
</span><span class="noop">                                  &#39;result in bugs and is thus not supported &#39;
</span><span class="noop">                                  &#39;at the moment.&#39;)
</span><span class="noop">
</span><span class="hit">    value = property(_getvalue, _setvalue)
</span><span class="hit">    values = value
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="miss">            return ()
</span><span class="hit">        elif self.NDIM == 1:
</span><span class="hit">            try:
</span><span class="hit">                return getattr(self.fastaccess, self.name).shape
</span><span class="miss">            except AttributeError:
</span><span class="miss">                return (getattr(self.fastaccess, &#39;_%s_length_0&#39; % self.name), )
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        if self.NDIM == 1:
</span><span class="hit">            try:
</span><span class="hit">                getattr(self.fastaccess, self.name).shape = shape
</span><span class="hit">            except AttributeError:
</span><span class="miss">                self.fastaccess.dealloc()
</span><span class="miss">                self.fastaccess.alloc(self.name, shape)
</span><span class="hit">            setattr(self.fastaccess, &#39;len_&#39;+self.name, self.shape[0])
</span><span class="noop">
</span><span class="hit">    shape = property(_getshape, _setshape)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NodeSequence(IOSequence):
</span><span class="noop">
</span><span class="hit">    def _getrawfilename(self):
</span><span class="noop">        &#34;&#34;&#34;Filename without ending for external and internal date files.&#34;&#34;&#34;
</span><span class="miss">        if self._rawfilename:
</span><span class="miss">            return self._rawfilename
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return &#39;%s_%s_%s&#39; % (
</span><span class="noop">                       self.subseqs.node.name,
</span><span class="noop">                       self.name,
</span><span class="noop">                       self.subseqs.node.variable.lower())
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence `%s` the raw filename cannot &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % self.name)
</span><span class="noop">
</span><span class="hit">    def _setrawfilename(self, name):
</span><span class="miss">        self._rawfilename = str(name)
</span><span class="noop">
</span><span class="hit">    def _delrawfilename(self):
</span><span class="miss">        self._rawfilename = None
</span><span class="noop">
</span><span class="hit">    rawfilename = property(_getrawfilename, _setrawfilename, _delrawfilename)
</span><span class="noop">
</span><span class="hit">    def _initvalues(self):
</span><span class="hit">        setattr(self.fastaccess, self.name, pointerutils.Double(0.))
</span><span class="noop">
</span><span class="hit">    def _getvalues(self):
</span><span class="noop">        &#34;&#34;&#34;Actual value(s) handled by the sequence.  For consistency,
</span><span class="noop">        `value` and `values` can always be used interchangeably.&#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return getattr(self.fastaccess, self.name)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            if self.NDIM == 0:
</span><span class="miss">                return self.fastaccess.getpointer0d(self.name)
</span><span class="miss">            elif self.NDIM == 1:
</span><span class="miss">                return self.fastaccess.getpointer1d(self.name)
</span><span class="noop">
</span><span class="hit">    def _setvalues(self, values):
</span><span class="hit">        getattr(self.fastaccess, self.name)[0] = values
</span><span class="noop">
</span><span class="hit">    values = property(_getvalues, _setvalues)
</span><span class="hit">    value = values
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Sim(NodeSequence):
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        NodeSequence.__init__(self)
</span><span class="hit">        self.use_ext = False
</span><span class="noop">
</span><span class="hit">    def activate_disk(self):
</span><span class="miss">        try:
</span><span class="miss">            NodeSequence.activate_disk(self)
</span><span class="miss">        except IOError:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            self.diskflag = False
</span><span class="miss">            if pub.options.warnmissingsimfile:
</span><span class="miss">                warnings.warn(&#39;The option `diskflag` of the simulation &#39;
</span><span class="noop">                              &#39;sequence `%s` had to be set to `False` due &#39;
</span><span class="noop">                              &#39;to the following problem: %s.&#39;
</span><span class="noop">                              % (objecttools.devicename(self), message))
</span><span class="noop">
</span><span class="hit">    def activate_ram(self):
</span><span class="miss">        try:
</span><span class="miss">            NodeSequence.activate_ram(self)
</span><span class="miss">        except IOError:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            self.ramflag = False
</span><span class="miss">            if pub.options.warnmissingsimfile:
</span><span class="miss">                warnings.warn(&#39;The option `ramflag` of the simulation &#39;
</span><span class="noop">                              &#39;sequence `%s` had to be set to `False` due &#39;
</span><span class="noop">                              &#39;to the following problem: %s.&#39;
</span><span class="noop">                              % (objecttools.devicename(self), message))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Obs(NodeSequence):
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        NodeSequence.__init__(self)
</span><span class="hit">        self.use_ext = True
</span><span class="noop">
</span><span class="hit">    def activate_disk(self):
</span><span class="miss">        try:
</span><span class="miss">            NodeSequence.activate_disk(self)
</span><span class="miss">        except IOError:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            self.diskflag = False
</span><span class="miss">            if pub.options.warnmissingobsfile:
</span><span class="miss">                warnings.warn(&#39;The option `diskflag` of the observation &#39;
</span><span class="noop">                              &#39;sequence `%s` had to be set to `False` due &#39;
</span><span class="noop">                              &#39;to the following problem: %s.&#39;
</span><span class="noop">                              % (objecttools.devicename(self), message))
</span><span class="noop">
</span><span class="hit">    def activate_ram(self):
</span><span class="miss">        try:
</span><span class="miss">            NodeSequence.activate_ram(self)
</span><span class="miss">        except IOError:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            self.ramflag = False
</span><span class="miss">            if pub.options.warnmissingobsfile:
</span><span class="miss">                warnings.warn(&#39;The option `ramflag` of the observation &#39;
</span><span class="noop">                              &#39;sequence `%s` had to be set to `False` due &#39;
</span><span class="noop">                              &#39;to the following problem: %s.&#39;
</span><span class="noop">                              % (objecttools.devicename(self), message))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def series_complete(self):
</span><span class="miss">        return self.memoryflag and not numpy.any(numpy.isnan(self.series))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NodeSequences(IOSubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling node sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Sim, Obs)
</span><span class="noop">
</span><span class="hit">    def __init__(self, seqs, cls_fastaccess=None):
</span><span class="hit">        IOSubSequences.__init__(self, seqs, cls_fastaccess)
</span><span class="hit">        self.node = seqs
</span><span class="noop">
</span><span class="hit">    def loaddata(self, idx):
</span><span class="miss">        self.fastaccess.loaddata(idx)
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="miss">        self.fastaccess.savedata(idx)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FastAccess(object):
</span><span class="noop">    &#34;&#34;&#34;Provides fast access to the values of the sequences of a sequence
</span><span class="noop">    subgroup and supports the handling of internal data series during
</span><span class="noop">    simulations.
</span><span class="noop">
</span><span class="noop">    The following details are of relevance for :ref:`HydPy` developers only.
</span><span class="noop">
</span><span class="noop">    :class:`FastAccess` is applied in Python mode only.  In Cython mode,
</span><span class="noop">    specialized and more efficient cdef classes replace it.  For
</span><span class="noop">    compatibility with these cdef classes, :class:`FastAccess` objects
</span><span class="noop">    work with dynamically set instance members.  Suppose there is a
</span><span class="noop">    sequence named `seq1` which is 2-dimensional, then its associated
</span><span class="noop">    attributes are:
</span><span class="noop">
</span><span class="noop">      * seq1 (:class:`~numpy.ndarray`): The actual sequence values.
</span><span class="noop">      * _seq1_ndim (:class:`int`): Number of dimensions.
</span><span class="noop">      * _seq1_length_0 (:class:`int`): Length in the first dimension.
</span><span class="noop">      * _seq1_length_1 (:class:`int`): Length in the second dimension.
</span><span class="noop">      * _seq1_ramflag (:class:`bool`): Handle internal data in RAM?
</span><span class="noop">      * _seq1_diskflag (:class:`bool`): Handle internal data on disk?
</span><span class="noop">      * _seq1_path (:class:`str`): Path of the internal data file.
</span><span class="noop">      * _seq1_file (:class:`file`): Object handling the internal data file.
</span><span class="noop">
</span><span class="noop">    Note that all these dynamical attributes and the following methods are
</span><span class="noop">    initialised, changed or applied by the respective :class:`SubSequences`
</span><span class="noop">    and :class:`Sequence` objects.  Handling them directly is error prone
</span><span class="noop">    and thus not recommended.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def openfiles(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Open all files with an activated disk flag.&#34;&#34;&#34;
</span><span class="hit">        for name in self:
</span><span class="hit">            if getattr(self, &#39;_%s_diskflag&#39; % name):
</span><span class="miss">                path = getattr(self, &#39;_%s_path&#39; % name)
</span><span class="miss">                file_ = open(path, &#39;rb+&#39;)
</span><span class="miss">                ndim = getattr(self, &#39;_%s_ndim&#39; % name)
</span><span class="miss">                position = 8*idx
</span><span class="miss">                for idim in range(ndim):
</span><span class="miss">                    length = getattr(self, &#39;_%s_length_%d&#39; % (name, idim))
</span><span class="miss">                    position *= length
</span><span class="miss">                file_.seek(position)
</span><span class="miss">                setattr(self, &#39;_%s_file&#39; % name, file_)
</span><span class="noop">
</span><span class="hit">    def closefiles(self):
</span><span class="noop">        &#34;&#34;&#34;Close all files with an activated disk flag.&#34;&#34;&#34;
</span><span class="hit">        for name in self:
</span><span class="hit">            if getattr(self, &#39;_%s_diskflag&#39; % name):
</span><span class="miss">                file_ = getattr(self, &#39;_%s_file&#39; % name)
</span><span class="miss">                file_.close()
</span><span class="noop">
</span><span class="hit">    def loaddata(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Load the internal data of all sequences.  Load from file if the
</span><span class="noop">        corresponding disk flag is activated, otherwise load from RAM.&#34;&#34;&#34;
</span><span class="hit">        for name in self:
</span><span class="hit">            ndim = getattr(self, &#39;_%s_ndim&#39; % name)
</span><span class="hit">            diskflag = getattr(self, &#39;_%s_diskflag&#39; % name)
</span><span class="hit">            ramflag = getattr(self, &#39;_%s_ramflag&#39; % name)
</span><span class="hit">            if diskflag:
</span><span class="miss">                file_ = getattr(self, &#39;_%s_file&#39; % name)
</span><span class="miss">                length_tot = 1
</span><span class="miss">                shape = []
</span><span class="miss">                for idx in range(ndim):
</span><span class="miss">                    length = getattr(self, &#39;_%s_length_%s&#39; % (name, idx))
</span><span class="miss">                    length_tot *= length
</span><span class="miss">                    shape.append(length)
</span><span class="miss">                raw = file_.read(length_tot*8)
</span><span class="miss">                values = struct.unpack(length_tot*&#39;d&#39;, raw)
</span><span class="miss">                if ndim:
</span><span class="miss">                    values = numpy.array(values).reshape(shape)
</span><span class="noop">                else:
</span><span class="miss">                    values = values[0]
</span><span class="hit">            elif ramflag:
</span><span class="hit">                array = getattr(self, &#39;_%s_array&#39; % name)
</span><span class="hit">                values = array[idx]
</span><span class="hit">            if (diskflag or ramflag):
</span><span class="hit">                if ndim == 0:
</span><span class="hit">                    setattr(self, name, values)
</span><span class="noop">                else:
</span><span class="miss">                    getattr(self, name)[:] = values
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Save the internal data of all sequences with an activated flag.
</span><span class="noop">        Write to file if the corresponding disk flag is activated; store
</span><span class="noop">        in working memory if the corresponding ram flag is activated.&#34;&#34;&#34;
</span><span class="hit">        for name in self:
</span><span class="hit">            actual = getattr(self, name)
</span><span class="hit">            diskflag = getattr(self, &#39;_%s_diskflag&#39; % name)
</span><span class="hit">            ramflag = getattr(self, &#39;_%s_ramflag&#39; % name)
</span><span class="hit">            if diskflag:
</span><span class="miss">                file_ = getattr(self, &#39;_%s_file&#39; % name)
</span><span class="miss">                ndim = getattr(self, &#39;_%s_ndim&#39; % name)
</span><span class="miss">                length_tot = 1
</span><span class="miss">                for idx in range(ndim):
</span><span class="miss">                    length = getattr(self, &#39;_%s_length_%s&#39; % (name, idx))
</span><span class="miss">                    length_tot *= length
</span><span class="miss">                if ndim:
</span><span class="miss">                    raw = struct.pack(length_tot*&#39;d&#39;, *actual.flatten())
</span><span class="noop">                else:
</span><span class="miss">                    raw = struct.pack(&#39;d&#39;, actual)
</span><span class="miss">                file_.write(raw)
</span><span class="hit">            elif ramflag:
</span><span class="hit">                array = getattr(self, &#39;_%s_array&#39; % name)
</span><span class="hit">                array[idx] = actual
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="noop">        &#34;&#34;&#34;Iterate over all sequence names.&#34;&#34;&#34;
</span><span class="hit">        for key in vars(self).keys():
</span><span class="hit">            if not key.startswith(&#39;_&#39;):
</span><span class="hit">                yield key
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/testtools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/testtools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements tools for making doctests more legible.&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import datetime
</span><span class="hit">import itertools
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import hydpytools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy.core import selectiontools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Array(object):
</span><span class="noop">    &#34;&#34;&#34;Assures that attributes are :class:`~numpy.ndarray` objects.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, name, value):
</span><span class="hit">        object.__setattr__(self, name,  numpy.array(value))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ArrayDescriptor(object):
</span><span class="noop">    &#34;&#34;&#34;Descriptor for handling values of :class:`Array` objects.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.values = Array()
</span><span class="noop">
</span><span class="hit">    def __set__(self, obj, values):
</span><span class="hit">        self.__delete__(obj)
</span><span class="hit">        if values is not None:
</span><span class="hit">            for (key, value) in values:
</span><span class="hit">                setattr(self.values, key.name, value)
</span><span class="noop">
</span><span class="hit">    def __get__(self, obj, type_=None):
</span><span class="hit">        return self.values
</span><span class="noop">
</span><span class="hit">    def __delete__(self, obj):
</span><span class="hit">        for name in list(vars(self.values).keys()):
</span><span class="hit">            delattr(self.values, name)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for :class:`IntegrationTest` and :class:`UnitTest`.
</span><span class="noop">
</span><span class="noop">    This base class defines the printing of the test results primarily.
</span><span class="noop">    How the tests shall be prepared and performed, is to be defined in
</span><span class="noop">    its subclasses.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    inits = ArrayDescriptor()
</span><span class="noop">    &#34;&#34;&#34;Stores arrays for setting the same values of parameters and/or
</span><span class="noop">    sequences before each new experiment.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nmb_rows(self):
</span><span class="noop">        &#34;&#34;&#34;Number of rows of the table.&#34;&#34;&#34;
</span><span class="hit">        return len(self.raw_first_col_strings)+1
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nmb_cols(self):
</span><span class="noop">        &#34;&#34;&#34;Number of columns of the table.&#34;&#34;&#34;
</span><span class="hit">        nmb = 1
</span><span class="hit">        for parseq in self.parseqs:
</span><span class="hit">            nmb += max(parseq.length, 1)
</span><span class="hit">        return nmb
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def raw_header_strings(self):
</span><span class="noop">        &#34;&#34;&#34;All raw strings for the tables header.&#34;&#34;&#34;
</span><span class="hit">        strings = [self.HEADER_OF_FIRST_COL]
</span><span class="hit">        for parseq in self.parseqs:
</span><span class="hit">            for idx in range(parseq.length-1):
</span><span class="hit">                strings.append(&#39;&#39;)
</span><span class="hit">            if ((parseq.name == &#39;sim&#39;) and
</span><span class="noop">                    isinstance(parseq, sequencetools.Sequence)):
</span><span class="hit">                strings.append(parseq.subseqs.node.name)
</span><span class="noop">            else:
</span><span class="hit">                strings.append(parseq.name)
</span><span class="hit">        return strings
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def raw_body_strings(self):
</span><span class="noop">        &#34;&#34;&#34;All raw strings for the tables body.&#34;&#34;&#34;
</span><span class="hit">        strings = []
</span><span class="hit">        for (idx, first_string) in enumerate(self.raw_first_col_strings):
</span><span class="hit">            strings.append([first_string])
</span><span class="hit">            for parseq in self.parseqs:
</span><span class="hit">                array = self.get_output_array(parseq)
</span><span class="hit">                if parseq.NDIM == 0:
</span><span class="hit">                    strings[-1].append(objecttools.repr_(array[idx]))
</span><span class="hit">                elif parseq.NDIM == 1:
</span><span class="hit">                    if parseq.shape[0] &gt; 0:
</span><span class="hit">                        strings[-1].extend(objecttools.repr_(value)
</span><span class="noop">                                           for value in array[idx])
</span><span class="noop">                    else:
</span><span class="hit">                        strings[-1].append(&#39;empty&#39;)
</span><span class="noop">                else:
</span><span class="miss">                    thing = (&#39;sequence&#39;
</span><span class="noop">                             if isinstance(parseq, sequencetools.Sequence)
</span><span class="noop">                             else &#39;parameter&#39;)
</span><span class="miss">                    raise RuntimeError(
</span><span class="noop">                        &#39;An instance of class `Test` of module `testtools` &#39;
</span><span class="noop">                        &#39;is requested to print the results of %s `%s`. &#39;
</span><span class="noop">                        &#39;Unfortunately, for %d-dimensional sequences this &#39;
</span><span class="noop">                        &#39;feature is not supported yet.&#39;
</span><span class="noop">                        % (thing, parseq.name, parseq.NDIM, parseq.shape))
</span><span class="hit">        return strings
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def raw_strings(self):
</span><span class="noop">        &#34;&#34;&#34;All raw strings for the complete table.&#34;&#34;&#34;
</span><span class="hit">        return [self.raw_header_strings] + self.raw_body_strings
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def col_widths(self):
</span><span class="noop">        &#34;&#34;&#34;The widths of all columns of the table.&#34;&#34;&#34;
</span><span class="hit">        strings = self.raw_strings
</span><span class="hit">        widths = []
</span><span class="hit">        for jdx in range(self.nmb_cols):
</span><span class="hit">            widths.append(0)
</span><span class="hit">            for idx in range(self.nmb_rows):
</span><span class="hit">                widths[-1] = max(len(strings[idx][jdx]), widths[-1])
</span><span class="hit">        return widths
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def col_seperators(self):
</span><span class="noop">        &#34;&#34;&#34;The seperators for adjacent columns.&#34;&#34;&#34;
</span><span class="hit">        seps = [&#39;| &#39;]
</span><span class="hit">        for parseq in self.parseqs:
</span><span class="hit">            seps.append(&#39; | &#39;)
</span><span class="hit">            for idx in range(parseq.length-1):
</span><span class="hit">                seps.append(&#39;  &#39;)
</span><span class="hit">        seps.append(&#39; |&#39;)
</span><span class="hit">        return seps
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def row_nmb_characters(self):
</span><span class="noop">        &#34;&#34;&#34;Number of characters of a single row of the table.&#34;&#34;&#34;
</span><span class="hit">        return (sum(self.col_widths) +
</span><span class="noop">                sum((len(sep) for sep in self.col_seperators)))
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def _interleave(seperators, strings, widths):
</span><span class="noop">        &#34;&#34;&#34;Generate a table line from the given arguments.&#34;&#34;&#34;
</span><span class="hit">        lst = [value for (seperator, string, width)
</span><span class="noop">               in zip(seperators, strings, widths)
</span><span class="noop">               for value in (seperator, string.rjust(width))]
</span><span class="hit">        lst.append(seperators[-1])
</span><span class="hit">        return &#39;&#39;.join(lst)
</span><span class="noop">
</span><span class="hit">    def print_table(self, idx1=None, idx2=None):
</span><span class="noop">        &#34;&#34;&#34;Print the result table between the given indices.&#34;&#34;&#34;
</span><span class="hit">        print(self._interleave(self.col_seperators,
</span><span class="noop">                               self.raw_header_strings,
</span><span class="noop">                               self.col_widths))
</span><span class="hit">        print(&#39;-&#39;*self.row_nmb_characters)
</span><span class="hit">        for strings_in_line in self.raw_body_strings[idx1:idx2]:
</span><span class="hit">            print(self._interleave(self.col_seperators,
</span><span class="noop">                                   strings_in_line,
</span><span class="noop">                                   self.col_widths))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class IntegrationTest(Test):
</span><span class="noop">    &#34;&#34;&#34;Defines model integration doctests.
</span><span class="noop">
</span><span class="noop">    The functionality of :class:`Test` is easiest to understand by inspecting
</span><span class="noop">    doctests like the ones of modules :mod:`~hydpy.models.llake_v1` or
</span><span class="noop">    :mod:`~hydpy.models.arma_v1`.
</span><span class="noop">
</span><span class="noop">    Note that all condition sequences (state and logging sequences) are
</span><span class="noop">    initialized in accordance with the values are given in the `inits`
</span><span class="noop">    values.  The values of the simulation sequences of outlet and
</span><span class="noop">    sender nodes are always set to zero before each test run.  All other
</span><span class="noop">    parameter and sequence values can be changed between different test
</span><span class="noop">    runs.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    HEADER_OF_FIRST_COL = &#39;date&#39;
</span><span class="noop">    &#34;&#34;&#34;The header of the first column containing dates.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _dateformat = None
</span><span class="noop">
</span><span class="hit">    def __init__(self, element, seqs=None, inits=None):
</span><span class="noop">        &#34;&#34;&#34;Prepare the element and its nodes and put them into a HydPy object
</span><span class="noop">        and make their sequences ready for use for integration testing.&#34;&#34;&#34;
</span><span class="hit">        del self.inits
</span><span class="hit">        self.element = element
</span><span class="hit">        self.elements = devicetools.Element.registered_elements()
</span><span class="hit">        self.nodes = devicetools.Node.registered_nodes()
</span><span class="hit">        self.prepare_node_sequences()
</span><span class="hit">        self.prepare_input_model_sequences()
</span><span class="hit">        self.parseqs = seqs if seqs else self.extract_print_sequences()
</span><span class="hit">        self.inits = inits
</span><span class="hit">        self.model = element.model
</span><span class="hit">        hydpytools.HydPy.nmb_instances = 0
</span><span class="hit">        self.hp = hydpytools.HydPy()
</span><span class="hit">        self.hp.updatedevices(selectiontools.Selection(
</span><span class="noop">                                        &#39;test&#39;, self.nodes, self.elements))
</span><span class="noop">
</span><span class="hit">    def __call__(self):
</span><span class="noop">        &#34;&#34;&#34;Prepare and perform an integration test and print its results.&#34;&#34;&#34;
</span><span class="hit">        self.prepare_model()
</span><span class="hit">        self.hp.doit()
</span><span class="hit">        self.print_table()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def raw_first_col_strings(self):
</span><span class="noop">        &#34;&#34;&#34;The raw date strings of the first column, except the header.&#34;&#34;&#34;
</span><span class="hit">        return [date.datetime.strftime(self.dateformat)
</span><span class="noop">                for date in pub.timegrids.sim]
</span><span class="noop">
</span><span class="hit">    def _getdateformat(self):
</span><span class="noop">        &#34;&#34;&#34;Format string for printing dates in the first column of the table.
</span><span class="noop">
</span><span class="noop">        See :mod:`datetime` for the format strings allowed.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self._dateformat is None:
</span><span class="miss">            return timetools.Date._formatstrings[&#39;iso&#39;]
</span><span class="noop">        else:
</span><span class="hit">            return self._dateformat
</span><span class="noop">
</span><span class="hit">    def _setdateformat(self, dateformat):
</span><span class="hit">        try:
</span><span class="hit">            dateformat = str(dateformat)
</span><span class="miss">        except BaseException:
</span><span class="miss">            raise TypeError(
</span><span class="noop">                &#39;The given `dateformat` of type `%s` could not be converted &#39;
</span><span class="noop">                &#39;to a `str` instance.&#39; % objecttools.classname(dateformat))
</span><span class="hit">        try:
</span><span class="hit">            datetime.datetime(2000, 1, 1).strftime(dateformat)
</span><span class="miss">        except BaseException:
</span><span class="miss">            raise ValueError(
</span><span class="noop">                &#34;The given `dateformat` `%s` is not a valid format string &#34;
</span><span class="noop">                &#34;for `datetime` objects.  Please read the documentation &#34;
</span><span class="noop">                &#34;on module `datetime` of Python&#39;s the standard library &#34;
</span><span class="noop">                &#34;for further information.&#34; % dateformat)
</span><span class="hit">        self._dateformat = dateformat
</span><span class="noop">
</span><span class="hit">    dateformat = property(_getdateformat, _setdateformat)
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def get_output_array(seq):
</span><span class="noop">        &#34;&#34;&#34;Return the array containing the output results of the given
</span><span class="noop">        sequence.&#34;&#34;&#34;
</span><span class="hit">        return seq.series
</span><span class="noop">
</span><span class="hit">    def prepare_node_sequences(self):
</span><span class="noop">        &#34;&#34;&#34;Prepare the simulations sequences of all nodes in.
</span><span class="noop">
</span><span class="noop">        This preparation might not be suitable for all types of integration
</span><span class="noop">        tests.  Prepare those node sequences manually, for which this method
</span><span class="noop">        does not result in the desired outcome.&#34;&#34;&#34;
</span><span class="hit">        for node in self.nodes:
</span><span class="hit">            if not node.entries:
</span><span class="hit">                node.deploy_mode = &#39;oldsim&#39;
</span><span class="hit">            sim = node.sequences.sim
</span><span class="hit">            sim.ramflag = True
</span><span class="hit">            sim._setarray(numpy.zeros(len(pub.timegrids.init), dtype=float))
</span><span class="noop">
</span><span class="hit">    def prepare_input_model_sequences(self):
</span><span class="noop">        &#34;&#34;&#34;Configure the input sequences of the model in a manner that allows
</span><span class="noop">        for applying their time series data in integration tests.&#34;&#34;&#34;
</span><span class="hit">        for (name, seq) in getattr(self.element.model.sequences, &#39;inputs&#39;, ()):
</span><span class="hit">            seq.ramflag = True
</span><span class="hit">            seq._setarray(numpy.zeros(len(pub.timegrids.init), dtype=float))
</span><span class="noop">
</span><span class="hit">    def extract_print_sequences(self):
</span><span class="noop">        &#34;&#34;&#34;Return a list of all input, flux and state sequences of the model
</span><span class="noop">        as well as the simulation sequences of all nodes.&#34;&#34;&#34;
</span><span class="hit">        seqs = []
</span><span class="hit">        for subseqs in (&#39;inputs&#39;, &#39;fluxes&#39;, &#39;states&#39;):
</span><span class="hit">            for (name, seq) in getattr(
</span><span class="noop">                                    self.element.model.sequences, subseqs, ()):
</span><span class="hit">                seqs.append(seq)
</span><span class="hit">        for node in self.nodes:
</span><span class="hit">            seqs.append(node.sequences.sim)
</span><span class="hit">        return seqs
</span><span class="noop">
</span><span class="hit">    def prepare_model(self):
</span><span class="noop">        &#34;&#34;&#34;Derive the secondary parameter values, prepare all required time
</span><span class="noop">        series and set the initial conditions.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.model.parameters.update()
</span><span class="hit">        self.element.prepare_fluxseries()
</span><span class="hit">        self.element.prepare_stateseries()
</span><span class="hit">        self.reset_outputs()
</span><span class="hit">        self.reset_inits()
</span><span class="noop">
</span><span class="hit">    def reset_outputs(self):
</span><span class="noop">        &#34;&#34;&#34;Set the values of the simulation sequences of all outlet nodes to
</span><span class="noop">        zero.&#34;&#34;&#34;
</span><span class="hit">        for node in self.nodes:
</span><span class="hit">            if ((node in self.element.outlets) or
</span><span class="noop">                    (node in self.element.senders)):
</span><span class="hit">                node.sequences.sim[:] = 0.
</span><span class="noop">
</span><span class="hit">    def reset_inits(self):
</span><span class="noop">        &#34;&#34;&#34;Set all initial conditions of all models.&#34;&#34;&#34;
</span><span class="hit">        for subname in (&#39;states&#39;, &#39;logs&#39;):
</span><span class="hit">            for element in self.elements:
</span><span class="hit">                for (name, seq) in getattr(element.model.sequences,
</span><span class="noop">                                           subname, ()):
</span><span class="hit">                    try:
</span><span class="hit">                        seq(getattr(self.inits, name))
</span><span class="hit">                    except AttributeError:
</span><span class="hit">                        pass
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class UnitTest(Test):
</span><span class="noop">
</span><span class="hit">    HEADER_OF_FIRST_COL = &#39;ex.&#39;
</span><span class="noop">    &#34;&#34;&#34;The header of the first column containing sequential numbers.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    nexts = ArrayDescriptor()
</span><span class="noop">    &#34;&#34;&#34;Stores arrays for setting different values of parameters and/or
</span><span class="noop">    sequences before each new experiment.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    results = ArrayDescriptor()
</span><span class="noop">    &#34;&#34;&#34;Stores arrays with the resulting values of parameters and/or
</span><span class="noop">    sequences of each new experiment.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, model, method, first_example=1, last_example=1,
</span><span class="noop">                 parseqs=None):
</span><span class="hit">        del self.inits
</span><span class="hit">        del self.nexts
</span><span class="hit">        del self.results
</span><span class="hit">        self.model = model
</span><span class="hit">        self.method = method
</span><span class="hit">        self.doc = self.extract_method_doc()
</span><span class="hit">        self.first_example_calc = first_example
</span><span class="hit">        self.last_example_calc = last_example
</span><span class="hit">        self.first_example_plot = first_example
</span><span class="hit">        self.last_example_plot = last_example
</span><span class="hit">        if parseqs:
</span><span class="hit">            self.parseqs = parseqs
</span><span class="noop">        else:
</span><span class="hit">            self.parseqs = self.extract_print_parameters_and_sequences()
</span><span class="hit">        self.memorize_inits()
</span><span class="hit">        self.prepare_output_arrays()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def nmb_examples(self):
</span><span class="hit">        return self.last_example_calc-self.first_example_calc+1
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def idx0(self):
</span><span class="noop">        &#34;&#34;&#34;First index of the examples selected for printing.&#34;&#34;&#34;
</span><span class="hit">        return self.first_example_plot-self.first_example_calc
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def idx1(self):
</span><span class="noop">        &#34;&#34;&#34;Last index of the examples selected for printing.&#34;&#34;&#34;
</span><span class="hit">        return self.nmb_examples-(self.last_example_calc -
</span><span class="noop">                                  self.last_example_plot)
</span><span class="noop">
</span><span class="hit">    def __call__(self, first_example=None, last_example=None):
</span><span class="hit">        if first_example is None:
</span><span class="hit">            self.first_example_plot = self.first_example_calc
</span><span class="noop">        else:
</span><span class="miss">            self.first_example_plot = first_example
</span><span class="hit">        if last_example is None:
</span><span class="hit">            self.last_example_plot = self.last_example_calc
</span><span class="noop">        else:
</span><span class="miss">            self.last_example_plot = last_example
</span><span class="hit">        self.reset_inits()
</span><span class="hit">        for idx in range(self.nmb_examples):
</span><span class="hit">            self._update_inputs(idx)
</span><span class="hit">            self.method()
</span><span class="hit">            self._update_outputs(idx)
</span><span class="hit">        self.print_table(self.idx0, self.idx1)
</span><span class="noop">
</span><span class="hit">    def get_output_array(self, parseq):
</span><span class="noop">        &#34;&#34;&#34;Return the array containing the output results of the given
</span><span class="noop">        parameter or sequence.&#34;&#34;&#34;
</span><span class="hit">        return getattr(self.results, parseq.name)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def raw_first_col_strings(self):
</span><span class="noop">        &#34;&#34;&#34;The raw integer strings of the first column, except the header.&#34;&#34;&#34;
</span><span class="hit">        return [str(example) for example in
</span><span class="noop">                range(self.first_example_plot, self.last_example_plot+1)]
</span><span class="noop">
</span><span class="hit">    def memorize_inits(self):
</span><span class="noop">        &#34;&#34;&#34;Memorize all initial conditions.&#34;&#34;&#34;
</span><span class="hit">        for parseq in self.parseqs:
</span><span class="hit">            setattr(self.inits, parseq.name, parseq.values)
</span><span class="noop">
</span><span class="hit">    def prepare_output_arrays(self):
</span><span class="hit">        for parseq in self.parseqs:
</span><span class="hit">            shape = [len(self.raw_first_col_strings)] + list(parseq.shape)
</span><span class="hit">            type_ = getattr(parseq, &#39;TYPE&#39;, float)
</span><span class="hit">            array = numpy.full(shape, numpy.nan, type_)
</span><span class="hit">            setattr(self.results, parseq.name, array)
</span><span class="noop">
</span><span class="hit">    def reset_inits(self):
</span><span class="noop">        &#34;&#34;&#34;Set all initial conditions.&#34;&#34;&#34;
</span><span class="hit">        for parseq in self.parseqs:
</span><span class="hit">            parseq(getattr(self.inits, parseq.name))
</span><span class="noop">
</span><span class="hit">    def extract_method_doc(self):
</span><span class="noop">        &#34;&#34;&#34;Return the documentation string of the method to be tested.&#34;&#34;&#34;
</span><span class="hit">        if getattr(self.method, &#39;__doc__&#39;, None):
</span><span class="hit">            return self.method.__doc__
</span><span class="noop">        else:
</span><span class="miss">            Model = type(self.model)
</span><span class="miss">            for group_name in Model._METHOD_GROUPS:
</span><span class="miss">                for function in getattr(Model, group_name, ()):
</span><span class="miss">                    if function.__name__ == self.method.__name__:
</span><span class="miss">                        return function.__doc__
</span><span class="noop">
</span><span class="hit">    def extract_print_parameters_and_sequences(self):
</span><span class="noop">        &#34;&#34;&#34;Return a list of all parameter and sequences of the model.
</span><span class="noop">
</span><span class="noop">        Note that all parameters and sequences without the common `values`
</span><span class="noop">        attribute are omitted.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        parseqs = []
</span><span class="hit">        for (_, subparseqs) in itertools.chain(self.model.parameters,
</span><span class="noop">                                               self.model.sequences):
</span><span class="hit">            for (_, parseq) in subparseqs:
</span><span class="hit">                if str(type(parseq)).split(&#34;&#39;&#34;)[1] in self.doc:
</span><span class="hit">                    if hasattr(parseq, &#39;values&#39;):
</span><span class="hit">                        parseqs.append(parseq)
</span><span class="hit">        return tuple(parseqs)
</span><span class="noop">
</span><span class="hit">    def _update_inputs(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Update the actual values with the :attr:`~UnitTest.nexts` data of
</span><span class="noop">        the given index.&#34;&#34;&#34;
</span><span class="hit">        for parseq in self.parseqs:
</span><span class="hit">            if hasattr(self.nexts, parseq.name):
</span><span class="hit">                parseq(getattr(self.nexts, parseq.name)[idx])
</span><span class="noop">
</span><span class="hit">    def _update_outputs(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Update the :attr:`~UnitTest.results` data with the actual values of
</span><span class="noop">        the given index.&#34;&#34;&#34;
</span><span class="hit">        for parseq in self.parseqs:
</span><span class="hit">            if hasattr(self.results, parseq.name):
</span><span class="hit">                getattr(self.results, parseq.name)[idx] = parseq.values
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/timetools.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/core/timetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
1399 &nbsp;
1400 &nbsp;
1401 &nbsp;
1402 &nbsp;
1403 &nbsp;
1404 &nbsp;
1405 &nbsp;
1406 &nbsp;
1407 &nbsp;
1408 &nbsp;
1409 &nbsp;
1410 &nbsp;
1411 &nbsp;
1412 &nbsp;
1413 &nbsp;
1414 &nbsp;
1415 &nbsp;
1416 &nbsp;
1417 &nbsp;
1418 &nbsp;
1419 &nbsp;
1420 &nbsp;
1421 &nbsp;
1422 &nbsp;
1423 &nbsp;
1424 &nbsp;
1425 &nbsp;
1426 &nbsp;
1427 &nbsp;
1428 &nbsp;
1429 &nbsp;
1430 &nbsp;
1431 &nbsp;
1432 &nbsp;
1433 &nbsp;
1434 &nbsp;
1435 &nbsp;
1436 &nbsp;
1437 &nbsp;
1438 &nbsp;
1439 &nbsp;
1440 &nbsp;
1441 &nbsp;
1442 &nbsp;
1443 &nbsp;
1444 &nbsp;
1445 &nbsp;
1446 &nbsp;
1447 &nbsp;
1448 &nbsp;
1449 &nbsp;
1450 &nbsp;
1451 &nbsp;
1452 &nbsp;
1453 &nbsp;
1454 &nbsp;
1455 &nbsp;
1456 &nbsp;
1457 &nbsp;
1458 &nbsp;
1459 &nbsp;
1460 &nbsp;
1461 &nbsp;
1462 &nbsp;
1463 &nbsp;
1464 &nbsp;
1465 &nbsp;
1466 &nbsp;
1467 &nbsp;
1468 &nbsp;
1469 &nbsp;
1470 &nbsp;
1471 &nbsp;
1472 &nbsp;
1473 &nbsp;
1474 &nbsp;
1475 &nbsp;
1476 &nbsp;
1477 &nbsp;
1478 &nbsp;
1479 &nbsp;
1480 &nbsp;
1481 &nbsp;
1482 &nbsp;
1483 &nbsp;
1484 &nbsp;
1485 &nbsp;
1486 &nbsp;
1487 &nbsp;
1488 &nbsp;
1489 &nbsp;
1490 &nbsp;
1491 &nbsp;
1492 &nbsp;
1493 &nbsp;
1494 &nbsp;
1495 &nbsp;
1496 &nbsp;
1497 &nbsp;
1498 &nbsp;
1499 &nbsp;
1500 &nbsp;
1501 &nbsp;
1502 &nbsp;
1503 &nbsp;
1504 &nbsp;
1505 &nbsp;
1506 &nbsp;
1507 &nbsp;
1508 &nbsp;
1509 &nbsp;
1510 &nbsp;
1511 &nbsp;
1512 &nbsp;
1513 &nbsp;
1514 &nbsp;
1515 &nbsp;
1516 &nbsp;
1517 &nbsp;
1518 &nbsp;
1519 &nbsp;
1520 &nbsp;
1521 &nbsp;
1522 &nbsp;
1523 &nbsp;
1524 &nbsp;
1525 &nbsp;
1526 &nbsp;
1527 &nbsp;
1528 &nbsp;
1529 &nbsp;
1530 &nbsp;
1531 &nbsp;
1532 &nbsp;
1533 &nbsp;
1534 &nbsp;
1535 &nbsp;
1536 &nbsp;
1537 &nbsp;
1538 &nbsp;
1539 &nbsp;
1540 &nbsp;
1541 &nbsp;
1542 &nbsp;
1543 &nbsp;
1544 &nbsp;
1545 &nbsp;
1546 &nbsp;
1547 &nbsp;
1548 &nbsp;
1549 &nbsp;
1550 &nbsp;
1551 &nbsp;
1552 &nbsp;
1553 &nbsp;
1554 &nbsp;
1555 &nbsp;
1556 &nbsp;
1557 &nbsp;
1558 &nbsp;
1559 &nbsp;
1560 &nbsp;
1561 &nbsp;
1562 &nbsp;
1563 &nbsp;
1564 &nbsp;
1565 &nbsp;
1566 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module specifies how  dates and periods are handled in HydPy.&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import datetime
</span><span class="hit">import copy
</span><span class="hit">import time
</span><span class="hit">import calendar
</span><span class="hit">import collections
</span><span class="hit">import warnings
</span><span class="noop"># ...from third party packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># The import of `_strptime` is not thread save.  The following call of
</span><span class="noop"># `strptime` is supposed to prevent possible problems arising from this bug.
</span><span class="hit">time.strptime(&#39;1999&#39;, &#39;%Y&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Date(object):
</span><span class="noop">    &#34;&#34;&#34;Handles a single date.
</span><span class="noop">
</span><span class="noop">    Classes :class:`Date` is build on top of the Python module :mod:`datetime`.
</span><span class="noop">    In essence, it wraps the :mod:`datetime` class :class:`~datetime.datetime`,
</span><span class="noop">    and is supposed to specialise this general class on the needs of HydPy
</span><span class="noop">    users.
</span><span class="noop">
</span><span class="noop">    Be aware of the different minimum time resolution of module :mod:`datetime`
</span><span class="noop">    (microseconds) and module :mod:`~hydpy.core.timetools` (seconds).
</span><span class="noop">
</span><span class="noop">    :class:`Date` objects can be initialized via :class:`~datetime.datetime`
</span><span class="noop">    objects directly, e.g.:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from datetime import datetime
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Date
</span><span class="noop">        &gt;&gt;&gt; # Initialize a `datetime` object...
</span><span class="noop">        &gt;&gt;&gt; datetime_object = datetime(1996, 11, 1, 0, 0, 0)
</span><span class="noop">        &gt;&gt;&gt; # ...and use it to initialise a `Date` object.
</span><span class="noop">        &gt;&gt;&gt; date1 = Date(datetime_object)
</span><span class="noop">
</span><span class="noop">    Alternatively, one can use :class:`str` objects as initialization
</span><span class="noop">    arguments, which need to match one of the following format styles:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # The `os` style without empty space and colon, which is applied in
</span><span class="noop">        &gt;&gt;&gt; # text files and folder names:
</span><span class="noop">        &gt;&gt;&gt; date2 = Date(&#39;1997_11_01_00_00_00&#39;)
</span><span class="noop">        &gt;&gt;&gt; # The `iso` style, which is more legible and in accordance with the
</span><span class="noop">        &gt;&gt;&gt; # international ISO norm:
</span><span class="noop">        &gt;&gt;&gt; date2 = Date(&#39;1997.11.01 00:00:00&#39;)
</span><span class="noop">        &gt;&gt;&gt; # The `din` style, which is more legible for users in countries
</span><span class="noop">        &gt;&gt;&gt; # where the position of day and year are interchanged (DIN refers
</span><span class="noop">        &gt;&gt;&gt; # to a german norm):
</span><span class="noop">        &gt;&gt;&gt; date2 = Date(&#39;01.11.1997 00:00:00&#39;)
</span><span class="noop">
</span><span class="noop">    :class:`Date` keeps the chosen style in mind and uses it for printing.
</span><span class="noop">    But the user is also allowed to change it:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # Print in accordance with the `iso` style...
</span><span class="noop">        &gt;&gt;&gt; date2.string(&#39;iso&#39;)
</span><span class="noop">        &#39;1997.11.01 00:00:00&#39;
</span><span class="noop">        &gt;&gt;&gt; # ...without changing the memorized `din` style:
</span><span class="noop">        &gt;&gt;&gt; date2.style
</span><span class="noop">        &#39;din&#39;
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # Alternatively, the style property can be set permanentely:
</span><span class="noop">        &gt;&gt;&gt; date2.style = &#39;iso&#39;
</span><span class="noop">        &gt;&gt;&gt; str(date2)
</span><span class="noop">        &#39;1997.11.01 00:00:00&#39;
</span><span class="noop">
</span><span class="noop">    It is allowed to abbreviate the input strings. Using the `iso` style as an
</span><span class="noop">    example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # The following three input arguments...
</span><span class="noop">        &gt;&gt;&gt; test1 = Date(&#39;1996.11.01 00:00:00&#39;)
</span><span class="noop">        &gt;&gt;&gt; test2 = Date(&#39;1996.11.01 00:00&#39;)
</span><span class="noop">        &gt;&gt;&gt; test3 = Date(&#39;1996.11.01 00&#39;)
</span><span class="noop">        &gt;&gt;&gt; test4 = Date(&#39;1996.11.01&#39;)
</span><span class="noop">        &gt;&gt;&gt; # ...all lead to identical `Date` instances.
</span><span class="noop">        &gt;&gt;&gt; for test in (test1, test2, test3, test4):
</span><span class="noop">        ...     print(test)
</span><span class="noop">        1996.11.01 00:00:00
</span><span class="noop">        1996.11.01 00:00:00
</span><span class="noop">        1996.11.01 00:00:00
</span><span class="noop">        1996.11.01 00:00:00
</span><span class="noop">
</span><span class="noop">    If :class:`Date` has not been initialized via a :class:`str` object and
</span><span class="noop">    the style property has not been set manually, the default style `iso`
</span><span class="noop">    is selected.
</span><span class="noop">
</span><span class="noop">    One can change the year, month... of a :class:`Date` object via numbers:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # Assign an integer...
</span><span class="noop">        &gt;&gt;&gt; test4.year = 1997
</span><span class="noop">        &gt;&gt;&gt; # ...or something that can be converted to an integer.
</span><span class="noop">        &gt;&gt;&gt; test4.month = &#39;10&#39;
</span><span class="noop">        &gt;&gt;&gt; print(test4)
</span><span class="noop">        1997.10.01 00:00:00
</span><span class="noop">
</span><span class="noop">    One can ask for the actual water year, which depends on the selected
</span><span class="noop">    reference month:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; oct = Date(&#39;1996.10.01&#39;)
</span><span class="noop">        &gt;&gt;&gt; nov = Date(&#39;1996.11.01&#39;)
</span><span class="noop">        &gt;&gt;&gt; # Under the standard settings, the water year is assumed to start
</span><span class="noop">        &gt;&gt;&gt; # November.
</span><span class="noop">        &gt;&gt;&gt; oct.wateryear
</span><span class="noop">        1996
</span><span class="noop">        &gt;&gt;&gt; nov.wateryear
</span><span class="noop">        1997
</span><span class="noop">        &gt;&gt;&gt; # Changing the reference month via one `Date` object affects all
</span><span class="noop">        &gt;&gt;&gt; # objects.
</span><span class="noop">        &gt;&gt;&gt; test4.refmonth = 10
</span><span class="noop">        &gt;&gt;&gt; oct.wateryear
</span><span class="noop">        1997
</span><span class="noop">        &gt;&gt;&gt; nov.wateryear
</span><span class="noop">        1997
</span><span class="noop">        &gt;&gt;&gt; test4.refmonth = &#39;November&#39;
</span><span class="noop">        &gt;&gt;&gt; oct.wateryear
</span><span class="noop">        1996
</span><span class="noop">        &gt;&gt;&gt; nov.wateryear
</span><span class="noop">        1997
</span><span class="noop">
</span><span class="noop">    Note that :class:`Date` objects are mutable.  Use the `copy` method
</span><span class="noop">    to prevent from unintentional results:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; date1 = Date(&#39;1996.11.01 00:00&#39;)
</span><span class="noop">        &gt;&gt;&gt; date2 = date1
</span><span class="noop">        &gt;&gt;&gt; date3 = date1.copy()
</span><span class="noop">        &gt;&gt;&gt; date1.year = 1997
</span><span class="noop">        &gt;&gt;&gt; for date in (date1, date2, date3):
</span><span class="noop">        ...     print(date)
</span><span class="noop">        1997.11.01 00:00:00
</span><span class="noop">        1997.11.01 00:00:00
</span><span class="noop">        1996.11.01 00:00:00
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">    # These are the so far accepted date format strings.
</span><span class="hit">    _formatstrings = {&#39;os&#39;: &#39;%Y_%m_%d_%H_%M_%S&#39;,
</span><span class="noop">                      &#39;iso&#39;: &#39;%Y.%m.%d %H:%M:%S&#39;,
</span><span class="noop">                      &#39;din&#39;: &#39;%d.%m.%Y %H:%M:%S&#39;}
</span><span class="noop">    # The first month of the hydrological year (e.g. November in Germany)
</span><span class="hit">    _firstmonth_wateryear = 11
</span><span class="noop">
</span><span class="hit">    def __init__(self, date):
</span><span class="hit">        self.datetime = None
</span><span class="hit">        self._style = None
</span><span class="hit">        if isinstance(date, Date):
</span><span class="hit">            self.datetime = date.datetime
</span><span class="hit">        elif isinstance(date, datetime.datetime):
</span><span class="hit">            if date.microsecond:
</span><span class="miss">                raise ValueError(&#39;For `Date` instances, the microsecond must &#39;
</span><span class="noop">                                 &#39;be `0`.  For the given `datetime` object, &#39;
</span><span class="noop">                                 &#39;it is `%d` instead.&#39; % date.microsecond)
</span><span class="hit">            self.datetime = date
</span><span class="hit">        elif isinstance(date, str):
</span><span class="hit">            self._initfromstr(date)
</span><span class="hit">        elif isinstance(date, TOY):
</span><span class="hit">            self.datetime = datetime.datetime(2000,
</span><span class="noop">                                              date.month, date.day, date.hour,
</span><span class="noop">                                              date.minute, date.second)
</span><span class="noop">        else:
</span><span class="hit">            raise TypeError(&#39;The supplied argument must be either an &#39;
</span><span class="noop">                            &#39;instance of `datetime.datetime` or of `str`.  &#39;
</span><span class="noop">                            &#39;The given arguments type is %s.&#39; % type(date))
</span><span class="noop">
</span><span class="hit">    def _initfromstr(self, date):
</span><span class="noop">        &#34;&#34;&#34;Try to initialize `datetime` from the given :class:`str` instance.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * date (:class:`str`): Initialization date.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        for (style, string) in self._formatstrings.items():
</span><span class="hit">            for idx in range(4):
</span><span class="hit">                try:
</span><span class="hit">                    self.datetime = datetime.datetime.strptime(date, string)
</span><span class="hit">                    self._style = style
</span><span class="hit">                except ValueError:
</span><span class="hit">                    string = string[:-3]
</span><span class="hit">        if self.datetime is None:
</span><span class="hit">            raise ValueError(&#39;Date could not be identified out of the given &#39;
</span><span class="noop">                             &#39;string %s.  The available formats are %s.&#39;
</span><span class="noop">                             % (date, self._formatstrings))
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def fromarray(cls, array):
</span><span class="noop">        &#34;&#34;&#34;Returns a :class:`Date` instance based on date information (year,
</span><span class="noop">        month, day, hour, minute, second) stored as the first entries of the
</span><span class="noop">        successive rows of a :class:`~numpy.ndarray` object.&#34;&#34;&#34;
</span><span class="miss">        intarray = numpy.array(array, dtype=int)
</span><span class="miss">        for idx in range(1, array.ndim):
</span><span class="miss">            intarray = intarray[:, 0]
</span><span class="miss">        return cls(datetime.datetime(*intarray))
</span><span class="noop">
</span><span class="hit">    def toarray(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a 1-dimensional :mod:`numpy` :class:`~numpy.ndarray` with
</span><span class="noop">        six entries defining the actual date (year, month, day, hour, minute,
</span><span class="noop">        second).&#34;&#34;&#34;
</span><span class="hit">        return numpy.array([self.year, self.month, self.day, self.hour,
</span><span class="noop">                            self.minute, self.second], dtype=float)
</span><span class="noop">
</span><span class="hit">    def _getrefmonth(self):
</span><span class="noop">        &#34;&#34;&#34;First month of the hydrological year. The default value is 11
</span><span class="noop">        (November which is the german reference month). Setting it e.g. to 10
</span><span class="noop">        (October is another common reference month many different countries)
</span><span class="noop">        affects all :class:`Date` instances.&#34;&#34;&#34;
</span><span class="hit">        return Date._firstmonth_wateryear
</span><span class="noop">
</span><span class="hit">    def _setrefmonth(self, value):
</span><span class="hit">        try:
</span><span class="hit">            Date._firstmonth_wateryear = int(value)
</span><span class="hit">        except ValueError:
</span><span class="hit">            string = str(value)[:3].lower()
</span><span class="hit">            try:
</span><span class="hit">                months = [&#39;jan&#39;, &#39;feb&#39;, &#39;mar&#39;, &#39;apr&#39;, &#39;may&#39;, &#39;jun&#39;,
</span><span class="noop">                          &#39;jul&#39;, &#39;aug&#39;, &#39;sew&#39;, &#39;oct&#39;, &#39;nov&#39;, &#39;dec&#39;]
</span><span class="hit">                Date._firstmonth_wateryear = months.index(string) + 1
</span><span class="hit">            except ValueError:
</span><span class="hit">                raise ValueError(&#39;The given value `%s` cannot be interpreted &#39;
</span><span class="noop">                                 &#39;as a month. Supply e.g. a number between 1 &#39;
</span><span class="noop">                                 &#39;and 12 or a month name instead.&#39; % value)
</span><span class="noop">
</span><span class="hit">    refmonth = property(_getrefmonth, _setrefmonth)
</span><span class="noop">
</span><span class="hit">    def _getstyle(self):
</span><span class="noop">        &#34;&#34;&#34;Date format style to be applied in printing.&#34;&#34;&#34;
</span><span class="hit">        if self._style is None:
</span><span class="hit">            return &#39;iso&#39;
</span><span class="noop">        else:
</span><span class="hit">            return self._style
</span><span class="noop">
</span><span class="hit">    def _setstyle(self, style):
</span><span class="hit">        if style in self._formatstrings:
</span><span class="hit">            self._style = style
</span><span class="noop">        else:
</span><span class="miss">            self._style = None
</span><span class="miss">            raise KeyError(&#39;Date format style `%s` is not available.&#39; % style)
</span><span class="noop">
</span><span class="hit">    style = property(_getstyle, _setstyle)
</span><span class="noop">
</span><span class="hit">    def _setthing(self, thing, value):
</span><span class="noop">        &#34;&#34;&#34;Convenience method for `_setyear`, `_setmonth`...&#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            value = int(value)
</span><span class="hit">        except (TypeError, ValueError):
</span><span class="hit">            raise ValueError(&#39;Changing the %s of a `Date` instance is only &#39;
</span><span class="noop">                             &#39;allowed via numbers, but the given value `%s` &#39;
</span><span class="noop">                             &#39;is of type `%s` instead.&#39;
</span><span class="noop">                             % (thing, value, type(value)))
</span><span class="hit">        kwargs = {}
</span><span class="hit">        for unit in (&#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;hour&#39;, &#39;minute&#39;, &#39;second&#39;):
</span><span class="hit">            kwargs[unit] = getattr(self, unit)
</span><span class="hit">        kwargs[thing] = value
</span><span class="hit">        self.datetime = datetime.datetime(**kwargs)
</span><span class="noop">
</span><span class="hit">    def _getsecond(self):
</span><span class="noop">        &#34;&#34;&#34;The actual second.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.second
</span><span class="noop">
</span><span class="hit">    def _setsecond(self, second):
</span><span class="hit">        self._setthing(&#39;second&#39;, second)
</span><span class="noop">
</span><span class="hit">    second = property(_getsecond, _setsecond)
</span><span class="noop">
</span><span class="hit">    def _getminute(self):
</span><span class="noop">        &#34;&#34;&#34;The actual minute.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.minute
</span><span class="noop">
</span><span class="hit">    def _setminute(self, minute):
</span><span class="hit">        self._setthing(&#39;minute&#39;, minute)
</span><span class="noop">
</span><span class="hit">    minute = property(_getminute, _setminute)
</span><span class="noop">
</span><span class="hit">    def _gethour(self):
</span><span class="noop">        &#34;&#34;&#34;The actual hour.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.hour
</span><span class="noop">
</span><span class="hit">    def _sethour(self, hour):
</span><span class="hit">        self._setthing(&#39;hour&#39;, hour)
</span><span class="noop">
</span><span class="hit">    hour = property(_gethour, _sethour)
</span><span class="noop">
</span><span class="hit">    def _getday(self):
</span><span class="noop">        &#34;&#34;&#34;The actual day.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.day
</span><span class="noop">
</span><span class="hit">    def _setday(self, day):
</span><span class="hit">        self._setthing(&#39;day&#39;, day)
</span><span class="noop">
</span><span class="hit">    day = property(_getday, _setday)
</span><span class="noop">
</span><span class="hit">    def _getmonth(self):
</span><span class="noop">        &#34;&#34;&#34;The actual month.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.month
</span><span class="noop">
</span><span class="hit">    def _setmonth(self, month):
</span><span class="hit">        self._setthing(&#39;month&#39;, month)
</span><span class="noop">
</span><span class="hit">    month = property(_getmonth, _setmonth)
</span><span class="noop">
</span><span class="hit">    def _getyear(self):
</span><span class="noop">        &#34;&#34;&#34;The actual year.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.year
</span><span class="noop">
</span><span class="hit">    def _setyear(self, year):
</span><span class="hit">        self._setthing(&#39;year&#39;, year)
</span><span class="noop">
</span><span class="hit">    year = property(_getyear, _setyear)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def wateryear(self):
</span><span class="noop">        &#34;&#34;&#34;The actual hydrological year according selected reference month.&#34;&#34;&#34;
</span><span class="hit">        if self.month &lt; self._firstmonth_wateryear:
</span><span class="hit">            return self.year
</span><span class="noop">        else:
</span><span class="hit">            return self.year + 1
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def dayofyear(self):
</span><span class="noop">        &#34;&#34;&#34;Day of year as an integer value.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.timetuple().tm_yday
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def leapyear(self):
</span><span class="noop">        &#34;&#34;&#34;Return whether the actual date falls in a leap year or not.&#34;&#34;&#34;
</span><span class="hit">        year = self.year
</span><span class="hit">        return (((year % 4) == 0) and
</span><span class="noop">                (((year % 100) != 0) or ((year % 400) == 0)))
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Date` instance.&#34;&#34;&#34;
</span><span class="hit">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __add__(self, other):
</span><span class="hit">        new = Date(self.datetime + Period(other).timedelta)
</span><span class="hit">        new.style = self.style
</span><span class="hit">        return new
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, other):
</span><span class="hit">        self.datetime += Period(other).timedelta
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return Period(self.datetime-Date(other).datetime)
</span><span class="hit">        except (TypeError, ValueError):
</span><span class="hit">            try:
</span><span class="hit">                new = Date(self.datetime-Period(other).timedelta)
</span><span class="hit">                new.style = self.style
</span><span class="hit">                return new
</span><span class="miss">            except (TypeError, ValueError):
</span><span class="miss">                raise Exception(&#39;Object `%s` of type `%s` can not be &#39;
</span><span class="noop">                                &#39;substracted from a `Date` instance.&#39;
</span><span class="noop">                                % (str(other), type(other)))
</span><span class="noop">
</span><span class="hit">    def __isub__(self, other):
</span><span class="hit">        self.datetime -= Period(other).timedelta
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="hit">        return self.datetime &lt; Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="hit">        return self.datetime &lt;= Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return self.datetime == Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        return self.datetime != Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="hit">        return self.datetime &gt; Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="hit">        return self.datetime &gt;= Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def string(self, style):
</span><span class="noop">        &#34;&#34;&#34;Returns a :class:`str` object representing the actual date in
</span><span class="noop">        accordance with the given style.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        retain = self.style
</span><span class="hit">        try:
</span><span class="hit">            self.style = style
</span><span class="hit">            return str(self)
</span><span class="noop">        finally:
</span><span class="hit">            self.style = retain
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="hit">        return self.datetime.strftime(self._formatstrings[self.style])
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return &#34;Date(&#39;%s&#39;)&#34; % str(self)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Period(object):
</span><span class="noop">    &#34;&#34;&#34;Handles the length of a single time period.
</span><span class="noop">
</span><span class="noop">    Class :class:`Period` is build on top of the Python module :mod:`datetime`.
</span><span class="noop">    In essence, it wraps the :mod:`datetime` class
</span><span class="noop">    :class:`~datetime.timedelta` and is supposed to specialise this general
</span><span class="noop">    classes on the needs of HydPy users.
</span><span class="noop">
</span><span class="noop">    Be aware of the different minimum time resolution of module :mod:`datetime`
</span><span class="noop">    (microseconds) and module :mod:`~hydpy.core.timetools` (seconds).
</span><span class="noop">
</span><span class="noop">    :class:`Period` objects can be directly initialized via
</span><span class="noop">    :class:`~datetime.timedelta` objects, e.g.:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from datetime import timedelta
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Period
</span><span class="noop">        &gt;&gt;&gt; # Initialize a `timedelta` object...
</span><span class="noop">        &gt;&gt;&gt; timedelta_object = timedelta(1, 0)
</span><span class="noop">        &gt;&gt;&gt; # ...and use it to initialise a `Period` object
</span><span class="noop">        &gt;&gt;&gt; period = Period(timedelta_object)
</span><span class="noop">
</span><span class="noop">    Alternatively, one can initialize from :class:`str` objects.  These must
</span><span class="noop">    consist of some characters defining an integer value directly followed by
</span><span class="noop">    a single character defining the unit:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # 30 seconds:
</span><span class="noop">        &gt;&gt;&gt; period = Period(&#39;30s&#39;)
</span><span class="noop">        &gt;&gt;&gt; # 5 minutes:
</span><span class="noop">        &gt;&gt;&gt; period = Period(&#39;5m&#39;)
</span><span class="noop">        &gt;&gt;&gt; # 6 hours:
</span><span class="noop">        &gt;&gt;&gt; period = Period(&#39;6h&#39;)
</span><span class="noop">        &gt;&gt;&gt; # 1 day:
</span><span class="noop">        &gt;&gt;&gt; period = Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="noop">    :class:`Period` always determines the unit leading to the most legigible
</span><span class="noop">    expression:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # Print using the unit leading to the smallest integer value:
</span><span class="noop">        &gt;&gt;&gt; print(period)
</span><span class="noop">        1d
</span><span class="noop">        &gt;&gt;&gt; # Alternatively, the values of all time units are directly
</span><span class="noop">        &gt;&gt;&gt; # available as `float` objects:
</span><span class="noop">        &gt;&gt;&gt; period.days
</span><span class="noop">        1.0
</span><span class="noop">        &gt;&gt;&gt; period.hours
</span><span class="noop">        24.0
</span><span class="noop">        &gt;&gt;&gt; period.minutes
</span><span class="noop">        1440.0
</span><span class="noop">        &gt;&gt;&gt; period.seconds
</span><span class="noop">        86400.0
</span><span class="noop">
</span><span class="noop">    If considered useful, logic and arithmetic operations are supported.
</span><span class="noop">    Some examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # Determine the period length between two dates.
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Date
</span><span class="noop">        &gt;&gt;&gt; date1, date2 = Date(&#39;1997.11.01&#39;), Date(&#39;1996.11.01&#39;)
</span><span class="noop">        &gt;&gt;&gt; wholeperiod = date1 - date2
</span><span class="noop">        &gt;&gt;&gt; print(wholeperiod)
</span><span class="noop">        365d
</span><span class="noop">        &gt;&gt;&gt; # Determine, how often one period fits into the other.
</span><span class="noop">        &gt;&gt;&gt; wholeperiod / period
</span><span class="noop">        365.0
</span><span class="noop">        &gt;&gt;&gt; # Get one sixths of period:
</span><span class="noop">        &gt;&gt;&gt; period / 6
</span><span class="noop">        Period(&#39;4h&#39;)
</span><span class="noop">        &gt;&gt;&gt; # But when trying to get one seventh of period, the following
</span><span class="noop">        &gt;&gt;&gt; # error is raised:
</span><span class="noop">        &gt;&gt;&gt; period / 7
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: For `Period` instances, microseconds must be zero.  However, for the given `timedelta` object, it is`857142` instead.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # Double a period duration.
</span><span class="noop">        &gt;&gt;&gt; period *= 2
</span><span class="noop">        &gt;&gt;&gt; period
</span><span class="noop">        Period(&#39;2d&#39;)
</span><span class="noop">        &gt;&gt;&gt; # Shift a date.
</span><span class="noop">        &gt;&gt;&gt; date1 - period
</span><span class="noop">        Date(&#39;1997.10.30 00:00:00&#39;)
</span><span class="noop">        &gt;&gt;&gt; # Note that the modulo operator returns a boolean value, indicating
</span><span class="noop">        &gt;&gt;&gt; # whether division results in a remainder or not:
</span><span class="noop">        &gt;&gt;&gt; Period(&#39;1d&#39;) % Period(&#39;12h&#39;)
</span><span class="noop">        False
</span><span class="noop">        &gt;&gt;&gt; Period(&#39;1d&#39;) % Period(&#39;13h&#39;)
</span><span class="noop">        True
</span><span class="noop">        &gt;&gt;&gt; # Following the same line of thinking, floor division leads to the
</span><span class="noop">        &gt;&gt;&gt; # opposite results:
</span><span class="noop">        &gt;&gt;&gt; Period(&#39;1d&#39;) // Period(&#39;12h&#39;)
</span><span class="noop">        True
</span><span class="noop">        &gt;&gt;&gt; Period(&#39;1d&#39;) // Period(&#39;13h&#39;)
</span><span class="noop">        False
</span><span class="noop">        &gt;&gt;&gt; # Compare dates or periods.
</span><span class="noop">        &gt;&gt;&gt; date1 &lt; date2
</span><span class="noop">        False
</span><span class="noop">        &gt;&gt;&gt; min(date1, date2)
</span><span class="noop">        Date(&#39;1996.11.01 00:00:00&#39;)
</span><span class="noop">        &gt;&gt;&gt; period == wholeperiod
</span><span class="noop">        False
</span><span class="noop">        &gt;&gt;&gt; # Operations on initialisation arguments are supported.
</span><span class="noop">        &gt;&gt;&gt; date1 + &#39;5m&#39;
</span><span class="noop">        Date(&#39;1997.11.01 00:05:00&#39;)
</span><span class="noop">        &gt;&gt;&gt; period != &#39;12h&#39;
</span><span class="noop">        True
</span><span class="noop">
</span><span class="noop">    Note that :class:`Period` objects are mutable.  Use the `copy` method
</span><span class="noop">    to prevent from unintentional results::
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; period1 = Period(&#39;6h&#39;)
</span><span class="noop">        &gt;&gt;&gt; period2 = period1
</span><span class="noop">        &gt;&gt;&gt; period3 = period1.copy()
</span><span class="noop">        &gt;&gt;&gt; period1 -= &#39;2h&#39;
</span><span class="noop">        &gt;&gt;&gt; period1, period2, period3
</span><span class="noop">        (Period(&#39;4h&#39;), Period(&#39;4h&#39;), Period(&#39;6h&#39;))
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    def __init__(self, period):
</span><span class="hit">        self.timedelta = None
</span><span class="hit">        self._unit = None
</span><span class="hit">        if isinstance(period, Period):
</span><span class="hit">            self.timedelta = period.timedelta
</span><span class="hit">        elif isinstance(period, datetime.timedelta):
</span><span class="hit">            if period.microseconds:
</span><span class="hit">                raise ValueError(
</span><span class="noop">                    &#39;For `Period` instances, microseconds must be zero.  &#39;
</span><span class="noop">                    &#39;However, for the given `timedelta` object, it is&#39;
</span><span class="noop">                    &#39;`%d` instead.&#39; % period.microseconds)
</span><span class="hit">            self.timedelta = period
</span><span class="hit">        elif isinstance(period, str):
</span><span class="hit">            self._initfromstr(period)
</span><span class="noop">        else:
</span><span class="hit">            raise ValueError(&#39;The supplied argument must be either an &#39;
</span><span class="noop">                             &#39;instance of `datetime.timedelta` or `str`.  &#39;
</span><span class="noop">                             &#39;The given arguments type is %s.&#39;
</span><span class="noop">                             % objecttools.classname(period))
</span><span class="noop">
</span><span class="hit">    def _initfromstr(self, period):
</span><span class="noop">        &#34;&#34;&#34;Try to initialize `timedelta` from the given :class:`str` instance.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * period (:class:`str`): Period length.
</span><span class="noop">         &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            number = int(period[:-1])
</span><span class="miss">        except ValueError:
</span><span class="miss">            raise ValueError(&#39;All characters of the given period string, &#39;
</span><span class="noop">                             &#39;except the last one which represents the unit, &#39;
</span><span class="noop">                             &#39;need to define a whole decimal number.  Instead,&#39;
</span><span class="noop">                             &#39; these characters are `%s`.&#39; % period[:-1])
</span><span class="hit">        self._unit = period[-1]
</span><span class="hit">        if self._unit not in (&#39;d&#39;, &#39;h&#39;, &#39;m&#39;, &#39;s&#39;):
</span><span class="miss">            raise ValueError(&#39;The last character of the given period string &#39;
</span><span class="noop">                             &#39;needs to be either `d` (days), `h` (hours) or &#39;
</span><span class="noop">                             &#39;`m` (minutes).  Instead, the last character is &#39;
</span><span class="noop">                             &#39;`%s`.&#39; % self._unit)
</span><span class="hit">        if self._unit == &#39;d&#39;:
</span><span class="hit">            self.timedelta = datetime.timedelta(number, 0)
</span><span class="hit">        elif self._unit == &#39;h&#39;:
</span><span class="hit">            self.timedelta = datetime.timedelta(0, number*3600)
</span><span class="hit">        elif self._unit == &#39;m&#39;:
</span><span class="hit">            self.timedelta = datetime.timedelta(0, number*60)
</span><span class="hit">        elif self._unit == &#39;s&#39;:
</span><span class="hit">            self.timedelta = datetime.timedelta(0, number)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def fromseconds(cls, seconds):
</span><span class="noop">        &#34;&#34;&#34;Returns a :class:`Period` instance based on a given number of
</span><span class="noop">        seconds.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            seconds = int(seconds)
</span><span class="miss">        except TypeError:
</span><span class="miss">            seconds = int(seconds.flatten()[0])
</span><span class="hit">        return cls(datetime.timedelta(0, int(seconds)))
</span><span class="noop">
</span><span class="hit">    def _guessunit(self):
</span><span class="noop">        &#34;&#34;&#34;Guess the unit of the period as the largest one, which results in
</span><span class="noop">        an integer duration.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if not self.days % 1:
</span><span class="hit">            return &#39;d&#39;
</span><span class="hit">        elif not self.hours % 1:
</span><span class="hit">            return &#39;h&#39;
</span><span class="hit">        elif not self.minutes % 1:
</span><span class="hit">            return &#39;m&#39;
</span><span class="hit">        elif not self.seconds % 1:
</span><span class="hit">            return &#39;s&#39;
</span><span class="noop">        else:
</span><span class="miss">            raise ValueError(&#39;The stepsize is not a multiple of one &#39;
</span><span class="noop">                             &#39;second, which is not allowed.&#39;)
</span><span class="noop">
</span><span class="hit">    unit = property(_guessunit)
</span><span class="noop">
</span><span class="hit">    def _getseconds(self):
</span><span class="noop">        &#34;&#34;&#34;Period length in seconds.&#34;&#34;&#34;
</span><span class="hit">        return self.timedelta.total_seconds()
</span><span class="noop">
</span><span class="hit">    seconds = property(_getseconds)
</span><span class="noop">
</span><span class="hit">    def _getminutes(self):
</span><span class="noop">        &#34;&#34;&#34;Period length in minutes.&#34;&#34;&#34;
</span><span class="hit">        return self.seconds / 60
</span><span class="noop">
</span><span class="hit">    minutes = property(_getminutes)
</span><span class="noop">
</span><span class="hit">    def _gethours(self):
</span><span class="noop">        &#34;&#34;&#34;Period length in hours.&#34;&#34;&#34;
</span><span class="hit">        return self.minutes / 60
</span><span class="noop">
</span><span class="hit">    hours = property(_gethours)
</span><span class="noop">
</span><span class="hit">    def _getdays(self):
</span><span class="noop">        &#34;&#34;&#34;Period length in days.&#34;&#34;&#34;
</span><span class="hit">        return self.hours / 24
</span><span class="noop">
</span><span class="hit">    days = property(_getdays)
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Period` instance.&#34;&#34;&#34;
</span><span class="hit">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __add__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            new = Date(Date(other).datetime + self.timedelta)
</span><span class="hit">            new.style = other.style
</span><span class="hit">            return new
</span><span class="hit">        except (TypeError, ValueError):
</span><span class="hit">            try:
</span><span class="hit">                return Period(self.timedelta + Period(other).timedelta)
</span><span class="miss">            except (TypeError, ValueError):
</span><span class="miss">                raise Exception(&#39;Object `%s` of type `%s` can not be &#39;
</span><span class="noop">                                &#39;added to a `Period` instance.&#39;
</span><span class="noop">                                % (str(other), type(other)))
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, other):
</span><span class="hit">        self.timedelta += Period(other).timedelta
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, other):
</span><span class="miss">        return Period(self.timedelta - Period(other).timedelta)
</span><span class="noop">
</span><span class="hit">    def __isub__(self, other):
</span><span class="hit">        self.timedelta -= Period(other).timedelta
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __mul__(self, value):
</span><span class="hit">        return Period(self.timedelta * value)
</span><span class="noop">
</span><span class="hit">    def __rmul__(self, value):
</span><span class="hit">        return self * value
</span><span class="noop">
</span><span class="hit">    def __imul__(self, value):
</span><span class="hit">        self.timedelta *= value
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __truediv__(self, other):
</span><span class="hit">        if isinstance(other, int):
</span><span class="hit">            return Period(self.timedelta // other)
</span><span class="noop">        else:
</span><span class="hit">            return self.seconds / Period(other).seconds
</span><span class="noop">
</span><span class="hit">    def __itruediv__(self, value):
</span><span class="hit">        return self / value
</span><span class="noop">
</span><span class="hit">    def __mod__(self, other):
</span><span class="hit">        return (self.seconds % Period(other).seconds) != 0.
</span><span class="noop">
</span><span class="hit">    def __floordiv__(self, other):
</span><span class="hit">        return (self.seconds % Period(other).seconds) == 0.
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="hit">        return self.timedelta &lt; Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="hit">        return self.timedelta &lt;= Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return self.timedelta == Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        return self.timedelta != Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="hit">        return self.timedelta &gt; Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="hit">        return self.timedelta &gt;= Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="hit">        if self.unit == &#39;d&#39;:
</span><span class="hit">            return &#39;%dd&#39; % self.days
</span><span class="hit">        elif self.unit == &#39;h&#39;:
</span><span class="hit">            return &#39;%dh&#39; % self.hours
</span><span class="hit">        elif self.unit == &#39;m&#39;:
</span><span class="hit">            return &#39;%dm&#39; % self.minutes
</span><span class="miss">        elif self.unit == &#39;s&#39;:
</span><span class="miss">            return &#39;%ds&#39; % self.seconds
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return &#34;Period(&#39;%s&#39;)&#34; % str(self)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Timegrid(object):
</span><span class="noop">    &#34;&#34;&#34;Handle a time period defined by to dates and a step size in between.
</span><span class="noop">
</span><span class="noop">    In hydrological modelling, input (and output) data are usually only
</span><span class="noop">    available with a certain resolution, which also determines the possible
</span><span class="noop">    resolution of the actual simulation.  This is reflected by the class
</span><span class="noop">    :class:`Timegrid`, which represents the first and the last date of e.g.
</span><span class="noop">    a simulation period as well as the intermediate dates. A :class:`Timegrid`
</span><span class="noop">    object is initialized by defining its first date, its last date and its
</span><span class="noop">    stepsize:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Date, Period, Timegrid
</span><span class="noop">        &gt;&gt;&gt; # Either pass the proper attributes directly...
</span><span class="noop">        &gt;&gt;&gt; firstdate = Date(&#39;1996.11.01&#39;)
</span><span class="noop">        &gt;&gt;&gt; lastdate = Date(&#39;1997.11.01&#39;)
</span><span class="noop">        &gt;&gt;&gt; stepsize = Period(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim = Timegrid(firstdate, lastdate, stepsize)
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim
</span><span class="noop">        Timegrid(&#39;1996.11.01 00:00:00&#39;,
</span><span class="noop">                 &#39;1997.11.01 00:00:00&#39;,
</span><span class="noop">                 &#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; # ...or pass their initialization arguments:
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim = Timegrid(&#39;1996.11.01&#39;, &#39;1997.11.01&#39;, &#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim
</span><span class="noop">        Timegrid(&#39;1996.11.01 00:00:00&#39;,
</span><span class="noop">                 &#39;1997.11.01 00:00:00&#39;,
</span><span class="noop">                 &#39;1d&#39;)
</span><span class="noop">
</span><span class="noop">    :class:`Timegrid` provides functionalities to ease and secure the handling
</span><span class="noop">    of dates in HydPy. Here some examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # Retrieve a date via indexing, e.g. the second one:
</span><span class="noop">        &gt;&gt;&gt; date = timegrid_sim[1]
</span><span class="noop">        &gt;&gt;&gt; date
</span><span class="noop">        Date(&#39;1996.11.02 00:00:00&#39;)
</span><span class="noop">        &gt;&gt;&gt; # Or the other way round, retrieve the index belonging to a date:
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim[date]
</span><span class="noop">        1
</span><span class="noop">        &gt;&gt;&gt; # Indexing beyond the ranges of the actual time period is allowed:
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim[-366]
</span><span class="noop">        Date(&#39;1995.11.01 00:00:00&#39;)
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim[timegrid_sim[date+&#39;365d&#39;]]
</span><span class="noop">        Date(&#39;1997.11.02 00:00:00&#39;)
</span><span class="noop">        &gt;&gt;&gt; # Iterate through all time grid points (e.g. to print the first
</span><span class="noop">        &gt;&gt;&gt; # day of each month):
</span><span class="noop">        &gt;&gt;&gt; for date in timegrid_sim:
</span><span class="noop">        ...     if date.day == 1:
</span><span class="noop">        ...         print(date)
</span><span class="noop">        1996.11.01 00:00:00
</span><span class="noop">        1996.12.01 00:00:00
</span><span class="noop">        1997.01.01 00:00:00
</span><span class="noop">        1997.02.01 00:00:00
</span><span class="noop">        1997.03.01 00:00:00
</span><span class="noop">        1997.04.01 00:00:00
</span><span class="noop">        1997.05.01 00:00:00
</span><span class="noop">        1997.06.01 00:00:00
</span><span class="noop">        1997.07.01 00:00:00
</span><span class="noop">        1997.08.01 00:00:00
</span><span class="noop">        1997.09.01 00:00:00
</span><span class="noop">        1997.10.01 00:00:00
</span><span class="noop">
</span><span class="noop">    After doing some changes one should call the :func:`~Timegrid.verify`
</span><span class="noop">    method:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # `verify` keeps silent if everything seems to be alright...
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim.verify()
</span><span class="noop">        &gt;&gt;&gt; # ...but raises an suitable exception otherwise:
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim.firstdate.minute = 30
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim.verify()
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: Unplausible timegrid. The period span between the given dates 1996.11.01 00:30:00 and 1997.11.01 00:00:00 is not a multiple of the given step size 1d.
</span><span class="noop">
</span><span class="noop">    One can check two :class:`Timegrid` instances for equality:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # Make a deep copy of the timegrid already existing.
</span><span class="noop">        &gt;&gt;&gt; timegrid_test = timegrid_sim.copy()
</span><span class="noop">        &gt;&gt;&gt; # Test for equality and non-equality.
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim == timegrid_test
</span><span class="noop">        True
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim != timegrid_test
</span><span class="noop">        False
</span><span class="noop">        &gt;&gt;&gt; # Modify one date of the new timegrid.
</span><span class="noop">        &gt;&gt;&gt; timegrid_test.firstdate += &#39;1d&#39;
</span><span class="noop">        &gt;&gt;&gt; # Again, test for equality and non-equality.
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim == timegrid_test
</span><span class="noop">        False
</span><span class="noop">        &gt;&gt;&gt; timegrid_sim != timegrid_test
</span><span class="noop">        True
</span><span class="noop">
</span><span class="noop">    Also, one can check if a date or even the whole timegrid lies within a
</span><span class="noop">    span defined by a :class:`Timegrid` instance::
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # Define a long timegrid:
</span><span class="noop">        &gt;&gt;&gt; timegrid_long = Timegrid(&#39;1996.11.01&#39;, &#39;2006.11.01&#39;, &#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; # Check different dates for lying in the defined time period:
</span><span class="noop">        &gt;&gt;&gt; &#39;1996.10.31&#39; in timegrid_long
</span><span class="noop">        False
</span><span class="noop">        &gt;&gt;&gt; &#39;1996.11.01&#39; in timegrid_long
</span><span class="noop">        True
</span><span class="noop">        &gt;&gt;&gt; &#39;1996.11.02&#39; in timegrid_long
</span><span class="noop">        True
</span><span class="noop">        &gt;&gt;&gt; # For dates not alligned on the grid `False` is returned:
</span><span class="noop">        &gt;&gt;&gt; &#39;1996.11.01 12:00&#39; in timegrid_long
</span><span class="noop">        False
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # Now define a timegrid containing only the first year of the
</span><span class="noop">        &gt;&gt;&gt; # long one:
</span><span class="noop">        &gt;&gt;&gt; timegrid_short = Timegrid(&#39;1996.11.01&#39;, &#39;1997.11.01&#39;, &#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; # Check which timegrid is contained by the other:
</span><span class="noop">        &gt;&gt;&gt; timegrid_short in timegrid_long
</span><span class="noop">        True
</span><span class="noop">        &gt;&gt;&gt; timegrid_long in timegrid_short
</span><span class="noop">        False
</span><span class="noop">        &gt;&gt;&gt; # For timegrids with different stepsizes `False` is returned:
</span><span class="noop">        &gt;&gt;&gt; timegrid_short.stepsize = Period(&#39;1h&#39;)
</span><span class="noop">        &gt;&gt;&gt; timegrid_short in timegrid_long
</span><span class="noop">        False
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _firstdate = None
</span><span class="hit">    _lastdate = None
</span><span class="hit">    _stepsize = None
</span><span class="noop">
</span><span class="hit">    def __init__(self, firstdate, lastdate, stepsize):
</span><span class="hit">        self.firstdate = firstdate
</span><span class="hit">        self.lastdate = lastdate
</span><span class="hit">        self.stepsize = stepsize
</span><span class="hit">        self.verify()
</span><span class="noop">
</span><span class="hit">    def _getfirstdate(self):
</span><span class="hit">        return self._firstdate
</span><span class="noop">
</span><span class="hit">    def _setfirstdate(self, firstdate):
</span><span class="hit">        self._firstdate = Date(firstdate)
</span><span class="noop">
</span><span class="hit">    firstdate = property(_getfirstdate, _setfirstdate)
</span><span class="noop">
</span><span class="hit">    def _getlastdate(self):
</span><span class="hit">        return self._lastdate
</span><span class="noop">
</span><span class="hit">    def _setlastdate(self, lastdate):
</span><span class="hit">        self._lastdate = Date(lastdate)
</span><span class="noop">
</span><span class="hit">    lastdate = property(_getlastdate, _setlastdate)
</span><span class="noop">
</span><span class="hit">    def _getstepsize(self):
</span><span class="hit">        return self._stepsize
</span><span class="noop">
</span><span class="hit">    def _setstepsize(self, stepsize):
</span><span class="hit">        self._stepsize = Period(stepsize)
</span><span class="noop">
</span><span class="hit">    stepsize = property(_getstepsize, _setstepsize)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def fromarray(cls, array):
</span><span class="noop">        &#34;&#34;&#34;Returns a :class:`Timegrid` instance based on two date and one
</span><span class="noop">        period information stored in the first 13 rows of a
</span><span class="noop">        :class:`~numpy.ndarray` object.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        try:
</span><span class="miss">            return cls(firstdate=Date.fromarray(array[:6]),
</span><span class="noop">                       lastdate=Date.fromarray(array[6:12]),
</span><span class="noop">                       stepsize=Period.fromseconds(array[12]))
</span><span class="miss">        except IndexError:
</span><span class="miss">            raise IndexError(&#39;To define a Timegrid instance via an array, 13 &#39;
</span><span class="noop">                             &#39;numbers are required.  However, the given array &#39;
</span><span class="noop">                             &#39;consist of %d entries/rows only.&#39; % len(array))
</span><span class="noop">
</span><span class="hit">    def toarray(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a 1-dimensional :mod:`numpy` :class:`~numpy.ndarray` with
</span><span class="noop">        thirteen entries first defining the start date, secondly defining the
</span><span class="noop">        end date and thirdly the step size in seconds.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">        values = numpy.empty(13, dtype=float)
</span><span class="hit">        values[:6] = self.firstdate.toarray()
</span><span class="hit">        values[6:12] = self.lastdate.toarray()
</span><span class="hit">        values[12] = self.stepsize.seconds
</span><span class="hit">        return values
</span><span class="noop">
</span><span class="hit">    def array2series(self, array):
</span><span class="noop">        &#34;&#34;&#34;Prefix the information of the actual Timegrid object to the given
</span><span class="noop">        array and return it.
</span><span class="noop">
</span><span class="noop">        The Timegrid information is stored in the first thirteen values of
</span><span class="noop">        the first axis of the returned series.  Initialize a Timegrid object
</span><span class="noop">        and apply its `array2series` method on a simple list containing
</span><span class="noop">        numbers:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrid
</span><span class="noop">        &gt;&gt;&gt; timegrid = Timegrid(&#39;2000.11.01 00:00&#39;, &#39;2000.11.01 04:00&#39;, &#39;1h&#39;)
</span><span class="noop">        &gt;&gt;&gt; series = timegrid.array2series([1, 2, 3.5, &#39;5.0&#39;])
</span><span class="noop">
</span><span class="noop">        The first six entries contain the first date of the timegrid (year,
</span><span class="noop">        month, day, hour, minute, second):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(series[:6])
</span><span class="noop">        2000.0, 11.0, 1.0, 0.0, 0.0, 0.0
</span><span class="noop">
</span><span class="noop">        The six subsequent entries contain the last date:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; round_(series[6:12])
</span><span class="noop">        2000.0, 11.0, 1.0, 4.0, 0.0, 0.0
</span><span class="noop">
</span><span class="noop">        The thirteens value is the step size in seconds:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; round_(series[12])
</span><span class="noop">        3600.0
</span><span class="noop">
</span><span class="noop">        The last four value are the ones of the given vector:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; round_(series[-4:])
</span><span class="noop">        1.0, 2.0, 3.5, 5.0
</span><span class="noop">
</span><span class="noop">        The given array can have an arbitrary number of dimensions:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; import numpy
</span><span class="noop">        &gt;&gt;&gt; array = numpy.eye(4)
</span><span class="noop">        &gt;&gt;&gt; series = timegrid.array2series(array)
</span><span class="noop">
</span><span class="noop">        Now the timegrid information is stored in the first column:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; round_(series[:13, 0])
</span><span class="noop">        2000.0, 11.0, 1.0, 0.0, 0.0, 0.0, 2000.0, 11.0, 1.0, 4.0, 0.0, 0.0, 3600.0
</span><span class="noop">
</span><span class="noop">        All other columns of the first thirteen rows contain nan values, e.g.:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; round_(series[12, :])
</span><span class="noop">        3600.0, nan, nan, nan
</span><span class="noop">
</span><span class="noop">        The original values are stored in the last four rows, e.g.:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; round_(series[13, :])
</span><span class="noop">        1.0, 0.0, 0.0, 0.0
</span><span class="noop">
</span><span class="noop">        Inappropriate array objects result in error messages like:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; timegrid.array2series([[1, 2], [3]])
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: While trying to prefix timegrid information to the given array, the following error occured: setting an array element with a sequence.
</span><span class="noop">
</span><span class="noop">        If the given array does not fit to the defined timegrid, a special
</span><span class="noop">        error message is returned:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; timegrid.array2series([[1, 2], [3, 4]])
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: When converting an array to a sequence, the lengths of the timegrid and the given array must be equal, but the length of the timegrid object is `4` and the length of the array object is `2`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            array = numpy.array(array, dtype=float)
</span><span class="hit">        except BaseException:
</span><span class="hit">            objecttools.augmentexcmessage(&#39;While trying to prefix timegrid &#39;
</span><span class="noop">                                          &#39;information to the given array&#39;)
</span><span class="hit">        if len(array) != len(self):
</span><span class="hit">            raise ValueError(
</span><span class="noop">                &#39;When converting an array to a sequence, the lengths of the &#39;
</span><span class="noop">                &#39;timegrid and the given array must be equal, but the length &#39;
</span><span class="noop">                &#39;of the timegrid object is `%s` and the length of the array &#39;
</span><span class="noop">                &#39;object is `%s`.&#39; % (len(self), len(array)))
</span><span class="hit">        shape = list(array.shape)
</span><span class="hit">        shape[0] += 13
</span><span class="hit">        series = numpy.full(shape, numpy.nan)
</span><span class="hit">        slices = [slice(0, 13)]
</span><span class="hit">        subshape = [13]
</span><span class="hit">        for idx in range(1, series.ndim):
</span><span class="hit">            slices.append(slice(0, 1))
</span><span class="hit">            subshape.append(1)
</span><span class="hit">        series[slices] = self.toarray().reshape(subshape)
</span><span class="hit">        series[13:] = array
</span><span class="hit">        return series
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raise an :class:`~exceptions.ValueError` if the dates or the
</span><span class="noop">        step size of the time frame are inconsistent.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self.firstdate &gt;= self.lastdate:
</span><span class="hit">            raise ValueError(&#39;Unplausible timegrid. The first given &#39;
</span><span class="noop">                             &#39;date %s, the second given date is %s. &#39;
</span><span class="noop">                             % (self.firstdate, self.lastdate))
</span><span class="hit">        if (self.lastdate-self.firstdate) % self.stepsize:
</span><span class="hit">            raise ValueError(&#39;Unplausible timegrid. The period span &#39;
</span><span class="noop">                             &#39;between the given dates %s and %s is not &#39;
</span><span class="noop">                             &#39;a multiple of the given step size %s.&#39; %
</span><span class="noop">                             (self.firstdate, self.lastdate, self.stepsize))
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Timegrid` instance.&#34;&#34;&#34;
</span><span class="hit">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return int((self.lastdate-self.firstdate) / self.stepsize)
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="hit">        if isinstance(key, int):
</span><span class="hit">            return Date(self.firstdate + key*self.stepsize)
</span><span class="noop">        else:
</span><span class="hit">            key = Date(key)
</span><span class="hit">            index = (key-self.firstdate) / self.stepsize
</span><span class="hit">            if index % 1.:
</span><span class="hit">                raise ValueError(&#39;The given date `%s` is not properly &#39;
</span><span class="noop">                                 &#39;alligned on the indexed timegrid.&#39; % key)
</span><span class="noop">            else:
</span><span class="hit">                return int(index)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        date = self.firstdate.copy()
</span><span class="hit">        while date &lt; self.lastdate:
</span><span class="hit">            yield date
</span><span class="hit">            date = date + self.stepsize
</span><span class="noop">
</span><span class="hit">    def _containsdate(self, date):
</span><span class="hit">        date = Date(date)
</span><span class="hit">        return ((self.firstdate &lt;= date &lt;= self.lastdate) and
</span><span class="noop">                ((date-self.firstdate) // self.stepsize))
</span><span class="noop">
</span><span class="hit">    def _containstimegrid(self, timegrid):
</span><span class="hit">        return (self._containsdate(timegrid.firstdate) and
</span><span class="noop">                self._containsdate(timegrid.lastdate) and
</span><span class="noop">                (timegrid.stepsize == self.stepsize))
</span><span class="noop">
</span><span class="hit">    def __contains__(self, other):
</span><span class="hit">        if isinstance(other, Timegrid):
</span><span class="hit">            return self._containstimegrid(other)
</span><span class="noop">        else:
</span><span class="hit">            return self._containsdate(other)
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return ((self.firstdate == other.firstdate) and
</span><span class="noop">                (self.lastdate == other.lastdate) and
</span><span class="noop">                (self.stepsize == other.stepsize))
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        return ((self.firstdate != other.firstdate) or
</span><span class="noop">                (self.lastdate != other.lastdate) or
</span><span class="noop">                (self.stepsize != other.stepsize))
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return (&#39;from %s to %s in %s steps&#39;
</span><span class="noop">                % (self.firstdate, self.lastdate, self.stepsize))
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        skip = len(prefix) + 9
</span><span class="hit">        blanks = &#39; &#39; * skip
</span><span class="hit">        lines = [&#34;%sTimegrid(&#39;%s&#39;,&#34; % (prefix, str(self.firstdate)),
</span><span class="noop">                 &#34;%s&#39;%s&#39;,&#34; % (blanks, str(self.lastdate)),
</span><span class="noop">                 &#34;%s&#39;%s&#39;)&#34; % (blanks, str(self.stepsize))]
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Timegrids(object):
</span><span class="noop">    &#34;&#34;&#34;Handles all :class:`Timegrid` instances of a HydPy project.
</span><span class="noop">
</span><span class="noop">    The HydPy framework distinguishes three `time frames`, one associated
</span><span class="noop">    with the input date available on disk (`data`), one associated, with the
</span><span class="noop">    initialisation period (`init`), and one associated with the actual
</span><span class="noop">    simulation period (`sim`).  The last two latter time frames are
</span><span class="noop">    represented by two different :class:`Timegrid` objects, which are both
</span><span class="noop">    handled by a single :class:`Timegrids` object.  (The `data` time frames
</span><span class="noop">    are also defined via :class:`Timegrid` objects, but for each input data
</span><span class="noop">    file seperately. See module :mod:`~hydpy.core.sequencetools` for
</span><span class="noop">    further information.)
</span><span class="noop">
</span><span class="noop">    There is usually only one :class:`Timegrids` object required within each
</span><span class="noop">    HydPy project.  Usually It is instantiated in the project&#39;s main file
</span><span class="noop">    or at the top of script defining a HydPy workflow and assigned to the
</span><span class="noop">    :mod:`~hydpy.pub` module, which provides access to &#34;global&#34; project
</span><span class="noop">    settings:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import Timegrid, Timegrids
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">
</span><span class="noop">    In many cases, one want to perform the simulation over the whole
</span><span class="noop">    initialization period.  Then only one Timegrid instance must be
</span><span class="noop">    defined:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2000.11.11&#39;,
</span><span class="noop">        ...                                    &#39;2003.11.11&#39;,
</span><span class="noop">        ...                                     &#39;1d&#39;))
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids
</span><span class="noop">        Timegrids(Timegrid(&#39;2000.11.11 00:00:00&#39;,
</span><span class="noop">                           &#39;2003.11.11 00:00:00&#39;,
</span><span class="noop">                           &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">    Otherwise, two Timegrid instances must be given:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(init=Timegrid(&#39;2000.11.11&#39;,
</span><span class="noop">        ...                                         &#39;2003.11.11&#39;,
</span><span class="noop">        ...                                         &#39;1h&#39;),
</span><span class="noop">        ...                           sim=Timegrid(&#39;2001.11.11&#39;,
</span><span class="noop">        ...                                        &#39;2002.11.11&#39;,
</span><span class="noop">        ...                                        &#39;1h&#39;))
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids
</span><span class="noop">        Timegrids(init=Timegrid(&#39;2000.11.11 00:00:00&#39;,
</span><span class="noop">                                &#39;2003.11.11 00:00:00&#39;,
</span><span class="noop">                                &#39;1h&#39;),
</span><span class="noop">                  sim=Timegrid(&#39;2001.11.11 00:00:00&#39;,
</span><span class="noop">                               &#39;2002.11.11 00:00:00&#39;,
</span><span class="noop">                               &#39;1h&#39;))
</span><span class="noop">
</span><span class="noop">    Some examples on the usage of this :class:`Timegrids` instance:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # Get the general data and simulation step size:
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.stepsize
</span><span class="noop">        Period(&#39;1h&#39;)
</span><span class="noop">        &gt;&gt;&gt; # Get the factor to convert `mm/stepsize` to m^3/s for an area
</span><span class="noop">        &gt;&gt;&gt; # of 36 km^2:
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.qfactor(36.)
</span><span class="noop">        10.0
</span><span class="noop">        &gt;&gt;&gt; # Get the index of the first values of the `initialization frame`
</span><span class="noop">        &gt;&gt;&gt; # which belong to the `simulation frame`.
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.init[pub.timegrids.sim.firstdate]
</span><span class="noop">        8760
</span><span class="noop">
</span><span class="noop">    Each manual change should be followed by calling the
</span><span class="noop">    :func:`~Timegrids.verify` method, which calls the :func:`~Timegrid.verify`
</span><span class="noop">    method of the single :class:`Timegrid` instances and performs some
</span><span class="noop">    additional tests:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # To postpone the end of the `simulation time frame` exactly
</span><span class="noop">        &gt;&gt;&gt; # one year is fine:
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.sim.lastdate += &#39;365d&#39;
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.verify()
</span><span class="noop">        &gt;&gt;&gt; # But any additional day shifts it outside the `initialisation
</span><span class="noop">        &gt;&gt;&gt; # time frame`, so verification raises a value error:
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.sim.lastdate += &#39;1d&#39;
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.verify()
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: The last date of the initialisation period (2003.11.11 00:00:00) must not be earlier than the last date of the simulation period (2003.11.12 00:00:00).
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.sim.lastdate -= &#39;1d&#39;
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # The other boundary is also checked:
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.sim.firstdate -= &#39;366d&#39;
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.verify()
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: The first date of the initialisation period (2000.11.11 00:00:00) must not be later than the first date of the simulation period (2000.11.10 00:00:00).
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # Both timegrids are checked to have the same step size:
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.sim = Timegrid(&#39;2001.11.11&#39;,
</span><span class="noop">        ...                              &#39;2002.11.11&#39;,
</span><span class="noop">        ...                              &#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.verify()
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: The initialization stepsize (1h) must be identical with the simulation stepsize (1d).
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; # Also, they are checked to be properly aligned:
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.sim = Timegrid(&#39;2001.11.11 00:30&#39;,
</span><span class="noop">        ...                              &#39;2002.11.11 00:30&#39;,
</span><span class="noop">        ...                              &#39;1h&#39;)
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids.verify()
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: The simulation time grid is not properly alligned on the initialization time grid.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    def __init__(self, init, sim=None, data=None):
</span><span class="hit">        if data is not None:
</span><span class="miss">            warnings.warn(objecttools.HydPyDeprecationWarning(
</span><span class="noop">                &#39;The global `data` timegrid information is outdated.  Now &#39;
</span><span class="noop">                &#39;each time series file contains its own `data` timegrid.  &#39;
</span><span class="noop">                &#39;Supplying the `data` keyword to the `Timegrids` constructor &#39;
</span><span class="noop">                &#39;does nothing and will be banned in the future.&#39;))
</span><span class="hit">        self.init = init
</span><span class="hit">        if sim is None:
</span><span class="hit">            self.sim = self.init.copy()
</span><span class="noop">        else:
</span><span class="hit">            self.sim = sim
</span><span class="hit">        self.verify()
</span><span class="noop">
</span><span class="hit">    def _getstepsize(self):
</span><span class="noop">        &#34;&#34;&#34;Stepsize of all handled :class:`Timegrid` objects.&#34;&#34;&#34;
</span><span class="hit">        return self.init.stepsize
</span><span class="noop">
</span><span class="hit">    def _setstepsize(self, stepsize):
</span><span class="miss">        stepsize = Period(stepsize)
</span><span class="miss">        for (name, timegrid) in self:
</span><span class="miss">            timegrid.stepsize = stepsize
</span><span class="noop">
</span><span class="hit">    stepsize = property(_getstepsize, _setstepsize)
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raise an :class:`~exceptions.ValueError` it the different
</span><span class="noop">        time grids are inconsistent.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.init.verify()
</span><span class="hit">        self.sim.verify()
</span><span class="hit">        if self.init.firstdate &gt; self.sim.firstdate:
</span><span class="hit">            raise ValueError(&#39;The first date of the initialisation period &#39;
</span><span class="noop">                             &#39;(%s) must not be later than the first date &#39;
</span><span class="noop">                             &#39;of the simulation period (%s).&#39;
</span><span class="noop">                             % (self.init.firstdate, self.sim.firstdate))
</span><span class="hit">        elif self.init.lastdate &lt; self.sim.lastdate:
</span><span class="hit">            raise ValueError(&#39;The last date of the initialisation period &#39;
</span><span class="noop">                             &#39;(%s) must not be earlier than the last date &#39;
</span><span class="noop">                             &#39;of the simulation period (%s).&#39;
</span><span class="noop">                             % (self.init.lastdate, self.sim.lastdate))
</span><span class="hit">        elif self.init.stepsize != self.sim.stepsize:
</span><span class="hit">            raise ValueError(&#39;The initialization stepsize (%s) must be &#39;
</span><span class="noop">                             &#39;identical with the simulation stepsize (%s).&#39;
</span><span class="noop">                             % (self.init.stepsize, self.sim.stepsize))
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                self.init[self.sim.firstdate]
</span><span class="hit">            except ValueError:
</span><span class="hit">                raise ValueError(&#39;The simulation time grid is not properly &#39;
</span><span class="noop">                                 &#39;alligned on the initialization time grid.&#39;)
</span><span class="noop">
</span><span class="hit">    def qfactor(self, area):
</span><span class="noop">        &#34;&#34;&#34;Return the factor for converting `mm/stepsize` to `m^3/s`.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * area (:class:`float`): Reference area, which must be given in
</span><span class="noop">              the unit `km^2`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return area * 1000. / self.stepsize.seconds
</span><span class="noop">
</span><span class="hit">    def parfactor(self, stepsize):
</span><span class="noop">        &#34;&#34;&#34;Return the factor for converting parameter to simulation step size.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * stepsize (:class:`Period` or an suitable initialization argument
</span><span class="noop">              thereof): Time interval, to which the parameter values refer.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self.stepsize / Period(stepsize)
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Timegrids` instance.&#34;&#34;&#34;
</span><span class="miss">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        for (name, timegrid) in dict(self).items():
</span><span class="miss">            yield (name, timegrid)
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return &#39;All timegrids of the actual HydPy project.&#39;
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        caller = &#39;Timegrids(&#39;
</span><span class="hit">        blanks = &#39; &#39; * (len(prefix) + len(caller))
</span><span class="hit">        prefix = &#39;%s%s&#39; % (prefix, caller)
</span><span class="hit">        if self.sim != self.init:
</span><span class="hit">            prefix += &#39;init=&#39;
</span><span class="hit">        lines = [&#39;%s,&#39; % self.init.assignrepr(prefix)]
</span><span class="hit">        if self.sim != self.init:
</span><span class="hit">            prefix = &#39;%ssim=&#39; % blanks
</span><span class="hit">            lines.append(&#39;%s,&#39; % self.sim.assignrepr(prefix))
</span><span class="hit">        lines[-1] = lines[-1][:-1] + &#39;)&#39;
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TOY(object):
</span><span class="noop">    &#34;&#34;&#34;Time of year handler.
</span><span class="noop">
</span><span class="noop">    :class:`TOY` objects are used to define certain things that are true for
</span><span class="noop">    a certain time point in each year.  The smallest supported time unit is
</span><span class="noop">    seconds.
</span><span class="noop">
</span><span class="noop">    Normally, for initialization a string is passed, defining the month, the
</span><span class="noop">    day, the hour, the minute and the second in the order they are mentioned,
</span><span class="noop">    seperated by a single underscore:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.timetools import TOY
</span><span class="noop">    &gt;&gt;&gt; t = TOY(&#39;3_13_23_33_43&#39;)
</span><span class="noop">    &gt;&gt;&gt; t.month
</span><span class="noop">    3
</span><span class="noop">    &gt;&gt;&gt; t.day
</span><span class="noop">    13
</span><span class="noop">    &gt;&gt;&gt; t.hour
</span><span class="noop">    23
</span><span class="noop">    &gt;&gt;&gt; t.minute
</span><span class="noop">    33
</span><span class="noop">    &gt;&gt;&gt; t.second
</span><span class="noop">    43
</span><span class="noop">
</span><span class="noop">    If a lower precision is required, one can shorten the string, which
</span><span class="noop">    implicitely sets the omitted property to the lowest possible value:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; TOY(&#39;3_13_23_33&#39;)
</span><span class="noop">    TOY(&#39;3_13_23_33_0&#39;)
</span><span class="noop">
</span><span class="noop">    The most extreme example would be, to pass not string at all:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; TOY()
</span><span class="noop">    TOY(&#39;1_1_0_0_0&#39;)
</span><span class="noop">
</span><span class="noop">    One can prefix some information to the string, which is usefull when the
</span><span class="noop">    string is to be used as a valid variable name somewhere else:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; TOY(&#39;something_3_13_23_33_2&#39;)
</span><span class="noop">    TOY(&#39;3_13_23_33_2&#39;)
</span><span class="noop">
</span><span class="noop">    As one can see, the prefixed information is lost in the printed string
</span><span class="noop">    representation.  But a string with a standard prefix is returned through
</span><span class="noop">    applying :class:`str` on :class:`TOY` instances:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; str(TOY(&#39;something_3_13_23_33_2&#39;))
</span><span class="noop">    &#39;toy_3_13_23_33_2&#39;
</span><span class="noop">
</span><span class="noop">    Alternatively, one can use a :class:`Date` object as a initialization
</span><span class="noop">    argument, ommitting the year:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; TOY(Date(&#39;2001.02.03 04:05:06&#39;))
</span><span class="noop">    TOY(&#39;2_3_4_5_6&#39;)
</span><span class="noop">
</span><span class="noop">    It is only allowed to modify the mentioned properties, not to define new
</span><span class="noop">    ones:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.microsecond = 53
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    AttributeError: TOY (time of year) objects only allow to set the properties month, day, hour, minute or second, but `microsecond` is given.
</span><span class="noop">
</span><span class="noop">    It is allowed to pass objects that can be converted to integers:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.second = &#39;53&#39;
</span><span class="noop">    &gt;&gt;&gt; t.second
</span><span class="noop">    53
</span><span class="noop">
</span><span class="noop">    If the passed object cannot be converted properly, an exception is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.second = &#39;fiftythree&#39;
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: For TOY (time of year) objects, all properties must be of type `int`, but the value `fiftythree` of type `str` given for property `second` cannot be converted to `int`.
</span><span class="noop">
</span><span class="noop">    Additionally, given values are checked to lie within a suitable range:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.second = 60
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: The value of property `second` of TOY (time of year) objects must lie within the range `(0, 59)`, but the given value is `60`.
</span><span class="noop">
</span><span class="noop">    Note that the allowed values for `month` and `day` depend on each other,
</span><span class="noop">    which is why the order one defines them might be of importance.  So, if
</span><span class="noop">    January is predefined, one can set day to the 31th:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.month = 1
</span><span class="noop">    &gt;&gt;&gt; t.day = 31
</span><span class="noop">
</span><span class="noop">    But afterwards one cannot directly change the month to February:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.month = 2
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: The value of property `month` of the actual TOY (time of year) object must not be the given value `2`, as the day has already been set to `31`.
</span><span class="noop">
</span><span class="noop">    Hence first set `day` to a smaller value and then change `month`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.day = 28
</span><span class="noop">    &gt;&gt;&gt; t.month = 2
</span><span class="noop">
</span><span class="noop">    For February it is important to note, that the 29th is generally
</span><span class="noop">    disallowed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.day = 29
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: The value of property `day` of the actual TOY (time of year) object must lie within the range `(1, 28)`, as the month has already been set to `2`, but the given value is `29`.
</span><span class="noop">
</span><span class="noop">    It is possible to compare two :class:`TOY` instances:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t1, t2 = TOY(&#39;1&#39;), TOY(&#39;2&#39;)
</span><span class="noop">    &gt;&gt;&gt; (t1 &lt; t1, t1 &lt; t2, t2 &lt; t1)
</span><span class="noop">    (False, True, False)
</span><span class="noop">    &gt;&gt;&gt; (t1 &lt;= t1, t1 &lt;= t2, t2 &lt;= t1)
</span><span class="noop">    (True, True, False)
</span><span class="noop">    &gt;&gt;&gt; (t1 == t1, t1 == t2)
</span><span class="noop">    (True, False)
</span><span class="noop">    &gt;&gt;&gt; (t1 != t1, t1 != t2)
</span><span class="noop">    (False, True)
</span><span class="noop">    &gt;&gt;&gt; (t1 &gt;= t1, t1 &gt;= t2, t2 &gt;= t1)
</span><span class="noop">    (True, False, True)
</span><span class="noop">    &gt;&gt;&gt; (t1 &gt; t1, t1 &gt; t2, t2 &gt; t1)
</span><span class="noop">    (False, False, True)
</span><span class="noop">
</span><span class="noop">    Subtracting two :class:`TOY` object gives their time difference in seconds:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; TOY(&#39;1_1_0_3_0&#39;) - TOY(&#39;1_1_0_1_30&#39;)
</span><span class="noop">    90
</span><span class="noop">
</span><span class="noop">    Instead of negative values, it is always assumed that the first
</span><span class="noop">    :class:`TOY` object lies within the future (eventually within the
</span><span class="noop">    subsequent year):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; TOY(&#39;1_1_0_1_30&#39;) - TOY(&#39;12_31_23_58_30&#39;)
</span><span class="noop">    180
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _PROPERTIES = collections.OrderedDict(((&#39;month&#39;, (1, 12)),
</span><span class="noop">                                           (&#39;day&#39;, (1, 31)),
</span><span class="noop">                                           (&#39;hour&#39;, (0, 23)),
</span><span class="noop">                                           (&#39;minute&#39;, (0, 59)),
</span><span class="noop">                                           (&#39;second&#39;, (0, 59))))
</span><span class="hit">    _STARTDATE = Date(&#39;01.01.2000&#39;)
</span><span class="hit">    _ENDDATE = Date(&#39;01.01.2001&#39;)
</span><span class="noop">
</span><span class="hit">    def __init__(self, value=&#39;&#39;):
</span><span class="hit">        if isinstance(value, Date):
</span><span class="hit">            for name in self._PROPERTIES.keys():
</span><span class="hit">                self.__dict__[name] = getattr(value, name)
</span><span class="noop">        else:
</span><span class="hit">            for name in self._PROPERTIES.keys():
</span><span class="hit">                self.__dict__[name] = None
</span><span class="hit">            values = value.split(&#39;_&#39;)
</span><span class="hit">            if not values[0].isdigit():
</span><span class="hit">                del values[0]
</span><span class="hit">            for prop in self._PROPERTIES:
</span><span class="hit">                try:
</span><span class="hit">                    setattr(self, prop, values.pop(0))
</span><span class="hit">                except IndexError:
</span><span class="hit">                    if prop in (&#39;month&#39;, &#39;day&#39;):
</span><span class="hit">                        setattr(self, prop, 1)
</span><span class="noop">                    else:
</span><span class="hit">                        setattr(self, prop, 0)
</span><span class="hit">                except ValueError:
</span><span class="hit">                    objecttools.augmentexcmessage(
</span><span class="noop">                        &#39;While trying to retrieve the %s for TOY (time of &#39;
</span><span class="noop">                        &#39;year) object based on the string `%s`&#39;
</span><span class="noop">                        % (prop, value))
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, name, value):
</span><span class="hit">        if name not in self._PROPERTIES:
</span><span class="hit">            keys = list(self._PROPERTIES.keys())
</span><span class="hit">            props = &#39; or &#39;.join((&#39;, &#39;.join(keys[:-1]), keys[-1]))
</span><span class="hit">            raise AttributeError(&#39;TOY (time of year) objects only allow to &#39;
</span><span class="noop">                                 &#39;set the properties %s, but `%s` is given.&#39;
</span><span class="noop">                                 % (props, name))
</span><span class="hit">        try:
</span><span class="hit">            value = int(value)
</span><span class="hit">        except ValueError:
</span><span class="hit">            raise ValueError(&#39;For TOY (time of year) objects, all properties &#39;
</span><span class="noop">                             &#39;must be of type `int`, but the value `%s` of &#39;
</span><span class="noop">                             &#39;type `%s` given for property `%s` cannot be &#39;
</span><span class="noop">                             &#39;converted to `int`.&#39;
</span><span class="noop">                             % (value, objecttools.classname(value), name))
</span><span class="hit">        if (name == &#39;day&#39;) and (self.month is not None):
</span><span class="hit">            bounds = (1, calendar.monthrange(1999, self.month)[1])
</span><span class="hit">            if not (bounds[0] &lt;= value &lt;= bounds[1]):
</span><span class="hit">                raise ValueError(&#39;The value of property `day` of the actual &#39;
</span><span class="noop">                                 &#39;TOY (time of year) object must lie within &#39;
</span><span class="noop">                                 &#39;the range `%s`, as the month has already &#39;
</span><span class="noop">                                 &#39;been set to `%s`, but the given value is &#39;
</span><span class="noop">                                 &#39;`%s`.&#39; % (bounds, self.month, value))
</span><span class="hit">        elif (name == &#39;month&#39;) and (self.day is not None):
</span><span class="hit">            bounds = (1, calendar.monthrange(2000, value)[1])
</span><span class="hit">            if not (bounds[0] &lt;= self.day &lt;= bounds[1]):
</span><span class="hit">                raise ValueError(&#39;The value of property `month` of the actual &#39;
</span><span class="noop">                                 &#39;TOY (time of year) object must not be the &#39;
</span><span class="noop">                                 &#39;given value `%s`, as the day has already &#39;
</span><span class="noop">                                 &#39;been set to `%s`.&#39; % (value, self.day))
</span><span class="noop">        else:
</span><span class="hit">            bounds = self._PROPERTIES[name]
</span><span class="hit">            if not (bounds[0] &lt;= value &lt;= bounds[1]):
</span><span class="hit">                raise ValueError(&#39;The value of property `%s` of TOY (time of &#39;
</span><span class="noop">                                 &#39;year) objects must lie within the range &#39;
</span><span class="noop">                                 &#39;`%s`, but the given value is `%s`.&#39;
</span><span class="noop">                                 % (name, bounds, value))
</span><span class="hit">        object.__setattr__(self, name, value)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def passed_seconds(self):
</span><span class="noop">        &#34;&#34;&#34;Amount of time passed in seconds since the beginning of the year.
</span><span class="noop">
</span><span class="noop">        In the first example, the year is only one minute and thirty seconds
</span><span class="noop">        old:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import TOY
</span><span class="noop">        &gt;&gt;&gt; TOY(&#39;1_1_0_1_30&#39;).passed_seconds
</span><span class="noop">        90
</span><span class="noop">
</span><span class="noop">        The second example shows that the 29th February is generally included:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; TOY(&#39;3&#39;).passed_seconds
</span><span class="noop">        5184000
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return int((Date(self).datetime -
</span><span class="noop">                    self._STARTDATE.datetime).total_seconds())
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def left_seconds(self):
</span><span class="noop">        &#34;&#34;&#34;Remaining part of the year in seconds.
</span><span class="noop">
</span><span class="noop">        In the first example, only one minute and thirty seconds of the year
</span><span class="noop">        remain:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import TOY
</span><span class="noop">        &gt;&gt;&gt; TOY(&#39;12_31_23_58_30&#39;).left_seconds
</span><span class="noop">        90
</span><span class="noop">
</span><span class="noop">        The second example shows that the 29th February is generally included:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; TOY(&#39;2&#39;).left_seconds
</span><span class="noop">        28944000
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return int((self._ENDDATE.datetime -
</span><span class="noop">                    Date(self).datetime).total_seconds())
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="hit">        return self.passed_seconds &lt; other.passed_seconds
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="hit">        return self.passed_seconds &lt;= other.passed_seconds
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return self.passed_seconds == other.passed_seconds
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        return self.passed_seconds != other.passed_seconds
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="hit">        return self.passed_seconds &gt; other.passed_seconds
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="hit">        return self.passed_seconds &gt;= other.passed_seconds
</span><span class="noop">
</span><span class="hit">    def __sub__(self, other):
</span><span class="hit">        if self &gt;= other:
</span><span class="hit">            return self.passed_seconds - other.passed_seconds
</span><span class="noop">        else:
</span><span class="hit">            return self.passed_seconds + other.left_seconds
</span><span class="noop">
</span><span class="hit">    def __hash__(self):
</span><span class="hit">        return hash(str(self))
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="hit">        return &#34;toy_%s&#34; % &#39;_&#39;.join(str(getattr(self, prop)) for prop
</span><span class="noop">                                   in self._PROPERTIES.keys())
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return &#34;TOY(&#39;%s&#39;)&#34; % &#39;_&#39;.join(str(getattr(self, prop)) for prop
</span><span class="noop">                                      in self._PROPERTIES.keys())
</span><span class="noop">
</span><span class="hit">    __dir__ = objecttools.dir_
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/cythons/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/cythons/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="hit">import sys
</span><span class="hit">import importlib
</span><span class="noop">
</span><span class="hit">_modulenames = (&#39;pointerutils&#39;,
</span><span class="noop">                &#39;annutils&#39;,
</span><span class="noop">                &#39;configutils&#39;,
</span><span class="noop">                &#39;smoothutils&#39;)
</span><span class="noop">
</span><span class="hit">for modulename in _modulenames:
</span><span class="hit">    module = importlib.import_module(&#39;hydpy.cythons.autogen.&#39;+modulename)
</span><span class="hit">    sys.modules[&#39;hydpy.cythons.&#39;+modulename] = module
</span><span class="hit">    locals()[modulename] = module
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/cythons/modelutils.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/cythons/modelutils.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34; This module provides utilities to build and apply cython models.&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import sys
</span><span class="hit">import platform
</span><span class="hit">import shutil
</span><span class="hit">import copy
</span><span class="hit">import inspect
</span><span class="hit">import importlib
</span><span class="hit">import distutils.core
</span><span class="hit">import distutils.extension
</span><span class="noop"># from Cython import Build (the actual import command has been moved to method
</span><span class="noop"># `compile_` of class `Cythonizer` due to PyInstaller incompatibility)
</span><span class="noop">
</span><span class="hit">import math
</span><span class="hit">import functools
</span><span class="noop"># ...third party modules
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy import cythons
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="hit">from hydpy.core import magictools
</span><span class="hit">from hydpy.core import autodoctools
</span><span class="hit">from hydpy.cythons import smoothutils
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">if platform.system().lower() == &#39;windows&#39;:
</span><span class="miss">    dllextension = &#39;.pyd&#39;
</span><span class="miss">    &#34;&#34;&#34;The dll file extension on the respective system.&#34;&#34;&#34;
</span><span class="noop">else:
</span><span class="hit">    dllextension = &#39;.so&#39;
</span><span class="noop">
</span><span class="hit">TYPE2STR = {bool: &#39;bint&#39;,
</span><span class="noop">            int: &#39;numpy.&#39;+str(numpy.array([1]).dtype)+&#39;_t&#39;,
</span><span class="noop">            float: &#39;double&#39;,
</span><span class="noop">            str: &#39;str&#39;,
</span><span class="noop">            None: &#39;void&#39;}
</span><span class="noop">&#34;&#34;&#34;Maps Python types to Cython compatible type declarations.
</span><span class="noop">
</span><span class="noop">The Cython type belonging to Python&#39;s :class:`int` is selected to be in
</span><span class="noop">agreement with numpy&#39;s default integer type on the respective platform/system.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">NDIM2STR = {0: &#39;&#39;,
</span><span class="noop">            1: &#39;[:]&#39;,
</span><span class="noop">            2: &#39;[:,:]&#39;,
</span><span class="noop">            3: &#39;[:,:,:]&#39;}
</span><span class="noop">
</span><span class="hit">_nogil = &#39; nogil&#39; if pub.options.fastcython else &#39;&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Lines(list):
</span><span class="noop">    &#34;&#34;&#34;Handles lines to be written into a `.pyx` file.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, *args):
</span><span class="hit">        super(Lines, self).__init__(args)
</span><span class="noop">
</span><span class="hit">    def add(self, indent, line):
</span><span class="noop">        &#34;&#34;&#34;Appends the given text line with prefixed spaces in accordance with
</span><span class="noop">        the given number of indentation levels.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if isinstance(line, str):
</span><span class="hit">            super(Lines, self).append(indent*4*&#39; &#39; + line)
</span><span class="noop">        else:
</span><span class="hit">            for subline in line:
</span><span class="hit">                super(Lines, self).append(indent*4*&#39; &#39; + subline)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return &#39;\n&#39;.join(self) + &#39;\n&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def method_header(method_name, nogil=False, idx_as_arg=False):
</span><span class="noop">    &#34;&#34;&#34;Returns the Cython method header for methods without arguments except
</span><span class="noop">    `self`.&#34;&#34;&#34;
</span><span class="hit">    if not pub.options.fastcython:
</span><span class="miss">        nogil = False
</span><span class="hit">    header = &#39;cpdef inline void %s(self&#39; % method_name
</span><span class="hit">    header += &#39;, int idx)&#39; if idx_as_arg else &#39;)&#39;
</span><span class="hit">    header += &#39; nogil:&#39; if nogil else &#39;:&#39;
</span><span class="hit">    return header
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def decorate_method(wrapped):
</span><span class="noop">    &#34;&#34;&#34;The decorated method will return a :class:`Lines` object including
</span><span class="noop">    a method header.  However, the :class:`Lines` object will be empty if
</span><span class="noop">    the respective model does not implement a method with the same name as
</span><span class="noop">    the wrapped method.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    def wrapper(self):
</span><span class="hit">        lines = Lines()
</span><span class="hit">        if hasattr(self.model, wrapped.__name__):
</span><span class="hit">            print(&#39;            . %s&#39; % wrapped.__name__)
</span><span class="hit">            lines.add(1, method_header(wrapped.__name__, nogil=True))
</span><span class="hit">            for line in wrapped(self):
</span><span class="hit">                lines.add(2, line)
</span><span class="hit">        return lines
</span><span class="hit">    functools.update_wrapper(wrapper, wrapped)
</span><span class="hit">    wrapper.__doc__ = &#39;Lines of model method %s.&#39; % wrapped.__name__
</span><span class="hit">    return property(wrapper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Cythonizer(object):
</span><span class="noop">    &#34;&#34;&#34;Handles the writing, compiling and initialization of cython models.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        frame = inspect.currentframe().f_back
</span><span class="hit">        self.pymodule = frame.f_globals[&#39;__name__&#39;]
</span><span class="hit">        for (key, value) in frame.f_locals.items():
</span><span class="hit">            setattr(self, key, value)
</span><span class="noop">
</span><span class="hit">    def complete(self):
</span><span class="hit">        if (not pub._am_i_an_exe) and self.outdated:
</span><span class="hit">            usecython = pub.options.usecython
</span><span class="hit">            try:
</span><span class="hit">                if not pub.options.skipdoctests:
</span><span class="miss">                    pub.options.usecython = False
</span><span class="miss">                    self.tester.doit()
</span><span class="hit">                if usecython:
</span><span class="hit">                    self.doit()
</span><span class="hit">                    if not pub.options.skipdoctests:
</span><span class="miss">                        pub.options.usecython = True
</span><span class="miss">                        self.tester.doit()
</span><span class="noop">            finally:
</span><span class="hit">                pub.options.usecython = usecython
</span><span class="noop">
</span><span class="hit">    def doit(self):
</span><span class="hit">        with magictools.PrintStyle(color=33, font=4):
</span><span class="hit">            print(&#39;Translate module/package %s.&#39; % self.pyname)
</span><span class="hit">        with magictools.PrintStyle(color=33, font=2):
</span><span class="hit">            self.pyxwriter.write()
</span><span class="hit">        with magictools.PrintStyle(color=31, font=4):
</span><span class="hit">            print(&#39;Compile module %s.&#39; % self.cyname)
</span><span class="hit">        with magictools.PrintStyle(color=31, font=2):
</span><span class="hit">            self.compile_()
</span><span class="hit">            self.movedll()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def pyname(self):
</span><span class="noop">        &#34;&#34;&#34;Name of the compiled module.&#34;&#34;&#34;
</span><span class="hit">        if self.pymodule.endswith(&#39;__init__&#39;):
</span><span class="hit">            return self.pymodule.split(&#39;.&#39;)[-2]
</span><span class="noop">        else:
</span><span class="hit">            return self.pymodule.split(&#39;.&#39;)[-1]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cyname(self):
</span><span class="noop">        &#34;&#34;&#34;Name of the compiled module.&#34;&#34;&#34;
</span><span class="hit">        return &#39;c_&#39; + self.pyname
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cydirpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the directory containing the compiled modules.&#34;&#34;&#34;
</span><span class="hit">        return cythons.autogen.__path__[0]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cymodule(self):
</span><span class="noop">        &#34;&#34;&#34;The compiled module.&#34;&#34;&#34;
</span><span class="miss">        return importlib.import_module(&#39;hydpy.cythons.autogen.&#39;+self.cyname)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cyfilepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the compiled module.&#34;&#34;&#34;
</span><span class="hit">        return os.path.join(self.cydirpath, self.cyname+&#39;.pyx&#39;)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def buildpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path for temporarily build files.&#34;&#34;&#34;
</span><span class="hit">        return os.path.join(self.cydirpath, &#39;_build&#39;)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def pyxwriter(self):
</span><span class="noop">        &#34;&#34;&#34;Update the pyx file.&#34;&#34;&#34;
</span><span class="hit">        model = self.Model()
</span><span class="hit">        if hasattr(self, &#39;Parameters&#39;):
</span><span class="hit">            model.parameters = self.Parameters(vars(self))
</span><span class="noop">        else:
</span><span class="hit">            model.parameters = parametertools.Parameters(vars(self))
</span><span class="hit">        if hasattr(self, &#39;Sequences&#39;):
</span><span class="miss">            model.sequences = self.Sequences(model=model, **vars(self))
</span><span class="noop">        else:
</span><span class="hit">            model.sequences = sequencetools.Sequences(model=model,
</span><span class="noop">                                                      **vars(self))
</span><span class="hit">        return PyxWriter(self, model, self.cyfilepath)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def pysourcefiles(self):
</span><span class="noop">        &#34;&#34;&#34;All source files of the actual models Python classes and their
</span><span class="noop">        respective base classes.&#34;&#34;&#34;
</span><span class="hit">        sourcefiles = set()
</span><span class="hit">        for (name, child) in vars(self).items():
</span><span class="hit">            try:
</span><span class="hit">                parents = inspect.getmro(child)
</span><span class="hit">            except AttributeError:
</span><span class="hit">                continue
</span><span class="hit">            for parent in parents:
</span><span class="hit">                try:
</span><span class="hit">                    sourcefile = inspect.getfile(parent)
</span><span class="hit">                except TypeError:
</span><span class="hit">                    break
</span><span class="hit">                sourcefiles.add(sourcefile)
</span><span class="hit">        return Lines(*sourcefiles)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def outdated(self):
</span><span class="noop">        &#34;&#34;&#34;True if at least one of the :attr:`~Cythonizer.pysourcefiles`
</span><span class="noop">        is newer than the compiled file under :attr:`~Cythonizer.cyfilepath`,
</span><span class="noop">        otherwise False.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if not os.path.exists(self.cyfilepath):
</span><span class="hit">            return True
</span><span class="hit">        cydate = os.stat(self.cyfilepath).st_mtime
</span><span class="hit">        for pysourcefile in self.pysourcefiles:
</span><span class="hit">            pydate = os.stat(pysourcefile).st_mtime
</span><span class="hit">            if pydate &gt; cydate:
</span><span class="miss">                return True
</span><span class="hit">        return False
</span><span class="noop">
</span><span class="hit">    def compile_(self):
</span><span class="noop">        &#34;&#34;&#34;Translate cython code to C code and compile it.&#34;&#34;&#34;
</span><span class="hit">        from Cython import Build
</span><span class="hit">        argv = copy.deepcopy(sys.argv)
</span><span class="hit">        sys.argv = [sys.argv[0], &#39;build_ext&#39;, &#39;--build-lib=&#39;+self.buildpath]
</span><span class="hit">        exc_modules = [
</span><span class="noop">                distutils.extension.Extension(
</span><span class="noop">                        &#39;hydpy.cythons.autogen.&#39;+self.cyname,
</span><span class="noop">                        [self.cyfilepath], extra_compile_args=[&#39;-O2&#39;])]
</span><span class="hit">        distutils.core.setup(ext_modules=Build.cythonize(exc_modules),
</span><span class="noop">                             include_dirs=[numpy.get_include()])
</span><span class="hit">        sys.argv = argv
</span><span class="noop">
</span><span class="hit">    def movedll(self):
</span><span class="noop">        &#34;&#34;&#34;Try to find the resulting dll file and to move it into the
</span><span class="noop">        `cythons` package.
</span><span class="noop">
</span><span class="noop">        Things to be aware of:
</span><span class="noop">          * The file extension either `pyd` (Window) or `so` (Linux).
</span><span class="noop">          * The folder containing the dll file is system dependend, but is
</span><span class="noop">            always a subfolder of the `cythons` package.
</span><span class="noop">          * Under Linux, the filename might contain system information, e.g.
</span><span class="noop">            ...cpython-36m-x86_64-linux-gnu.so.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        dirinfos = os.walk(self.buildpath)
</span><span class="hit">        next(dirinfos)
</span><span class="hit">        system_dependend_filename = None
</span><span class="hit">        for dirinfo in dirinfos:
</span><span class="hit">            for filename in dirinfo[2]:
</span><span class="hit">                if (filename.startswith(self.cyname) and
</span><span class="noop">                        filename.endswith(dllextension)):
</span><span class="hit">                    system_dependend_filename = filename
</span><span class="hit">                    break
</span><span class="hit">            if system_dependend_filename:
</span><span class="hit">                try:
</span><span class="hit">                    shutil.move(os.path.join(dirinfo[0],
</span><span class="noop">                                             system_dependend_filename),
</span><span class="noop">                                os.path.join(self.cydirpath,
</span><span class="noop">                                             self.cyname+dllextension))
</span><span class="hit">                    break
</span><span class="miss">                except BaseException:
</span><span class="miss">                    prefix = (&#39;After trying to cythonize module %s, when &#39;
</span><span class="noop">                              &#39;trying to move the final cython module %s &#39;
</span><span class="noop">                              &#39;from directory %s to directory %s&#39;
</span><span class="noop">                              % (self.pyname, system_dependend_filename,
</span><span class="noop">                                 self.buildpath, self.cydirpath))
</span><span class="miss">                    suffix = (&#39;A likely error cause is that the cython module &#39;
</span><span class="noop">                              &#39;%s does already exist in this directory and is &#39;
</span><span class="noop">                              &#39;currently blocked by another Python process.  &#39;
</span><span class="noop">                              &#39;Maybe it helps to close all Python processes &#39;
</span><span class="noop">                              &#39;and restart the cyhonization afterwards.&#39;
</span><span class="noop">                              % self.cyname+dllextension)
</span><span class="miss">                    objecttools.augmentexcmessage(prefix, suffix)
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;After trying to cythonize module %s, the resulting &#39;
</span><span class="noop">                          &#39;file %s could neither be found in directory %s nor &#39;
</span><span class="noop">                          &#39;its subdirectories.  The distul report should tell &#39;
</span><span class="noop">                          &#39;whether the file has been stored somewhere else,&#39;
</span><span class="noop">                          &#39;is named somehow else, or could not be build at &#39;
</span><span class="noop">                          &#39;all.&#39; % self.buildpath)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PyxWriter(object):
</span><span class="noop">    &#34;&#34;&#34;Writes a new pyx file into framework.models.cython when initialized.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, cythonizer, model, pyxpath):
</span><span class="hit">        self.cythonizer = cythonizer
</span><span class="hit">        self.model = model
</span><span class="hit">        self.pyxpath = pyxpath
</span><span class="noop">
</span><span class="hit">    def write(self):
</span><span class="hit">        with open(self.pyxpath, &#39;w&#39;) as pxf:
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* cython options&#39;)
</span><span class="hit">            pxf.write(repr(self.cythonoptions))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* C imports&#39;)
</span><span class="hit">            pxf.write(repr(self.cimports))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* constants (if defined)&#39;)
</span><span class="hit">            pxf.write(repr(self.constants))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* parameter classes&#39;)
</span><span class="hit">            pxf.write(repr(self.parameters))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* sequence classes&#39;)
</span><span class="hit">            pxf.write(repr(self.sequences))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* numerical parameters&#39;)
</span><span class="hit">            pxf.write(repr(self.numericalparameters))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* model class&#39;)
</span><span class="hit">            print(&#39;        %s&#39; % &#39;- model attributes&#39;)
</span><span class="hit">            pxf.write(repr(self.modeldeclarations))
</span><span class="hit">            print(&#39;        %s&#39; % &#39;- standard functions&#39;)
</span><span class="hit">            pxf.write(repr(self.modelstandardfunctions))
</span><span class="hit">            print(&#39;        %s&#39; % &#39;- numeric functions&#39;)
</span><span class="hit">            pxf.write(repr(self.modelnumericfunctions))
</span><span class="hit">            print(&#39;        %s&#39; % &#39;- additional functions&#39;)
</span><span class="hit">            pxf.write(repr(self.modeluserfunctions))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cythonoptions(self):
</span><span class="noop">        &#34;&#34;&#34;Cython option lines.&#34;&#34;&#34;
</span><span class="hit">        flag = &#39;False&#39; if pub.options.fastcython else &#39;True&#39;
</span><span class="hit">        return Lines(&#39;#!python&#39;,
</span><span class="noop">                     &#39;#cython: boundscheck=%s&#39; % flag,
</span><span class="noop">                     &#39;#cython: wraparound=%s&#39; % flag,
</span><span class="noop">                     &#39;#cython: initializedcheck=%s&#39; % flag)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cimports(self):
</span><span class="noop">        &#34;&#34;&#34;Import command lines.&#34;&#34;&#34;
</span><span class="hit">        return Lines(&#39;import numpy&#39;,
</span><span class="noop">                     &#39;cimport numpy&#39;,
</span><span class="noop">                     &#39;from libc.math cimport exp, fabs, log&#39;,
</span><span class="noop">                     &#39;from libc.stdio cimport *&#39;,
</span><span class="noop">                     &#39;from libc.stdlib cimport *&#39;,
</span><span class="noop">                     &#39;import cython&#39;,
</span><span class="noop">                     &#39;from cpython.mem cimport PyMem_Malloc&#39;,
</span><span class="noop">                     &#39;from cpython.mem cimport PyMem_Realloc&#39;,
</span><span class="noop">                     &#39;from cpython.mem cimport PyMem_Free&#39;,
</span><span class="noop">                     &#39;from hydpy.cythons.autogen cimport pointerutils&#39;,
</span><span class="noop">                     &#39;from hydpy.cythons.autogen cimport configutils&#39;,
</span><span class="noop">                     &#39;from hydpy.cythons.autogen cimport smoothutils&#39;,
</span><span class="noop">                     &#39;from hydpy.cythons.autogen cimport annutils&#39;)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def constants(self):
</span><span class="noop">        &#34;&#34;&#34;Constants declaration lines.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for (name, member) in vars(self.cythonizer).items():
</span><span class="hit">            if (name.isupper() and
</span><span class="noop">                    (not inspect.isclass(member)) and
</span><span class="noop">                    (type(member) in TYPE2STR)):
</span><span class="hit">                ndim = numpy.array(member).ndim
</span><span class="hit">                ctype = TYPE2STR[type(member)] + NDIM2STR[ndim]
</span><span class="hit">                lines.add(0, &#39;cdef public %s %s = %s&#39;
</span><span class="noop">                             % (ctype, name, member))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def parameters(self):
</span><span class="noop">        &#34;&#34;&#34;Parameter declaration lines.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(0, &#39;@cython.final&#39;)
</span><span class="hit">        lines.add(0, &#39;cdef class Parameters(object):&#39;)
</span><span class="hit">        for (name, subpars) in self.model.parameters:
</span><span class="hit">            lines.add(1, &#39;cdef public %s %s&#39;
</span><span class="noop">                         % (objecttools.classname(subpars), name))
</span><span class="hit">        for (name1, subpars) in self.model.parameters:
</span><span class="hit">            print(&#39;        - %s&#39; % name1)
</span><span class="hit">            lines.add(0, &#39;@cython.final&#39;)
</span><span class="hit">            lines.add(0, &#39;cdef class %s(object):&#39;
</span><span class="noop">                         % objecttools.classname(subpars))
</span><span class="hit">            for (name2, par) in subpars:
</span><span class="hit">                try:
</span><span class="hit">                    ctype = TYPE2STR[par.TYPE] + NDIM2STR[par.NDIM]
</span><span class="hit">                except KeyError:
</span><span class="hit">                    ctype = par.TYPE + NDIM2STR[par.NDIM]
</span><span class="hit">                lines.add(1, &#39;cdef public %s %s&#39; % (ctype, name2))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def sequences(self):
</span><span class="noop">        &#34;&#34;&#34;Sequence declaration lines.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(0, &#39;@cython.final&#39;)
</span><span class="hit">        lines.add(0, &#39;cdef class Sequences(object):&#39;)
</span><span class="hit">        for (name, subseqs) in self.model.sequences:
</span><span class="hit">            lines.add(1, &#39;cdef public %s %s&#39;
</span><span class="noop">                         % (objecttools.classname(subseqs), name))
</span><span class="hit">        if getattr(self.model.sequences, &#39;states&#39;, None) is not None:
</span><span class="hit">            lines.add(1, &#39;cdef public StateSequences old_states&#39;)
</span><span class="hit">            lines.add(1, &#39;cdef public StateSequences new_states&#39;)
</span><span class="hit">        for (name1, subseqs) in self.model.sequences:
</span><span class="hit">            print(&#39;        - %s&#39; % name1)
</span><span class="hit">            lines.add(0, &#39;@cython.final&#39;)
</span><span class="hit">            lines.add(0, &#39;cdef class %s(object):&#39;
</span><span class="noop">                         % objecttools.classname(subseqs))
</span><span class="hit">            for (name2, seq) in subseqs:
</span><span class="hit">                ctype = &#39;double&#39; + NDIM2STR[seq.NDIM]
</span><span class="hit">                if isinstance(subseqs, sequencetools.LinkSequences):
</span><span class="hit">                    if seq.NDIM == 0:
</span><span class="hit">                        lines.add(1, &#39;cdef double *%s&#39; % name2)
</span><span class="hit">                    elif seq.NDIM == 1:
</span><span class="hit">                        lines.add(1, &#39;cdef double **%s&#39; % name2)
</span><span class="hit">                        lines.add(1, &#39;cdef public int len_%s&#39; % name2)
</span><span class="noop">                else:
</span><span class="hit">                    lines.add(1, &#39;cdef public %s %s&#39; % (ctype, name2))
</span><span class="hit">                lines.add(1, &#39;cdef public int _%s_ndim&#39; % name2)
</span><span class="hit">                lines.add(1, &#39;cdef public int _%s_length&#39; % name2)
</span><span class="hit">                for idx in range(seq.NDIM):
</span><span class="hit">                    lines.add(1, &#39;cdef public int _%s_length_%d&#39;
</span><span class="noop">                                 % (seq.name, idx))
</span><span class="hit">                if seq.NUMERIC:
</span><span class="hit">                    ctype_numeric = &#39;double&#39; + NDIM2STR[seq.NDIM+1]
</span><span class="hit">                    lines.add(1, &#39;cdef public %s _%s_points&#39;
</span><span class="noop">                                 % (ctype_numeric, name2))
</span><span class="hit">                    lines.add(1, &#39;cdef public %s _%s_results&#39;
</span><span class="noop">                                 % (ctype_numeric, name2))
</span><span class="hit">                    if isinstance(subseqs, sequencetools.FluxSequences):
</span><span class="hit">                        lines.add(1, &#39;cdef public %s _%s_integrals&#39;
</span><span class="noop">                                     % (ctype_numeric, name2))
</span><span class="hit">                        lines.add(1, &#39;cdef public %s _%s_sum&#39;
</span><span class="noop">                                     % (ctype, name2))
</span><span class="hit">                if isinstance(subseqs, sequencetools.IOSubSequences):
</span><span class="hit">                    lines.extend(self.iosequence(seq))
</span><span class="hit">            if isinstance(subseqs, sequencetools.InputSequences):
</span><span class="hit">                lines.extend(self.loaddata(subseqs))
</span><span class="hit">            if isinstance(subseqs, sequencetools.IOSubSequences):
</span><span class="hit">                lines.extend(self.openfiles(subseqs))
</span><span class="hit">                lines.extend(self.closefiles(subseqs))
</span><span class="hit">                if not isinstance(subseqs, sequencetools.InputSequence):
</span><span class="hit">                    lines.extend(self.savedata(subseqs))
</span><span class="hit">            if isinstance(subseqs, sequencetools.LinkSequences):
</span><span class="hit">                lines.extend(self.setpointer(subseqs))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def iosequence(self, seq):
</span><span class="noop">        &#34;&#34;&#34;Special declaration lines for the given
</span><span class="noop">        :class:`~hydpy.core.sequencetools.IOSequence` object.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cdef public bint _%s_diskflag&#39; % seq.name)
</span><span class="hit">        lines.add(1, &#39;cdef public str _%s_path&#39; % seq.name)
</span><span class="hit">        lines.add(1, &#39;cdef FILE *_%s_file&#39; % seq.name)
</span><span class="hit">        lines.add(1, &#39;cdef public bint _%s_ramflag&#39; % seq.name)
</span><span class="hit">        ctype = &#39;double&#39; + NDIM2STR[seq.NDIM+1]
</span><span class="hit">        lines.add(1, &#39;cdef public %s _%s_array&#39; % (ctype, seq.name))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def openfiles(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Open file statements.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . openfiles&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef openfiles(self, int idx):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;if self._%s_diskflag:&#39; % name)
</span><span class="hit">            lines.add(3, &#39;self._%s_file = fopen(str(self._%s_path).encode(), &#39;
</span><span class="noop">                         &#39;&#34;rb+&#34;)&#39; % (2*(name,)))
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3, &#39;fseek(self._%s_file, idx*8, SEEK_SET)&#39; % name)
</span><span class="noop">            else:
</span><span class="hit">                lines.add(3, &#39;fseek(self._%s_file, idx*self._%s_length*8, &#39;
</span><span class="noop">                             &#39;SEEK_SET)&#39; % (2*(name,)))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def closefiles(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Close file statements.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . closefiles&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline closefiles(self):&#39;)
</span><span class="hit">        for (name, seq) in sorted(subseqs):
</span><span class="hit">            lines.add(2, &#39;if self._%s_diskflag:&#39; % name)
</span><span class="hit">            lines.add(3, &#39;fclose(self._%s_file)&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def loaddata(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Load data statements.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . loaddata&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline void loaddata(self, int idx) %s:&#39; % _nogil)
</span><span class="hit">        lines.add(2, &#39;cdef int jdx0, jdx1, jdx2, jdx3, jdx4, jdx5&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;if self._%s_diskflag:&#39; % name)
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3, &#39;fread(&amp;self.%s, 8, 1, self._%s_file)&#39;
</span><span class="noop">                             % (2*(name,)))
</span><span class="noop">            else:
</span><span class="miss">                lines.add(3, &#39;fread(&amp;self.%s[0], 8, self._%s_length, &#39;
</span><span class="noop">                             &#39;self._%s_file)&#39; % (3*((name,))))
</span><span class="hit">            lines.add(2, &#39;elif self._%s_ramflag:&#39; % name)
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3, &#39;self.%s = self._%s_array[idx]&#39; % (2*(name,)))
</span><span class="noop">            else:
</span><span class="miss">                indexing = &#39;&#39;
</span><span class="miss">                for idx in range(seq.NDIM):
</span><span class="miss">                    lines.add(3+idx, &#39;for jdx%d in range(self._%s_length_%d):&#39;
</span><span class="noop">                                     % (idx, name, idx))
</span><span class="miss">                    indexing += &#39;jdx%d,&#39; % idx
</span><span class="miss">                indexing = indexing[:-1]
</span><span class="miss">                lines.add(3+seq.NDIM, &#39;self.%s[%s] = self._%s_array[idx,%s]&#39;
</span><span class="noop">                                      % (2*(name, indexing)))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def savedata(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Save data statements.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . savedata&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline void savedata(self, int idx) %s:&#39; % _nogil)
</span><span class="hit">        lines.add(2, &#39;cdef int jdx0, jdx1, jdx2, jdx3, jdx4, jdx5&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;if self._%s_diskflag:&#39; % name)
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3, &#39;fwrite(&amp;self.%s, 8, 1, self._%s_file)&#39;
</span><span class="noop">                             % (2*(name,)))
</span><span class="noop">            else:
</span><span class="hit">                lines.add(3, &#39;fwrite(&amp;self.%s[0], 8, self._%s_length, &#39;
</span><span class="noop">                             &#39;self._%s_file)&#39; % (3*(name,)))
</span><span class="hit">            lines.add(2, &#39;elif self._%s_ramflag:&#39; % name)
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3, &#39;self._%s_array[idx] = self.%s&#39; % (2*(name,)))
</span><span class="noop">            else:
</span><span class="hit">                indexing = &#39;&#39;
</span><span class="hit">                for idx in range(seq.NDIM):
</span><span class="hit">                    lines.add(3+idx, &#39;for jdx%d in range(self._%s_length_%d):&#39;
</span><span class="noop">                                     % (idx, name, idx))
</span><span class="hit">                    indexing += &#39;jdx%d,&#39; % idx
</span><span class="hit">                indexing = indexing[:-1]
</span><span class="hit">                lines.add(3+seq.NDIM, &#39;self._%s_array[idx,%s] = self.%s[%s]&#39;
</span><span class="noop">                                      % (2*(name, indexing)))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def setpointer(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Setpointer functions for link sequences.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.extend(self.setpointer0d(subseqs))
</span><span class="hit">            break
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            if seq.NDIM == 1:
</span><span class="hit">                lines.extend(self.alloc(subseqs))
</span><span class="hit">                lines.extend(self.dealloc(subseqs))
</span><span class="hit">                lines.extend(self.setpointer1d(subseqs))
</span><span class="hit">            break
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def setpointer0d(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Setpointer function for 0-dimensional link sequences.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . setpointer0d&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline setpointer0d&#39;
</span><span class="noop">                     &#39;(self, str name, pointerutils.PDouble value):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;if name == &#34;%s&#34;:&#39; % name)
</span><span class="hit">            lines.add(3, &#39;self.%s = value.p_value&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def alloc(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Allocate memory for 1-dimensional link sequences.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . setlength&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline alloc(self, name, int length):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;if name == &#34;%s&#34;:&#39; % name)
</span><span class="hit">            lines.add(3, &#39;self._%s_length_0 = length&#39; % name)
</span><span class="hit">            lines.add(3, &#39;self.%s = &lt;double**&gt; &#39;
</span><span class="noop">                         &#39;PyMem_Malloc(length * sizeof(double*))&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def dealloc(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Deallocate memory for 1-dimensional link sequences.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . dealloc&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline dealloc(self):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;PyMem_Free(self.%s)&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def setpointer1d(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Setpointer function for 1-dimensional link sequences.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . setpointer1d&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline setpointer1d&#39;
</span><span class="noop">                     &#39;(self, str name, pointerutils.PDouble value, int idx):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;if name == &#34;%s&#34;:&#39; % name)
</span><span class="hit">            lines.add(3, &#39;self.%s[idx] = value.p_value&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def numericalparameters(self):
</span><span class="noop">        &#34;&#34;&#34;Numeric parameter declaration lines.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        if self.model.NUMERICAL:
</span><span class="hit">            lines.add(0, &#39;@cython.final&#39;)
</span><span class="hit">            lines.add(0, &#39;cdef class NumConsts(object):&#39;)
</span><span class="hit">            for name in (&#39;nmb_methods&#39;, &#39;nmb_stages&#39;):
</span><span class="hit">                lines.add(1, &#39;cdef public %s %s&#39; % (TYPE2STR[int], name))
</span><span class="hit">            for name in (&#39;dt_increase&#39;, &#39;dt_decrease&#39;):
</span><span class="hit">                lines.add(1, &#39;cdef public %s %s&#39; % (TYPE2STR[float], name))
</span><span class="hit">            lines.add(1, &#39;cdef public configutils.Config pub&#39;)
</span><span class="hit">            lines.add(1, &#39;cdef public double[:, :, :] a_coefs&#39;)
</span><span class="hit">            lines.add(0, &#39;cdef class NumVars(object):&#39;)
</span><span class="hit">            for name in (&#39;nmb_calls&#39;, &#39;idx_method&#39;, &#39;idx_stage&#39;):
</span><span class="hit">                lines.add(1, &#39;cdef public %s %s&#39; % (TYPE2STR[int], name))
</span><span class="hit">            for name in (&#39;t0&#39;, &#39;t1&#39;, &#39;dt&#39;, &#39;dt_est&#39;,
</span><span class="noop">                         &#39;error&#39;, &#39;last_error&#39;, &#39;extrapolated_error&#39;):
</span><span class="hit">                lines.add(1, &#39;cdef public %s %s&#39; % (TYPE2STR[float], name))
</span><span class="hit">            lines.add(1, &#39;cdef public %s f0_ready&#39; % TYPE2STR[bool])
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def modeldeclarations(self):
</span><span class="noop">        &#34;&#34;&#34;Attribute declarations of the model class.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(0, &#39;@cython.final&#39;)
</span><span class="hit">        lines.add(0, &#39;cdef class Model(object):&#39;)
</span><span class="hit">        lines.add(1, &#39;cdef public int idx_sim&#39;)
</span><span class="hit">        lines.add(1, &#39;cdef public Parameters parameters&#39;)
</span><span class="hit">        lines.add(1, &#39;cdef public Sequences sequences&#39;)
</span><span class="hit">        if hasattr(self.model, &#39;numconsts&#39;):
</span><span class="hit">            lines.add(1, &#39;cdef public NumConsts numconsts&#39;)
</span><span class="hit">        if hasattr(self.model, &#39;numvars&#39;):
</span><span class="hit">            lines.add(1, &#39;cdef public NumVars numvars&#39;)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def modelstandardfunctions(self):
</span><span class="noop">        &#34;&#34;&#34;Standard functions of the model class.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.extend(self.doit)
</span><span class="hit">        lines.extend(self.iofunctions)
</span><span class="hit">        lines.extend(self.new2old)
</span><span class="hit">        lines.extend(self.run)
</span><span class="hit">        lines.extend(self.update_inlets)
</span><span class="hit">        lines.extend(self.update_outlets)
</span><span class="hit">        lines.extend(self.update_receivers)
</span><span class="hit">        lines.extend(self.update_senders)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def modelnumericfunctions(self):
</span><span class="noop">        &#34;&#34;&#34;Numerical functions of the model class.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.extend(self.solve)
</span><span class="hit">        lines.extend(self.calculate_single_terms)
</span><span class="hit">        lines.extend(self.calculate_full_terms)
</span><span class="hit">        lines.extend(self.get_point_states)
</span><span class="hit">        lines.extend(self.set_point_states)
</span><span class="hit">        lines.extend(self.set_result_states)
</span><span class="hit">        lines.extend(self.get_sum_fluxes)
</span><span class="hit">        lines.extend(self.set_point_fluxes)
</span><span class="hit">        lines.extend(self.set_result_fluxes)
</span><span class="hit">        lines.extend(self.integrate_fluxes)
</span><span class="hit">        lines.extend(self.reset_sum_fluxes)
</span><span class="hit">        lines.extend(self.addup_fluxes)
</span><span class="hit">        lines.extend(self.calculate_error)
</span><span class="hit">        lines.extend(self.extrapolate_error)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def doit(self):
</span><span class="noop">        &#34;&#34;&#34;Do (most of) it function of the model class.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;                . doit&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline void doit(self, int idx) %s:&#39; % _nogil)
</span><span class="hit">        lines.add(2, &#39;self.idx_sim = idx&#39;)
</span><span class="hit">        if getattr(self.model.sequences, &#39;inputs&#39;, None) is not None:
</span><span class="hit">            lines.add(2, &#39;self.loaddata()&#39;)
</span><span class="hit">        if self.model._INLET_METHODS:
</span><span class="hit">            lines.add(2, &#39;self.update_inlets()&#39;)
</span><span class="hit">        if hasattr(self.model, &#39;solve&#39;):
</span><span class="hit">            lines.add(2, &#39;self.solve()&#39;)
</span><span class="noop">        else:
</span><span class="hit">            lines.add(2, &#39;self.run()&#39;)
</span><span class="hit">            if getattr(self.model.sequences, &#39;states&#39;, None) is not None:
</span><span class="hit">                lines.add(2, &#39;self.new2old()&#39;)
</span><span class="hit">        if self.model._OUTLET_METHODS:
</span><span class="hit">            lines.add(2, &#39;self.update_outlets()&#39;)
</span><span class="hit">        if ((getattr(self.model.sequences, &#39;fluxes&#39;, None) is not None) or
</span><span class="noop">                (getattr(self.model.sequences, &#39;states&#39;, None) is not None)):
</span><span class="hit">            lines.add(2, &#39;self.savedata()&#39;)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def iofunctions(self):
</span><span class="noop">        &#34;&#34;&#34;Input/output functions of the model class.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for func in (&#39;openfiles&#39;, &#39;closefiles&#39;, &#39;loaddata&#39;, &#39;savedata&#39;):
</span><span class="hit">            if ((func == &#39;loaddata&#39;) and
</span><span class="noop">                    (getattr(self.model.sequences, &#39;inputs&#39;, None) is None)):
</span><span class="hit">                continue
</span><span class="hit">            if ((func == &#39;savedata&#39;) and
</span><span class="noop">                ((getattr(self.model.sequences, &#39;fluxes&#39;, None) is None) and
</span><span class="noop">                 (getattr(self.model.sequences, &#39;states&#39;, None) is None))):
</span><span class="miss">                continue
</span><span class="hit">            print(&#39;            . %s&#39; % func)
</span><span class="hit">            nogil = func in (&#39;loaddata&#39;, &#39;savedata&#39;)
</span><span class="hit">            lines.add(1, method_header(func, nogil=nogil))
</span><span class="hit">            for (name, subseqs) in self.model.sequences:
</span><span class="hit">                if func == &#39;loaddata&#39;:
</span><span class="hit">                    applyfuncs = (&#39;inputs&#39;,)
</span><span class="hit">                elif func == &#39;savedata&#39;:
</span><span class="hit">                    applyfuncs = (&#39;fluxes&#39;, &#39;states&#39;)
</span><span class="noop">                else:
</span><span class="hit">                    applyfuncs = (&#39;inputs&#39;, &#39;fluxes&#39;, &#39;states&#39;)
</span><span class="hit">                if name in applyfuncs:
</span><span class="hit">                    if func == &#39;closefiles&#39;:
</span><span class="hit">                        lines.add(2, &#39;self.sequences.%s.%s()&#39; % (name, func))
</span><span class="noop">                    else:
</span><span class="hit">                        lines.add(2, &#39;self.sequences.%s.%s(self.idx_sim)&#39;
</span><span class="noop">                                     % (name, func))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def new2old(self):
</span><span class="hit">        lines = Lines()
</span><span class="hit">        if getattr(self.model.sequences, &#39;states&#39;, None) is not None:
</span><span class="hit">            print(&#39;                . new2old&#39;)
</span><span class="hit">            lines.add(1, method_header(&#39;new2old&#39;, nogil=True))
</span><span class="hit">            lines.add(2, &#39;cdef int jdx0, jdx1, jdx2, jdx3, jdx4, jdx5&#39;)
</span><span class="hit">            for (name, seq) in sorted(self.model.sequences.states):
</span><span class="hit">                if seq.NDIM == 0:
</span><span class="hit">                    lines.add(2, &#39;self.sequences.old_states.%s = &#39;
</span><span class="noop">                                 &#39;self.sequences.new_states.%s&#39;
</span><span class="noop">                                 % (2*(name,)))
</span><span class="noop">                else:
</span><span class="hit">                    indexing = &#39;&#39;
</span><span class="hit">                    for idx in range(seq.NDIM):
</span><span class="hit">                        lines.add(2+idx,
</span><span class="noop">                                  &#39;for jdx%d in range(&#39;
</span><span class="noop">                                  &#39;self.sequences.states._%s_length_%d):&#39;
</span><span class="noop">                                  % (idx, name, idx))
</span><span class="hit">                        indexing += &#39;jdx%d,&#39; % idx
</span><span class="hit">                    indexing = indexing[:-1]
</span><span class="hit">                    lines.add(
</span><span class="noop">                        2+seq.NDIM,
</span><span class="noop">                        &#39;self.sequences.old_states.%s[%s] = &#39;
</span><span class="noop">                        &#39;self.sequences.new_states.%s[%s]&#39;
</span><span class="noop">                        % (2*(name, indexing)))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def _call_methods(self, name, methods, idx_as_arg=False):
</span><span class="hit">        lines = Lines()
</span><span class="hit">        if hasattr(self.model, name):
</span><span class="hit">            lines.add(1, method_header(name,
</span><span class="noop">                                       nogil=True,
</span><span class="noop">                                       idx_as_arg=idx_as_arg))
</span><span class="hit">            if idx_as_arg:
</span><span class="hit">                lines.add(2, &#39;self.idx_sim = idx&#39;)
</span><span class="hit">            anything = False
</span><span class="hit">            for method in methods:
</span><span class="hit">                lines.add(2, &#39;self.%s()&#39; % method.__name__)
</span><span class="hit">                anything = True
</span><span class="hit">            if not anything:
</span><span class="hit">                lines.add(2, &#39;pass&#39;)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def update_receivers(self):
</span><span class="noop">        &#34;&#34;&#34;Lines of model method with the same name.&#34;&#34;&#34;
</span><span class="hit">        return self._call_methods(&#39;update_receivers&#39;,
</span><span class="noop">                                  self.model._RECEIVER_METHODS,
</span><span class="noop">                                  True)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def update_inlets(self):
</span><span class="noop">        &#34;&#34;&#34;Lines of model method with the same name.&#34;&#34;&#34;
</span><span class="hit">        return self._call_methods(&#39;update_inlets&#39;,
</span><span class="noop">                                  self.model._INLET_METHODS)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def run(self):
</span><span class="noop">        &#34;&#34;&#34;Lines of model method with the same name.&#34;&#34;&#34;
</span><span class="hit">        return self._call_methods(&#39;run&#39;,
</span><span class="noop">                                  self.model._RUN_METHODS)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def update_outlets(self):
</span><span class="noop">        &#34;&#34;&#34;Lines of model method with the same name.&#34;&#34;&#34;
</span><span class="hit">        return self._call_methods(&#39;update_outlets&#39;,
</span><span class="noop">                                  self.model._OUTLET_METHODS)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def update_senders(self):
</span><span class="noop">        &#34;&#34;&#34;Lines of model method with the same name.&#34;&#34;&#34;
</span><span class="hit">        return self._call_methods(&#39;update_senders&#39;,
</span><span class="noop">                                  self.model._SENDER_METHODS,
</span><span class="noop">                                  True)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def calculate_single_terms(self):
</span><span class="noop">        &#34;&#34;&#34;Lines of model method with the same name.&#34;&#34;&#34;
</span><span class="hit">        lines = self._call_methods(&#39;calculate_single_terms&#39;,
</span><span class="noop">                                   self.model._PART_ODE_METHODS)
</span><span class="hit">        if lines:
</span><span class="hit">            lines.insert(1, (&#39;        self.numvars.nmb_calls =&#39;
</span><span class="noop">                             &#39;self.numvars.nmb_calls+1&#39;))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def calculate_full_terms(self):
</span><span class="noop">        &#34;&#34;&#34;Lines of model method with the same name.&#34;&#34;&#34;
</span><span class="hit">        return self._call_methods(&#39;calculate_full_terms&#39;,
</span><span class="noop">                                  self.model._FULL_ODE_METHODS)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def listofmodeluserfunctions(self):
</span><span class="noop">        &#34;&#34;&#34;User functions of the model class.&#34;&#34;&#34;
</span><span class="hit">        lines = []
</span><span class="hit">        for (name, member) in vars(self.model.__class__).items():
</span><span class="hit">            if (inspect.isfunction(member) and
</span><span class="noop">                    (name not in (&#39;run&#39;, &#39;new2old&#39;)) and
</span><span class="noop">                    (&#39;fastaccess&#39; in inspect.getsource(member))):
</span><span class="miss">                lines.append((name, member))
</span><span class="hit">        run = vars(self.model.__class__).get(&#39;run&#39;)
</span><span class="hit">        if run is not None:
</span><span class="miss">            lines.append((&#39;run&#39;, run))
</span><span class="hit">        for (name, member) in vars(self.model).items():
</span><span class="hit">            if (inspect.ismethod(member) and
</span><span class="noop">                    (&#39;fastaccess&#39; in inspect.getsource(member))):
</span><span class="hit">                lines.append((name, member))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def modeluserfunctions(self):
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for (name, func) in self.listofmodeluserfunctions:
</span><span class="hit">            print(&#39;            . %s&#39; % name)
</span><span class="hit">            funcconverter = FuncConverter(self.model, name, func)
</span><span class="hit">            lines.extend(funcconverter.pyxlines)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def solve(self):
</span><span class="hit">        lines = Lines()
</span><span class="hit">        if hasattr(self.model, &#39;solve&#39;):
</span><span class="hit">            print(&#39;            . solve&#39;)
</span><span class="hit">            funcconverter = FuncConverter(self.model, &#39;solve&#39;,
</span><span class="noop">                                          self.model.solve)
</span><span class="hit">            lines.extend(funcconverter.pyxlines)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def _assign_seqvalues(subseqs, subseqs_name, target, index, load):
</span><span class="hit">        from1 = &#39;self.sequences.%s.&#39; % subseqs_name + &#39;%s&#39;
</span><span class="hit">        to1 = &#39;self.sequences.%s.&#39; % subseqs_name + &#39;_%s_&#39; + target
</span><span class="hit">        if index is not None:
</span><span class="hit">            to1 += &#39;[self.numvars.%s]&#39; % index
</span><span class="hit">        if load:
</span><span class="hit">            from1, to1 = to1, from1
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            from2 = from1 % name
</span><span class="hit">            to2 = to1 % name
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                yield &#39;%s = %s&#39; % (to2, from2)
</span><span class="miss">            elif seq.NDIM == 1:
</span><span class="miss">                yield &#39;cdef int idx0&#39;
</span><span class="miss">                yield (&#39;for idx0 in range(self.sequences.%s._%s_length0):&#39;
</span><span class="noop">                       % (subseqs.name, name))
</span><span class="miss">                yield (&#39;    %s[idx0] = %s[idx0]&#39;
</span><span class="noop">                       % (to2, from2))
</span><span class="miss">            elif seq.NDIM == 2:
</span><span class="miss">                yield &#39;cdef int idx0, idx1&#39;
</span><span class="miss">                yield (&#39;for idx0 in range(self.sequences.%s._%s_length0):&#39;
</span><span class="noop">                       % (subseqs.name, name))
</span><span class="miss">                yield (&#39;    for idx1 in range(self.sequences._%s_length1):&#39;
</span><span class="noop">                       % (subseqs.name, name))
</span><span class="miss">                yield (&#39;        %s[idx0, idx1] = %s[idx0, idx1]&#39;
</span><span class="noop">                       % (to2, from2))
</span><span class="noop">            else:
</span><span class="miss">                raise NotImplementedError(
</span><span class="noop">                        &#39;NDIM of sequence `%s` is higher than expected&#39; % name)
</span><span class="noop">
</span><span class="hit">    @decorate_method
</span><span class="noop">    def get_point_states(self):
</span><span class="hit">        yield self._assign_seqvalues(subseqs=self.model.sequences.states,
</span><span class="noop">                                     subseqs_name=&#39;states&#39;,
</span><span class="noop">                                     target=&#39;points&#39;,
</span><span class="noop">                                     index=&#39;idx_stage&#39;,
</span><span class="noop">                                     load=True)
</span><span class="noop">
</span><span class="hit">    @decorate_method
</span><span class="noop">    def set_point_states(self):
</span><span class="hit">        yield self._assign_seqvalues(subseqs=self.model.sequences.states,
</span><span class="noop">                                     subseqs_name=&#39;states&#39;,
</span><span class="noop">                                     target=&#39;points&#39;,
</span><span class="noop">                                     index=&#39;idx_stage&#39;,
</span><span class="noop">                                     load=False)
</span><span class="noop">
</span><span class="hit">    @decorate_method
</span><span class="noop">    def set_result_states(self):
</span><span class="hit">        yield self._assign_seqvalues(subseqs=self.model.sequences.states,
</span><span class="noop">                                     subseqs_name=&#39;states&#39;,
</span><span class="noop">                                     target=&#39;results&#39;,
</span><span class="noop">                                     index=&#39;idx_method&#39;,
</span><span class="noop">                                     load=False)
</span><span class="noop">
</span><span class="hit">    @decorate_method
</span><span class="noop">    def get_sum_fluxes(self):
</span><span class="hit">        yield self._assign_seqvalues(subseqs=self.model.sequences.fluxes.numerics,
</span><span class="noop">                                     subseqs_name=&#39;fluxes&#39;,
</span><span class="noop">                                     target=&#39;sum&#39;,
</span><span class="noop">                                     index=None,
</span><span class="noop">                                     load=True)
</span><span class="noop">
</span><span class="hit">    @decorate_method
</span><span class="noop">    def set_point_fluxes(self):
</span><span class="hit">        yield self._assign_seqvalues(subseqs=self.model.sequences.fluxes.numerics,
</span><span class="noop">                                     subseqs_name=&#39;fluxes&#39;,
</span><span class="noop">                                     target=&#39;points&#39;,
</span><span class="noop">                                     index=&#39;idx_stage&#39;,
</span><span class="noop">                                     load=False)
</span><span class="noop">
</span><span class="hit">    @decorate_method
</span><span class="noop">    def set_result_fluxes(self):
</span><span class="hit">        yield self._assign_seqvalues(subseqs=self.model.sequences.fluxes.numerics,
</span><span class="noop">                                     subseqs_name=&#39;fluxes&#39;,
</span><span class="noop">                                     target=&#39;results&#39;,
</span><span class="noop">                                     index=&#39;idx_method&#39;,
</span><span class="noop">                                     load=False)
</span><span class="noop">
</span><span class="hit">    @decorate_method
</span><span class="noop">    def integrate_fluxes(self):
</span><span class="hit">        max_ndim = -1
</span><span class="hit">        for (name, seq) in self.model.sequences.fluxes.numerics:
</span><span class="hit">            max_ndim = max(max_ndim, seq.NDIM)
</span><span class="hit">        if max_ndim == 0:
</span><span class="hit">            yield &#39;cdef int jdx&#39;
</span><span class="miss">        elif max_ndim == 1:
</span><span class="miss">            yield &#39;cdef int jdx, idx0&#39;
</span><span class="miss">        elif max_ndim == 2:
</span><span class="miss">            yield &#39;cdef int jdx, idx0, idx1&#39;
</span><span class="hit">        for (name, seq) in self.model.sequences.fluxes.numerics:
</span><span class="hit">            to_ = &#39;self.sequences.fluxes.%s&#39; % name
</span><span class="hit">            from_ = &#39;self.sequences.fluxes._%s_points&#39; % name
</span><span class="hit">            coefs = (&#39;self.numvars.dt * self.numconsts.a_coefs&#39;
</span><span class="noop">                     &#39;[self.numvars.idx_method-1,self.numvars.idx_stage,jdx]&#39;)
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                yield &#39;%s = 0.&#39; % to_
</span><span class="hit">                yield &#39;for jdx in range(self.numvars.idx_method):&#39;
</span><span class="hit">                yield &#39;    %s = %s +%s*%s[jdx]&#39; % (to_, to_, coefs, from_)
</span><span class="miss">            elif seq.NDIM == 1:
</span><span class="miss">                yield (&#39;for idx0 in range(self.sequences.fluxes._%s_length0):&#39;
</span><span class="noop">                       % name)
</span><span class="miss">                yield &#39;    %s[idx0] = 0.&#39; % to_
</span><span class="miss">                yield &#39;    for jdx in range(self.numvars.idx_method):&#39;
</span><span class="miss">                yield (&#39;        %s[idx0] = %s[idx0] + %s*%s[jdx, idx0]&#39;
</span><span class="noop">                       % (to_, to_, coefs, from_))
</span><span class="miss">            elif seq.NDIM == 2:
</span><span class="miss">                yield (&#39;for idx0 in range(self.sequences.fluxes._%s_length0):&#39;
</span><span class="noop">                       % name)
</span><span class="miss">                yield (&#39;    for idx1 in range(&#39;
</span><span class="noop">                       &#39;self.sequences.fluxes._%s_length1):&#39; % name)
</span><span class="miss">                yield &#39;        %s[idx0, idx1] = 0.&#39; % to_
</span><span class="miss">                yield &#39;        for jdx in range(self.numvars.idx_method):&#39;
</span><span class="miss">                yield (&#39;            %s[idx0, idx1] = &#39;
</span><span class="noop">                       &#39;%s[idx0, idx1] + %s*%s[jdx, idx0, idx1]&#39;
</span><span class="noop">                       % (to_, to_, coefs, from_))
</span><span class="noop">            else:
</span><span class="miss">                raise NotImplementedError(
</span><span class="noop">                        &#39;NDIM of sequence `%s` is higher than expected&#39; % name)
</span><span class="noop">
</span><span class="hit">    @decorate_method
</span><span class="noop">    def reset_sum_fluxes(self):
</span><span class="hit">        for (name, seq) in self.model.sequences.fluxes.numerics:
</span><span class="hit">            to_ = &#39;self.sequences.fluxes._%s_sum&#39; % name
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                yield &#39;%s = 0.&#39; % to_
</span><span class="miss">            elif seq.NDIM == 1:
</span><span class="miss">                yield &#39;cdef int idx0&#39;
</span><span class="miss">                yield (&#39;for idx0 in range(self.sequences.fluxes._%s_length0):&#39;
</span><span class="noop">                       % name)
</span><span class="miss">                yield &#39;    %s[idx0] = 0.&#39; % to_
</span><span class="miss">            elif seq.NDIM == 2:
</span><span class="miss">                yield &#39;cdef int idx0, idx1&#39;
</span><span class="miss">                yield (&#39;for idx0 in range(self.sequences.fluxes._%s_length0):&#39;
</span><span class="noop">                       % name)
</span><span class="miss">                yield (&#39;    for idx1 in range(&#39;
</span><span class="noop">                       &#39;self.sequences.fluxes._%s_length1):&#39; % name)
</span><span class="miss">                yield &#39;        %s[idx0, idx1] = 0.&#39; % to_
</span><span class="noop">            else:
</span><span class="miss">                raise NotImplementedError(
</span><span class="noop">                        &#39;NDIM of sequence `%s` is higher than expected&#39; % name)
</span><span class="noop">
</span><span class="hit">    @decorate_method
</span><span class="noop">    def addup_fluxes(self):
</span><span class="hit">        for (name, seq) in self.model.sequences.fluxes.numerics:
</span><span class="hit">            to_ = &#39;self.sequences.fluxes._%s_sum&#39; % name
</span><span class="hit">            from_ = &#39;self.sequences.fluxes.%s&#39; % name
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                yield &#39;%s = %s + %s&#39; % (to_, to_, from_)
</span><span class="miss">            elif seq.NDIM == 1:
</span><span class="miss">                yield &#39;cdef int idx0&#39;
</span><span class="miss">                yield (&#39;for idx0 in range(self.sequences.fluxes._%s_length0):&#39;
</span><span class="noop">                       % name)
</span><span class="miss">                yield (&#39;    %s[idx0] = %s[idx0] + %s[idx0]&#39;
</span><span class="noop">                       % (to_, to_, from_))
</span><span class="miss">            elif seq.NDIM == 2:
</span><span class="miss">                yield &#39;cdef int idx0, idx1&#39;
</span><span class="miss">                yield (&#39;for idx0 in range(self.sequences.fluxes._%s_length0):&#39;
</span><span class="noop">                       % name)
</span><span class="miss">                yield (&#39;    for idx1 in range(&#39;
</span><span class="noop">                       &#39;self.sequences.fluxes._%s_length1):&#39; % name)
</span><span class="miss">                yield (&#39;        %s[idx0, idx1] = &#39;
</span><span class="noop">                       &#39;%s[idx0, idx1] + %s[idx0, idx1]&#39;
</span><span class="noop">                       % (to_, to_, from_))
</span><span class="noop">            else:
</span><span class="miss">                raise NotImplementedError(
</span><span class="noop">                        &#39;NDIM of sequence `%s` is higher than expected&#39; % name)
</span><span class="noop">
</span><span class="hit">    @decorate_method
</span><span class="noop">    def calculate_error(self):
</span><span class="hit">        to_ = &#39;self.numvars.error&#39;
</span><span class="hit">        index = &#39;self.numvars.idx_method&#39;
</span><span class="hit">        yield &#39;%s = 0.&#39; % to_
</span><span class="hit">        for (name, seq) in self.model.sequences.fluxes.numerics:
</span><span class="hit">            from_ = &#39;self.sequences.fluxes._%s_results&#39; % name
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                yield (&#39;%s = max(%s, fabs(%s[%s]-%s[%s-1]))&#39;
</span><span class="noop">                       % (to_, to_, from_, index, from_, index))
</span><span class="miss">            elif seq.NDIM == 1:
</span><span class="miss">                yield &#39;cdef int idx0&#39;
</span><span class="miss">                yield (&#39;for idx0 in range(self.sequences.fluxes._%s_length0):&#39;
</span><span class="noop">                       % name)
</span><span class="miss">                yield (&#39;    %s = max(%s, abs(%s[%s, idx0]-%s[%s-1, idx0]))&#39;
</span><span class="noop">                       % (to_, to_, from_, index, from_, index))
</span><span class="miss">            elif seq.NDIM == 2:
</span><span class="miss">                yield &#39;cdef int idx0, idx1&#39;
</span><span class="miss">                yield (&#39;for idx0 in range(self.sequences.fluxes._%s_length0):&#39;
</span><span class="noop">                       % name)
</span><span class="miss">                yield (&#39;    for idx1 in range(&#39;
</span><span class="noop">                       &#39;self.sequences.fluxes._%s_length1):&#39; % name)
</span><span class="miss">                yield (&#39;        %s = &#39;
</span><span class="noop">                       &#39;max(%s, abs(%s[%s, idx0, idx1]-%s[%s-1, idx0, idx1]))&#39;
</span><span class="noop">                       % (to_, to_, from_, index, from_, index))
</span><span class="noop">            else:
</span><span class="miss">                raise NotImplementedError(
</span><span class="noop">                        &#39;NDIM of sequence `%s` is higher than expected&#39; % name)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def extrapolate_error(self):
</span><span class="hit">        lines = Lines()
</span><span class="hit">        if hasattr(self.model, &#39;extrapolate_error&#39;):
</span><span class="hit">            print(&#39;            . extrapolate_error&#39;)
</span><span class="hit">            funcconverter = FuncConverter(self.model, &#39;extrapolate_error&#39;,
</span><span class="noop">                                          self.model.extrapolate_error)
</span><span class="hit">            lines.extend(funcconverter.pyxlines)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FuncConverter(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self, model, funcname, func):
</span><span class="hit">        self.model = model
</span><span class="hit">        self.funcname = funcname
</span><span class="hit">        self.func = func
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def argnames(self):
</span><span class="miss">        return inspect.getargs(self.func.__code__)[0]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def varnames(self):
</span><span class="hit">        return self.func.__code__.co_varnames
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def locnames(self):
</span><span class="miss">        return [vn for vn in self.varnames if vn not in self.argnames]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def sourcelines(self):
</span><span class="miss">        return Lines(*inspect.getsourcelines(self.func)[0])
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def collectornames(self):
</span><span class="hit">        names = []
</span><span class="hit">        for groupname in (&#39;parameters&#39;, &#39;sequences&#39;):
</span><span class="hit">            for (name, subgroup) in getattr(self.model, groupname):
</span><span class="hit">                if name[:3] in self.varnames:
</span><span class="hit">                    names.append(groupname + &#39;.&#39; + name)
</span><span class="hit">        if &#39;old&#39; in self.varnames:
</span><span class="hit">            names.append(&#39;sequences.old_states&#39;)
</span><span class="hit">        if &#39;new&#39; in self.varnames:
</span><span class="hit">            names.append(&#39;sequences.new_states&#39;)
</span><span class="hit">        return names
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def collectorshortcuts(self):
</span><span class="hit">        return [name.split(&#39;.&#39;)[-1][:3] for name in self.collectornames]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def untypedvarnames(self):
</span><span class="hit">        return [name for name in self.varnames
</span><span class="noop">                if name not in (self.collectorshortcuts + [&#39;self&#39;])]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def untypedarguments(self):
</span><span class="hit">        defline = self.cleanlines[0]
</span><span class="hit">        return [name for name in self.untypedvarnames
</span><span class="noop">                if ((&#39;, %s,&#39; % name in defline) or
</span><span class="noop">                    (&#39;, %s)&#39; % name in defline))]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def untypedinternalvarnames(self):
</span><span class="hit">        return [name for name in self.untypedvarnames if
</span><span class="noop">                name not in self.untypedarguments]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cleanlines(self):
</span><span class="noop">        &#34;&#34;&#34;Cleaned code lines.
</span><span class="noop">
</span><span class="noop">        Implemented cleanups:
</span><span class="noop">          * eventually remove method version
</span><span class="noop">          * remove docstrings
</span><span class="noop">          * remove comments
</span><span class="noop">          * remove empty lines
</span><span class="noop">          * remove line brackes within brackets
</span><span class="noop">          * replace `modelutils` with nothing
</span><span class="noop">          * remove complete lines containing `fastaccess`
</span><span class="noop">          * replace shortcuts with complete references
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        code = inspect.getsource(self.func)
</span><span class="hit">        code = &#39;\n&#39;.join(code.split(&#39;&#34;&#34;&#34;&#39;)[::2])
</span><span class="hit">        code = code.replace(&#39;modelutils.&#39;, &#39;&#39;)
</span><span class="hit">        for (name, shortcut) in zip(self.collectornames,
</span><span class="noop">                                    self.collectorshortcuts):
</span><span class="hit">            code = code.replace(&#39;%s.&#39; % shortcut, &#39;self.%s.&#39; % name)
</span><span class="hit">        code = self.remove_linebreaks_within_equations(code)
</span><span class="hit">        lines = code.splitlines()
</span><span class="hit">        self.remove_imath_operators(lines)
</span><span class="hit">        lines[0] = &#39;def %s(self):&#39; % self.funcname
</span><span class="hit">        lines = [l.split(&#39;#&#39;)[0] for l in lines]
</span><span class="hit">        lines = [l for l in lines if &#39;fastaccess&#39; not in l]
</span><span class="hit">        lines = [l.rstrip() for l in lines if l.rstrip()]
</span><span class="hit">        return Lines(*lines)
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def remove_linebreaks_within_equations(code):
</span><span class="noop">        r&#34;&#34;&#34;Remove line breaks within equations.
</span><span class="noop">
</span><span class="noop">        This is not a exhaustive test, but shows how the method works:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; code = &#39;asdf = \\\n(a\n+b)&#39;
</span><span class="noop">        &gt;&gt;&gt; from hydpy.cythons.modelutils import FuncConverter
</span><span class="noop">        &gt;&gt;&gt; FuncConverter.remove_linebreaks_within_equations(code)
</span><span class="noop">        &#39;asdf = (a+b)&#39;
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        code = code.replace(&#39;\\\n&#39;, &#39;&#39;)
</span><span class="hit">        chars = []
</span><span class="hit">        counter = 0
</span><span class="hit">        for char in code:
</span><span class="hit">            if char in (&#39;(&#39;, &#39;[&#39;, &#39;{&#39;):
</span><span class="hit">                counter += 1
</span><span class="hit">            elif char in (&#39;)&#39;, &#39;]&#39;, &#39;}&#39;):
</span><span class="hit">                counter -= 1
</span><span class="hit">            if not (counter and (char == &#39;\n&#39;)):
</span><span class="hit">                chars.append(char)
</span><span class="hit">        return &#39;&#39;.join(chars)
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def remove_imath_operators(lines):
</span><span class="noop">        &#34;&#34;&#34;Remove mathematical expressions that require Pythons global
</span><span class="noop">        interpreter locking mechanism.
</span><span class="noop">
</span><span class="noop">        This is not a exhaustive test, but shows how the method works:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; lines = [&#39;    x += 1*1&#39;]
</span><span class="noop">        &gt;&gt;&gt; from hydpy.cythons.modelutils import FuncConverter
</span><span class="noop">        &gt;&gt;&gt; FuncConverter.remove_imath_operators(lines)
</span><span class="noop">        &gt;&gt;&gt; lines
</span><span class="noop">        [&#39;    x = x + (1*1)&#39;]
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        for idx, line in enumerate(lines):
</span><span class="hit">            for operator in (&#39;+=&#39;, &#39;-=&#39;, &#39;**=&#39;, &#39;*=&#39;, &#39;//=&#39;, &#39;/=&#39;, &#39;%=&#39;):
</span><span class="hit">                sublines = line.split(operator)
</span><span class="hit">                if len(sublines) &gt; 1:
</span><span class="hit">                    indent = line.count(&#39; &#39;) - line.lstrip().count(&#39; &#39;)
</span><span class="hit">                    sublines = [sl.strip() for sl in sublines]
</span><span class="hit">                    line = (&#39;%s%s = %s %s (%s)&#39;
</span><span class="noop">                            % (indent*&#39; &#39;, sublines[0], sublines[0],
</span><span class="noop">                               operator[:-1], sublines[1]))
</span><span class="hit">                    lines[idx] = line
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def pyxlines(self):
</span><span class="noop">        &#34;&#34;&#34;Cython code lines.
</span><span class="noop">
</span><span class="noop">        Assumptions:
</span><span class="noop">          * Function shall be a method
</span><span class="noop">          * Method shall be inlined
</span><span class="noop">          * Method returns nothing
</span><span class="noop">          * Method arguments are of type `int` (except self)
</span><span class="noop">          * Local variables are of type `int`
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        lines = [&#39;    &#39;+line for line in self.cleanlines]
</span><span class="hit">        lines[0] = lines[0].replace(&#39;def &#39;, &#39;cpdef inline void &#39;)
</span><span class="hit">        lines[0] = lines[0].replace(&#39;):&#39;, &#39;) %s:&#39; % _nogil)
</span><span class="hit">        for name in self.untypedarguments:
</span><span class="miss">            lines[0] = lines[0].replace(&#39;, %s &#39; % name, &#39;, int %s &#39; % name)
</span><span class="miss">            lines[0] = lines[0].replace(&#39;, %s)&#39; % name, &#39;, int %s)&#39; % name)
</span><span class="hit">        if self.untypedinternalvarnames:
</span><span class="hit">            lines.insert(1, &#39;        cdef int &#39; +
</span><span class="noop">                            &#39;, &#39;.join(self.untypedinternalvarnames))
</span><span class="hit">        return Lines(*lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def exp(double):
</span><span class="noop">    &#34;&#34;&#34;Cython wrapper for numpys exp function applied on a single float.&#34;&#34;&#34;
</span><span class="hit">    return numpy.exp(double)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def log(double):
</span><span class="noop">    &#34;&#34;&#34;Cython wrapper for numpys log function applied on a single float.&#34;&#34;&#34;
</span><span class="hit">    return numpy.log(double)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def fabs(double):
</span><span class="noop">    &#34;&#34;&#34;Cython wrapper for maths fabs function applied on a single float.&#34;&#34;&#34;
</span><span class="hit">    return math.fabs(double)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">autodoctools.autodoc_module()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/cythons/autogen/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/cythons/autogen/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">#</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/docs/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/docs/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre></pre>
      </td>
      <td class="source">
        <pre></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/docs/apidoc.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/docs/apidoc.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="miss">import os
</span><span class="miss">import webbrowser
</span><span class="noop">
</span><span class="miss">os.system(r&#39;make clean&#39;)
</span><span class="miss">os.system(r&#39;make html&#39;)
</span><span class="noop">
</span><span class="miss">paths = [os.path.join(&#39;_build&#39;, &#39;html&#39;, fn)
</span><span class="noop">         for fn in os.listdir(os.path.join(&#39;_build&#39;, &#39;html&#39;))
</span><span class="noop">         if fn.endswith(&#39;.html&#39;)]
</span><span class="miss">for path in paths:
</span><span class="miss">    lines = []
</span><span class="miss">    for line in open(path):
</span><span class="miss">        if line.startswith(&#39;&lt;dd&gt;&lt;p&gt;alias of &lt;a class=&#34;reference external&#34;&#39;):
</span><span class="miss">            line = line.split(&#39;span&#39;)[1]
</span><span class="miss">            line = line.split(&#39;&gt;&#39;)[1]
</span><span class="miss">            line = line.split(&#39;&lt;&#39;)[0]
</span><span class="miss">            lines[-1] = lines[-1].replace(
</span><span class="noop">                    &#39;TYPE&lt;/code&gt;&#39;,
</span><span class="noop">                    &#39;TYPE&lt;/code&gt;&lt;em class=&#34;property&#34;&gt; = %s&lt;/em&gt;&#39; % line)
</span><span class="noop">        else:
</span><span class="miss">            lines.append(line)
</span><span class="miss">    open(path, &#39;w&#39;).write(&#39;&#39;.join(lines))
</span><span class="noop">
</span><span class="noop">
</span><span class="miss">os.chdir(r&#39;C:\Program Files (x86)\Mozilla Firefox&#39;)
</span><span class="miss">webbrowser.register(&#39;firefox&#39;, None, webbrowser.GenericBrowser(&#39;firefox&#39;), 1)
</span><span class="miss">webbrowser.get(&#39;firefox&#39;).open_new_tab(
</span><span class="noop">                                r&#39;C:\HydPy\hydpy\docs\_build\html\index.html&#39;)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/docs/conf.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/docs/conf.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">#
</span><span class="noop"># HydPy documentation build configuration file, created by
</span><span class="noop"># sphinx-quickstart on Thu Jun 09 14:33:31 2016.
</span><span class="noop">#
</span><span class="noop"># This file is execfile()d with the current directory set to its containing dir.
</span><span class="noop">#
</span><span class="noop"># Note that not all possible configuration values are present in this
</span><span class="noop"># autogenerated file.
</span><span class="noop">#
</span><span class="noop"># All configuration values have a default; values that are commented out
</span><span class="noop"># serve to show the default.
</span><span class="noop">
</span><span class="hit">import sys, os
</span><span class="noop">
</span><span class="noop"># If extensions (or modules to document with autodoc) are in another directory,
</span><span class="noop"># add these directories to sys.path here. If the directory is relative to the
</span><span class="noop"># documentation root, use os.path.abspath to make it absolute, like shown here.
</span><span class="hit">sys.path.insert(0, os.path.abspath(&#39;..\\..\\&#39;))
</span><span class="noop">
</span><span class="noop"># -- General configuration -----------------------------------------------------
</span><span class="noop">
</span><span class="noop"># If your documentation needs a minimal Sphinx version, state it here.
</span><span class="noop">#needs_sphinx = &#39;1.0&#39;
</span><span class="noop">
</span><span class="noop"># Add any Sphinx extension module names here, as strings. They can be extensions
</span><span class="noop"># coming with Sphinx (named &#39;sphinx.ext.*&#39;) or your custom ones.
</span><span class="hit">extensions = [&#39;sphinx.ext.autodoc&#39;,
</span><span class="noop">              &#39;sphinx.ext.napoleon&#39;,
</span><span class="noop">              &#39;sphinx.ext.intersphinx&#39;,
</span><span class="noop">              &#39;sphinx.ext.viewcode&#39;,
</span><span class="noop">              &#39;sphinx.ext.inheritance_diagram&#39;,
</span><span class="noop">              &#39;sphinx.ext.mathjax&#39;]
</span><span class="noop">
</span><span class="hit">autoclass_content = &#39;class&#39;
</span><span class="hit">autodoc_default_flags = [&#39;undoc-members&#39;]
</span><span class="hit">autodoc_member_order = &#39;bysource&#39;
</span><span class="noop">
</span><span class="noop"># Napoleon settings
</span><span class="hit">napoleon_google_docstring = False
</span><span class="hit">napoleon_numpy_docstring = False
</span><span class="hit">napoleon_include_private_with_doc = False
</span><span class="hit">napoleon_include_special_with_doc = False
</span><span class="hit">napoleon_use_admonition_for_examples = False
</span><span class="hit">napoleon_use_admonition_for_notes = False
</span><span class="hit">napoleon_use_admonition_for_references = False
</span><span class="hit">napoleon_use_ivar = False
</span><span class="hit">napoleon_use_param = False
</span><span class="hit">napoleon_use_rtype = False
</span><span class="noop">
</span><span class="hit">intersphinx_mapping = {&#39;python&#39;: (&#39;https://docs.python.org/2.7&#39;, None)}
</span><span class="noop">
</span><span class="noop"># Add any paths that contain templates here, relative to this directory.
</span><span class="hit">templates_path = [&#39;_templates&#39;]
</span><span class="noop">
</span><span class="noop"># The suffix of source filenames.
</span><span class="hit">source_suffix = &#39;.rst&#39;
</span><span class="noop">
</span><span class="noop"># The encoding of source files.
</span><span class="noop">#source_encoding = &#39;utf-8-sig&#39;
</span><span class="noop">
</span><span class="noop"># The master toctree document.
</span><span class="hit">master_doc = &#39;index&#39;
</span><span class="noop">
</span><span class="noop"># General information about the project.
</span><span class="hit">project = u&#39;HydPy&#39;
</span><span class="hit">copyright = u&#39;2017, Christoph Tyralla&#39;
</span><span class="noop">
</span><span class="noop"># The version info for the project you&#39;re documenting, acts as replacement for
</span><span class="noop"># |version| and |release|, also used in various other places throughout the
</span><span class="noop"># built documents.
</span><span class="noop">#
</span><span class="noop"># The short X.Y version.
</span><span class="hit">version = &#39;2.0&#39;
</span><span class="noop"># The full version, including alpha/beta/rc tags.
</span><span class="hit">release = &#39;2.0.0&#39;
</span><span class="noop">
</span><span class="noop"># The language for content autogenerated by Sphinx. Refer to documentation
</span><span class="noop"># for a list of supported languages.
</span><span class="noop">#language = None
</span><span class="noop">
</span><span class="noop"># There are two options for replacing |today|: either, you set today to some
</span><span class="noop"># non-false value, then it is used:
</span><span class="noop">#today = &#39;&#39;
</span><span class="noop"># Else, today_fmt is used as the format for a strftime call.
</span><span class="noop">#today_fmt = &#39;%B %d, %Y&#39;
</span><span class="noop">
</span><span class="noop"># List of patterns, relative to source directory, that match files and
</span><span class="noop"># directories to ignore when looking for source files.
</span><span class="hit">exclude_patterns = [&#39;_build&#39;]
</span><span class="noop">
</span><span class="noop"># The reST default role (used for this markup: `text`) to use for all documents.
</span><span class="noop">#default_role = None
</span><span class="noop">
</span><span class="noop"># If true, &#39;()&#39; will be appended to :func: etc. cross-reference text.
</span><span class="hit">add_function_parentheses = True
</span><span class="noop">
</span><span class="noop"># If true, the current module name will be prepended to all description
</span><span class="noop"># unit titles (such as .. function::).
</span><span class="noop">#add_module_names = True
</span><span class="noop">
</span><span class="noop"># If true, sectionauthor and moduleauthor directives will be shown in the
</span><span class="noop"># output. They are ignored by default.
</span><span class="noop">#show_authors = False
</span><span class="noop">
</span><span class="noop"># The name of the Pygments (syntax highlighting) style to use.
</span><span class="hit">pygments_style = &#39;sphinx&#39;
</span><span class="noop">
</span><span class="noop"># A list of ignored prefixes for module index sorting.
</span><span class="noop">#modindex_common_prefix = []
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># -- Options for HTML output ---------------------------------------------------
</span><span class="noop">
</span><span class="noop"># The theme to use for HTML and HTML Help pages.  See the documentation for
</span><span class="noop"># a list of builtin themes.
</span><span class="hit">html_theme = &#39;default&#39;
</span><span class="noop">
</span><span class="noop"># Theme options are theme-specific and customize the look and feel of a theme
</span><span class="noop"># further.  For a list of options available for each theme, see the
</span><span class="noop"># documentation.
</span><span class="hit">html_theme_options = {&#39;stickysidebar&#39;: True}
</span><span class="noop">
</span><span class="noop"># Add any paths that contain custom themes here, relative to this directory.
</span><span class="noop">#html_theme_path = []
</span><span class="noop">
</span><span class="noop"># The name for this set of Sphinx documents.  If None, it defaults to
</span><span class="noop"># &#34;&lt;project&gt; v&lt;release&gt; documentation&#34;.
</span><span class="noop">#html_title = None
</span><span class="noop">
</span><span class="noop"># A shorter title for the navigation bar.  Default is the same as html_title.
</span><span class="noop">#html_short_title = None
</span><span class="noop">
</span><span class="noop"># The name of an image file (relative to this directory) to place at the top
</span><span class="noop"># of the sidebar.
</span><span class="noop">#html_logo = None
</span><span class="noop">
</span><span class="noop"># The name of an image file (within the static path) to use as favicon of the
</span><span class="noop"># docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
</span><span class="noop"># pixels large.
</span><span class="noop">#html_favicon = None
</span><span class="noop">
</span><span class="noop"># Add any paths that contain custom static files (such as style sheets) here,
</span><span class="noop"># relative to this directory. They are copied after the builtin static files,
</span><span class="noop"># so a file named &#34;default.css&#34; will overwrite the builtin &#34;default.css&#34;.
</span><span class="hit">html_static_path = []
</span><span class="noop">
</span><span class="noop"># If not &#39;&#39;, a &#39;Last updated on:&#39; timestamp is inserted at every page bottom,
</span><span class="noop"># using the given strftime format.
</span><span class="noop">#html_last_updated_fmt = &#39;%b %d, %Y&#39;
</span><span class="noop">
</span><span class="noop"># If true, SmartyPants will be used to convert quotes and dashes to
</span><span class="noop"># typographically correct entities.
</span><span class="noop">#html_use_smartypants = True
</span><span class="noop">
</span><span class="noop"># Custom sidebar templates, maps document names to template names.
</span><span class="noop">#html_sidebars = {}
</span><span class="noop">
</span><span class="noop"># Additional templates that should be rendered to pages, maps page names to
</span><span class="noop"># template names.
</span><span class="noop">#html_additional_pages = {}
</span><span class="noop">
</span><span class="noop"># If false, no module index is generated.
</span><span class="noop">#html_domain_indices = True
</span><span class="noop">
</span><span class="noop"># If false, no index is generated.
</span><span class="noop">#html_use_index = True
</span><span class="noop">
</span><span class="noop"># If true, the index is split into individual pages for each letter.
</span><span class="noop">#html_split_index = False
</span><span class="noop">
</span><span class="noop"># If true, links to the reST sources are added to the pages.
</span><span class="noop">#html_show_sourcelink = True
</span><span class="noop">
</span><span class="noop"># If true, &#34;Created using Sphinx&#34; is shown in the HTML footer. Default is True.
</span><span class="noop">#html_show_sphinx = True
</span><span class="noop">
</span><span class="noop"># If true, &#34;(C) Copyright ...&#34; is shown in the HTML footer. Default is True.
</span><span class="noop">#html_show_copyright = True
</span><span class="noop">
</span><span class="noop"># If true, an OpenSearch description file will be output, and all pages will
</span><span class="noop"># contain a &lt;link&gt; tag referring to it.  The value of this option must be the
</span><span class="noop"># base URL from which the finished HTML is served.
</span><span class="noop">#html_use_opensearch = &#39;&#39;
</span><span class="noop">
</span><span class="noop"># This is the file name suffix for HTML files (e.g. &#34;.xhtml&#34;).
</span><span class="noop">#html_file_suffix = None
</span><span class="noop">
</span><span class="noop"># Output file base name for HTML help builder.
</span><span class="hit">htmlhelp_basename = &#39;HydPydoc&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># -- Options for LaTeX output --------------------------------------------------
</span><span class="noop">
</span><span class="hit">latex_elements = {
</span><span class="noop"># The paper size (&#39;letterpaper&#39; or &#39;a4paper&#39;).
</span><span class="noop">#&#39;papersize&#39;: &#39;letterpaper&#39;,
</span><span class="noop">
</span><span class="noop"># The font size (&#39;10pt&#39;, &#39;11pt&#39; or &#39;12pt&#39;).
</span><span class="noop">#&#39;pointsize&#39;: &#39;10pt&#39;,
</span><span class="noop">
</span><span class="noop"># Additional stuff for the LaTeX preamble.
</span><span class="noop">#&#39;preamble&#39;: &#39;&#39;,
</span><span class="noop">}
</span><span class="noop">
</span><span class="noop"># Grouping the document tree into LaTeX files. List of tuples
</span><span class="noop"># (source start file, target name, title, author, documentclass [howto/manual]).
</span><span class="hit">latex_documents = [
</span><span class="noop">  (&#39;index&#39;, &#39;HydPy.tex&#39;, u&#39;HydPy Documentation&#39;,
</span><span class="noop">   u&#39;Christoph Tyralla&#39;, &#39;manual&#39;),
</span><span class="noop">]
</span><span class="noop">
</span><span class="noop"># The name of an image file (relative to this directory) to place at the top of
</span><span class="noop"># the title page.
</span><span class="noop">#latex_logo = None
</span><span class="noop">
</span><span class="noop"># For &#34;manual&#34; documents, if this is true, then toplevel headings are parts,
</span><span class="noop"># not chapters.
</span><span class="noop">#latex_use_parts = False
</span><span class="noop">
</span><span class="noop"># If true, show page references after internal links.
</span><span class="noop">#latex_show_pagerefs = False
</span><span class="noop">
</span><span class="noop"># If true, show URL addresses after external links.
</span><span class="noop">#latex_show_urls = False
</span><span class="noop">
</span><span class="noop"># Documents to append as an appendix to all manuals.
</span><span class="noop">#latex_appendices = []
</span><span class="noop">
</span><span class="noop"># If false, no module index is generated.
</span><span class="noop">#latex_domain_indices = True
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># -- Options for manual page output --------------------------------------------
</span><span class="noop">
</span><span class="noop"># One entry per manual page. List of tuples
</span><span class="noop"># (source start file, name, description, authors, manual section).
</span><span class="hit">man_pages = [
</span><span class="noop">    (&#39;index&#39;, &#39;hydpy&#39;, u&#39;HydPy Documentation&#39;,
</span><span class="noop">     [u&#39;Christoph Tyralla&#39;], 1)
</span><span class="noop">]
</span><span class="noop">
</span><span class="noop"># If true, show URL addresses after external links.
</span><span class="noop">#man_show_urls = False
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># -- Options for Texinfo output ------------------------------------------------
</span><span class="noop">
</span><span class="noop"># Grouping the document tree into Texinfo files. List of tuples
</span><span class="noop"># (source start file, target name, title, author,
</span><span class="noop">#  dir menu entry, description, category)
</span><span class="hit">texinfo_documents = [
</span><span class="noop">  (&#39;index&#39;, &#39;HydPy&#39;, u&#39;HydPy Documentation&#39;,
</span><span class="noop">   u&#39;Christoph Tyralla&#39;, &#39;HydPy&#39;, &#39;One line description of project.&#39;,
</span><span class="noop">   &#39;Miscellaneous&#39;),
</span><span class="noop">]
</span><span class="noop">
</span><span class="noop"># Documents to append as an appendix to all manuals.
</span><span class="noop">#texinfo_appendices = []
</span><span class="noop">
</span><span class="noop"># If false, no module index is generated.
</span><span class="noop">#texinfo_domain_indices = True
</span><span class="noop">
</span><span class="noop"># How to display URL addresses: &#39;footnote&#39;, &#39;no&#39;, or &#39;inline&#39;.
</span><span class="noop">#texinfo_show_urls = &#39;footnote&#39;
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre></pre>
      </td>
      <td class="source">
        <pre></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Integration examples:
</span><span class="noop">
</span><span class="noop">    The following tests are performed over a period of 20 hours:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import pub, Timegrid, Timegrids, Nodes, Element
</span><span class="noop">    &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;01.01.2000 00:00&#39;,
</span><span class="noop">    ...                                    &#39;01.01.2000 20:00&#39;,
</span><span class="noop">    ...                                    &#39;1h&#39;))
</span><span class="noop">
</span><span class="noop">    Import the model and define the time settings:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.arma_v1 import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1h&#39;)
</span><span class="noop">
</span><span class="noop">    For testing purposes, the model input shall be retrieved from the nodes
</span><span class="noop">    `input1` and `input2` and the model output shall be passed to node
</span><span class="noop">    `output`.  Firstly, define all nodes:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nodes = Nodes(&#39;input1&#39;, &#39;input2&#39;, &#39;output&#39;)
</span><span class="noop">
</span><span class="noop">    Define the element &#34;stream&#34; and build the connections between
</span><span class="noop">    the nodes defined above and the `arma_v1` model instance:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; stream = Element(&#39;stream&#39;,
</span><span class="noop">    ...                  inlets=[&#39;input1&#39;, &#39;input2&#39;],
</span><span class="noop">    ...                  outlets=&#39;output&#39;)
</span><span class="noop">    &gt;&gt;&gt; stream.connect(model)
</span><span class="noop">
</span><span class="noop">    Prepare a test function object, which prints the respective values of
</span><span class="noop">    the model sequences `qin`, `qpin`, `qpout`, and `qout`.  The node sequence
</span><span class="noop">    `sim` is added in order to prove that the values calculated for `qout` are
</span><span class="noop">    actually passed to `sim`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.testtools import IntegrationTest
</span><span class="noop">    &gt;&gt;&gt; test = IntegrationTest(stream,
</span><span class="noop">    ...                        seqs=(fluxes.qin, fluxes.qpin, fluxes.qpout,
</span><span class="noop">    ...                              fluxes.qout, nodes.output.sequences.sim))
</span><span class="noop">
</span><span class="noop">    To start the respective example runs from stationary conditions, a
</span><span class="noop">    base flow value of 2m³/s is set for all values of the log sequences
</span><span class="noop">    `login` and `logout`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test.inits = ((logs.login, 2.),
</span><span class="noop">    ...               (logs.logout, 2.))
</span><span class="noop">
</span><span class="noop">    Print just the time instead of the whole date:
</span><span class="noop">    &gt;&gt;&gt; test.dateformat = &#39;%H:%M&#39;
</span><span class="noop">
</span><span class="noop">    Define two flood events, one for each lake inflow:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nodes.input1.sequences.sim.series = (
</span><span class="noop">    ...                         1., 1., 2., 4., 3., 2., 1., 1., 1., 1.,
</span><span class="noop">    ...                         1., 1., 1., 1., 1., 1., 1., 1., 1., 1.)
</span><span class="noop">    &gt;&gt;&gt; nodes.input2.sequences.sim.series = (
</span><span class="noop">    ...                         1., 2., 6., 9., 8., 6., 4., 3., 2., 1.,
</span><span class="noop">    ...                         1., 1., 1., 1., 1., 1., 1., 1., 1., 1.)
</span><span class="noop">
</span><span class="noop">    In the first example, a pure fourth order moving avarage (MA) process is
</span><span class="noop">    defined:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses(((), (0.2, 0.4, 0.3, 0.1)))
</span><span class="noop">
</span><span class="noop">    This leads to a usual &#34;unit hydrograph&#34; convolution result, where all
</span><span class="noop">    inflow &#34;impulses&#34; are seperated onto the actual and the three subsequent
</span><span class="noop">    time steps:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |  date |  qin | qpin | qpout | qout | output |
</span><span class="noop">    -----------------------------------------------
</span><span class="noop">    | 00:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
</span><span class="noop">    | 01:00 |  3.0 |  3.0 |   2.2 |  2.2 |    2.2 |
</span><span class="noop">    | 02:00 |  8.0 |  8.0 |   3.6 |  3.6 |    3.6 |
</span><span class="noop">    | 03:00 | 13.0 | 13.0 |   6.9 |  6.9 |    6.9 |
</span><span class="noop">    | 04:00 | 11.0 | 11.0 |  10.1 | 10.1 |   10.1 |
</span><span class="noop">    | 05:00 |  8.0 |  8.0 |  10.7 | 10.7 |   10.7 |
</span><span class="noop">    | 06:00 |  5.0 |  5.0 |   8.8 |  8.8 |    8.8 |
</span><span class="noop">    | 07:00 |  4.0 |  4.0 |   6.3 |  6.3 |    6.3 |
</span><span class="noop">    | 08:00 |  3.0 |  3.0 |   4.5 |  4.5 |    4.5 |
</span><span class="noop">    | 09:00 |  2.0 |  2.0 |   3.3 |  3.3 |    3.3 |
</span><span class="noop">    | 10:00 |  2.0 |  2.0 |   2.5 |  2.5 |    2.5 |
</span><span class="noop">    | 11:00 |  2.0 |  2.0 |   2.1 |  2.1 |    2.1 |
</span><span class="noop">    | 12:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
</span><span class="noop">    | 13:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
</span><span class="noop">    | 14:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
</span><span class="noop">    | 15:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
</span><span class="noop">    | 16:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
</span><span class="noop">    | 17:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
</span><span class="noop">    | 18:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
</span><span class="noop">    | 19:00 |  2.0 |  2.0 |   2.0 |  2.0 |    2.0 |
</span><span class="noop">
</span><span class="noop">    In the second example, the mimimum order the MA process is defined,
</span><span class="noop">    which is one.  The autoregression (AR) process is of order two.  Note
</span><span class="noop">    that negative AR coefficients are allowed (also note the opposite signs
</span><span class="noop">    of the coefficients contrast to the statistical literature):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses(((1.1, -0.3), (0.2,)))
</span><span class="noop">
</span><span class="noop">    Due to the AR process, the maximum time delay of some fractions of each
</span><span class="noop">    input impulse is theoretically infinite:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |  date |  qin | qpin |    qpout |     qout |   output |
</span><span class="noop">    --------------------------------------------------------
</span><span class="noop">    | 00:00 |  2.0 |  2.0 |      2.0 |      2.0 |      2.0 |
</span><span class="noop">    | 01:00 |  3.0 |  3.0 |      2.2 |      2.2 |      2.2 |
</span><span class="noop">    | 02:00 |  8.0 |  8.0 |     3.42 |     3.42 |     3.42 |
</span><span class="noop">    | 03:00 | 13.0 | 13.0 |    5.702 |    5.702 |    5.702 |
</span><span class="noop">    | 04:00 | 11.0 | 11.0 |   7.4462 |   7.4462 |   7.4462 |
</span><span class="noop">    | 05:00 |  8.0 |  8.0 |  8.08022 |  8.08022 |  8.08022 |
</span><span class="noop">    | 06:00 |  5.0 |  5.0 | 7.654382 | 7.654382 | 7.654382 |
</span><span class="noop">    | 07:00 |  4.0 |  4.0 | 6.795754 | 6.795754 | 6.795754 |
</span><span class="noop">    | 08:00 |  3.0 |  3.0 | 5.779015 | 5.779015 | 5.779015 |
</span><span class="noop">    | 09:00 |  2.0 |  2.0 |  4.71819 |  4.71819 |  4.71819 |
</span><span class="noop">    | 10:00 |  2.0 |  2.0 | 3.856305 | 3.856305 | 3.856305 |
</span><span class="noop">    | 11:00 |  2.0 |  2.0 | 3.226478 | 3.226478 | 3.226478 |
</span><span class="noop">    | 12:00 |  2.0 |  2.0 | 2.792235 | 2.792235 | 2.792235 |
</span><span class="noop">    | 13:00 |  2.0 |  2.0 | 2.503515 | 2.503515 | 2.503515 |
</span><span class="noop">    | 14:00 |  2.0 |  2.0 | 2.316196 | 2.316196 | 2.316196 |
</span><span class="noop">    | 15:00 |  2.0 |  2.0 | 2.196761 | 2.196761 | 2.196761 |
</span><span class="noop">    | 16:00 |  2.0 |  2.0 | 2.121578 | 2.121578 | 2.121578 |
</span><span class="noop">    | 17:00 |  2.0 |  2.0 | 2.074708 | 2.074708 | 2.074708 |
</span><span class="noop">    | 18:00 |  2.0 |  2.0 | 2.045705 | 2.045705 | 2.045705 |
</span><span class="noop">    | 19:00 |  2.0 |  2.0 | 2.027863 | 2.027863 | 2.027863 |
</span><span class="noop">
</span><span class="noop">    The third example equalts the second one, except in additional time
</span><span class="noop">    delay of exactly one hour, due to the changed MA process:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses(((1.1, -0.3), (0.0, 0.2)))
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |  date |  qin | qpin |    qpout |     qout |   output |
</span><span class="noop">    --------------------------------------------------------
</span><span class="noop">    | 00:00 |  2.0 |  2.0 |      2.0 |      2.0 |      2.0 |
</span><span class="noop">    | 01:00 |  3.0 |  3.0 |      2.0 |      2.0 |      2.0 |
</span><span class="noop">    | 02:00 |  8.0 |  8.0 |      2.2 |      2.2 |      2.2 |
</span><span class="noop">    | 03:00 | 13.0 | 13.0 |     3.42 |     3.42 |     3.42 |
</span><span class="noop">    | 04:00 | 11.0 | 11.0 |    5.702 |    5.702 |    5.702 |
</span><span class="noop">    | 05:00 |  8.0 |  8.0 |   7.4462 |   7.4462 |   7.4462 |
</span><span class="noop">    | 06:00 |  5.0 |  5.0 |  8.08022 |  8.08022 |  8.08022 |
</span><span class="noop">    | 07:00 |  4.0 |  4.0 | 7.654382 | 7.654382 | 7.654382 |
</span><span class="noop">    | 08:00 |  3.0 |  3.0 | 6.795754 | 6.795754 | 6.795754 |
</span><span class="noop">    | 09:00 |  2.0 |  2.0 | 5.779015 | 5.779015 | 5.779015 |
</span><span class="noop">    | 10:00 |  2.0 |  2.0 |  4.71819 |  4.71819 |  4.71819 |
</span><span class="noop">    | 11:00 |  2.0 |  2.0 | 3.856305 | 3.856305 | 3.856305 |
</span><span class="noop">    | 12:00 |  2.0 |  2.0 | 3.226478 | 3.226478 | 3.226478 |
</span><span class="noop">    | 13:00 |  2.0 |  2.0 | 2.792235 | 2.792235 | 2.792235 |
</span><span class="noop">    | 14:00 |  2.0 |  2.0 | 2.503515 | 2.503515 | 2.503515 |
</span><span class="noop">    | 15:00 |  2.0 |  2.0 | 2.316196 | 2.316196 | 2.316196 |
</span><span class="noop">    | 16:00 |  2.0 |  2.0 | 2.196761 | 2.196761 | 2.196761 |
</span><span class="noop">    | 17:00 |  2.0 |  2.0 | 2.121578 | 2.121578 | 2.121578 |
</span><span class="noop">    | 18:00 |  2.0 |  2.0 | 2.074708 | 2.074708 | 2.074708 |
</span><span class="noop">    | 19:00 |  2.0 |  2.0 | 2.045705 | 2.045705 | 2.045705 |
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses(((1.5, -0.7), (0.0, 0.2)))
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |  date |  qin | qpin |     qpout |      qout |    output |
</span><span class="noop">    -----------------------------------------------------------
</span><span class="noop">    | 00:00 |  2.0 |  2.0 |       2.0 |       2.0 |       2.0 |
</span><span class="noop">    | 01:00 |  3.0 |  3.0 |       2.0 |       2.0 |       2.0 |
</span><span class="noop">    | 02:00 |  8.0 |  8.0 |       2.2 |       2.2 |       2.2 |
</span><span class="noop">    | 03:00 | 13.0 | 13.0 |       3.5 |       3.5 |       3.5 |
</span><span class="noop">    | 04:00 | 11.0 | 11.0 |      6.31 |      6.31 |      6.31 |
</span><span class="noop">    | 05:00 |  8.0 |  8.0 |     9.215 |     9.215 |     9.215 |
</span><span class="noop">    | 06:00 |  5.0 |  5.0 |   11.0055 |   11.0055 |   11.0055 |
</span><span class="noop">    | 07:00 |  4.0 |  4.0 |  11.05775 |  11.05775 |  11.05775 |
</span><span class="noop">    | 08:00 |  3.0 |  3.0 |  9.682775 |  9.682775 |  9.682775 |
</span><span class="noop">    | 09:00 |  2.0 |  2.0 |  7.383738 |  7.383738 |  7.383738 |
</span><span class="noop">    | 10:00 |  2.0 |  2.0 |  4.697664 |  4.697664 |  4.697664 |
</span><span class="noop">    | 11:00 |  2.0 |  2.0 |  2.277879 |  2.277879 |  2.277879 |
</span><span class="noop">    | 12:00 |  2.0 |  2.0 |  0.528454 |  0.528454 |  0.528454 |
</span><span class="noop">    | 13:00 |  2.0 |  2.0 | -0.401834 | -0.401834 | -0.401834 |
</span><span class="noop">    | 14:00 |  2.0 |  2.0 | -0.572669 | -0.572669 | -0.572669 |
</span><span class="noop">    | 15:00 |  2.0 |  2.0 |  -0.17772 |  -0.17772 |  -0.17772 |
</span><span class="noop">    | 16:00 |  2.0 |  2.0 |  0.534289 |  0.534289 |  0.534289 |
</span><span class="noop">    | 17:00 |  2.0 |  2.0 |  1.325837 |  1.325837 |  1.325837 |
</span><span class="noop">    | 18:00 |  2.0 |  2.0 |  2.014753 |  2.014753 |  2.014753 |
</span><span class="noop">    | 19:00 |  2.0 |  2.0 |  2.494044 |  2.494044 |  2.494044 |
</span><span class="noop">
</span><span class="noop">    The plausiblity of the coefficients is not checked.  Be aware that
</span><span class="noop">    the water balance is only met, if the sum of all equation is one.  But
</span><span class="noop">    even then problems like negative discharge values might occur, if the
</span><span class="noop">    coefficients are not set carefully, is shown in the fourth example:
</span><span class="noop">
</span><span class="noop">    In the fifth example, the coefficients of the first two examples are
</span><span class="noop">    combined.  For inflow discharges between 0 and 7m³/s, the pure AR
</span><span class="noop">    process is applied.  For inflow discharges exceeding 7m³/s, inflow
</span><span class="noop">    is seperated.  The AR process is still applied on a portion of 7m³/s,
</span><span class="noop">    but for the inflow exceeding the threshold the mixed ARMA model is
</span><span class="noop">    applied:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses(_0=((), (0.2, 0.4, 0.3, 0.1)),
</span><span class="noop">    ...           _7=((1.1, -0.3), (0.2,)))
</span><span class="noop">
</span><span class="noop">    To again start from stationary conditions, one has to apply different
</span><span class="noop">    values to both log sequences.  The base flow value of 2m³/s is only
</span><span class="noop">    given to the (low flow) MA model, the (high flow) ARMA is initialized
</span><span class="noop">    with zero values instead:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test.inits.login = [[2.0], [0.0]]
</span><span class="noop">    &gt;&gt;&gt; test.inits.logout = [[2.0], [0.0]]
</span><span class="noop">
</span><span class="noop">    The seperate handling of the inflow can be studied by inspecting the
</span><span class="noop">    columns of sequence `qpin` and sequence `qpout`.  The respective left
</span><span class="noop">    columns show the input and output of the MA model, the respective right
</span><span class="noop">    colums show the input and output of the ARMA model:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |  date |  qin |      qpin |         qpout |     qout |   output |
</span><span class="noop">    ------------------------------------------------------------------
</span><span class="noop">    | 00:00 |  2.0 | 2.0   0.0 | 2.0       0.0 |      2.0 |      2.0 |
</span><span class="noop">    | 01:00 |  3.0 | 3.0   0.0 | 2.2       0.0 |      2.2 |      2.2 |
</span><span class="noop">    | 02:00 |  8.0 | 7.0   1.0 | 3.4       0.2 |      3.6 |      3.6 |
</span><span class="noop">    | 03:00 | 13.0 | 7.0   6.0 | 5.3      1.42 |     6.72 |     6.72 |
</span><span class="noop">    | 04:00 | 11.0 | 7.0   4.0 | 6.6     2.302 |    8.902 |    8.902 |
</span><span class="noop">    | 05:00 |  8.0 | 7.0   1.0 | 7.0    2.3062 |   9.3062 |   9.3062 |
</span><span class="noop">    | 06:00 |  5.0 | 5.0   0.0 | 6.6   1.84622 |  8.44622 |  8.44622 |
</span><span class="noop">    | 07:00 |  4.0 | 4.0   0.0 | 5.6  1.338982 | 6.938982 | 6.938982 |
</span><span class="noop">    | 08:00 |  3.0 | 3.0   0.0 | 4.4  0.919014 | 5.319014 | 5.319014 |
</span><span class="noop">    | 09:00 |  2.0 | 2.0   0.0 | 3.3  0.609221 | 3.909221 | 3.909221 |
</span><span class="noop">    | 10:00 |  2.0 | 2.0   0.0 | 2.5  0.394439 | 2.894439 | 2.894439 |
</span><span class="noop">    | 11:00 |  2.0 | 2.0   0.0 | 2.1  0.251116 | 2.351116 | 2.351116 |
</span><span class="noop">    | 12:00 |  2.0 | 2.0   0.0 | 2.0  0.157896 | 2.157896 | 2.157896 |
</span><span class="noop">    | 13:00 |  2.0 | 2.0   0.0 | 2.0  0.098351 | 2.098351 | 2.098351 |
</span><span class="noop">    | 14:00 |  2.0 | 2.0   0.0 | 2.0  0.060817 | 2.060817 | 2.060817 |
</span><span class="noop">    | 15:00 |  2.0 | 2.0   0.0 | 2.0  0.037394 | 2.037394 | 2.037394 |
</span><span class="noop">    | 16:00 |  2.0 | 2.0   0.0 | 2.0  0.022888 | 2.022888 | 2.022888 |
</span><span class="noop">    | 17:00 |  2.0 | 2.0   0.0 | 2.0  0.013959 | 2.013959 | 2.013959 |
</span><span class="noop">    | 18:00 |  2.0 | 2.0   0.0 | 2.0  0.008488 | 2.008488 | 2.008488 |
</span><span class="noop">    | 19:00 |  2.0 | 2.0   0.0 | 2.0  0.005149 | 2.005149 | 2.005149 |
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from arma
</span><span class="hit">from hydpy.models.arma import arma_model
</span><span class="hit">from hydpy.models.arma import arma_control
</span><span class="hit">from hydpy.models.arma import arma_derived
</span><span class="hit">from hydpy.models.arma import arma_fluxes
</span><span class="hit">from hydpy.models.arma import arma_logs
</span><span class="hit">from hydpy.models.arma import arma_inlets
</span><span class="hit">from hydpy.models.arma import arma_outlets
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;Rimo/Rido version of ARMA (arma_v1).&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _INLET_METHODS = (arma_model.pick_q_v1,)
</span><span class="hit">    _RUN_METHODS = (arma_model.calc_qpin_v1,
</span><span class="noop">                    arma_model.calc_login_v1,
</span><span class="noop">                    arma_model.calc_qma_v1,
</span><span class="noop">                    arma_model.calc_qar_v1,
</span><span class="noop">                    arma_model.calc_qpout_v1,
</span><span class="noop">                    arma_model.calc_logout_v1,
</span><span class="noop">                    arma_model.calc_qout_v1)
</span><span class="hit">    _OUTLET_METHODS = (arma_model.pass_q_v1,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of arma_v1, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (arma_control.Responses,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of arma_v1, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (arma_derived.Nmb,
</span><span class="noop">                   arma_derived.MaxQ,
</span><span class="noop">                   arma_derived.DiffQ,
</span><span class="noop">                   arma_derived.AR_Order,
</span><span class="noop">                   arma_derived.MA_Order,
</span><span class="noop">                   arma_derived.AR_Coefs,
</span><span class="noop">                   arma_derived.MA_Coefs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of arma_v1&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (arma_fluxes.QIn,
</span><span class="noop">                   arma_fluxes.QPIn,
</span><span class="noop">                   arma_fluxes.QMA,
</span><span class="noop">                   arma_fluxes.QAR,
</span><span class="noop">                   arma_fluxes.QPOut,
</span><span class="noop">                   arma_fluxes.QOut)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequences(sequencetools.LogSequences):
</span><span class="noop">    &#34;&#34;&#34;Log sequences of arma_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (arma_logs.LogIn,
</span><span class="noop">                   arma_logs.LogOut)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of arma_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (arma_inlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of arma_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (arma_outlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">Obviously, using the &#34;smoothly applied&#34; parameter `remotedischargesavety`
</span><span class="noop">can be beneficial.  But the proper definition of the values of the
</span><span class="noop">&#34;smoothing parameters&#34; of the dam model might require some experience.
</span><span class="noop">It seems advisable to investigate the functioning of each new
</span><span class="noop">model parameterization on a large number of synthetic and/or measured
</span><span class="noop">drought events.
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">Integration examples:
</span><span class="noop">
</span><span class="noop">    The following are performed over a period of 20 days:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import pub, Timegrid, Timegrids
</span><span class="noop">    &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;01.01.2000&#39;,
</span><span class="noop">    ...                                    &#39;21.01.2000&#39;,
</span><span class="noop">    ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">    The first examples are supposed to demonstrate how drought events at a
</span><span class="noop">    cross section far downstream are reduced by the corresponding methods of
</span><span class="noop">    the dam model under different configurations.  To show this in a
</span><span class="noop">    realistic manner, a relatively complex setting is required.  We will
</span><span class="noop">    make use of the :mod:`~hydpy.models.arma_v1` application model.  This
</span><span class="noop">    model will be used to route the outflow of the dam to the cross section
</span><span class="noop">    under investigation and add some `natural` discharge of the subcatchment
</span><span class="noop">    between the dam and the cross section (a picture would be helful).
</span><span class="noop">
</span><span class="noop">    We define four nodes.  The `input` node is used to define the inflow into
</span><span class="noop">    the dam and the `natural` node is used to define the additional discharge
</span><span class="noop">    of the subcatchment.  The `output` node receives the (unmodified) outflow
</span><span class="noop">    out of dam and the `remote` node receives both the routed outflow of the
</span><span class="noop">    dam and the additional discharge of the subcatchment:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import Node
</span><span class="noop">    &gt;&gt;&gt; input_ = Node(&#39;input&#39;)
</span><span class="noop">    &gt;&gt;&gt; output = Node(&#39;output&#39;)
</span><span class="noop">    &gt;&gt;&gt; natural = Node(&#39;natural&#39;)
</span><span class="noop">    &gt;&gt;&gt; remote = Node(&#39;remote&#39;)
</span><span class="noop">
</span><span class="noop">    These nodes are used to connect the following three elements.  There is
</span><span class="noop">    one element for handling the `dam` model and there are two elements for
</span><span class="noop">    handling different `stream` models.  The model of element `stream1` is
</span><span class="noop">    supposed to route the outflow of the dam model with significant delay
</span><span class="noop">    and the model of element `stream2` is supposed to directly pass the
</span><span class="noop">    discharge of the subcatchment:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import Element
</span><span class="noop">    &gt;&gt;&gt; dam = Element(&#39;dam&#39;, inlets=input_, outlets=output, receivers=remote)
</span><span class="noop">    &gt;&gt;&gt; stream1 = Element(&#39;stream1&#39;, inlets=output, outlets=remote)
</span><span class="noop">    &gt;&gt;&gt; stream2 = Element(&#39;stream2&#39;, inlets=natural, outlets=remote)
</span><span class="noop">
</span><span class="noop">    Now the models can be prepared.  We begin with the `stream2` model.
</span><span class="noop">    By setting the `responses` parameter in the following manner we define
</span><span class="noop">    a pure Moving Average model that neither results in translation nor
</span><span class="noop">    retention processes:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.magictools import prepare_model
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models import arma_v1
</span><span class="noop">    &gt;&gt;&gt; arma_model = prepare_model(arma_v1)
</span><span class="noop">    &gt;&gt;&gt; stream2.connect(arma_model)
</span><span class="noop">    &gt;&gt;&gt; arma_model.parameters.control.responses(((), (1.0,)))
</span><span class="noop">    &gt;&gt;&gt; arma_model.parameters.update()
</span><span class="noop">
</span><span class="noop">    The second stream model is also configured as pure Moving Average model
</span><span class="noop">    but with a time delay of 1.8 days:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; arma_model = prepare_model(arma_v1)
</span><span class="noop">    &gt;&gt;&gt; stream1.connect(arma_model)
</span><span class="noop">    &gt;&gt;&gt; arma_model.parameters.control.responses(((), (0.2, 0.4, 0.3, 0.1)))
</span><span class="noop">    &gt;&gt;&gt; arma_model.parameters.update()
</span><span class="noop">    &gt;&gt;&gt; arma_model.sequences.logs.login = 0.0
</span><span class="noop">
</span><span class="noop">    Last but not least, the dam model is initialized and handed over to its
</span><span class="noop">    the `dam` element (different sets of parameters will be defined in the
</span><span class="noop">    examples below):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.dam_v1 import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; dam.connect(model)
</span><span class="noop">
</span><span class="noop">    To execute the following examples conveniently, a test function object
</span><span class="noop">    is prepared:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.testtools import IntegrationTest
</span><span class="noop">    &gt;&gt;&gt; test = IntegrationTest(dam,
</span><span class="noop">    ...                        inits=((states.watervolume, 0.0),
</span><span class="noop">    ...                               (logs.loggedtotalremotedischarge, 1.9),
</span><span class="noop">    ...                               (logs.loggedoutflow, 0.0),
</span><span class="noop">    ...                               (stream1.model.sequences.logs.login, 0.0)))
</span><span class="noop">    &gt;&gt;&gt; test.dateformat = &#39;%d.%m.&#39;
</span><span class="noop">
</span><span class="noop">    Next the drought event needs to be defined.  The natural discharge of
</span><span class="noop">    the subcatchment decreases constantly for 9 days, than stays at constant
</span><span class="noop">    level of 1 m³/s for 4 days, and finally increases constantly again:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; natural.sequences.sim.series = [
</span><span class="noop">    ...         1.8, 1.7, 1.6, 1.5, 1.4, 1.3, 1.2, 1.1, 1.0, 1.0,
</span><span class="noop">    ...         1.0, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8]
</span><span class="noop">
</span><span class="noop">    The inflow into the dam is assumened to remain constant for the whole
</span><span class="noop">    simulation period:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; input_.sequences.sim.series = 1.0
</span><span class="noop">
</span><span class="noop">    Finally, we can set the parameter values of the dam model.  For the sake
</span><span class="noop">    of simplicity, the relationship between water level and volume is assumed
</span><span class="noop">    to be linear in the range relevant for the following examples (between
</span><span class="noop">    0 to 25 m or 0 to 1e8 m³).  This is approximately true if with the
</span><span class="noop">    following configuration of the `watervolume2waterlevel` parameter:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; watervolume2waterlevel(
</span><span class="noop">    ...         weights_input=1e-6, weights_output=1e6,
</span><span class="noop">    ...         intercepts_hidden=0.0, intercepts_output=-1e6/2)
</span><span class="noop">    &gt;&gt;&gt; #The following plot confirms the linearity of the defined relationship:
</span><span class="noop">    &gt;&gt;&gt; watervolume2waterlevel.plot(0.0, 100.)
</span><span class="noop">
</span><span class="noop">    Either close the plot manually or write the following lines:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from matplotlib import pyplot
</span><span class="noop">    &gt;&gt;&gt; pyplot.close()
</span><span class="noop">
</span><span class="noop">    To focus on the drought related algorithms solely we turn of the flood
</span><span class="noop">    related processes.  This is accomplished by setting the weights and
</span><span class="noop">    intercepts of the `waterlevel2flooddischarge` to zero:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; waterlevel2flooddischarge(
</span><span class="noop">    ...        weights_input=0.0, weights_output=0.0,
</span><span class="noop">    ...        intercepts_hidden=0.0, intercepts_output=0.0)
</span><span class="noop">    &gt;&gt;&gt; waterlevel2flooddischarge.plot(0.0, 25.0)
</span><span class="noop">    &gt;&gt;&gt; pyplot.close()
</span><span class="noop">
</span><span class="noop">    To confirm that the whole scenario is properly aranged, we also turn of
</span><span class="noop">    of the drought related methods at first:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nmblogentries(1)
</span><span class="noop">    &gt;&gt;&gt; remotedischargeminimum(0.0)
</span><span class="noop">    &gt;&gt;&gt; remotedischargesavety(0.0)
</span><span class="noop">    &gt;&gt;&gt; neardischargeminimumthreshold(0.0)
</span><span class="noop">    &gt;&gt;&gt; neardischargeminimumtolerance(0.0)
</span><span class="noop">    &gt;&gt;&gt; waterlevelminimumthreshold(0.0)
</span><span class="noop">    &gt;&gt;&gt; waterlevelminimumtolerance(0.0)
</span><span class="noop">
</span><span class="noop">    Also, we have to define the area of the catchment draining into the dam.
</span><span class="noop">    The information is required for adjusting the numerical local truncation
</span><span class="noop">    error only.  For a catchment area of 86.4 km² the general local truncation
</span><span class="noop">    error (in mm per simulation step) is identical with the actually applied
</span><span class="noop">    site specific local truncation error (in m³/s):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; catchmentarea(86.4)
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; round_(solver.abserrormax.INIT)
</span><span class="noop">    0.01
</span><span class="noop">    &gt;&gt;&gt; parameters.update()
</span><span class="noop">    &gt;&gt;&gt; solver.abserrormax
</span><span class="noop">    abserrormax(0.01)
</span><span class="noop">
</span><span class="noop">    The following table confirms that the dam model does not release any
</span><span class="noop">    discharge (row `output` contains zero values only).  Hence the
</span><span class="noop">    discharge at the cross section downstream (row `remote`) is identical
</span><span class="noop">    with the discharge of the subcatchment (row `natural`):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge | outflow | watervolume | input | natural | output | remote |
</span><span class="noop">    -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |    1.0 |                  nan |                    1.9 |          0.0 |          -1.9 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      0.0864 |   1.0 |     1.8 |    0.0 |    1.8 |
</span><span class="noop">    | 02.01. |    1.0 |                  1.8 |                    1.8 |          0.0 |          -1.8 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      0.1728 |   1.0 |     1.7 |    0.0 |    1.7 |
</span><span class="noop">    | 03.01. |    1.0 |                  1.7 |                    1.7 |          0.0 |          -1.7 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      0.2592 |   1.0 |     1.6 |    0.0 |    1.6 |
</span><span class="noop">    | 04.01. |    1.0 |                  1.6 |                    1.6 |          0.0 |          -1.6 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      0.3456 |   1.0 |     1.5 |    0.0 |    1.5 |
</span><span class="noop">    | 05.01. |    1.0 |                  1.5 |                    1.5 |          0.0 |          -1.5 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |       0.432 |   1.0 |     1.4 |    0.0 |    1.4 |
</span><span class="noop">    | 06.01. |    1.0 |                  1.4 |                    1.4 |          0.0 |          -1.4 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      0.5184 |   1.0 |     1.3 |    0.0 |    1.3 |
</span><span class="noop">    | 07.01. |    1.0 |                  1.3 |                    1.3 |          0.0 |          -1.3 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      0.6048 |   1.0 |     1.2 |    0.0 |    1.2 |
</span><span class="noop">    | 08.01. |    1.0 |                  1.2 |                    1.2 |          0.0 |          -1.2 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      0.6912 |   1.0 |     1.1 |    0.0 |    1.1 |
</span><span class="noop">    | 09.01. |    1.0 |                  1.1 |                    1.1 |          0.0 |          -1.1 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      0.7776 |   1.0 |     1.0 |    0.0 |    1.0 |
</span><span class="noop">    | 10.01. |    1.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |       0.864 |   1.0 |     1.0 |    0.0 |    1.0 |
</span><span class="noop">    | 11.01. |    1.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      0.9504 |   1.0 |     1.0 |    0.0 |    1.0 |
</span><span class="noop">    | 12.01. |    1.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      1.0368 |   1.0 |     1.0 |    0.0 |    1.0 |
</span><span class="noop">    | 13.01. |    1.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      1.1232 |   1.0 |     1.1 |    0.0 |    1.1 |
</span><span class="noop">    | 14.01. |    1.0 |                  1.1 |                    1.1 |          0.0 |          -1.1 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      1.2096 |   1.0 |     1.2 |    0.0 |    1.2 |
</span><span class="noop">    | 15.01. |    1.0 |                  1.2 |                    1.2 |          0.0 |          -1.2 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |       1.296 |   1.0 |     1.3 |    0.0 |    1.3 |
</span><span class="noop">    | 16.01. |    1.0 |                  1.3 |                    1.3 |          0.0 |          -1.3 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      1.3824 |   1.0 |     1.4 |    0.0 |    1.4 |
</span><span class="noop">    | 17.01. |    1.0 |                  1.4 |                    1.4 |          0.0 |          -1.4 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      1.4688 |   1.0 |     1.5 |    0.0 |    1.5 |
</span><span class="noop">    | 18.01. |    1.0 |                  1.5 |                    1.5 |          0.0 |          -1.5 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      1.5552 |   1.0 |     1.6 |    0.0 |    1.6 |
</span><span class="noop">    | 19.01. |    1.0 |                  1.6 |                    1.6 |          0.0 |          -1.6 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |      1.6416 |   1.0 |     1.7 |    0.0 |    1.7 |
</span><span class="noop">    | 20.01. |    1.0 |                  1.7 |                    1.7 |          0.0 |          -1.7 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |     0.0 |       1.728 |   1.0 |     1.8 |    0.0 |    1.8 |
</span><span class="noop">
</span><span class="noop">    Note that the first value of sequence `totalremotedischarge` is `nan`.
</span><span class="noop">    This is due to a time delay of one simulation step.  `totalremotedischarge`
</span><span class="noop">    knows the last value of the remote node, which has not been defined
</span><span class="noop">    initially.  Hence, in this and the following examples, the first value
</span><span class="noop">    of sequence `totalremotedischarge` can be ignored.
</span><span class="noop">
</span><span class="noop">    Next the discharge that should not be undercut at the cross section
</span><span class="noop">    downstream is set to 1.4 m³/s:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; remotedischargeminimum(1.4)
</span><span class="noop">
</span><span class="noop">    The dam model decreases the drought but is not very successful in
</span><span class="noop">    doing so.  The lowest discharge at the cross section is increased from
</span><span class="noop">    1 m³/s to approximately 1.2 m³/s in the beginning of the event, which
</span><span class="noop">    is still below the threshold value of 1.4 m³/s.  Furthermore, in the
</span><span class="noop">    second half of the event too much discharge is released.  On January 12,
</span><span class="noop">    the discharge at the cross section is increased from 1 m³/s to
</span><span class="noop">    approximately 1.6 m³/s:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume | input | natural |   output |   remote |
</span><span class="noop">    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |    1.0 |                  1.8 |                    1.9 |          0.0 |          -0.5 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |      0.0864 |   1.0 |     1.8 |      0.0 |      1.8 |
</span><span class="noop">    | 02.01. |    1.0 |                  1.8 |                    1.8 |          0.0 |          -0.4 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |      0.1728 |   1.0 |     1.7 |      0.0 |      1.7 |
</span><span class="noop">    | 03.01. |    1.0 |                  1.7 |                    1.7 |          0.0 |          -0.3 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |      0.2592 |   1.0 |     1.6 |      0.0 |      1.6 |
</span><span class="noop">    | 04.01. |    1.0 |                  1.6 |                    1.6 |          0.0 |          -0.2 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |      0.3456 |   1.0 |     1.5 |      0.0 |      1.5 |
</span><span class="noop">    | 05.01. |    1.0 |                  1.5 |                    1.5 |          0.0 |          -0.1 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |       0.432 |   1.0 |     1.4 |      0.0 |      1.4 |
</span><span class="noop">    | 06.01. |    1.0 |                  1.4 |                    1.4 |          0.0 |           0.0 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |      0.5184 |   1.0 |     1.3 |      0.0 |      1.3 |
</span><span class="noop">    | 07.01. |    1.0 |                  1.3 |                    1.3 |          0.1 |           0.1 |                   0.1 |             0.1 |             0.1 |           0.1 |            0.0 |      0.1 |     0.59616 |   1.0 |     1.2 |      0.1 |     1.22 |
</span><span class="noop">    | 08.01. |    1.0 |                 1.22 |                   1.12 |         0.28 |          0.18 |                  0.28 |            0.28 |            0.28 |          0.28 |            0.0 |     0.28 |    0.658368 |   1.0 |     1.1 |     0.28 |    1.196 |
</span><span class="noop">    | 09.01. |    1.0 |                1.196 |                  0.916 |        0.484 |         0.204 |                 0.484 |           0.484 |           0.484 |         0.484 |            0.0 |    0.484 |     0.70295 |   1.0 |     1.0 |    0.484 |   1.2388 |
</span><span class="noop">    | 10.01. |    1.0 |               1.2388 |                 0.7548 |       0.6452 |        0.1612 |                0.6452 |          0.6452 |          0.6452 |        0.6452 |            0.0 |   0.6452 |    0.733605 |   1.0 |     1.0 |   0.6452 |  1.41664 |
</span><span class="noop">    | 11.01. |    1.0 |              1.41664 |                0.77144 |      0.62856 |      -0.01664 |               0.62856 |         0.62856 |         0.62856 |       0.62856 |            0.0 |  0.62856 |    0.765698 |   1.0 |     1.0 |  0.62856 | 1.556992 |
</span><span class="noop">    | 12.01. |    1.0 |             1.556992 |               0.928432 |     0.471568 |     -0.156992 |              0.471568 |        0.471568 |        0.471568 |      0.471568 |            0.0 | 0.471568 |    0.811354 |   1.0 |     1.0 | 0.471568 | 1.587698 |
</span><span class="noop">    | 13.01. |    1.0 |             1.587698 |                1.11613 |      0.28387 |     -0.187698 |               0.28387 |         0.28387 |         0.28387 |       0.28387 |            0.0 |  0.28387 |    0.873228 |   1.0 |     1.1 |  0.28387 | 1.598489 |
</span><span class="noop">    | 14.01. |    1.0 |             1.598489 |               1.314619 |     0.085381 |     -0.198489 |              0.085381 |        0.085381 |        0.085381 |      0.085381 |            0.0 | 0.085381 |    0.952251 |   1.0 |     1.2 | 0.085381 | 1.534951 |
</span><span class="noop">    | 15.01. |    1.0 |             1.534951 |                1.44957 |          0.0 |     -0.134951 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |    1.038651 |   1.0 |     1.3 |      0.0 |  1.46647 |
</span><span class="noop">    | 16.01. |    1.0 |              1.46647 |                1.46647 |          0.0 |      -0.06647 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |    1.125051 |   1.0 |     1.4 |      0.0 | 1.454001 |
</span><span class="noop">    | 17.01. |    1.0 |             1.454001 |               1.454001 |          0.0 |     -0.054001 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |    1.211451 |   1.0 |     1.5 |      0.0 | 1.508538 |
</span><span class="noop">    | 18.01. |    1.0 |             1.508538 |               1.508538 |          0.0 |     -0.108538 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |    1.297851 |   1.0 |     1.6 |      0.0 |      1.6 |
</span><span class="noop">    | 19.01. |    1.0 |                  1.6 |                    1.6 |          0.0 |          -0.2 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |    1.384251 |   1.0 |     1.7 |      0.0 |      1.7 |
</span><span class="noop">    | 20.01. |    1.0 |                  1.7 |                    1.7 |          0.0 |          -0.3 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |    1.470651 |   1.0 |     1.8 |      0.0 |      1.8 |
</span><span class="noop">
</span><span class="noop">    The qualified success in the example above is due to the time delay
</span><span class="noop">    of the information flow from the cross section to the dam and, more
</span><span class="noop">    importantly, due to the travel time of the discharge released.
</span><span class="noop">    A simple strategy to increase reliability would be to set a higher
</span><span class="noop">    value for parameter `remotedischargeminimum`, e.g.:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; remotedischargeminimum(1.6)
</span><span class="noop">
</span><span class="noop">    Now there is only a small violation of threshold value on January, 6:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume | input | natural |   output |   remote |
</span><span class="noop">    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |    1.0 |                  1.8 |                    1.9 |          0.0 |          -0.3 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |      0.0864 |   1.0 |     1.8 |      0.0 |      1.8 |
</span><span class="noop">    | 02.01. |    1.0 |                  1.8 |                    1.8 |          0.0 |          -0.2 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |      0.1728 |   1.0 |     1.7 |      0.0 |      1.7 |
</span><span class="noop">    | 03.01. |    1.0 |                  1.7 |                    1.7 |          0.0 |          -0.1 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |      0.2592 |   1.0 |     1.6 |      0.0 |      1.6 |
</span><span class="noop">    | 04.01. |    1.0 |                  1.6 |                    1.6 |          0.0 |           0.0 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |      0.3456 |   1.0 |     1.5 |      0.0 |      1.5 |
</span><span class="noop">    | 05.01. |    1.0 |                  1.5 |                    1.5 |          0.1 |           0.1 |                   0.1 |             0.1 |             0.1 |           0.1 |            0.0 |      0.1 |     0.42336 |   1.0 |     1.4 |      0.1 |     1.42 |
</span><span class="noop">    | 06.01. |    1.0 |                 1.42 |                   1.32 |         0.28 |          0.18 |                  0.28 |            0.28 |            0.28 |          0.28 |            0.0 |     0.28 |    0.485568 |   1.0 |     1.3 |     0.28 |    1.396 |
</span><span class="noop">    | 07.01. |    1.0 |                1.396 |                  1.116 |        0.484 |         0.204 |                 0.484 |           0.484 |           0.484 |         0.484 |            0.0 |    0.484 |     0.53015 |   1.0 |     1.2 |    0.484 |   1.4388 |
</span><span class="noop">    | 08.01. |    1.0 |               1.4388 |                 0.9548 |       0.6452 |        0.1612 |                0.6452 |          0.6452 |          0.6452 |        0.6452 |            0.0 |   0.6452 |    0.560805 |   1.0 |     1.1 |   0.6452 |  1.51664 |
</span><span class="noop">    | 09.01. |    1.0 |              1.51664 |                0.87144 |      0.72856 |       0.08336 |               0.72856 |         0.72856 |         0.72856 |       0.72856 |            0.0 |  0.72856 |    0.584258 |   1.0 |     1.0 |  0.72856 | 1.576992 |
</span><span class="noop">    | 10.01. |    1.0 |             1.576992 |               0.848432 |     0.751568 |      0.023008 |              0.751568 |        0.751568 |        0.751568 |      0.751568 |            0.0 | 0.751568 |    0.605722 |   1.0 |     1.0 | 0.751568 | 1.683698 |
</span><span class="noop">    | 11.01. |    1.0 |             1.683698 |                0.93213 |      0.66787 |     -0.083698 |               0.66787 |         0.66787 |         0.66787 |       0.66787 |            0.0 |  0.66787 |    0.634418 |   1.0 |     1.0 |  0.66787 | 1.717289 |
</span><span class="noop">    | 12.01. |    1.0 |             1.717289 |               1.049419 |     0.550581 |     -0.117289 |              0.550581 |        0.550581 |        0.550581 |      0.550581 |            0.0 | 0.550581 |    0.673248 |   1.0 |     1.0 | 0.550581 | 1.675591 |
</span><span class="noop">    | 13.01. |    1.0 |             1.675591 |                1.12501 |      0.47499 |     -0.075591 |               0.47499 |         0.47499 |         0.47499 |       0.47499 |            0.0 |  0.47499 |    0.718609 |   1.0 |     1.1 |  0.47499 | 1.690748 |
</span><span class="noop">    | 14.01. |    1.0 |             1.690748 |               1.215758 |     0.384242 |     -0.090748 |              0.384242 |        0.384242 |        0.384242 |      0.384242 |            0.0 | 0.384242 |     0.77181 |   1.0 |     1.2 | 0.384242 | 1.698806 |
</span><span class="noop">    | 15.01. |    1.0 |             1.698806 |               1.314564 |     0.285436 |     -0.098806 |              0.285436 |        0.285436 |        0.285436 |      0.285436 |            0.0 | 0.285436 |    0.833549 |   1.0 |     1.3 | 0.285436 | 1.708339 |
</span><span class="noop">    | 16.01. |    1.0 |             1.708339 |               1.422903 |     0.177097 |     -0.108339 |              0.177097 |        0.177097 |        0.177097 |      0.177097 |            0.0 | 0.177097 |    0.904647 |   1.0 |     1.4 | 0.177097 | 1.712365 |
</span><span class="noop">    | 17.01. |    1.0 |             1.712365 |               1.535269 |     0.064731 |     -0.112365 |              0.064731 |        0.064731 |        0.064731 |      0.064731 |            0.0 | 0.064731 |    0.985455 |   1.0 |     1.5 | 0.064731 |  1.70784 |
</span><span class="noop">    | 18.01. |    1.0 |              1.70784 |               1.643109 |          0.0 |      -0.10784 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |    1.071855 |   1.0 |     1.6 |      0.0 | 1.707565 |
</span><span class="noop">    | 19.01. |    1.0 |             1.707565 |               1.707565 |          0.0 |     -0.107565 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |    1.158255 |   1.0 |     1.7 |      0.0 | 1.737129 |
</span><span class="noop">    | 20.01. |    1.0 |             1.737129 |               1.737129 |          0.0 |     -0.137129 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |    1.244655 |   1.0 |     1.8 |      0.0 | 1.806473 |
</span><span class="noop">
</span><span class="noop">    While is is possible to simply increase the value of parameter
</span><span class="noop">    `remotedischargeminimum`, it is often advisable to use parameter
</span><span class="noop">    &#39;remotedischargesavety´ instead:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; remotedischargeminimum(1.4)
</span><span class="noop">    &gt;&gt;&gt; remotedischargesavety(0.5)
</span><span class="noop">
</span><span class="noop">    Under this configuration, the threshold value is exceeded at each
</span><span class="noop">    simulation time step.  Additionally, the final storage content of
</span><span class="noop">    the dam is about 4 % higher than in the last example, meaning the
</span><span class="noop">    available water has been used more efficiently:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume | input | natural |   output |   remote |
</span><span class="noop">    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |    1.0 |             1.806473 |                    1.9 |          0.0 |          -0.5 |                 0.005 |           0.005 |           0.005 |       0.00375 |            0.0 |  0.00375 |    0.086076 |   1.0 |     1.8 |  0.00375 |  1.80075 |
</span><span class="noop">    | 02.01. |    1.0 |              1.80075 |                  1.797 |          0.0 |      -0.40075 |              0.012265 |        0.012265 |        0.012265 |      0.012265 |            0.0 | 0.012265 |    0.171416 |   1.0 |     1.7 | 0.012265 | 1.703953 |
</span><span class="noop">    | 03.01. |    1.0 |             1.703953 |               1.691688 |          0.0 |     -0.303953 |              0.028841 |        0.028841 |        0.028841 |      0.028841 |            0.0 | 0.028841 |    0.255324 |   1.0 |     1.6 | 0.028841 | 1.611799 |
</span><span class="noop">    | 04.01. |    1.0 |             1.611799 |               1.582958 |          0.0 |     -0.211799 |              0.062468 |        0.062468 |        0.062468 |      0.062468 |            0.0 | 0.062468 |    0.336327 |   1.0 |     1.5 | 0.062468 | 1.528085 |
</span><span class="noop">    | 05.01. |    1.0 |             1.528085 |               1.465616 |          0.0 |     -0.128085 |              0.117784 |        0.117784 |        0.117784 |      0.117784 |            0.0 | 0.117784 |    0.412551 |   1.0 |     1.4 | 0.117784 | 1.458423 |
</span><span class="noop">    | 06.01. |    1.0 |             1.458423 |               1.340639 |     0.059361 |     -0.058423 |              0.243813 |        0.243813 |        0.243813 |      0.243813 |            0.0 | 0.243813 |    0.477885 |   1.0 |     1.3 | 0.243813 | 1.417501 |
</span><span class="noop">    | 07.01. |    1.0 |             1.417501 |               1.173688 |     0.226312 |     -0.017501 |              0.456251 |        0.456251 |        0.456251 |      0.456251 |            0.0 | 0.456251 |    0.524865 |   1.0 |     1.2 | 0.456251 | 1.430358 |
</span><span class="noop">    | 08.01. |    1.0 |             1.430358 |               0.974107 |     0.425893 |     -0.030358 |              0.641243 |        0.641243 |        0.641243 |      0.641243 |            0.0 | 0.641243 |    0.555862 |   1.0 |     1.1 | 0.641243 | 1.495671 |
</span><span class="noop">    | 09.01. |    1.0 |             1.495671 |               0.854428 |     0.545572 |     -0.095671 |              0.692239 |        0.692239 |        0.692239 |      0.692239 |            0.0 | 0.692239 |    0.582452 |   1.0 |     1.0 | 0.692239 | 1.556202 |
</span><span class="noop">    | 10.01. |    1.0 |             1.556202 |               0.863962 |     0.536038 |     -0.156202 |              0.632157 |        0.632157 |        0.632157 |      0.632157 |            0.0 | 0.632157 |    0.614234 |   1.0 |     1.0 | 0.632157 | 1.641325 |
</span><span class="noop">    | 11.01. |    1.0 |             1.641325 |               1.009168 |     0.390832 |     -0.241325 |              0.439912 |        0.439912 |        0.439912 |      0.439912 |            0.0 | 0.439912 |    0.662625 |   1.0 |     1.0 | 0.439912 | 1.612641 |
</span><span class="noop">    | 12.01. |    1.0 |             1.612641 |               1.172729 |     0.227271 |     -0.212641 |              0.289317 |        0.289317 |        0.289317 |      0.289317 |            0.0 | 0.289317 |    0.724028 |   1.0 |     1.0 | 0.289317 | 1.492699 |
</span><span class="noop">    | 13.01. |    1.0 |             1.492699 |               1.203382 |     0.196618 |     -0.092699 |              0.346132 |        0.346132 |        0.346132 |      0.346132 |            0.0 | 0.346132 |    0.780523 |   1.0 |     1.1 | 0.346132 | 1.480143 |
</span><span class="noop">    | 14.01. |    1.0 |             1.480143 |                1.13401 |      0.26599 |     -0.080143 |              0.427871 |        0.427871 |        0.427871 |      0.427871 |            0.0 | 0.427871 |    0.829954 |   1.0 |     1.2 | 0.427871 | 1.554814 |
</span><span class="noop">    | 15.01. |    1.0 |             1.554814 |               1.126942 |     0.273058 |     -0.154814 |              0.370171 |        0.370171 |        0.370171 |      0.370171 |            0.0 | 0.370171 |    0.884372 |   1.0 |     1.3 | 0.370171 | 1.677954 |
</span><span class="noop">    | 16.01. |    1.0 |             1.677954 |               1.307783 |     0.092217 |     -0.277954 |               0.12828 |         0.12828 |         0.12828 |       0.12828 |            0.0 |  0.12828 |    0.959688 |   1.0 |     1.4 |  0.12828 | 1.736699 |
</span><span class="noop">    | 17.01. |    1.0 |             1.736699 |               1.608419 |          0.0 |     -0.336699 |              0.021671 |        0.021671 |        0.021671 |      0.021671 |            0.0 | 0.021671 |    1.044216 |   1.0 |     1.5 | 0.021671 | 1.709485 |
</span><span class="noop">    | 18.01. |    1.0 |             1.709485 |               1.687814 |          0.0 |     -0.309485 |               0.02749 |         0.02749 |         0.02749 |       0.02749 |            0.0 |  0.02749 |    1.128241 |   1.0 |     1.6 |  0.02749 | 1.689667 |
</span><span class="noop">    | 19.01. |    1.0 |             1.689667 |               1.662178 |          0.0 |     -0.289667 |              0.032623 |        0.032623 |        0.032623 |      0.032623 |            0.0 | 0.032623 |    1.211822 |   1.0 |     1.7 | 0.032623 |  1.73685 |
</span><span class="noop">    | 20.01. |    1.0 |              1.73685 |               1.704227 |          0.0 |      -0.33685 |              0.021642 |        0.021642 |        0.021642 |      0.021642 |            0.0 | 0.021642 |    1.296352 |   1.0 |     1.8 | 0.021642 | 1.827792 |
</span><span class="noop">
</span><span class="noop">    Building upon the last example, we subsequently increase the complexity
</span><span class="noop">    of the model parameterization.  Firstly, we introduce a required minimum
</span><span class="noop">    water release of 0.2 m³/s:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; neardischargeminimumthreshold(0.2)
</span><span class="noop">
</span><span class="noop">    Now there is also a relevant water release before and after the drought
</span><span class="noop">    event occurs:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume | input | natural |   output |   remote |
</span><span class="noop">    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |    1.0 |             1.827792 |                    1.9 |          0.0 |          -0.5 |                 0.005 |             0.2 |             0.2 |      0.191667 |            0.0 | 0.191667 |     0.06984 |   1.0 |     1.8 | 0.191667 | 1.838333 |
</span><span class="noop">    | 02.01. |    1.0 |             1.838333 |               1.646667 |          0.0 |     -0.438333 |              0.008746 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     0.13896 |   1.0 |     1.7 |      0.2 | 1.816667 |
</span><span class="noop">    | 03.01. |    1.0 |             1.816667 |               1.616667 |          0.0 |     -0.416667 |              0.010632 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     0.20808 |   1.0 |     1.6 |      0.2 |   1.7775 |
</span><span class="noop">    | 04.01. |    1.0 |               1.7775 |                 1.5775 |          0.0 |       -0.3775 |              0.015099 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |      0.2772 |   1.0 |     1.5 |      0.2 | 1.699167 |
</span><span class="noop">    | 05.01. |    1.0 |             1.699167 |               1.499167 |          0.0 |     -0.299167 |               0.03006 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     0.34632 |   1.0 |     1.4 |      0.2 |      1.6 |
</span><span class="noop">    | 06.01. |    1.0 |                  1.6 |                    1.4 |          0.0 |          -0.2 |              0.068641 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     0.41544 |   1.0 |     1.3 |      0.2 |      1.5 |
</span><span class="noop">    | 07.01. |    1.0 |                  1.5 |                    1.3 |          0.1 |          -0.1 |              0.242578 |        0.242578 |        0.242578 |      0.242578 |            0.0 | 0.242578 |    0.480881 |   1.0 |     1.2 | 0.242578 | 1.408516 |
</span><span class="noop">    | 08.01. |    1.0 |             1.408516 |               1.165937 |     0.234063 |     -0.008516 |              0.474285 |        0.474285 |        0.474285 |      0.474285 |            0.0 | 0.474285 |    0.526303 |   1.0 |     1.1 | 0.474285 | 1.371888 |
</span><span class="noop">    | 09.01. |    1.0 |             1.371888 |               0.897603 |     0.502397 |      0.028112 |              0.784512 |        0.784512 |        0.784512 |      0.784512 |            0.0 | 0.784512 |    0.544921 |   1.0 |     1.0 | 0.784512 |  1.43939 |
</span><span class="noop">    | 10.01. |    1.0 |              1.43939 |               0.654878 |     0.745122 |      -0.03939 |               0.95036 |         0.95036 |         0.95036 |       0.95036 |            0.0 |  0.95036 |     0.54921 |   1.0 |     1.0 |  0.95036 |  1.67042 |
</span><span class="noop">    | 11.01. |    1.0 |              1.67042 |               0.720061 |     0.679939 |      -0.27042 |               0.71839 |         0.71839 |         0.71839 |       0.71839 |            0.0 |  0.71839 |    0.573541 |   1.0 |     1.0 |  0.71839 | 1.806604 |
</span><span class="noop">    | 12.01. |    1.0 |             1.806604 |               1.088214 |     0.311786 |     -0.406604 |              0.323424 |        0.323424 |        0.323424 |      0.323424 |            0.0 | 0.323424 |    0.631997 |   1.0 |     1.0 | 0.323424 |   1.7156 |
</span><span class="noop">    | 13.01. |    1.0 |               1.7156 |               1.392176 |     0.007824 |       -0.3156 |               0.03389 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |    0.701117 |   1.0 |     1.1 |      0.2 | 1.579922 |
</span><span class="noop">    | 14.01. |    1.0 |             1.579922 |               1.379922 |     0.020078 |     -0.179922 |              0.100394 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |    0.770237 |   1.0 |     1.2 |      0.2 | 1.488866 |
</span><span class="noop">    | 15.01. |    1.0 |             1.488866 |               1.288866 |     0.111134 |     -0.088866 |              0.264366 |        0.264366 |        0.264366 |      0.264366 |            0.0 | 0.264366 |    0.833796 |   1.0 |     1.3 | 0.264366 | 1.525216 |
</span><span class="noop">    | 16.01. |    1.0 |             1.525216 |               1.260849 |     0.139151 |     -0.125216 |              0.259326 |        0.259326 |        0.259326 |      0.259326 |            0.0 | 0.259326 |     0.89779 |   1.0 |     1.4 | 0.259326 | 1.637612 |
</span><span class="noop">    | 17.01. |    1.0 |             1.637612 |               1.378286 |     0.021714 |     -0.237612 |              0.072326 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     0.96691 |   1.0 |     1.5 |      0.2 |  1.74304 |
</span><span class="noop">    | 18.01. |    1.0 |              1.74304 |                1.54304 |          0.0 |      -0.34304 |              0.020494 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     1.03603 |   1.0 |     1.6 |      0.2 | 1.824234 |
</span><span class="noop">    | 19.01. |    1.0 |             1.824234 |               1.624234 |          0.0 |     -0.424234 |              0.009932 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     1.10515 |   1.0 |     1.7 |      0.2 | 1.905933 |
</span><span class="noop">    | 20.01. |    1.0 |             1.905933 |               1.705933 |          0.0 |     -0.505933 |              0.004737 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     1.17427 |   1.0 |     1.8 |      0.2 |      2.0 |
</span><span class="noop">
</span><span class="noop">    One may have noted that the water release is only 0.19 m³/s instead
</span><span class="noop">    of 0.2 m³/s on January 1.  This is due to the low local truncation
</span><span class="noop">    error of 1e-2 m³/s in combination with the fact that the simulation
</span><span class="noop">    starts with an completely dry dam. To confirm this, the required
</span><span class="noop">    numerical accuracy is increased temporarily:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; solver.abserrormax(1e-6)
</span><span class="noop">
</span><span class="noop">    Now there is only a tiny deviation left in the last shown digit:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume | input | natural |   output |   remote |
</span><span class="noop">    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |    1.0 |                  2.0 |                    1.9 |          0.0 |          -0.5 |                 0.005 |             0.2 |             0.2 |      0.199998 |            0.0 | 0.199998 |     0.06912 |   1.0 |     1.8 | 0.199998 |     1.84 |
</span><span class="noop">    | 02.01. |    1.0 |                 1.84 |               1.640002 |          0.0 |         -0.44 |              0.008615 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     0.13824 |   1.0 |     1.7 |      0.2 | 1.819999 |
</span><span class="noop">    | 03.01. |    1.0 |             1.819999 |               1.619999 |          0.0 |     -0.419999 |              0.010318 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     0.20736 |   1.0 |     1.6 |      0.2 | 1.779999 |
</span><span class="noop">    | 04.01. |    1.0 |             1.779999 |               1.579999 |          0.0 |     -0.379999 |              0.014766 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     0.27648 |   1.0 |     1.5 |      0.2 |      1.7 |
</span><span class="noop">    | 05.01. |    1.0 |                  1.7 |                    1.5 |          0.0 |          -0.3 |              0.029844 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |      0.3456 |   1.0 |     1.4 |      0.2 |      1.6 |
</span><span class="noop">    | 06.01. |    1.0 |                  1.6 |                    1.4 |          0.0 |          -0.2 |              0.068641 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     0.41472 |   1.0 |     1.3 |      0.2 |      1.5 |
</span><span class="noop">    | 07.01. |    1.0 |                  1.5 |                    1.3 |          0.1 |          -0.1 |              0.242578 |        0.242578 |        0.242578 |      0.242578 |            0.0 | 0.242578 |    0.480161 |   1.0 |     1.2 | 0.242578 | 1.408516 |
</span><span class="noop">    | 08.01. |    1.0 |             1.408516 |               1.165937 |     0.234063 |     -0.008516 |              0.474285 |        0.474285 |        0.474285 |      0.474285 |            0.0 | 0.474285 |    0.525583 |   1.0 |     1.1 | 0.474285 | 1.371888 |
</span><span class="noop">    | 09.01. |    1.0 |             1.371888 |               0.897603 |     0.502397 |      0.028112 |              0.784512 |        0.784512 |        0.784512 |      0.784512 |            0.0 | 0.784512 |    0.544201 |   1.0 |     1.0 | 0.784512 |  1.43939 |
</span><span class="noop">    | 10.01. |    1.0 |              1.43939 |               0.654878 |     0.745122 |      -0.03939 |               0.95036 |         0.95036 |         0.95036 |       0.95036 |            0.0 |  0.95036 |     0.54849 |   1.0 |     1.0 |  0.95036 |  1.67042 |
</span><span class="noop">    | 11.01. |    1.0 |              1.67042 |               0.720061 |     0.679939 |      -0.27042 |               0.71839 |         0.71839 |         0.71839 |       0.71839 |            0.0 |  0.71839 |    0.572821 |   1.0 |     1.0 |  0.71839 | 1.806604 |
</span><span class="noop">    | 12.01. |    1.0 |             1.806604 |               1.088214 |     0.311786 |     -0.406604 |              0.323424 |        0.323424 |        0.323424 |      0.323424 |            0.0 | 0.323424 |    0.631278 |   1.0 |     1.0 | 0.323424 |   1.7156 |
</span><span class="noop">    | 13.01. |    1.0 |               1.7156 |               1.392176 |     0.007824 |       -0.3156 |               0.03389 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |    0.700398 |   1.0 |     1.1 |      0.2 | 1.579922 |
</span><span class="noop">    | 14.01. |    1.0 |             1.579922 |               1.379922 |     0.020078 |     -0.179922 |              0.100394 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |    0.769518 |   1.0 |     1.2 |      0.2 | 1.488866 |
</span><span class="noop">    | 15.01. |    1.0 |             1.488866 |               1.288866 |     0.111134 |     -0.088866 |              0.264366 |        0.264366 |        0.264366 |      0.264366 |            0.0 | 0.264366 |    0.833076 |   1.0 |     1.3 | 0.264366 | 1.525216 |
</span><span class="noop">    | 16.01. |    1.0 |             1.525216 |               1.260849 |     0.139151 |     -0.125216 |              0.259326 |        0.259326 |        0.259326 |      0.259326 |            0.0 | 0.259326 |    0.897071 |   1.0 |     1.4 | 0.259326 | 1.637612 |
</span><span class="noop">    | 17.01. |    1.0 |             1.637612 |               1.378286 |     0.021714 |     -0.237612 |              0.072326 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |    0.966191 |   1.0 |     1.5 |      0.2 |  1.74304 |
</span><span class="noop">    | 18.01. |    1.0 |              1.74304 |                1.54304 |          0.0 |      -0.34304 |              0.020494 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |    1.035311 |   1.0 |     1.6 |      0.2 | 1.824234 |
</span><span class="noop">    | 19.01. |    1.0 |             1.824234 |               1.624234 |          0.0 |     -0.424234 |              0.009932 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |    1.104431 |   1.0 |     1.7 |      0.2 | 1.905933 |
</span><span class="noop">    | 20.01. |    1.0 |             1.905933 |               1.705933 |          0.0 |     -0.505933 |              0.004737 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |    1.173551 |   1.0 |     1.8 |      0.2 |      2.0 |
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; solver.abserrormax(1e-2)
</span><span class="noop">
</span><span class="noop">    To allow for a smooth transition of the water release in periods where
</span><span class="noop">    the highest demand switches from `remote` to `near` or the other way
</span><span class="noop">    round, one can increase the value of the `neardischargeminimumtolerance`
</span><span class="noop">    parameter:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; neardischargeminimumtolerance(0.2)
</span><span class="noop">
</span><span class="noop">    It is easiest to inspect the functioning the effect of this &#34;smooth
</span><span class="noop">    switch&#34; by looking at the results of column `requiredrelease`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume | input | natural |   output |   remote |
</span><span class="noop">    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |    1.0 |                  2.0 |                    1.9 |          0.0 |          -0.5 |                 0.005 |        0.210526 |        0.210526 |      0.201754 |            0.0 | 0.201754 |    0.068968 |   1.0 |     1.8 | 0.201754 | 1.840351 |
</span><span class="noop">    | 02.01. |    1.0 |             1.840351 |               1.638597 |          0.0 |     -0.440351 |              0.008588 |         0.21092 |         0.21092 |       0.21092 |            0.0 |  0.21092 |    0.137145 |   1.0 |     1.7 |  0.21092 | 1.822886 |
</span><span class="noop">    | 03.01. |    1.0 |             1.822886 |               1.611966 |          0.0 |     -0.422886 |              0.010053 |        0.211084 |        0.211084 |      0.211084 |            0.0 | 0.211084 |    0.205307 |   1.0 |     1.6 | 0.211084 | 1.787111 |
</span><span class="noop">    | 04.01. |    1.0 |             1.787111 |               1.576027 |          0.0 |     -0.387111 |              0.013858 |        0.211523 |        0.211523 |      0.211523 |            0.0 | 0.211523 |    0.273432 |   1.0 |     1.5 | 0.211523 |  1.71019 |
</span><span class="noop">    | 05.01. |    1.0 |              1.71019 |               1.498667 |          0.0 |      -0.31019 |              0.027322 |        0.213209 |        0.213209 |      0.213209 |            0.0 | 0.213209 |     0.34141 |   1.0 |     1.4 | 0.213209 | 1.611668 |
</span><span class="noop">    | 06.01. |    1.0 |             1.611668 |               1.398459 |     0.001541 |     -0.211668 |              0.064075 |        0.219043 |        0.219043 |      0.219043 |            0.0 | 0.219043 |    0.408885 |   1.0 |     1.3 | 0.219043 | 1.513658 |
</span><span class="noop">    | 07.01. |    1.0 |             1.513658 |               1.294615 |     0.105385 |     -0.113658 |              0.235523 |        0.283419 |        0.283419 |      0.283419 |            0.0 | 0.283419 |    0.470798 |   1.0 |     1.2 | 0.283419 | 1.429416 |
</span><span class="noop">    | 08.01. |    1.0 |             1.429416 |               1.145997 |     0.254003 |     -0.029416 |              0.470414 |        0.475212 |        0.475212 |      0.475212 |            0.0 | 0.475212 |    0.516139 |   1.0 |     1.1 | 0.475212 | 1.395444 |
</span><span class="noop">    | 09.01. |    1.0 |             1.395444 |               0.920232 |     0.479768 |      0.004556 |              0.735001 |        0.735281 |        0.735281 |      0.735281 |            0.0 | 0.735281 |    0.539011 |   1.0 |     1.0 | 0.735281 | 1.444071 |
</span><span class="noop">    | 10.01. |    1.0 |             1.444071 |                0.70879 |      0.69121 |     -0.044071 |              0.891263 |        0.891315 |        0.891315 |      0.891315 |            0.0 | 0.891315 |    0.548402 |   1.0 |     1.0 | 0.891315 | 1.643281 |
</span><span class="noop">    | 11.01. |    1.0 |             1.643281 |               0.751966 |     0.648034 |     -0.243281 |              0.696325 |        0.696749 |        0.696749 |      0.696749 |            0.0 | 0.696749 |    0.574602 |   1.0 |     1.0 | 0.696749 | 1.763981 |
</span><span class="noop">    | 12.01. |    1.0 |             1.763981 |               1.067232 |     0.332768 |     -0.363981 |              0.349797 |        0.366406 |        0.366406 |      0.366406 |            0.0 | 0.366406 |    0.629345 |   1.0 |     1.0 | 0.366406 | 1.692903 |
</span><span class="noop">    | 13.01. |    1.0 |             1.692903 |               1.326497 |     0.073503 |     -0.292903 |              0.105231 |        0.228241 |        0.228241 |      0.228241 |            0.0 | 0.228241 |    0.696025 |   1.0 |     1.1 | 0.228241 | 1.590367 |
</span><span class="noop">    | 14.01. |    1.0 |             1.590367 |               1.362126 |     0.037874 |     -0.190367 |              0.111928 |        0.230054 |        0.230054 |      0.230054 |            0.0 | 0.230054 |    0.762548 |   1.0 |     1.2 | 0.230054 | 1.516904 |
</span><span class="noop">    | 15.01. |    1.0 |             1.516904 |                1.28685 |      0.11315 |     -0.116904 |              0.240436 |        0.286374 |        0.286374 |      0.286374 |            0.0 | 0.286374 |    0.824205 |   1.0 |     1.3 | 0.286374 | 1.554409 |
</span><span class="noop">    | 16.01. |    1.0 |             1.554409 |               1.268035 |     0.131965 |     -0.154409 |              0.229369 |        0.279807 |        0.279807 |      0.279807 |            0.0 | 0.279807 |     0.88643 |   1.0 |     1.4 | 0.279807 | 1.662351 |
</span><span class="noop">    | 17.01. |    1.0 |             1.662351 |               1.382544 |     0.017456 |     -0.262351 |              0.058622 |         0.21805 |         0.21805 |       0.21805 |            0.0 |  0.21805 |    0.953991 |   1.0 |     1.5 |  0.21805 | 1.764451 |
</span><span class="noop">    | 18.01. |    1.0 |             1.764451 |                 1.5464 |          0.0 |     -0.364451 |              0.016958 |        0.211892 |        0.211892 |      0.211892 |            0.0 | 0.211892 |    1.022083 |   1.0 |     1.6 | 0.211892 | 1.842178 |
</span><span class="noop">    | 19.01. |    1.0 |             1.842178 |               1.630286 |          0.0 |     -0.442178 |              0.008447 |        0.210904 |        0.210904 |      0.210904 |            0.0 | 0.210904 |    1.090261 |   1.0 |     1.7 | 0.210904 | 1.920334 |
</span><span class="noop">    | 20.01. |    1.0 |             1.920334 |               1.709429 |          0.0 |     -0.520334 |              0.004155 |        0.210435 |        0.210435 |      0.210435 |            0.0 | 0.210435 |    1.158479 |   1.0 |     1.8 | 0.210435 | 2.011822 |
</span><span class="noop">
</span><span class="noop">    Version 1 of the dam model that is forced to keep a certain degree
</span><span class="noop">    of low flow variability.  It is not allowed to release an arbitrary
</span><span class="noop">    amount of water when its inflow falls below the required minimum
</span><span class="noop">    water release.  We show this by decreasing the inflow in the
</span><span class="noop">    second half of the simulation period to 0.1 m³/s:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; input_.sequences.sim.series[10:] = 0.1
</span><span class="noop">
</span><span class="noop">    The value of parameter `neardischargeminimumthreshold` (0.2 m³/s) is
</span><span class="noop">    maintained, but the value of `neardischargeminimumtolerance` is reset
</span><span class="noop">    to 0 m³/s for improving comprehensibility:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; neardischargeminimumtolerance(0.0)
</span><span class="noop">
</span><span class="noop">    As to be expected, the actual release drops to 0.1 m³/s on January 11.
</span><span class="noop">    But, due to the time delay of the discharge released earlier, the
</span><span class="noop">    largest violation of the threshold value takes place on January, 13:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume | input | natural |   output |   remote |
</span><span class="noop">    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |    1.0 |             2.011822 |                    1.9 |          0.0 |          -0.5 |                 0.005 |             0.2 |             0.2 |      0.191667 |            0.0 | 0.191667 |     0.06984 |   1.0 |     1.8 | 0.191667 | 1.838333 |
</span><span class="noop">    | 02.01. |    1.0 |             1.838333 |               1.646667 |          0.0 |     -0.438333 |              0.008746 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     0.13896 |   1.0 |     1.7 |      0.2 | 1.816667 |
</span><span class="noop">    | 03.01. |    1.0 |             1.816667 |               1.616667 |          0.0 |     -0.416667 |              0.010632 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     0.20808 |   1.0 |     1.6 |      0.2 |   1.7775 |
</span><span class="noop">    | 04.01. |    1.0 |               1.7775 |                 1.5775 |          0.0 |       -0.3775 |              0.015099 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |      0.2772 |   1.0 |     1.5 |      0.2 | 1.699167 |
</span><span class="noop">    | 05.01. |    1.0 |             1.699167 |               1.499167 |          0.0 |     -0.299167 |               0.03006 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     0.34632 |   1.0 |     1.4 |      0.2 |      1.6 |
</span><span class="noop">    | 06.01. |    1.0 |                  1.6 |                    1.4 |          0.0 |          -0.2 |              0.068641 |             0.2 |             0.2 |           0.2 |            0.0 |      0.2 |     0.41544 |   1.0 |     1.3 |      0.2 |      1.5 |
</span><span class="noop">    | 07.01. |    1.0 |                  1.5 |                    1.3 |          0.1 |          -0.1 |              0.242578 |        0.242578 |        0.242578 |      0.242578 |            0.0 | 0.242578 |    0.480881 |   1.0 |     1.2 | 0.242578 | 1.408516 |
</span><span class="noop">    | 08.01. |    1.0 |             1.408516 |               1.165937 |     0.234063 |     -0.008516 |              0.474285 |        0.474285 |        0.474285 |      0.474285 |            0.0 | 0.474285 |    0.526303 |   1.0 |     1.1 | 0.474285 | 1.371888 |
</span><span class="noop">    | 09.01. |    1.0 |             1.371888 |               0.897603 |     0.502397 |      0.028112 |              0.784512 |        0.784512 |        0.784512 |      0.784512 |            0.0 | 0.784512 |    0.544921 |   1.0 |     1.0 | 0.784512 |  1.43939 |
</span><span class="noop">    | 10.01. |    1.0 |              1.43939 |               0.654878 |     0.745122 |      -0.03939 |               0.95036 |         0.95036 |         0.95036 |       0.95036 |            0.0 |  0.95036 |     0.54921 |   1.0 |     1.0 |  0.95036 |  1.67042 |
</span><span class="noop">    | 11.01. |    0.1 |              1.67042 |               0.720061 |     0.679939 |      -0.27042 |               0.71839 |         0.71839 |             0.1 |           0.1 |            0.0 |      0.1 |     0.54921 |   0.1 |     1.0 |      0.1 | 1.682926 |
</span><span class="noop">    | 12.01. |    0.1 |             1.682926 |               1.582926 |          0.0 |     -0.282926 |              0.034564 |             0.2 |             0.1 |           0.1 |            0.0 |      0.1 |     0.54921 |   0.1 |     1.0 |      0.1 | 1.423559 |
</span><span class="noop">    | 13.01. |    0.1 |             1.423559 |               1.323559 |     0.076441 |     -0.023559 |              0.299482 |        0.299482 |             0.1 |           0.1 |            0.0 |      0.1 |     0.54921 |   0.1 |     1.1 |      0.1 | 1.285036 |
</span><span class="noop">    | 14.01. |    0.1 |             1.285036 |               1.185036 |     0.214964 |      0.114964 |              0.585979 |        0.585979 |             0.1 |           0.1 |            0.0 |      0.1 |     0.54921 |   0.1 |     1.2 |      0.1 |      1.3 |
</span><span class="noop">    | 15.01. |    0.1 |                  1.3 |                    1.2 |          0.2 |           0.1 |              0.557422 |        0.557422 |             0.1 |           0.1 |            0.0 |      0.1 |     0.54921 |   0.1 |     1.3 |      0.1 |      1.4 |
</span><span class="noop">    | 16.01. |    0.1 |                  1.4 |                    1.3 |          0.1 |          -0.0 |                  0.35 |            0.35 |             0.1 |           0.1 |            0.0 |      0.1 |     0.54921 |   0.1 |     1.4 |      0.1 |      1.5 |
</span><span class="noop">    | 17.01. |    0.1 |                  1.5 |                    1.4 |          0.0 |          -0.1 |              0.142578 |             0.2 |             0.1 |           0.1 |            0.0 |      0.1 |     0.54921 |   0.1 |     1.5 |      0.1 |      1.6 |
</span><span class="noop">    | 18.01. |    0.1 |                  1.6 |                    1.5 |          0.0 |          -0.2 |              0.068641 |             0.2 |             0.1 |           0.1 |            0.0 |      0.1 |     0.54921 |   0.1 |     1.6 |      0.1 |      1.7 |
</span><span class="noop">    | 19.01. |    0.1 |                  1.7 |                    1.6 |          0.0 |          -0.3 |              0.029844 |             0.2 |             0.1 |           0.1 |            0.0 |      0.1 |     0.54921 |   0.1 |     1.7 |      0.1 |      1.8 |
</span><span class="noop">    | 20.01. |    0.1 |                  1.8 |                    1.7 |          0.0 |          -0.4 |              0.012348 |             0.2 |             0.1 |           0.1 |            0.0 |      0.1 |     0.54921 |   0.1 |     1.8 |      0.1 |      1.9 |
</span><span class="noop">
</span><span class="noop">    Another issue of the dam model relevant for the simulation of drought
</span><span class="noop">    events to be discussed is the possible restriction of water release
</span><span class="noop">    due to limited storage.  To focus on this, we reset the parameter
</span><span class="noop">    `neardischargeminimumthreshold` to 0 m³/s and define smaller inflow
</span><span class="noop">    values, which are constantly decreasing from 0.2 m³/s to 0.0 m³/s:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; neardischargeminimumthreshold(0.0)
</span><span class="noop">    &gt;&gt;&gt; input_.sequences.sim.series = numpy.linspace(0.2, 0.0, 20)
</span><span class="noop">
</span><span class="noop">    Now the storage content increases only until January, 5.  Afterwards
</span><span class="noop">    the dam begins to run dry.  On January 11, the dam is actually empty.
</span><span class="noop">    But there are some fluctuations of the water volume around 0 m³.
</span><span class="noop">    The most severe deviation from the correct value of 0 m³ oocurs on
</span><span class="noop">    January 12, where the final storage volume is -666 m³:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume |    input | natural |   output |   remote |
</span><span class="noop">    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |      0.2 |                  1.9 |                    1.9 |          0.0 |          -0.5 |                 0.005 |           0.005 |           0.005 |       0.00375 |            0.0 |  0.00375 |    0.016956 |      0.2 |     1.8 |  0.00375 |  1.80075 |
</span><span class="noop">    | 02.01. | 0.189474 |              1.80075 |                  1.797 |          0.0 |      -0.40075 |              0.012265 |        0.012265 |        0.012265 |      0.012265 |            0.0 | 0.012265 |    0.032267 | 0.189474 |     1.7 | 0.012265 | 1.703953 |
</span><span class="noop">    | 03.01. | 0.178947 |             1.703953 |               1.691688 |          0.0 |     -0.303953 |              0.028841 |        0.028841 |        0.028841 |      0.028841 |            0.0 | 0.028841 |    0.045236 | 0.178947 |     1.6 | 0.028841 | 1.611799 |
</span><span class="noop">    | 04.01. | 0.168421 |             1.611799 |               1.582958 |          0.0 |     -0.211799 |              0.062468 |        0.062468 |        0.062468 |      0.062468 |            0.0 | 0.062468 |     0.05439 | 0.168421 |     1.5 | 0.062468 | 1.528085 |
</span><span class="noop">    | 05.01. | 0.157895 |             1.528085 |               1.465616 |          0.0 |     -0.128085 |              0.117784 |        0.117784 |        0.117784 |      0.117784 |            0.0 | 0.117784 |    0.057856 | 0.157895 |     1.4 | 0.117784 | 1.458423 |
</span><span class="noop">    | 06.01. | 0.147368 |             1.458423 |               1.340639 |     0.059361 |     -0.058423 |              0.243813 |        0.243813 |        0.243813 |      0.243813 |            0.0 | 0.243813 |    0.049523 | 0.147368 |     1.3 | 0.243813 | 1.417501 |
</span><span class="noop">    | 07.01. | 0.136842 |             1.417501 |               1.173688 |     0.226312 |     -0.017501 |              0.456251 |        0.456251 |        0.456251 |      0.456251 |            0.0 | 0.456251 |    0.021926 | 0.136842 |     1.2 | 0.456251 | 1.430358 |
</span><span class="noop">    | 08.01. | 0.126316 |             1.430358 |               0.974107 |     0.425893 |     -0.030358 |              0.641243 |        0.641243 |        0.641243 |      0.382861 |            0.0 | 0.382861 |   -0.000239 | 0.126316 |     1.1 | 0.382861 | 1.443995 |
</span><span class="noop">    | 09.01. | 0.115789 |             1.443995 |               1.061134 |     0.338866 |     -0.043995 |              0.539003 |        0.539003 |        0.539003 |       0.11547 |            0.0 |  0.11547 |   -0.000212 | 0.115789 |     1.0 |  0.11547 | 1.337495 |
</span><span class="noop">    | 10.01. | 0.105263 |             1.337495 |               1.222025 |     0.177975 |      0.062505 |              0.497868 |        0.497868 |        0.497868 |      0.108362 |            0.0 | 0.108362 |    -0.00048 | 0.105263 |     1.0 | 0.108362 | 1.228344 |
</span><span class="noop">    | 11.01. | 0.094737 |             1.228344 |               1.119981 |     0.280019 |      0.171656 |              0.694448 |        0.694448 |        0.694448 |      0.089381 |            0.0 | 0.089381 |   -0.000017 | 0.094737 |     1.0 | 0.089381 | 1.134148 |
</span><span class="noop">    | 12.01. | 0.084211 |             1.134148 |               1.044768 |     0.355232 |      0.265852 |              0.815265 |        0.815265 |        0.815265 |      0.091721 |            0.0 | 0.091721 |   -0.000666 | 0.084211 |     1.0 | 0.091721 | 1.098152 |
</span><span class="noop">    | 13.01. | 0.073684 |             1.098152 |               1.006431 |     0.393569 |      0.301848 |              0.864198 |        0.864198 |        0.864198 |      0.067904 |            0.0 | 0.067904 |   -0.000166 | 0.073684 |     1.1 | 0.067904 |  1.18792 |
</span><span class="noop">    | 14.01. | 0.063158 |              1.18792 |               1.120015 |     0.279985 |       0.21208 |              0.717657 |        0.717657 |        0.717657 |      0.067501 |            0.0 | 0.067501 |   -0.000542 | 0.063158 |     1.2 | 0.067501 | 1.277116 |
</span><span class="noop">    | 15.01. | 0.052632 |             1.277116 |               1.209616 |     0.190384 |      0.122884 |              0.568242 |        0.568242 |        0.568242 |      0.046544 |            0.0 | 0.046544 |   -0.000016 | 0.052632 |     1.3 | 0.046544 | 1.365852 |
</span><span class="noop">    | 16.01. | 0.042105 |             1.365852 |               1.319309 |     0.080691 |      0.034148 |              0.369601 |        0.369601 |        0.369601 |      0.048083 |            0.0 | 0.048083 |   -0.000532 | 0.042105 |     1.4 | 0.048083 | 1.455275 |
</span><span class="noop">    | 17.01. | 0.031579 |             1.455275 |               1.407192 |          0.0 |     -0.055275 |              0.187833 |        0.187833 |        0.187833 |      0.027168 |            0.0 | 0.027168 |   -0.000151 | 0.031579 |     1.5 | 0.027168 |  1.54538 |
</span><span class="noop">    | 18.01. | 0.021053 |              1.54538 |               1.518212 |          0.0 |      -0.14538 |              0.104078 |        0.104078 |        0.104078 |      0.021731 |            0.0 | 0.021731 |    -0.00021 | 0.021053 |     1.6 | 0.021731 | 1.634293 |
</span><span class="noop">    | 19.01. | 0.010526 |             1.634293 |               1.612561 |          0.0 |     -0.234293 |              0.052016 |        0.052016 |        0.052016 |      0.013004 |            0.0 | 0.013004 |   -0.000424 | 0.010526 |     1.7 | 0.013004 | 1.724252 |
</span><span class="noop">    | 20.01. |      0.0 |             1.724252 |               1.711248 |          0.0 |     -0.324252 |               0.02417 |         0.02417 |        0.012085 |           0.0 |            0.0 |      0.0 |   -0.000424 |      0.0 |     1.8 |      0.0 | 1.814438 |
</span><span class="noop">
</span><span class="noop">    This behaviour of the dam model is due to method
</span><span class="noop">    :func:`~hydpy.models.dam.dam_model.calc_actualrelease_v1` beeing
</span><span class="noop">    involved in the set of differential equation that are solved
</span><span class="noop">    approximately by a numerical integration algorithm.  Theoretically,
</span><span class="noop">    we could decrease the local truncation error to decrease this
</span><span class="noop">    problem significantly.  But this could result in quite huge
</span><span class="noop">    computation times, as the underlying numerical algorithm is not
</span><span class="noop">    really able to handle the discontinuous relationship between release
</span><span class="noop">    and volume around `neardischargeminimumthreshold`.
</span><span class="noop">
</span><span class="noop">    One solution would be to define another version of the dam model and
</span><span class="noop">    simply implement an alternative balance equation for the calculation of
</span><span class="noop">    the actual release (not done yet, but seems to be worth the effort).
</span><span class="noop">    When using the version of the dam model discussed here, it is instead
</span><span class="noop">    advised to smooth this problematic discontinuity by increasing the
</span><span class="noop">    value of parameter `waterlevelminimumtolerance` (which could not be
</span><span class="noop">    implemented properly if method
</span><span class="noop">    :func:`~hydpy.models.dam.dam_model.calc_actualrelease_v1` would
</span><span class="noop">    apply a simple balance equation):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; waterlevelminimumtolerance(0.01)
</span><span class="noop">
</span><span class="noop">    If one wants to avoid not only the fluctuation but also the negative
</span><span class="noop">    values of the water volume, one should also sligthly increase the
</span><span class="noop">    original threshold value, e.g.:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; waterlevelminimumthreshold(0.005)
</span><span class="noop">
</span><span class="noop">    Now water storage is decaying smoothly.  The lowest storage content
</span><span class="noop">    of 541 m³ occurs on January 14.  After that date, the dam is refilled
</span><span class="noop">    to a certain degree.  This is due the decreasing remote demand. Note
</span><span class="noop">    that negative storage values are circumvented in this example, but this
</span><span class="noop">    would have not been the case if the low flow period were prolonged:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume |    input | natural |   output |   remote |
</span><span class="noop">    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |      0.2 |             1.814438 |                    1.9 |          0.0 |          -0.5 |                 0.005 |           0.005 |           0.005 |      0.001282 |            0.0 | 0.001282 |    0.017169 |      0.2 |     1.8 | 0.001282 | 1.800256 |
</span><span class="noop">    | 02.01. | 0.189474 |             1.800256 |               1.798975 |          0.0 |     -0.400256 |               0.01232 |         0.01232 |         0.01232 |      0.007624 |            0.0 | 0.007624 |    0.032881 | 0.189474 |     1.7 | 0.007624 | 1.702037 |
</span><span class="noop">    | 03.01. | 0.178947 |             1.702037 |               1.694414 |          0.0 |     -0.302037 |              0.029323 |        0.029323 |        0.029323 |      0.025921 |            0.0 | 0.025921 |    0.046103 | 0.178947 |     1.6 | 0.025921 | 1.608618 |
</span><span class="noop">    | 04.01. | 0.168421 |             1.608618 |               1.582697 |          0.0 |     -0.208618 |              0.064084 |        0.064084 |        0.064084 |      0.062022 |            0.0 | 0.062022 |    0.055296 | 0.168421 |     1.5 | 0.062022 | 1.525188 |
</span><span class="noop">    | 05.01. | 0.157895 |             1.525188 |               1.463166 |          0.0 |     -0.125188 |              0.120198 |        0.120198 |        0.120198 |      0.118479 |            0.0 | 0.118479 |    0.058701 | 0.157895 |     1.4 | 0.118479 | 1.457043 |
</span><span class="noop">    | 06.01. | 0.147368 |             1.457043 |               1.338564 |     0.061436 |     -0.057043 |              0.247367 |        0.247367 |        0.247367 |      0.242243 |            0.0 | 0.242243 |    0.050504 | 0.147368 |     1.3 | 0.242243 | 1.417039 |
</span><span class="noop">    | 07.01. | 0.136842 |             1.417039 |               1.174796 |     0.225204 |     -0.017039 |               0.45567 |         0.45567 |         0.45567 |      0.397328 |            0.0 | 0.397328 |    0.027998 | 0.136842 |     1.2 | 0.397328 | 1.418109 |
</span><span class="noop">    | 08.01. | 0.126316 |             1.418109 |               1.020781 |     0.379219 |     -0.018109 |              0.608464 |        0.608464 |        0.608464 |      0.290761 |            0.0 | 0.290761 |     0.01379 | 0.126316 |     1.1 | 0.290761 | 1.401604 |
</span><span class="noop">    | 09.01. | 0.115789 |             1.401604 |               1.110843 |     0.289157 |     -0.001604 |              0.537314 |        0.537314 |        0.537314 |      0.154283 |            0.0 | 0.154283 |    0.010464 | 0.115789 |     1.0 | 0.154283 | 1.290584 |
</span><span class="noop">    | 10.01. | 0.105263 |             1.290584 |               1.136301 |     0.263699 |      0.109416 |              0.629775 |        0.629775 |        0.629775 |      0.138519 |            0.0 | 0.138519 |    0.007591 | 0.105263 |     1.0 | 0.138519 | 1.216378 |
</span><span class="noop">    | 11.01. | 0.094737 |             1.216378 |               1.077859 |     0.322141 |      0.183622 |              0.744091 |        0.744091 |        0.744091 |      0.126207 |            0.0 | 0.126207 |    0.004871 | 0.094737 |     1.0 | 0.126207 |  1.15601 |
</span><span class="noop">    | 12.01. | 0.084211 |              1.15601 |               1.029803 |     0.370197 |       0.24399 |               0.82219 |         0.82219 |         0.82219 |      0.109723 |            0.0 | 0.109723 |    0.002667 | 0.084211 |     1.0 | 0.109723 | 1.129412 |
</span><span class="noop">    | 13.01. | 0.073684 |             1.129412 |               1.019689 |     0.380311 |      0.270588 |              0.841916 |        0.841916 |        0.841916 |      0.092645 |            0.0 | 0.092645 |    0.001029 | 0.073684 |     1.1 | 0.092645 | 1.214132 |
</span><span class="noop">    | 14.01. | 0.063158 |             1.214132 |               1.121487 |     0.278513 |      0.185868 |              0.701812 |        0.701812 |        0.701812 |      0.068806 |            0.0 | 0.068806 |    0.000541 | 0.063158 |     1.2 | 0.068806 | 1.296357 |
</span><span class="noop">    | 15.01. | 0.052632 |             1.296357 |               1.227551 |     0.172449 |      0.103643 |              0.533258 |        0.533258 |        0.533258 |      0.051779 |            0.0 | 0.051779 |    0.000615 | 0.052632 |     1.3 | 0.051779 | 1.376644 |
</span><span class="noop">    | 16.01. | 0.042105 |             1.376644 |               1.324865 |     0.075135 |      0.023356 |              0.351863 |        0.351863 |        0.351863 |      0.035499 |            0.0 | 0.035499 |    0.001185 | 0.042105 |     1.4 | 0.035499 | 1.457718 |
</span><span class="noop">    | 17.01. | 0.031579 |             1.457718 |               1.422218 |          0.0 |     -0.057718 |              0.185207 |        0.185207 |        0.185207 |       0.02024 |            0.0 |  0.02024 |    0.002165 | 0.031579 |     1.5 |  0.02024 | 1.540662 |
</span><span class="noop">    | 18.01. | 0.021053 |             1.540662 |               1.520422 |          0.0 |     -0.140662 |              0.107697 |        0.107697 |        0.107697 |      0.012785 |            0.0 | 0.012785 |    0.002879 | 0.021053 |     1.6 | 0.012785 | 1.626481 |
</span><span class="noop">    | 19.01. | 0.010526 |             1.626481 |               1.613695 |          0.0 |     -0.226481 |              0.055458 |        0.055458 |        0.055458 |      0.006918 |            0.0 | 0.006918 |    0.003191 | 0.010526 |     1.7 | 0.006918 |  1.71612 |
</span><span class="noop">    | 20.01. |      0.0 |              1.71612 |               1.709201 |          0.0 |      -0.31612 |              0.025948 |        0.025948 |        0.012974 |      0.001631 |            0.0 | 0.001631 |     0.00305 |      0.0 |     1.8 | 0.001631 | 1.808953 |
</span><span class="noop">
</span><span class="noop">    So the fluctuation seems to be gone, but there is still some
</span><span class="noop">    inaccuracy in the results.  Note that the last outflow value is smaller
</span><span class="noop">    than the local truncation error.  However, due to the smoothing of
</span><span class="noop">    the discontinuous relationship it would now be possible to define
</span><span class="noop">    a lower local truncation error without to increase computation times
</span><span class="noop">    too much.
</span><span class="noop">
</span><span class="noop">    The last &#34;drought parameter&#34; we did no not vary so far is
</span><span class="noop">    `nmblogentries`.  In the examples above, this parameter was always
</span><span class="noop">    set to 1, meaning that each estimate of the `natural` discharge of
</span><span class="noop">    the subcatchment was based only on the latest observation.  Using
</span><span class="noop">    only the latest observation offers the advantage of quick adjustments
</span><span class="noop">    of the control of the dam.  But there is a risk of the estimates being
</span><span class="noop">    too uncertain and of a bad timing of water releases during periods of
</span><span class="noop">    fast fluctations.
</span><span class="noop">
</span><span class="noop">    Let us define a series of extreme fluctuations by repeating the the
</span><span class="noop">    natural discharge values of 1.5 m³/s and 0.5 m³/s ten times:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; natural.sequences.sim.series = 10*[1.5, 0.5]
</span><span class="noop">
</span><span class="noop">    Also increase the inflow to 1 m³/s again, to assure that the dam is
</span><span class="noop">    actually able to release as much water as has been estimated to be
</span><span class="noop">    required:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; input_.sequences.sim.series = 1.0
</span><span class="noop">
</span><span class="noop">    Furthermore, assume that there is no relevant routing time between
</span><span class="noop">    the outlet of the dam and the cross section downstream:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; stream1.model.parameters.control.responses(((), (1.0,)))
</span><span class="noop">    &gt;&gt;&gt; stream1.model.parameters.update()
</span><span class="noop">
</span><span class="noop">    The exemple is a little artificial, but exemplifies a general problem
</span><span class="noop">    that might occur in different forms.  Due to the time delay of the
</span><span class="noop">    information flow from the cross section to the dam, much water is
</span><span class="noop">    wasted to increase the peak flows, but the violations of the low flow
</span><span class="noop">    threshold remain almost unchanged:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume | input | natural |   output |   remote |
</span><span class="noop">    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |    1.0 |             1.808953 |                    1.9 |          0.0 |          -0.5 |                 0.005 |           0.005 |           0.005 |      0.002727 |            0.0 | 0.002727 |    0.086164 |   1.0 |     1.5 | 0.002727 | 1.502727 |
</span><span class="noop">    | 02.01. |    1.0 |             1.502727 |                    1.5 |          0.0 |     -0.102727 |              0.140038 |        0.140038 |        0.140038 |      0.140003 |            0.0 | 0.140003 |    0.160468 |   1.0 |     0.5 | 0.140003 | 0.640003 |
</span><span class="noop">    | 03.01. |    1.0 |             0.640003 |                    0.5 |          0.9 |      0.759997 |              1.399537 |        1.399537 |        1.399537 |      1.399534 |            0.0 | 1.399534 |    0.125948 |   1.0 |     1.5 | 1.399534 | 2.899534 |
</span><span class="noop">    | 04.01. |    1.0 |             2.899534 |                    1.5 |          0.0 |     -1.499534 |              0.000001 |        0.000001 |        0.000001 |      0.000001 |            0.0 | 0.000001 |    0.212348 |   1.0 |     0.5 | 0.000001 | 0.500001 |
</span><span class="noop">    | 05.01. |    1.0 |             0.500001 |                    0.5 |          0.9 |      0.899999 |              1.399872 |        1.399872 |        1.399872 |      1.399872 |            0.0 | 1.399872 |    0.177799 |   1.0 |     1.5 | 1.399872 | 2.899872 |
</span><span class="noop">    | 06.01. |    1.0 |             2.899872 |                    1.5 |          0.0 |     -1.499872 |              0.000001 |        0.000001 |        0.000001 |      0.000001 |            0.0 | 0.000001 |    0.264199 |   1.0 |     0.5 | 0.000001 | 0.500001 |
</span><span class="noop">    | 07.01. |    1.0 |             0.500001 |                    0.5 |          0.9 |      0.899999 |              1.399872 |        1.399872 |        1.399872 |      1.399872 |            0.0 | 1.399872 |     0.22965 |   1.0 |     1.5 | 1.399872 | 2.899872 |
</span><span class="noop">    | 08.01. |    1.0 |             2.899872 |                    1.5 |          0.0 |     -1.499872 |              0.000001 |        0.000001 |        0.000001 |      0.000001 |            0.0 | 0.000001 |     0.31605 |   1.0 |     0.5 | 0.000001 | 0.500001 |
</span><span class="noop">    | 09.01. |    1.0 |             0.500001 |                    0.5 |          0.9 |      0.899999 |              1.399872 |        1.399872 |        1.399872 |      1.399872 |            0.0 | 1.399872 |    0.281501 |   1.0 |     1.5 | 1.399872 | 2.899872 |
</span><span class="noop">    | 10.01. |    1.0 |             2.899872 |                    1.5 |          0.0 |     -1.499872 |              0.000001 |        0.000001 |        0.000001 |      0.000001 |            0.0 | 0.000001 |    0.367901 |   1.0 |     0.5 | 0.000001 | 0.500001 |
</span><span class="noop">    | 11.01. |    1.0 |             0.500001 |                    0.5 |          0.9 |      0.899999 |              1.399872 |        1.399872 |        1.399872 |      1.399872 |            0.0 | 1.399872 |    0.333352 |   1.0 |     1.5 | 1.399872 | 2.899872 |
</span><span class="noop">    | 12.01. |    1.0 |             2.899872 |                    1.5 |          0.0 |     -1.499872 |              0.000001 |        0.000001 |        0.000001 |      0.000001 |            0.0 | 0.000001 |    0.419752 |   1.0 |     0.5 | 0.000001 | 0.500001 |
</span><span class="noop">    | 13.01. |    1.0 |             0.500001 |                    0.5 |          0.9 |      0.899999 |              1.399872 |        1.399872 |        1.399872 |      1.399872 |            0.0 | 1.399872 |    0.385203 |   1.0 |     1.5 | 1.399872 | 2.899872 |
</span><span class="noop">    | 14.01. |    1.0 |             2.899872 |                    1.5 |          0.0 |     -1.499872 |              0.000001 |        0.000001 |        0.000001 |      0.000001 |            0.0 | 0.000001 |    0.471603 |   1.0 |     0.5 | 0.000001 | 0.500001 |
</span><span class="noop">    | 15.01. |    1.0 |             0.500001 |                    0.5 |          0.9 |      0.899999 |              1.399872 |        1.399872 |        1.399872 |      1.399872 |            0.0 | 1.399872 |    0.437054 |   1.0 |     1.5 | 1.399872 | 2.899872 |
</span><span class="noop">    | 16.01. |    1.0 |             2.899872 |                    1.5 |          0.0 |     -1.499872 |              0.000001 |        0.000001 |        0.000001 |      0.000001 |            0.0 | 0.000001 |    0.523454 |   1.0 |     0.5 | 0.000001 | 0.500001 |
</span><span class="noop">    | 17.01. |    1.0 |             0.500001 |                    0.5 |          0.9 |      0.899999 |              1.399872 |        1.399872 |        1.399872 |      1.399872 |            0.0 | 1.399872 |    0.488905 |   1.0 |     1.5 | 1.399872 | 2.899872 |
</span><span class="noop">    | 18.01. |    1.0 |             2.899872 |                    1.5 |          0.0 |     -1.499872 |              0.000001 |        0.000001 |        0.000001 |      0.000001 |            0.0 | 0.000001 |    0.575305 |   1.0 |     0.5 | 0.000001 | 0.500001 |
</span><span class="noop">    | 19.01. |    1.0 |             0.500001 |                    0.5 |          0.9 |      0.899999 |              1.399872 |        1.399872 |        1.399872 |      1.399872 |            0.0 | 1.399872 |    0.540756 |   1.0 |     1.5 | 1.399872 | 2.899872 |
</span><span class="noop">    | 20.01. |    1.0 |             2.899872 |                    1.5 |          0.0 |     -1.499872 |              0.000001 |        0.000001 |        0.000001 |      0.000001 |            0.0 | 0.000001 |    0.627156 |   1.0 |     0.5 | 0.000001 | 0.500001 |
</span><span class="noop">
</span><span class="noop">    It seems advisable to increase the number of observations taken into
</span><span class="noop">    account to estimate the natural discharge at the cross section.
</span><span class="noop">    For this purpuse, the value of parameter `nmblogentries` is set to
</span><span class="noop">    two days:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nmblogentries(2)
</span><span class="noop">
</span><span class="noop">    Now the water release is relatively constant.  This does not completely
</span><span class="noop">    solve the problems of wasting water during peak flows and the repeated
</span><span class="noop">    violation the low flow threshold, but reduces them significantly:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume | input | natural |   output |   remote |
</span><span class="noop">    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |    1.0 |             0.500001 |                    1.9 |          0.0 |          -0.5 |                 0.005 |           0.005 |           0.005 |      0.002727 |            0.0 | 0.002727 |    0.086164 |   1.0 |     1.5 | 0.002727 | 1.502727 |
</span><span class="noop">    | 02.01. |    1.0 |             1.502727 |                    1.7 |          0.0 |     -0.301364 |              0.029495 |        0.029495 |        0.029495 |      0.029487 |            0.0 | 0.029487 |    0.170017 |   1.0 |     0.5 | 0.029487 | 0.529487 |
</span><span class="noop">    | 03.01. |    1.0 |             0.529487 |                    1.0 |          0.4 |      0.383893 |              0.885738 |        0.885738 |        0.885738 |      0.885738 |            0.0 | 0.885738 |    0.179889 |   1.0 |     1.5 | 0.885738 | 2.385738 |
</span><span class="noop">    | 04.01. |    1.0 |             2.385738 |                    1.0 |          0.4 |     -0.057613 |               0.58532 |         0.58532 |         0.58532 |       0.58532 |            0.0 |  0.58532 |    0.215717 |   1.0 |     0.5 |  0.58532 |  1.08532 |
</span><span class="noop">    | 05.01. |    1.0 |              1.08532 |                    1.0 |          0.4 |     -0.335529 |              0.421895 |        0.421895 |        0.421895 |      0.421895 |            0.0 | 0.421895 |    0.265666 |   1.0 |     1.5 | 0.421895 | 1.921895 |
</span><span class="noop">    | 06.01. |    1.0 |             1.921895 |                    1.0 |          0.4 |     -0.103607 |              0.539224 |        0.539224 |        0.539224 |      0.539224 |            0.0 | 0.539224 |    0.305477 |   1.0 |     0.5 | 0.539224 | 1.039224 |
</span><span class="noop">    | 07.01. |    1.0 |             1.039224 |                    1.0 |          0.4 |     -0.080559 |              0.561463 |        0.561463 |        0.561463 |      0.561463 |            0.0 | 0.561463 |    0.343366 |   1.0 |     1.5 | 0.561463 | 2.061463 |
</span><span class="noop">    | 08.01. |    1.0 |             2.061463 |                    1.0 |          0.4 |     -0.150343 |              0.500369 |        0.500369 |        0.500369 |      0.500369 |            0.0 | 0.500369 |    0.386534 |   1.0 |     0.5 | 0.500369 | 1.000369 |
</span><span class="noop">    | 09.01. |    1.0 |             1.000369 |                    1.0 |          0.4 |     -0.130916 |              0.515458 |        0.515458 |        0.515458 |      0.515458 |            0.0 | 0.515458 |    0.428399 |   1.0 |     1.5 | 0.515458 | 2.015458 |
</span><span class="noop">    | 10.01. |    1.0 |             2.015458 |                    1.0 |          0.4 |     -0.107913 |              0.535283 |        0.535283 |        0.535283 |      0.535283 |            0.0 | 0.535283 |     0.46855 |   1.0 |     0.5 | 0.535283 | 1.035283 |
</span><span class="noop">    | 11.01. |    1.0 |             1.035283 |                    1.0 |          0.4 |     -0.125371 |              0.520045 |        0.520045 |        0.520045 |      0.520045 |            0.0 | 0.520045 |    0.510018 |   1.0 |     1.5 | 0.520045 | 2.020045 |
</span><span class="noop">    | 12.01. |    1.0 |             2.020045 |                    1.0 |          0.4 |     -0.127664 |              0.518133 |        0.518133 |        0.518133 |      0.518133 |            0.0 | 0.518133 |    0.551652 |   1.0 |     0.5 | 0.518133 | 1.018133 |
</span><span class="noop">    | 13.01. |    1.0 |             1.018133 |                    1.0 |          0.4 |     -0.119089 |               0.52539 |         0.52539 |         0.52539 |       0.52539 |            0.0 |  0.52539 |    0.592658 |   1.0 |     1.5 |  0.52539 |  2.02539 |
</span><span class="noop">    | 14.01. |    1.0 |              2.02539 |                    1.0 |          0.4 |     -0.121761 |              0.523097 |        0.523097 |        0.523097 |      0.523097 |            0.0 | 0.523097 |    0.633863 |   1.0 |     0.5 | 0.523097 | 1.023097 |
</span><span class="noop">    | 15.01. |    1.0 |             1.023097 |                    1.0 |          0.4 |     -0.124244 |              0.520992 |        0.520992 |        0.520992 |      0.520992 |            0.0 | 0.520992 |    0.675249 |   1.0 |     1.5 | 0.520992 | 2.020992 |
</span><span class="noop">    | 16.01. |    1.0 |             2.020992 |                    1.0 |          0.4 |     -0.122045 |              0.522855 |        0.522855 |        0.522855 |      0.522855 |            0.0 | 0.522855 |    0.716474 |   1.0 |     0.5 | 0.522855 | 1.022855 |
</span><span class="noop">    | 17.01. |    1.0 |             1.022855 |                    1.0 |          0.4 |     -0.121924 |              0.522958 |        0.522958 |        0.522958 |      0.522958 |            0.0 | 0.522958 |     0.75769 |   1.0 |     1.5 | 0.522958 | 2.022958 |
</span><span class="noop">    | 18.01. |    1.0 |             2.022958 |                    1.0 |          0.4 |     -0.122907 |              0.522123 |        0.522123 |        0.522123 |      0.522123 |            0.0 | 0.522123 |    0.798979 |   1.0 |     0.5 | 0.522123 | 1.022123 |
</span><span class="noop">    | 19.01. |    1.0 |             1.022123 |                    1.0 |          0.4 |      -0.12254 |              0.522434 |        0.522434 |        0.522434 |      0.522434 |            0.0 | 0.522434 |    0.840241 |   1.0 |     1.5 | 0.522434 | 2.022434 |
</span><span class="noop">    | 20.01. |    1.0 |             2.022434 |                    1.0 |          0.4 |     -0.122278 |              0.522657 |        0.522657 |        0.522657 |      0.522657 |            0.0 | 0.522657 |    0.881483 |   1.0 |     0.5 | 0.522657 | 1.022657 |
</span><span class="noop">
</span><span class="noop">    Such negative effects due to information delay cannot be circumvented
</span><span class="noop">    easily, unless one would solve the differential equations of all models
</span><span class="noop">    involved simultaneously.  However, at least for drougth events (with
</span><span class="noop">    much slower dynamics than flood events) these delays should normally
</span><span class="noop">    be not overly important.
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    The next examples are supposed to demonstrate that the flood retention
</span><span class="noop">    methods are implemented properly.  Hence, all parameters related to low
</span><span class="noop">    water calculations are set in a deactivating manner:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nmblogentries(1)
</span><span class="noop">    &gt;&gt;&gt; remotedischargeminimum(0.0)
</span><span class="noop">    &gt;&gt;&gt; remotedischargesavety(0.0)
</span><span class="noop">    &gt;&gt;&gt; neardischargeminimumthreshold(0.0)
</span><span class="noop">    &gt;&gt;&gt; neardischargeminimumtolerance(0.0)
</span><span class="noop">    &gt;&gt;&gt; waterlevelminimumthreshold(0.0)
</span><span class="noop">    &gt;&gt;&gt; waterlevelminimumtolerance(0.0)
</span><span class="noop">
</span><span class="noop">    To be able to compare the following numerical results of HydPy-Dam with
</span><span class="noop">    an analytical solution, we approximate a linear storage retetenion
</span><span class="noop">    process.  The relationship between water level and volume has already
</span><span class="noop">    been defined to be (approximately) linear in the range of 0 to 1e8 m³
</span><span class="noop">    or 0 to 25 m, respectively.  The relationship between flood discharge
</span><span class="noop">    and the water level is also approximately linear in this range, with a
</span><span class="noop">    discharge value of 62.5 m³/s for a water level 25 m:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; waterlevel2flooddischarge(
</span><span class="noop">    ...         weights_input=1e-6, weights_output=1e7,
</span><span class="noop">    ...         intercepts_hidden=0.0, intercepts_output=-1e7/2)
</span><span class="noop">    &gt;&gt;&gt; waterlevel2flooddischarge.plot(0.0, 25.0)
</span><span class="noop">
</span><span class="noop">    Close the drawn figure:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; pyplot.close()
</span><span class="noop">
</span><span class="noop">    Hence, for the given simulation step size, the linear storage
</span><span class="noop">    coefficient is approximately 0.054 per day.
</span><span class="noop">
</span><span class="noop">    (Please be careful when defining such extremely large and small parameter
</span><span class="noop">    values for `watervolume2waterlevel` and &#39;waterlevel2flooddischarge&#39;.
</span><span class="noop">    Otherwise you might get into precision loss trouble, causing the
</span><span class="noop">    numerical calculations of the dam model to become very slow or the
</span><span class="noop">    results to be very inaccurate.  So either use `normal` parameter values
</span><span class="noop">    or check the precision of the results of `watervolume2waterlevel` and
</span><span class="noop">    &#39;waterlevel2flooddischarge&#39; manually before performing the actual
</span><span class="noop">    simulation runs.)
</span><span class="noop">
</span><span class="noop">    Now a flood event needs to be defined:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; input_.sequences.sim.series = [ 0., 1., 5., 9., 8., 5., 3., 2., 1., 0.,
</span><span class="noop">    ...                                 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]
</span><span class="noop">
</span><span class="noop">    For the sake of simplicity, a constant discharge of 1 m³/s of the
</span><span class="noop">    subcatchment is assumed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test.inits.loggedtotalremotedischarge = 1.0
</span><span class="noop">    &gt;&gt;&gt; natural.sequences.sim.series = 1.0
</span><span class="noop">
</span><span class="noop">    At first, a low numerical accuracy of 0.01 m³/s is defined, which should
</span><span class="noop">    be sufficient for most flood simulations for large dams:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; solver.abserrormax(1e-2)
</span><span class="noop">
</span><span class="noop">    When simulating flood events, numerical stability and accuracy and
</span><span class="noop">    their relation to computation time should be examined more closely.
</span><span class="noop">    We use the number of function calls of the set of differential
</span><span class="noop">    equations as an indicator for computation time, and set the
</span><span class="noop">    corresponding counter to zero:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">
</span><span class="noop">    You can copy can plot this table to see that the dam actually responds
</span><span class="noop">    (approximately) like a linear storage:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume | input | natural |   output |   remote |
</span><span class="noop">    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |    0.0 |             1.022657 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |         0.0 |   0.0 |     1.0 |      0.0 |      1.0 |
</span><span class="noop">    | 02.01. |    1.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.026514 | 0.026514 |    0.084109 |   1.0 |     1.0 | 0.026514 | 1.026514 |
</span><span class="noop">    | 03.01. |    5.0 |             1.026514 |                    1.0 |          0.0 |     -1.026514 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.183744 | 0.183744 |    0.500234 |   5.0 |     1.0 | 0.183744 | 1.183744 |
</span><span class="noop">    | 04.01. |    9.0 |             1.183744 |                    1.0 |          0.0 |     -1.183744 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.542983 | 0.542983 |     1.23092 |   9.0 |     1.0 | 0.542983 | 1.542983 |
</span><span class="noop">    | 05.01. |    8.0 |             1.542983 |                    1.0 |          0.0 |     -1.542983 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.961039 | 0.961039 |    1.839086 |   8.0 |     1.0 | 0.961039 | 1.961039 |
</span><span class="noop">    | 06.01. |    5.0 |             1.961039 |                    1.0 |          0.0 |     -1.961039 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.251523 | 1.251523 |    2.162955 |   5.0 |     1.0 | 1.251523 | 2.251523 |
</span><span class="noop">    | 07.01. |    3.0 |             2.251523 |                    1.0 |          0.0 |     -2.251523 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.395546 | 1.395546 |    2.301579 |   3.0 |     1.0 | 1.395546 | 2.395546 |
</span><span class="noop">    | 08.01. |    2.0 |             2.395546 |                    1.0 |          0.0 |     -2.395546 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.453375 | 1.453375 |    2.348808 |   2.0 |     1.0 | 1.453375 | 2.453375 |
</span><span class="noop">    | 09.01. |    1.0 |             2.453375 |                    1.0 |          0.0 |     -2.453375 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.455596 | 1.455596 |    2.309444 |   1.0 |     1.0 | 1.455596 | 2.455596 |
</span><span class="noop">    | 10.01. |    0.0 |             2.455596 |                    1.0 |          0.0 |     -2.455596 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.405132 | 1.405132 |    2.188041 |   0.0 |     1.0 | 1.405132 | 2.405132 |
</span><span class="noop">    | 11.01. |    0.0 |             2.405132 |                    1.0 |          0.0 |     -2.405132 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.331267 | 1.331267 |    2.073019 |   0.0 |     1.0 | 1.331267 | 2.331267 |
</span><span class="noop">    | 12.01. |    0.0 |             2.331267 |                    1.0 |          0.0 |     -2.331267 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.261285 | 1.261285 |    1.964044 |   0.0 |     1.0 | 1.261285 | 2.261285 |
</span><span class="noop">    | 13.01. |    0.0 |             2.261285 |                    1.0 |          0.0 |     -2.261285 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.194981 | 1.194981 |    1.860798 |   0.0 |     1.0 | 1.194981 | 2.194981 |
</span><span class="noop">    | 14.01. |    0.0 |             2.194981 |                    1.0 |          0.0 |     -2.194981 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.132163 | 1.132163 |    1.762979 |   0.0 |     1.0 | 1.132163 | 2.132163 |
</span><span class="noop">    | 15.01. |    0.0 |             2.132163 |                    1.0 |          0.0 |     -2.132163 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.072647 | 1.072647 |    1.670302 |   0.0 |     1.0 | 1.072647 | 2.072647 |
</span><span class="noop">    | 16.01. |    0.0 |             2.072647 |                    1.0 |          0.0 |     -2.072647 |                   0.0 |             0.0 |             0.0 |           0.0 |        1.01626 |  1.01626 |    1.582498 |   0.0 |     1.0 |  1.01626 |  2.01626 |
</span><span class="noop">    | 17.01. |    0.0 |              2.01626 |                    1.0 |          0.0 |      -2.01626 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.962837 | 0.962837 |    1.499308 |   0.0 |     1.0 | 0.962837 | 1.962837 |
</span><span class="noop">    | 18.01. |    0.0 |             1.962837 |                    1.0 |          0.0 |     -1.962837 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.912222 | 0.912222 |    1.420492 |   0.0 |     1.0 | 0.912222 | 1.912222 |
</span><span class="noop">    | 19.01. |    0.0 |             1.912222 |                    1.0 |          0.0 |     -1.912222 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.864268 | 0.864268 |     1.34582 |   0.0 |     1.0 | 0.864268 | 1.864268 |
</span><span class="noop">    | 20.01. |    0.0 |             1.864268 |                    1.0 |          0.0 |     -1.864268 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.818835 | 0.818835 |    1.275072 |   0.0 |     1.0 | 0.818835 | 1.818835 |
</span><span class="noop">
</span><span class="noop">    For a more precise evaluation, you can compare the outflow of the dam
</span><span class="noop">    with the following results of the linear storage cascade with only
</span><span class="noop">    one storage:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.iuhtools import LinearStorageCascade
</span><span class="noop">    &gt;&gt;&gt; lsc = LinearStorageCascade(n=1, k=1.0/0.054)
</span><span class="noop">    &gt;&gt;&gt; round_(numpy.convolve(lsc.ma.coefs, input_.sequences.sim.series)[:20])
</span><span class="noop">    0.0, 0.02652, 0.183776, 0.543037, 0.961081, 1.251541, 1.395548, 1.453371, 1.455585, 1.405116, 1.331252, 1.261271, 1.194968, 1.132151, 1.072636, 1.01625, 0.962828, 0.912214, 0.864261, 0.818829
</span><span class="noop">
</span><span class="noop">    The largest difference occurs on January, 1. But this difference of
</span><span class="noop">    0.000054 m³/s is way below the required accuracy of 0.01 m³/s.  There
</span><span class="noop">    is no guarantee that the actual numerical error will always fall below
</span><span class="noop">    the defined tolerance value.  However, if everything works well, we
</span><span class="noop">    should at least expect so for the individual simulation time step,
</span><span class="noop">    as the actual error should be better as the error estimate by one order.
</span><span class="noop">    On the other hand, the accumulation of errors of individual simulation
</span><span class="noop">    time steps is not controlled and might sometimes result in an violation
</span><span class="noop">    of the defined tolerance value.
</span><span class="noop">
</span><span class="noop">    To achieve the results discussed above, about 4 calls of the methods
</span><span class="noop">    of the dam model were required:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">    78
</span><span class="noop">    &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">
</span><span class="noop">    If we set the tolerance value to 1e-6 m³/s, the printed table shows
</span><span class="noop">    (six decimal places) no deviation from the analytical solution of the
</span><span class="noop">    linear storage:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; solver.abserrormax(1e-6)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume | input | natural |   output |   remote |
</span><span class="noop">    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |    0.0 |             1.818835 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |         0.0 |   0.0 |     1.0 |      0.0 |      1.0 |
</span><span class="noop">    | 02.01. |    1.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |        0.02652 |  0.02652 |    0.084109 |   1.0 |     1.0 |  0.02652 |  1.02652 |
</span><span class="noop">    | 03.01. |    5.0 |              1.02652 |                    1.0 |          0.0 |      -1.02652 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.183776 | 0.183776 |     0.50023 |   5.0 |     1.0 | 0.183776 | 1.183776 |
</span><span class="noop">    | 04.01. |    9.0 |             1.183776 |                    1.0 |          0.0 |     -1.183776 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.543037 | 0.543037 |    1.230912 |   9.0 |     1.0 | 0.543037 | 1.543037 |
</span><span class="noop">    | 05.01. |    8.0 |             1.543037 |                    1.0 |          0.0 |     -1.543037 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.961081 | 0.961081 |    1.839075 |   8.0 |     1.0 | 0.961081 | 1.961081 |
</span><span class="noop">    | 06.01. |    5.0 |             1.961081 |                    1.0 |          0.0 |     -1.961081 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.251541 | 1.251541 |    2.162941 |   5.0 |     1.0 | 1.251541 | 2.251541 |
</span><span class="noop">    | 07.01. |    3.0 |             2.251541 |                    1.0 |          0.0 |     -2.251541 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.395548 | 1.395548 |    2.301566 |   3.0 |     1.0 | 1.395548 | 2.395548 |
</span><span class="noop">    | 08.01. |    2.0 |             2.395548 |                    1.0 |          0.0 |     -2.395548 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.453371 | 1.453371 |    2.348795 |   2.0 |     1.0 | 1.453371 | 2.453371 |
</span><span class="noop">    | 09.01. |    1.0 |             2.453371 |                    1.0 |          0.0 |     -2.453371 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.455585 | 1.455585 |    2.309432 |   1.0 |     1.0 | 1.455585 | 2.455585 |
</span><span class="noop">    | 10.01. |    0.0 |             2.455585 |                    1.0 |          0.0 |     -2.455585 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.405116 | 1.405116 |     2.18803 |   0.0 |     1.0 | 1.405116 | 2.405116 |
</span><span class="noop">    | 11.01. |    0.0 |             2.405116 |                    1.0 |          0.0 |     -2.405116 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.331252 | 1.331252 |     2.07301 |   0.0 |     1.0 | 1.331252 | 2.331252 |
</span><span class="noop">    | 12.01. |    0.0 |             2.331252 |                    1.0 |          0.0 |     -2.331252 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.261271 | 1.261271 |    1.964036 |   0.0 |     1.0 | 1.261271 | 2.261271 |
</span><span class="noop">    | 13.01. |    0.0 |             2.261271 |                    1.0 |          0.0 |     -2.261271 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.194968 | 1.194968 |    1.860791 |   0.0 |     1.0 | 1.194968 | 2.194968 |
</span><span class="noop">    | 14.01. |    0.0 |             2.194968 |                    1.0 |          0.0 |     -2.194968 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.132151 | 1.132151 |    1.762973 |   0.0 |     1.0 | 1.132151 | 2.132151 |
</span><span class="noop">    | 15.01. |    0.0 |             2.132151 |                    1.0 |          0.0 |     -2.132151 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.072636 | 1.072636 |    1.670297 |   0.0 |     1.0 | 1.072636 | 2.072636 |
</span><span class="noop">    | 16.01. |    0.0 |             2.072636 |                    1.0 |          0.0 |     -2.072636 |                   0.0 |             0.0 |             0.0 |           0.0 |        1.01625 |  1.01625 |    1.582493 |   0.0 |     1.0 |  1.01625 |  2.01625 |
</span><span class="noop">    | 17.01. |    0.0 |              2.01625 |                    1.0 |          0.0 |      -2.01625 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.962828 | 0.962828 |    1.499305 |   0.0 |     1.0 | 0.962828 | 1.962828 |
</span><span class="noop">    | 18.01. |    0.0 |             1.962828 |                    1.0 |          0.0 |     -1.962828 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.912214 | 0.912214 |     1.42049 |   0.0 |     1.0 | 0.912214 | 1.912214 |
</span><span class="noop">    | 19.01. |    0.0 |             1.912214 |                    1.0 |          0.0 |     -1.912214 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.864261 | 0.864261 |    1.345818 |   0.0 |     1.0 | 0.864261 | 1.864261 |
</span><span class="noop">    | 20.01. |    0.0 |             1.864261 |                    1.0 |          0.0 |     -1.864261 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.818829 | 0.818829 |    1.275071 |   0.0 |     1.0 | 0.818829 | 1.818829 |
</span><span class="noop">
</span><span class="noop">    However, this improvement in accuracy increases the computation time
</span><span class="noop">    significantly.  Now 10.5 calls were required on average:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">    211
</span><span class="noop">    &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">
</span><span class="noop">    Now we reset the local error tolerance to the more realistic value.
</span><span class="noop">    But we configure the `waterlevel2flooddischarge` parameter in a
</span><span class="noop">    highly reactive manner:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; solver.abserrormax(1e-2)
</span><span class="noop">    &gt;&gt;&gt; waterlevel2flooddischarge(
</span><span class="noop">    ...         weights_input=1e-4, weights_output=1e7,
</span><span class="noop">    ...         intercepts_hidden=0.0, intercepts_output=-1e7/2)
</span><span class="noop">    &gt;&gt;&gt; waterlevel2flooddischarge.plot(0.0, 25.0)
</span><span class="noop">
</span><span class="noop">   Close the drawn figure:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; pyplot.close()
</span><span class="noop">
</span><span class="noop">    With this new parameterization of the dam model, the linear storage
</span><span class="noop">    coefficient is approximately 5.4 per day.  This is why the following
</span><span class="noop">    test results show virtually no retention effects:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | inflow | totalremotedischarge | naturalremotedischarge | remotedemand | remotefailure | requiredremoterelease | requiredrelease | targetedrelease | actualrelease | flooddischarge |  outflow | watervolume | input | natural |   output |   remote |
</span><span class="noop">    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |    0.0 |             1.818829 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |            0.0 |      0.0 |         0.0 |   0.0 |     1.0 |      0.0 |      1.0 |
</span><span class="noop">    | 02.01. |    1.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.818699 | 0.818699 |    0.015664 |   1.0 |     1.0 | 0.818699 | 1.818699 |
</span><span class="noop">    | 03.01. |    5.0 |             1.818699 |                    1.0 |          0.0 |     -1.818699 |                   0.0 |             0.0 |             0.0 |           0.0 |        4.25814 |  4.25814 |    0.079761 |   5.0 |     1.0 |  4.25814 |  5.25814 |
</span><span class="noop">    | 04.01. |    9.0 |              5.25814 |                    1.0 |          0.0 |      -5.25814 |                   0.0 |             0.0 |             0.0 |           0.0 |       8.259255 | 8.259255 |    0.143761 |   9.0 |     1.0 | 8.259255 | 9.259255 |
</span><span class="noop">    | 05.01. |    8.0 |             9.259255 |                    1.0 |          0.0 |     -9.259255 |                   0.0 |             0.0 |             0.0 |           0.0 |       8.178598 | 8.178598 |    0.128331 |   8.0 |     1.0 | 8.178598 | 9.178598 |
</span><span class="noop">    | 06.01. |    5.0 |             9.178598 |                    1.0 |          0.0 |     -9.178598 |                   0.0 |             0.0 |             0.0 |           0.0 |       5.555424 | 5.555424 |    0.080342 |   5.0 |     1.0 | 5.555424 | 6.555424 |
</span><span class="noop">    | 07.01. |    3.0 |             6.555424 |                    1.0 |          0.0 |     -6.555424 |                   0.0 |             0.0 |             0.0 |           0.0 |       3.371696 | 3.371696 |    0.048227 |   3.0 |     1.0 | 3.371696 | 4.371696 |
</span><span class="noop">    | 08.01. |    2.0 |             4.371696 |                    1.0 |          0.0 |     -4.371696 |                   0.0 |             0.0 |             0.0 |           0.0 |       2.183878 | 2.183878 |     0.03234 |   2.0 |     1.0 | 2.183878 | 3.183878 |
</span><span class="noop">    | 09.01. |    1.0 |             3.183878 |                    1.0 |          0.0 |     -3.183878 |                   0.0 |             0.0 |             0.0 |           0.0 |       1.185158 | 1.185158 |    0.016343 |   1.0 |     1.0 | 1.185158 | 2.185158 |
</span><span class="noop">    | 10.01. |    0.0 |             2.185158 |                    1.0 |          0.0 |     -2.185158 |                   0.0 |             0.0 |             0.0 |           0.0 |       0.187346 | 0.188656 |    0.000043 |   0.0 |     1.0 | 0.188656 | 1.188656 |
</span><span class="noop">    | 11.01. |    0.0 |             1.188656 |                    1.0 |          0.0 |     -1.188656 |                   0.0 |             0.0 |             0.0 |           0.0 |       -0.00455 | 0.001338 |   -0.000073 |   0.0 |     1.0 | 0.001338 | 1.001338 |
</span><span class="noop">    | 12.01. |    0.0 |             1.001338 |                    1.0 |          0.0 |     -1.001338 |                   0.0 |             0.0 |             0.0 |           0.0 |       -0.00455 |      0.0 |   -0.000073 |   0.0 |     1.0 |      0.0 |      1.0 |
</span><span class="noop">    | 13.01. |    0.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |       -0.00455 |      0.0 |   -0.000073 |   0.0 |     1.0 |      0.0 |      1.0 |
</span><span class="noop">    | 14.01. |    0.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |       -0.00455 |      0.0 |   -0.000073 |   0.0 |     1.0 |      0.0 |      1.0 |
</span><span class="noop">    | 15.01. |    0.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |       -0.00455 |      0.0 |   -0.000073 |   0.0 |     1.0 |      0.0 |      1.0 |
</span><span class="noop">    | 16.01. |    0.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |       -0.00455 |      0.0 |   -0.000073 |   0.0 |     1.0 |      0.0 |      1.0 |
</span><span class="noop">    | 17.01. |    0.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |       -0.00455 |      0.0 |   -0.000073 |   0.0 |     1.0 |      0.0 |      1.0 |
</span><span class="noop">    | 18.01. |    0.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |       -0.00455 |      0.0 |   -0.000073 |   0.0 |     1.0 |      0.0 |      1.0 |
</span><span class="noop">    | 19.01. |    0.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |       -0.00455 |      0.0 |   -0.000073 |   0.0 |     1.0 |      0.0 |      1.0 |
</span><span class="noop">    | 20.01. |    0.0 |                  1.0 |                    1.0 |          0.0 |          -1.0 |                   0.0 |             0.0 |             0.0 |           0.0 |       -0.00455 |      0.0 |   -0.000073 |   0.0 |     1.0 |      0.0 |      1.0 |
</span><span class="noop">
</span><span class="noop">    The following calculations show that the dam model reaches the required
</span><span class="noop">    numerical for this extreme parameterizations:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; lsc.k = 1.0/5.4
</span><span class="noop">    &gt;&gt;&gt; round_(numpy.convolve(lsc.ma.coefs, input_.sequences.sim.series)[:20])
</span><span class="noop">    0.0, 0.815651, 4.261772, 8.259271, 8.181003, 5.553864, 3.371199, 2.186025, 1.185189, 0.185185, 0.000836, 0.000004, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
</span><span class="noop">
</span><span class="noop">    However, due to the potential stiffness of this parameterization, the
</span><span class="noop">    division of the different simulation steps into some substeps were
</span><span class="noop">    required.  This increased the average required number of model methods
</span><span class="noop">    calls to 19 per simulation step:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; model.numvars.nmb_calls
</span><span class="noop">    358
</span><span class="noop">    &gt;&gt;&gt; model.numvars.nmb_calls = 0
</span><span class="noop">
</span><span class="noop">    Also note that the final water volume is negative due the limited
</span><span class="noop">    numerical accuracy of the results.
</span><span class="noop">
</span><span class="noop">    For common (realistic) simulations of dam retention processes, the
</span><span class="noop">    stability issue disussed here should not be of big relevance.
</span><span class="noop">    But one should keep it in mind when playing around with parameters
</span><span class="noop">    e.g. during model calibration.  Otherwise unexpectedly long simulation
</span><span class="noop">    durations might occur.
</span><span class="noop">
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from dam
</span><span class="hit">from hydpy.models.dam import dam_model
</span><span class="hit">from hydpy.models.dam import dam_control
</span><span class="hit">from hydpy.models.dam import dam_derived
</span><span class="hit">from hydpy.models.dam import dam_solver
</span><span class="hit">from hydpy.models.dam import dam_fluxes
</span><span class="hit">from hydpy.models.dam import dam_states
</span><span class="hit">from hydpy.models.dam import dam_logs
</span><span class="hit">from hydpy.models.dam import dam_aides
</span><span class="hit">from hydpy.models.dam import dam_inlets
</span><span class="hit">from hydpy.models.dam import dam_outlets
</span><span class="hit">from hydpy.models.dam import dam_receivers
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.ModelELS):
</span><span class="noop">    &#34;&#34;&#34;Version 1 of HydPy-Dam.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _INLET_METHODS = (dam_model.pic_inflow_v1,
</span><span class="noop">                      dam_model.calc_naturalremotedischarge_v1,
</span><span class="noop">                      dam_model.calc_remotedemand_v1,
</span><span class="noop">                      dam_model.calc_remotefailure_v1,
</span><span class="noop">                      dam_model.calc_requiredremoterelease_v1,
</span><span class="noop">                      dam_model.calc_requiredrelease_v1,
</span><span class="noop">                      dam_model.calc_targetedrelease_v1)
</span><span class="hit">    _RECEIVER_METHODS = (dam_model.pic_totalremotedischarge_v1,
</span><span class="noop">                         dam_model.update_loggedtotalremotedischarge_v1)
</span><span class="hit">    _PART_ODE_METHODS = (dam_model.pic_inflow_v1,
</span><span class="noop">                         dam_model.calc_waterlevel_v1,
</span><span class="noop">                         dam_model.calc_actualrelease_v1,
</span><span class="noop">                         dam_model.calc_flooddischarge_v1,
</span><span class="noop">                         dam_model.calc_outflow_v1)
</span><span class="hit">    _FULL_ODE_METHODS = (dam_model.update_watervolume_v1,)
</span><span class="hit">    _OUTLET_METHODS = (dam_model.pass_outflow_v1,
</span><span class="noop">                       dam_model.update_loggedoutflow_v1)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of HydPy-Dam, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (dam_control.CatchmentArea,
</span><span class="noop">                   dam_control.NmbLogEntries,
</span><span class="noop">                   dam_control.RemoteDischargeMinimum,
</span><span class="noop">                   dam_control.RemoteDischargeSavety,
</span><span class="noop">                   dam_control.NearDischargeMinimumThreshold,
</span><span class="noop">                   dam_control.NearDischargeMinimumTolerance,
</span><span class="noop">                   dam_control.WaterLevelMinimumThreshold,
</span><span class="noop">                   dam_control.WaterLevelMinimumTolerance,
</span><span class="noop">                   dam_control.WaterVolume2WaterLevel,
</span><span class="noop">                   dam_control.WaterLevel2FloodDischarge)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of HydPy-Dam, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (dam_derived.TOY,
</span><span class="noop">                   dam_derived.Seconds,
</span><span class="noop">                   dam_derived.RemoteDischargeSmoothPar,
</span><span class="noop">                   dam_derived.NearDischargeMinimumSmoothPar1,
</span><span class="noop">                   dam_derived.NearDischargeMinimumSmoothPar2,
</span><span class="noop">                   dam_derived.WaterLevelMinimumSmoothPar)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SolverParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Solver parameters of HydPy-Dam, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (dam_solver.AbsErrorMax,
</span><span class="noop">                   dam_solver.RelDTMin)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of HydPy-Dam, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (dam_fluxes.Inflow,
</span><span class="noop">                   dam_fluxes.TotalRemoteDischarge,
</span><span class="noop">                   dam_fluxes.NaturalRemoteDischarge,
</span><span class="noop">                   dam_fluxes.RemoteDemand,
</span><span class="noop">                   dam_fluxes.RemoteFailure,
</span><span class="noop">                   dam_fluxes.RequiredRemoteRelease,
</span><span class="noop">                   dam_fluxes.RequiredRelease,
</span><span class="noop">                   dam_fluxes.TargetedRelease,
</span><span class="noop">                   dam_fluxes.ActualRelease,
</span><span class="noop">                   dam_fluxes.FloodDischarge,
</span><span class="noop">                   dam_fluxes.Outflow)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of HydPy-Dam, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (dam_states.WaterVolume,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequences(sequencetools.LogSequences):
</span><span class="noop">    &#34;&#34;&#34;Log sequences of HydPy-Dam, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (dam_logs.LoggedTotalRemoteDischarge,
</span><span class="noop">                   dam_logs.LoggedOutflow)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of HydPy-Dam, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (dam_aides.WaterLevel,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of HydPy-Dam, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (dam_inlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of HydPy-Dam, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (dam_outlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ReceiverSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Information link sequences of HydPy-Dam, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (dam_receivers.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from hbranch
</span><span class="hit">from hydpy.models.hbranch import hbranch_model
</span><span class="hit">from hydpy.models.hbranch import hbranch_control
</span><span class="hit">from hydpy.models.hbranch import hbranch_derived
</span><span class="hit">from hydpy.models.hbranch import hbranch_fluxes
</span><span class="hit">from hydpy.models.hbranch import hbranch_inlets
</span><span class="hit">from hydpy.models.hbranch import hbranch_outlets
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(hbranch_model.Model):
</span><span class="noop">    &#34;&#34;&#34;The HBV96 version of HydPy-H-Stream (hbranch_v1).&#34;&#34;&#34;
</span><span class="hit">    _INLET_METHODS = (hbranch_model.pick_input_v1,)
</span><span class="hit">    _RUN_METHODS = (hbranch_model.calc_outputs_v1,)
</span><span class="hit">    _OUTLET_METHODS = (hbranch_model.pass_outputs_v1,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of hbranch_v1, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (hbranch_control.XPoints,
</span><span class="noop">                   hbranch_control.YPoints)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of hbranch_v1, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (hbranch_derived.NmbBranches,
</span><span class="noop">                   hbranch_derived.NmbPoints)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of hbranch_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hbranch_fluxes.Input,
</span><span class="noop">                   hbranch_fluxes.Outputs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of hbranch_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hbranch_inlets.Total,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of hbranch_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hbranch_outlets.Branched,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Version 1 of the H-Land model is designed to agree with the HBV96
</span><span class="noop">configuration of the HBV model used by the German Federal Institute
</span><span class="noop">of Hydrology (BfG), but offers more flexibility in some regards (e.g. in
</span><span class="noop">parameterization).  It can briefly be summarized as follows:
</span><span class="noop">
</span><span class="noop">.. image:: HydPy-H-Land_Version-1.png
</span><span class="noop">
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from hland
</span><span class="hit">from hydpy.models.hland import hland_model
</span><span class="hit">from hydpy.models.hland import hland_control
</span><span class="hit">from hydpy.models.hland import hland_derived
</span><span class="hit">from hydpy.models.hland import hland_inputs
</span><span class="hit">from hydpy.models.hland import hland_fluxes
</span><span class="hit">from hydpy.models.hland import hland_states
</span><span class="hit">from hydpy.models.hland import hland_aides
</span><span class="hit">from hydpy.models.hland import hland_logs
</span><span class="hit">from hydpy.models.hland import hland_outlets
</span><span class="hit">from hydpy.models.hland.hland_parameters import Parameters
</span><span class="hit">from hydpy.models.hland.hland_constants import *
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;HBV96 version of HydPy-H-Land (hland_v1).&#34;&#34;&#34;
</span><span class="hit">    _RUN_METHODS = (hland_model.calc_tc_v1,
</span><span class="noop">                    hland_model.calc_tmean_v1,
</span><span class="noop">                    hland_model.calc_fracrain_v1,
</span><span class="noop">                    hland_model.calc_rfc_sfc_v1,
</span><span class="noop">                    hland_model.calc_pc_v1,
</span><span class="noop">                    hland_model.calc_ep_v1,
</span><span class="noop">                    hland_model.calc_epc_v1,
</span><span class="noop">                    hland_model.calc_tf_ic_v1,
</span><span class="noop">                    hland_model.calc_ei_ic_v1,
</span><span class="noop">                    hland_model.calc_sp_wc_v1,
</span><span class="noop">                    hland_model.calc_melt_sp_wc_v1,
</span><span class="noop">                    hland_model.calc_refr_sp_wc_v1,
</span><span class="noop">                    hland_model.calc_glmelt_in_v1,
</span><span class="noop">                    hland_model.calc_in_wc_v1,
</span><span class="noop">                    hland_model.calc_r_sm_v1,
</span><span class="noop">                    hland_model.calc_cf_sm_v1,
</span><span class="noop">                    hland_model.calc_ea_sm_v1,
</span><span class="noop">                    hland_model.calc_inuz_v1,
</span><span class="noop">                    hland_model.calc_contriarea_v1,
</span><span class="noop">                    hland_model.calc_q0_perc_uz_v1,
</span><span class="noop">                    hland_model.calc_lz_v1,
</span><span class="noop">                    hland_model.calc_el_lz_v1,
</span><span class="noop">                    hland_model.calc_q1_lz_v1,
</span><span class="noop">                    hland_model.calc_inuh_v1,
</span><span class="noop">                    hland_model.calc_outuh_quh_v1,
</span><span class="noop">                    hland_model.calc_qt_v1)
</span><span class="hit">    _OUTLET_METHODS = (hland_model.update_q_v1,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of hland_v1, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (hland_control.Area,
</span><span class="noop">                   hland_control.NmbZones,
</span><span class="noop">                   hland_control.ZoneType,
</span><span class="noop">                   hland_control.ZoneArea,
</span><span class="noop">                   hland_control.ZoneZ,
</span><span class="noop">                   hland_control.ZRelP,
</span><span class="noop">                   hland_control.ZRelT,
</span><span class="noop">                   hland_control.ZRelE,
</span><span class="noop">                   hland_control.PCorr,
</span><span class="noop">                   hland_control.PCAlt,
</span><span class="noop">                   hland_control.RfCF,
</span><span class="noop">                   hland_control.SfCF,
</span><span class="noop">                   hland_control.TCAlt,
</span><span class="noop">                   hland_control.ECorr,
</span><span class="noop">                   hland_control.ECAlt,
</span><span class="noop">                   hland_control.EPF,
</span><span class="noop">                   hland_control.ETF,
</span><span class="noop">                   hland_control.ERed,
</span><span class="noop">                   hland_control.TTIce,
</span><span class="noop">                   hland_control.IcMax,
</span><span class="noop">                   hland_control.TT,
</span><span class="noop">                   hland_control.TTInt,
</span><span class="noop">                   hland_control.DTTM,
</span><span class="noop">                   hland_control.CFMax,
</span><span class="noop">                   hland_control.GMelt,
</span><span class="noop">                   hland_control.CFR,
</span><span class="noop">                   hland_control.WHC,
</span><span class="noop">                   hland_control.FC,
</span><span class="noop">                   hland_control.LP,
</span><span class="noop">                   hland_control.Beta,
</span><span class="noop">                   hland_control.PercMax,
</span><span class="noop">                   hland_control.CFlux,
</span><span class="noop">                   hland_control.RespArea,
</span><span class="noop">                   hland_control.RecStep,
</span><span class="noop">                   hland_control.Alpha,
</span><span class="noop">                   hland_control.K,
</span><span class="noop">                   hland_control.K4,
</span><span class="noop">                   hland_control.Gamma,
</span><span class="noop">                   hland_control.MaxBaz,
</span><span class="noop">                   hland_control.Abstr)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of hland_v1, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (hland_derived.RelZoneArea,
</span><span class="noop">                   hland_derived.RelSoilArea,
</span><span class="noop">                   hland_derived.RelSoilZoneArea,
</span><span class="noop">                   hland_derived.RelLandZoneArea,
</span><span class="noop">                   hland_derived.RelLandArea,
</span><span class="noop">                   hland_derived.TTM,
</span><span class="noop">                   hland_derived.DT,
</span><span class="noop">                   hland_derived.NmbUH,
</span><span class="noop">                   hland_derived.UH,
</span><span class="noop">                   hland_derived.QFactor)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequences(sequencetools.InputSequences):
</span><span class="noop">    &#34;&#34;&#34;Input sequences of hland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hland_inputs.P,
</span><span class="noop">                   hland_inputs.T,
</span><span class="noop">                   hland_inputs.TN,
</span><span class="noop">                   hland_inputs.EPN)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of hland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hland_fluxes.TMean,
</span><span class="noop">                   hland_fluxes.TC,
</span><span class="noop">                   hland_fluxes.FracRain,
</span><span class="noop">                   hland_fluxes.RfC,
</span><span class="noop">                   hland_fluxes.SfC,
</span><span class="noop">                   hland_fluxes.PC,
</span><span class="noop">                   hland_fluxes.EP,
</span><span class="noop">                   hland_fluxes.EPC,
</span><span class="noop">                   hland_fluxes.EI,
</span><span class="noop">                   hland_fluxes.TF,
</span><span class="noop">                   hland_fluxes.TFWat,
</span><span class="noop">                   hland_fluxes.TFIce,
</span><span class="noop">                   hland_fluxes.GlMelt,
</span><span class="noop">                   hland_fluxes.MeltPot,
</span><span class="noop">                   hland_fluxes.Melt,
</span><span class="noop">                   hland_fluxes.RefrPot,
</span><span class="noop">                   hland_fluxes.Refr,
</span><span class="noop">                   hland_fluxes.In_,
</span><span class="noop">                   hland_fluxes.R,
</span><span class="noop">                   hland_fluxes.EA,
</span><span class="noop">                   hland_fluxes.CFPot,
</span><span class="noop">                   hland_fluxes.CF,
</span><span class="noop">                   hland_fluxes.Perc,
</span><span class="noop">                   hland_fluxes.ContriArea,
</span><span class="noop">                   hland_fluxes.InUZ,
</span><span class="noop">                   hland_fluxes.Q0,
</span><span class="noop">                   hland_fluxes.EL,
</span><span class="noop">                   hland_fluxes.Q1,
</span><span class="noop">                   hland_fluxes.InUH,
</span><span class="noop">                   hland_fluxes.OutUH,
</span><span class="noop">                   hland_fluxes.QT)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of hland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hland_states.Ic,
</span><span class="noop">                   hland_states.SP,
</span><span class="noop">                   hland_states.WC,
</span><span class="noop">                   hland_states.SM,
</span><span class="noop">                   hland_states.UZ,
</span><span class="noop">                   hland_states.LZ)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of hland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hland_logs.QUH,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of hland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hland_aides.Perc,
</span><span class="noop">                   hland_aides.Q0)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of hland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hland_outlets.Q,)
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from hstream
</span><span class="hit">from hydpy.models.hstream import hstream_model
</span><span class="hit">from hydpy.models.hstream import hstream_control
</span><span class="hit">from hydpy.models.hstream import hstream_derived
</span><span class="hit">from hydpy.models.hstream import hstream_states
</span><span class="hit">from hydpy.models.hstream import hstream_inlets
</span><span class="hit">from hydpy.models.hstream import hstream_outlets
</span><span class="hit">from hydpy.models.hstream.hstream_parameters import Parameters
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;The HBV96 version of HydPy-H-Stream (hstream_v1).&#34;&#34;&#34;
</span><span class="hit">    _INLET_METHODS = (hstream_model.pick_q_v1,)
</span><span class="hit">    _RUN_METHODS = (hstream_model.calc_qjoints_v1,)
</span><span class="hit">    _OUTLET_METHODS = (hstream_model.pass_q_v1,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of hstream_v1, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (hstream_control.Lag,
</span><span class="noop">                   hstream_control.Damp)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of hstream_v1, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (hstream_derived.NmbSegments,
</span><span class="noop">                   hstream_derived.C1,
</span><span class="noop">                   hstream_derived.C2,
</span><span class="noop">                   hstream_derived.C3)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of hstream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hstream_states.QJoints,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of stream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hstream_inlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of hstream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hstream_outlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">The LARSIM-Lake version of HydPy-L-Lake (called llake_v1) is a simple lake
</span><span class="noop">model. Its continuity equation is primarily solved via a central finite
</span><span class="noop">difference approach.  It allows for an arbitrary number of inflows and
</span><span class="noop">determines a single outflow value for each simulation time step.
</span><span class="noop">The relationships between water stage, water volume and the associated
</span><span class="noop">outflow are defined via vectors.  Between/beyond the triples defined by
</span><span class="noop">these vectors, linear interpolation/extrapolation is performed.
</span><span class="noop">The outflow vector is allowed to vary with seasonal pattern.  Therefore,
</span><span class="noop">different vectors for different times of the year need to be defined.
</span><span class="noop">Again, between these dates linear interpolation is performed to gain
</span><span class="noop">intermediate vectors.
</span><span class="noop">
</span><span class="noop">Two additional features are implemented.  Firstly, one can define a
</span><span class="noop">maximum drop of the water stage, which is not exceeded even when the
</span><span class="noop">triples of  water state, water volume and outflow indicate so.
</span><span class="noop">Secondly, water can be added to or substracted from the outflow
</span><span class="noop">calculated beforehand.  Both associated scalar parameters are allowed
</span><span class="noop">to vary in time, as explained for the outflow vector.
</span><span class="noop">
</span><span class="noop">Note that the accuracy of the results calculated by lake_v1 depend
</span><span class="noop">on the internal step size parameter
</span><span class="noop">:class:`~hydpy.models.llake.llake_control.MaxDT`.
</span><span class="noop">
</span><span class="noop">Integration examples:
</span><span class="noop">
</span><span class="noop">    The following are performed over a period of 20 days:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import pub, Timegrid, Timegrids, Nodes, Element
</span><span class="noop">    &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;01.01.2000&#39;,
</span><span class="noop">    ...                                    &#39;21.01.2000&#39;,
</span><span class="noop">    ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">    Import the model and define the time settings:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.llake_v1 import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">
</span><span class="noop">    For testing purposes, the model input shall be retrieved from the nodes
</span><span class="noop">    `input1` and `input2` and the model output shall be passed to node
</span><span class="noop">    `output`.  Firstly, define all nodes:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nodes = Nodes(&#39;input1&#39;, &#39;input2&#39;, &#39;output&#39;)
</span><span class="noop">
</span><span class="noop">    Secondly, define the element &#34;lake&#34; and build the connections between
</span><span class="noop">    the nodes defined above and the `llake_v1` model instance:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; lake = Element(&#39;lake&#39;, inlets=[&#39;input1&#39;, &#39;input2&#39;], outlets=&#39;output&#39;)
</span><span class="noop">    &gt;&gt;&gt; lake.connect(model)
</span><span class="noop">
</span><span class="noop">    Prepare a test function object, which prints the respective values of
</span><span class="noop">    the model sequences `qz`, `qa`, `v`, and `w`.  The node sequence `sim`
</span><span class="noop">    is added in order to prove that the values calculated for `qa` are
</span><span class="noop">    actually passed to `sim`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.testtools import IntegrationTest
</span><span class="noop">    &gt;&gt;&gt; test = IntegrationTest(lake,
</span><span class="noop">    ...                        seqs=(fluxes.qz, fluxes.qa,
</span><span class="noop">    ...                              nodes.output.sequences.sim,
</span><span class="noop">    ...                              states.v, states.w),
</span><span class="noop">    ...                        inits=((states.v, 0.),
</span><span class="noop">    ...                               (states.w, 0.)))
</span><span class="noop">    &gt;&gt;&gt; test.dateformat = &#39;%d.%m.&#39;
</span><span class="noop">
</span><span class="noop">    Set the values of those control parameter, which remain fixed for all
</span><span class="noop">    three example simulations, in the most simple manner:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; n(2)
</span><span class="noop">    &gt;&gt;&gt; w(0., 1.)
</span><span class="noop">    &gt;&gt;&gt; v(0., 1e6)
</span><span class="noop">    &gt;&gt;&gt; q(0., 10.)
</span><span class="noop">    &gt;&gt;&gt; maxdt(&#39;1d&#39;)
</span><span class="noop">
</span><span class="noop">    Define two flood events, one for each lake inflow:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nodes.input1.sequences.sim.series = [
</span><span class="noop">    ...                         0., 0., 1., 3., 2., 1., 0., 0., 0., 0.,
</span><span class="noop">    ...                         0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]
</span><span class="noop">    &gt;&gt;&gt; nodes.input2.sequences.sim.series = [
</span><span class="noop">    ...                         0., 1., 5., 9., 8., 5., 3., 2., 1., 0.,
</span><span class="noop">    ...                         0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]
</span><span class="noop">
</span><span class="noop">    In the first example, neither a restriction regarding the maximum
</span><span class="noop">    water drop nor a water abstraction is defined.  Hence the sums of
</span><span class="noop">    the total input (qz) and of the final output (identical with qa) are
</span><span class="noop">    nearly the same.  The maximum of the final output occurs when
</span><span class="noop">    the falling limb of qz intersects with qa:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdw(.0)
</span><span class="noop">    &gt;&gt;&gt; verzw(0.)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   qz |       qa |   output |             v |        w |
</span><span class="noop">    ------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 |      0.0 |      0.0 |           0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  1.0 | 0.301676 | 0.301676 |  60335.195531 | 0.060335 |
</span><span class="noop">    | 03.01. |  6.0 | 2.231391 | 2.231391 | 385943.010518 | 0.385943 |
</span><span class="noop">    | 04.01. | 12.0 | 6.315244 | 6.315244 | 877105.886853 | 0.877106 |
</span><span class="noop">    | 05.01. | 10.0 | 9.141801 | 9.141801 | 951254.290316 | 0.951254 |
</span><span class="noop">    | 06.01. |  6.0 | 8.452893 | 8.452893 | 739324.327444 | 0.739324 |
</span><span class="noop">    | 07.01. |  3.0 | 6.067907 | 6.067907 | 474257.135467 | 0.474257 |
</span><span class="noop">    | 08.01. |  2.0 | 3.915203 | 3.915203 | 308783.556526 | 0.308784 |
</span><span class="noop">    | 09.01. |  1.0 | 2.457986 | 2.457986 |  182813.58946 | 0.182814 |
</span><span class="noop">    | 10.01. |  0.0 | 1.276631 | 1.276631 |  72512.652803 | 0.072513 |
</span><span class="noop">    | 11.01. |  0.0 | 0.506373 | 0.506373 |   28762.00195 | 0.028762 |
</span><span class="noop">    | 12.01. |  0.0 | 0.200852 | 0.200852 |  11408.391835 | 0.011408 |
</span><span class="noop">    | 13.01. |  0.0 | 0.079668 | 0.079668 |   4525.116314 | 0.004525 |
</span><span class="noop">    | 14.01. |  0.0 |   0.0316 |   0.0316 |   1794.878538 | 0.001795 |
</span><span class="noop">    | 15.01. |  0.0 | 0.012534 | 0.012534 |    711.935063 | 0.000712 |
</span><span class="noop">    | 16.01. |  0.0 | 0.004972 | 0.004972 |    282.387651 | 0.000282 |
</span><span class="noop">    | 17.01. |  0.0 | 0.001972 | 0.001972 |    112.008509 | 0.000112 |
</span><span class="noop">    | 18.01. |  0.0 | 0.000782 | 0.000782 |     44.427956 | 0.000044 |
</span><span class="noop">    | 19.01. |  0.0 |  0.00031 |  0.00031 |     17.622262 | 0.000018 |
</span><span class="noop">    | 20.01. |  0.0 | 0.000123 | 0.000123 |      6.989836 | 0.000007 |
</span><span class="noop">
</span><span class="noop">    When the maximum water drop is set to 0.1 m/d, the resulting
</span><span class="noop">    outflow hydrograph shows a plateau in its falling limb.  This
</span><span class="noop">    plateau is placed in the time period, where little inflow occurs
</span><span class="noop">    but the (potential) outflow is still high, due to large amounts
</span><span class="noop">    of stored water.  In this time period, qa is limited by the
</span><span class="noop">    maximum water drop allowed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdw(.1)
</span><span class="noop">    &gt;&gt;&gt; verzw(0.)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   qz |       qa |   output |             v |        w |
</span><span class="noop">    ------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 |      0.0 |      0.0 |           0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  1.0 | 0.301676 | 0.301676 |  60335.195531 | 0.060335 |
</span><span class="noop">    | 03.01. |  6.0 | 2.231391 | 2.231391 | 385943.010518 | 0.385943 |
</span><span class="noop">    | 04.01. | 12.0 | 6.315244 | 6.315244 | 877105.886853 | 0.877106 |
</span><span class="noop">    | 05.01. | 10.0 | 9.141801 | 9.141801 | 951254.290316 | 0.951254 |
</span><span class="noop">    | 06.01. |  6.0 | 7.157407 | 7.157407 | 851254.290316 | 0.851254 |
</span><span class="noop">    | 07.01. |  3.0 | 4.157407 | 4.157407 | 751254.290316 | 0.751254 |
</span><span class="noop">    | 08.01. |  2.0 | 3.157407 | 3.157407 | 651254.290316 | 0.651254 |
</span><span class="noop">    | 09.01. |  1.0 | 2.157407 | 2.157407 | 551254.290316 | 0.551254 |
</span><span class="noop">    | 10.01. |  0.0 | 1.157407 | 1.157407 | 451254.290316 | 0.451254 |
</span><span class="noop">    | 11.01. |  0.0 | 1.157407 | 1.157407 | 351254.290316 | 0.351254 |
</span><span class="noop">    | 12.01. |  0.0 | 1.157407 | 1.157407 | 251254.290316 | 0.251254 |
</span><span class="noop">    | 13.01. |  0.0 | 1.157407 | 1.157407 | 151254.290316 | 0.151254 |
</span><span class="noop">    | 14.01. |  0.0 | 1.056245 | 1.056245 |  59994.718505 | 0.059995 |
</span><span class="noop">    | 15.01. |  0.0 | 0.418958 | 0.418958 |  23796.787787 | 0.023797 |
</span><span class="noop">    | 16.01. |  0.0 | 0.166179 | 0.166179 |   9438.949346 | 0.009439 |
</span><span class="noop">    | 17.01. |  0.0 | 0.065914 | 0.065914 |   3743.940802 | 0.003744 |
</span><span class="noop">    | 18.01. |  0.0 | 0.026145 | 0.026145 |   1485.026799 | 0.001485 |
</span><span class="noop">    | 19.01. |  0.0 |  0.01037 |  0.01037 |    589.032976 | 0.000589 |
</span><span class="noop">    | 20.01. |  0.0 | 0.004113 | 0.004113 |    233.638778 | 0.000234 |
</span><span class="noop">
</span><span class="noop">    In the above example, the water balance is still maintained.  This
</span><span class="noop">    is not the case for the last example, where 1 m³/s is subtracted
</span><span class="noop">    from the total outflow.  Regarding its peak time and form, the
</span><span class="noop">    output hydrograph is identical/similar to the one of the first
</span><span class="noop">    example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdw(.0)
</span><span class="noop">    &gt;&gt;&gt; verzw(1.)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   qz |       qa |   output |             v |        w |
</span><span class="noop">    ------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 |      0.0 |      0.0 |           0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  1.0 |      0.0 |      0.0 |  60335.195531 | 0.060335 |
</span><span class="noop">    | 03.01. |  6.0 | 1.231391 | 1.231391 | 385943.010518 | 0.385943 |
</span><span class="noop">    | 04.01. | 12.0 | 5.315244 | 5.315244 | 877105.886853 | 0.877106 |
</span><span class="noop">    | 05.01. | 10.0 | 8.141801 | 8.141801 | 951254.290316 | 0.951254 |
</span><span class="noop">    | 06.01. |  6.0 | 7.452893 | 7.452893 | 739324.327444 | 0.739324 |
</span><span class="noop">    | 07.01. |  3.0 | 5.067907 | 5.067907 | 474257.135467 | 0.474257 |
</span><span class="noop">    | 08.01. |  2.0 | 2.915203 | 2.915203 | 308783.556526 | 0.308784 |
</span><span class="noop">    | 09.01. |  1.0 | 1.457986 | 1.457986 |  182813.58946 | 0.182814 |
</span><span class="noop">    | 10.01. |  0.0 | 0.276631 | 0.276631 |  72512.652803 | 0.072513 |
</span><span class="noop">    | 11.01. |  0.0 |      0.0 |      0.0 |   28762.00195 | 0.028762 |
</span><span class="noop">    | 12.01. |  0.0 |      0.0 |      0.0 |  11408.391835 | 0.011408 |
</span><span class="noop">    | 13.01. |  0.0 |      0.0 |      0.0 |   4525.116314 | 0.004525 |
</span><span class="noop">    | 14.01. |  0.0 |      0.0 |      0.0 |   1794.878538 | 0.001795 |
</span><span class="noop">    | 15.01. |  0.0 |      0.0 |      0.0 |    711.935063 | 0.000712 |
</span><span class="noop">    | 16.01. |  0.0 |      0.0 |      0.0 |    282.387651 | 0.000282 |
</span><span class="noop">    | 17.01. |  0.0 |      0.0 |      0.0 |    112.008509 | 0.000112 |
</span><span class="noop">    | 18.01. |  0.0 |      0.0 |      0.0 |     44.427956 | 0.000044 |
</span><span class="noop">    | 19.01. |  0.0 |      0.0 |      0.0 |     17.622262 | 0.000018 |
</span><span class="noop">    | 20.01. |  0.0 |      0.0 |      0.0 |      6.989836 | 0.000007 |
</span><span class="noop">
</span><span class="noop">    In the following, the given examples above repeated.  The only
</span><span class="noop">    parameter that will be altered is the internal simulation step size,
</span><span class="noop">    beeing one hour instead of one day:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdt(&#39;1h&#39;)
</span><span class="noop">    &gt;&gt;&gt; model.parameters.update()
</span><span class="noop">
</span><span class="noop">    Hence, the principles discussed above remain valid, but the result are
</span><span class="noop">    a little more accurate.
</span><span class="noop">
</span><span class="noop">    Repetition of the first experiment:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdw(.0)
</span><span class="noop">    &gt;&gt;&gt; verzw(0.)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   qz |       qa |   output |             v |        w |
</span><span class="noop">    ------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 |      0.0 |      0.0 |           0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  1.0 | 0.330363 | 0.330363 |  57856.651951 | 0.057857 |
</span><span class="noop">    | 03.01. |  6.0 | 2.369607 | 2.369607 | 371522.641905 | 0.371523 |
</span><span class="noop">    | 04.01. | 12.0 | 6.452208 | 6.452208 | 850851.903469 | 0.850852 |
</span><span class="noop">    | 05.01. | 10.0 | 9.001249 | 9.001249 |  937143.99857 | 0.937144 |
</span><span class="noop">    | 06.01. |  6.0 | 8.257642 | 8.257642 | 742083.768745 | 0.742084 |
</span><span class="noop">    | 07.01. |  3.0 | 5.960357 | 5.960357 | 486308.901331 | 0.486309 |
</span><span class="noop">    | 08.01. |  2.0 | 3.917231 | 3.917231 | 320660.156784 |  0.32066 |
</span><span class="noop">    | 09.01. |  1.0 | 2.477622 | 2.477622 |  192993.57788 | 0.192994 |
</span><span class="noop">    | 10.01. |  0.0 | 1.292357 | 1.292357 |  81333.955239 | 0.081334 |
</span><span class="noop">    | 11.01. |  0.0 | 0.544642 | 0.544642 |  34276.851838 | 0.034277 |
</span><span class="noop">    | 12.01. |  0.0 | 0.229531 | 0.229531 |  14445.412971 | 0.014445 |
</span><span class="noop">    | 13.01. |  0.0 | 0.096732 | 0.096732 |   6087.780665 | 0.006088 |
</span><span class="noop">    | 14.01. |  0.0 | 0.040766 | 0.040766 |   2565.594594 | 0.002566 |
</span><span class="noop">    | 15.01. |  0.0 |  0.01718 |  0.01718 |   1081.227459 | 0.001081 |
</span><span class="noop">    | 16.01. |  0.0 |  0.00724 |  0.00724 |    455.665451 | 0.000456 |
</span><span class="noop">    | 17.01. |  0.0 | 0.003051 | 0.003051 |    192.032677 | 0.000192 |
</span><span class="noop">    | 18.01. |  0.0 | 0.001286 | 0.001286 |     80.928999 | 0.000081 |
</span><span class="noop">    | 19.01. |  0.0 | 0.000542 | 0.000542 |      34.10619 | 0.000034 |
</span><span class="noop">    | 20.01. |  0.0 | 0.000228 | 0.000228 |      14.37349 | 0.000014 |
</span><span class="noop">
</span><span class="noop">    Repetition of the second experiment:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdw(.1)
</span><span class="noop">    &gt;&gt;&gt; verzw(0.)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   qz |       qa |   output |             v |        w |
</span><span class="noop">    ------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 |      0.0 |      0.0 |           0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  1.0 | 0.330363 | 0.330363 |  57856.651951 | 0.057857 |
</span><span class="noop">    | 03.01. |  6.0 | 2.369607 | 2.369607 | 371522.641905 | 0.371523 |
</span><span class="noop">    | 04.01. | 12.0 | 6.452208 | 6.452208 | 850851.903469 | 0.850852 |
</span><span class="noop">    | 05.01. | 10.0 | 9.001249 | 9.001249 |  937143.99857 | 0.937144 |
</span><span class="noop">    | 06.01. |  6.0 | 7.157407 | 7.157407 |  837143.99857 | 0.837144 |
</span><span class="noop">    | 07.01. |  3.0 | 4.157407 | 4.157407 |  737143.99857 | 0.737144 |
</span><span class="noop">    | 08.01. |  2.0 | 3.157407 | 3.157407 |  637143.99857 | 0.637144 |
</span><span class="noop">    | 09.01. |  1.0 | 2.157407 | 2.157407 |  537143.99857 | 0.537144 |
</span><span class="noop">    | 10.01. |  0.0 | 1.157407 | 1.157407 |  437143.99857 | 0.437144 |
</span><span class="noop">    | 11.01. |  0.0 | 1.157407 | 1.157407 |  337143.99857 | 0.337144 |
</span><span class="noop">    | 12.01. |  0.0 | 1.157407 | 1.157407 |  237143.99857 | 0.237144 |
</span><span class="noop">    | 13.01. |  0.0 | 1.157407 | 1.157407 |  137143.99857 | 0.137144 |
</span><span class="noop">    | 14.01. |  0.0 | 0.918367 | 0.918367 |  57797.072646 | 0.057797 |
</span><span class="noop">    | 15.01. |  0.0 | 0.387031 | 0.387031 |  24357.621488 | 0.024358 |
</span><span class="noop">    | 16.01. |  0.0 | 0.163108 | 0.163108 |    10265.1172 | 0.010265 |
</span><span class="noop">    | 17.01. |  0.0 | 0.068739 | 0.068739 |   4326.064069 | 0.004326 |
</span><span class="noop">    | 18.01. |  0.0 | 0.028969 | 0.028969 |   1823.148238 | 0.001823 |
</span><span class="noop">    | 19.01. |  0.0 | 0.012208 | 0.012208 |    768.335707 | 0.000768 |
</span><span class="noop">    | 20.01. |  0.0 | 0.005145 | 0.005145 |    323.802391 | 0.000324 |
</span><span class="noop">
</span><span class="noop">    Repetition of the third experiment:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdw(.0)
</span><span class="noop">    &gt;&gt;&gt; verzw(1.)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   qz |       qa |   output |             v |        w |
</span><span class="noop">    ------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 |      0.0 |      0.0 |           0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  1.0 |      0.0 |      0.0 |  57856.651951 | 0.057857 |
</span><span class="noop">    | 03.01. |  6.0 | 1.369607 | 1.369607 | 371522.641905 | 0.371523 |
</span><span class="noop">    | 04.01. | 12.0 | 5.452208 | 5.452208 | 850851.903469 | 0.850852 |
</span><span class="noop">    | 05.01. | 10.0 | 8.001249 | 8.001249 |  937143.99857 | 0.937144 |
</span><span class="noop">    | 06.01. |  6.0 | 7.257642 | 7.257642 | 742083.768745 | 0.742084 |
</span><span class="noop">    | 07.01. |  3.0 | 4.960357 | 4.960357 | 486308.901331 | 0.486309 |
</span><span class="noop">    | 08.01. |  2.0 | 2.917231 | 2.917231 | 320660.156784 |  0.32066 |
</span><span class="noop">    | 09.01. |  1.0 | 1.477622 | 1.477622 |  192993.57788 | 0.192994 |
</span><span class="noop">    | 10.01. |  0.0 | 0.292357 | 0.292357 |  81333.955239 | 0.081334 |
</span><span class="noop">    | 11.01. |  0.0 |      0.0 |      0.0 |  34276.851838 | 0.034277 |
</span><span class="noop">    | 12.01. |  0.0 |      0.0 |      0.0 |  14445.412971 | 0.014445 |
</span><span class="noop">    | 13.01. |  0.0 |      0.0 |      0.0 |   6087.780665 | 0.006088 |
</span><span class="noop">    | 14.01. |  0.0 |      0.0 |      0.0 |   2565.594594 | 0.002566 |
</span><span class="noop">    | 15.01. |  0.0 |      0.0 |      0.0 |   1081.227459 | 0.001081 |
</span><span class="noop">    | 16.01. |  0.0 |      0.0 |      0.0 |    455.665451 | 0.000456 |
</span><span class="noop">    | 17.01. |  0.0 |      0.0 |      0.0 |    192.032677 | 0.000192 |
</span><span class="noop">    | 18.01. |  0.0 |      0.0 |      0.0 |     80.928999 | 0.000081 |
</span><span class="noop">    | 19.01. |  0.0 |      0.0 |      0.0 |      34.10619 | 0.000034 |
</span><span class="noop">    | 20.01. |  0.0 |      0.0 |      0.0 |      14.37349 | 0.000014 |
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from llake
</span><span class="hit">from hydpy.models.llake import llake_model
</span><span class="hit">from hydpy.models.llake import llake_control
</span><span class="hit">from hydpy.models.llake import llake_derived
</span><span class="hit">from hydpy.models.llake import llake_fluxes
</span><span class="hit">from hydpy.models.llake import llake_states
</span><span class="hit">from hydpy.models.llake import llake_aides
</span><span class="hit">from hydpy.models.llake import llake_inlets
</span><span class="hit">from hydpy.models.llake import llake_outlets
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;LARSIM-Lake version of HydPy-L-Lake (llake_v1).&#34;&#34;&#34;
</span><span class="hit">    _INLET_METHODS = (llake_model.pick_q_v1,)
</span><span class="hit">    _RUN_METHODS = (llake_model.solve_dv_dt_v1,
</span><span class="noop">                    llake_model.interp_w_v1,
</span><span class="noop">                    llake_model.corr_dw_v1,
</span><span class="noop">                    llake_model.modify_qa_v1,)
</span><span class="hit">    _ADD_METHODS = (llake_model.interp_v_v1,
</span><span class="noop">                    llake_model.calc_vq_v1,
</span><span class="noop">                    llake_model.interp_qa_v1,
</span><span class="noop">                    llake_model.calc_v_qa_v1)
</span><span class="hit">    _OUTLET_METHODS = (llake_model.pass_q_v1,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of llake_v1, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (llake_control.N,
</span><span class="noop">                   llake_control.W,
</span><span class="noop">                   llake_control.V,
</span><span class="noop">                   llake_control.Q,
</span><span class="noop">                   llake_control.MaxDT,
</span><span class="noop">                   llake_control.MaxDW,
</span><span class="noop">                   llake_control.Verzw)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of llake_v1, indirectly defined by the user.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (llake_derived.TOY,
</span><span class="noop">                   llake_derived.Seconds,
</span><span class="noop">                   llake_derived.NmbSubsteps,
</span><span class="noop">                   llake_derived.VQ)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of llake_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (llake_states.V,
</span><span class="noop">                   llake_states.W)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of llake_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (llake_fluxes.QZ,
</span><span class="noop">                   llake_fluxes.QA)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of llake_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (llake_aides.QA,
</span><span class="noop">                   llake_aides.VQ,
</span><span class="noop">                   llake_aides.V,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of llake_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (llake_inlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of llake_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (llake_outlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Version 1 of the L-Land model is designed to agree with the LARSIM-ME
</span><span class="noop">configuration of the LARSIM model used by the German Federal Institute
</span><span class="noop">of Hydrology (BfG), but offers more flexibility in some regards (e.g. in
</span><span class="noop">parameterization).  It can briefly be summarized as follows:
</span><span class="noop">
</span><span class="noop"> * Simple routines for adjusting the meteorological input data.
</span><span class="noop"> * Reference evapotranspiration after Turc-Wendling.
</span><span class="noop"> * An enhanced degree-day-method for calculating snow melt.
</span><span class="noop"> * A simple snow retention routine.
</span><span class="noop"> * Landuse and month specific potential evapotranspiration.
</span><span class="noop"> * Acual soil evapotranspiration after ATV-DVWK- 504 (2002).
</span><span class="noop"> * A Soil routine based on the Xinanjiang model.
</span><span class="noop"> * One base flow, two interflow and two direct flow components.
</span><span class="noop"> * Seperate linear storages for modelling runoff concentration.
</span><span class="noop"> * Additional evaporation from water areas.
</span><span class="noop">
</span><span class="noop">The following figure shows the general structure of L-Land Version 1.  Note
</span><span class="noop">that, besides water areas and sealed surface areas, all land use types rely
</span><span class="noop">on the same set of process equations:
</span><span class="noop">
</span><span class="noop">.. image:: HydPy-L-Land_Version-1.png
</span><span class="noop">
</span><span class="noop">As all models implemented in HydPy, base model L-Land can principally be
</span><span class="noop">applied on arbitrary simulation step sizes.  But for the L-Land version 1
</span><span class="noop">application model one has to be aware, that the Turc-Wendling equation
</span><span class="noop">for calculating reference evaporation is designed for daily time steps only.
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">Integration tests:
</span><span class="noop">
</span><span class="noop">    All integration tests are performed in January (to allow for realistic
</span><span class="noop">    snow examples), spanning over a period of five days:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import pub, Timegrid, Timegrids
</span><span class="noop">    &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;01.01.2000&#39;,
</span><span class="noop">    ...                                    &#39;06.01.2000&#39;,
</span><span class="noop">    ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">    Prepare the model instance and build the connections to element `land`
</span><span class="noop">    and node `outlet`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland_v1 import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; from hydpy import Node, Element
</span><span class="noop">    &gt;&gt;&gt; outlet = Node(&#39;outlet&#39;)
</span><span class="noop">    &gt;&gt;&gt; land = Element(&#39;land&#39;, outlets=outlet)
</span><span class="noop">    &gt;&gt;&gt; land.connect(model)
</span><span class="noop">
</span><span class="noop">    All tests shall be performed using a single hydrological response unit
</span><span class="noop">    with a size of one square kilometre at an altitude of 100 meter:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nhru(1)
</span><span class="noop">    &gt;&gt;&gt; ft(1.)
</span><span class="noop">    &gt;&gt;&gt; fhru(1.)
</span><span class="noop">    &gt;&gt;&gt; hnn(100.)
</span><span class="noop">
</span><span class="noop">    Initialize a test function object, which prepares and runs the tests
</span><span class="noop">    and prints their results for the given sequences:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.testtools import IntegrationTest
</span><span class="noop">    &gt;&gt;&gt; test = IntegrationTest(land)
</span><span class="noop">
</span><span class="noop">    Define a format for the dates to be printed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test.dateformat = &#39;%d.%m.&#39;
</span><span class="noop">
</span><span class="noop">    In the first example, coniferous forest is selected as the only
</span><span class="noop">    land use class:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; lnk(NADELW)
</span><span class="noop">
</span><span class="noop">    All control parameters are set in manner, that lets their corresponding
</span><span class="noop">    methods show an impact on the results:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; kg(1.2)
</span><span class="noop">    &gt;&gt;&gt; kt(1.)
</span><span class="noop">    &gt;&gt;&gt; ke(0.9)
</span><span class="noop">    &gt;&gt;&gt; kf(.6)
</span><span class="noop">    &gt;&gt;&gt; fln(.5)
</span><span class="noop">    &gt;&gt;&gt; hinz(.2)
</span><span class="noop">    &gt;&gt;&gt; lai(4.)
</span><span class="noop">    &gt;&gt;&gt; treft(0.)
</span><span class="noop">    &gt;&gt;&gt; trefn(0.)
</span><span class="noop">    &gt;&gt;&gt; tgr(1.)
</span><span class="noop">    &gt;&gt;&gt; tsp(2.)
</span><span class="noop">    &gt;&gt;&gt; gtf(5.)
</span><span class="noop">    &gt;&gt;&gt; rschmelz(334.)
</span><span class="noop">    &gt;&gt;&gt; cpwasser(4.1868)
</span><span class="noop">    &gt;&gt;&gt; pwmax(1.4)
</span><span class="noop">    &gt;&gt;&gt; grasref_r(5.)
</span><span class="noop">    &gt;&gt;&gt; nfk(200.)
</span><span class="noop">    &gt;&gt;&gt; relwz(.5)
</span><span class="noop">    &gt;&gt;&gt; relwb(.05)
</span><span class="noop">    &gt;&gt;&gt; beta(.01)
</span><span class="noop">    &gt;&gt;&gt; fbeta(1.)
</span><span class="noop">    &gt;&gt;&gt; dmax(5.)
</span><span class="noop">    &gt;&gt;&gt; dmin(1.)
</span><span class="noop">    &gt;&gt;&gt; bsf(.4)
</span><span class="noop">    &gt;&gt;&gt; a1(1.)
</span><span class="noop">    &gt;&gt;&gt; a2(1.)
</span><span class="noop">    &gt;&gt;&gt; tind(1.)
</span><span class="noop">    &gt;&gt;&gt; eqb(100.)
</span><span class="noop">    &gt;&gt;&gt; eqi1(50.)
</span><span class="noop">    &gt;&gt;&gt; eqi2(10.)
</span><span class="noop">    &gt;&gt;&gt; eqd1(2.)
</span><span class="noop">    &gt;&gt;&gt; eqd2(1.)
</span><span class="noop">
</span><span class="noop">    Initially, relative soil moisture is 75%, but all other storages are
</span><span class="noop">    empty and there is base flow only:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test.inits = ((states.inzp, 0.),
</span><span class="noop">    ...               (states.wats, 0.),
</span><span class="noop">    ...               (states.waes, 0.),
</span><span class="noop">    ...               (states.bowa, 150.),
</span><span class="noop">    ...               (states.qdgz1, 0.),
</span><span class="noop">    ...               (states.qdgz2, 0.),
</span><span class="noop">    ...               (states.qigz1, 0.),
</span><span class="noop">    ...               (states.qigz2, 0.),
</span><span class="noop">    ...               (states.qbgz, 1.),
</span><span class="noop">    ...               (states.qdga1, 0.),
</span><span class="noop">    ...               (states.qdga2, 0.),
</span><span class="noop">    ...               (states.qiga1, 0.),
</span><span class="noop">    ...               (states.qiga2, 0.),
</span><span class="noop">    ...               (states.qbga, 1.))
</span><span class="noop">
</span><span class="noop">    For the input data, a strong increase in temperature from -5°C to +10°C
</span><span class="noop">    is defined, to activate both the snow and the evapotranspiration routines:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; inputs.nied.series = 0., 5., 5., 5., 0.
</span><span class="noop">    &gt;&gt;&gt; inputs.teml.series = -5., -5., 0., 5., 10.
</span><span class="noop">    &gt;&gt;&gt; inputs.glob.series = 100.
</span><span class="noop">
</span><span class="noop">    The following results show that all relevant model components are at least
</span><span class="noop">    activated once during the simulation period:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | nied | teml |  glob | nkor | tkor |      et0 |     evpo |     nbes |     sbes |      evi |      evb |      wgtf |     schm |     wada |      qdb |     qib1 |     qib2 |      qbb |     qdgz |        q |     inzp |    wats |     waes |       bowa |    qdgz1 |    qdgz2 |    qigz1 |    qigz2 |     qbgz |    qdga1 |    qdga2 |    qiga1 |    qiga2 |     qbga |   outlet |
</span><span class="noop">    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 | -5.0 | 100.0 |  0.0 | -4.0 | 0.744738 | 0.372369 |      0.0 |      0.0 |      0.0 | 0.359997 |       0.0 |      0.0 |      0.0 |      0.0 |     0.75 | 1.414214 |      1.4 |      0.0 | 1.077855 |      0.0 |     0.0 |      0.0 |  146.07579 |      0.0 |      0.0 |     0.75 | 1.414214 |      1.4 |      0.0 |      0.0 |  0.00745 | 0.068411 | 1.001993 | 0.012475 |
</span><span class="noop">    | 02.01. |  5.0 | -5.0 | 100.0 |  6.0 | -4.0 | 0.744738 | 0.372369 |      5.2 |      5.2 | 0.372369 |      0.0 |       0.0 |      0.0 |      0.0 |      0.0 | 0.730379 | 1.251034 | 1.360758 |      0.0 | 1.216305 | 0.427631 |     5.2 |      5.2 | 142.733619 |      0.0 |      0.0 | 0.730379 | 1.251034 | 1.360758 |      0.0 |      0.0 | 0.021959 | 0.188588 | 1.005758 | 0.014078 |
</span><span class="noop">    | 03.01. |  5.0 |  0.0 | 100.0 |  6.0 |  1.0 | 0.913238 | 0.456619 | 5.627631 | 2.813816 | 0.456619 |      0.0 |  5.012535 | 5.012535 | 6.625839 |  2.04495 | 0.713668 | 1.117415 | 1.327336 |  2.04495 |  1.84654 | 0.343381 | 3.00128 | 4.201792 | 144.156088 | 1.510991 |  0.53396 | 0.713668 | 1.117415 | 1.327336 | 0.321934 | 0.196433 |  0.03582 | 0.283229 | 1.009124 | 0.021372 |
</span><span class="noop">    | 04.01. |  5.0 |  5.0 | 100.0 |  6.0 |  6.0 | 1.068676 | 0.534338 | 5.543381 |      0.0 | 0.534338 |      0.0 | 30.075212 |  3.00128 | 9.745173 | 3.096033 |  0.72078 |  1.17367 | 1.341561 | 3.096033 | 2.987559 | 0.265662 |     0.0 |      0.0 | 147.569218 | 1.677006 | 1.419027 |  0.72078 |  1.17367 | 1.341561 | 0.825163 | 0.735388 | 0.049313 | 0.365334 | 1.012361 | 0.034578 |
</span><span class="noop">    | 05.01. |  0.0 | 10.0 | 100.0 |  0.0 | 11.0 | 1.212514 | 0.606257 |      0.0 |      0.0 | 0.265662 | 0.328303 | 55.137889 |      0.0 |      0.0 |      0.0 | 0.737846 | 1.312348 | 1.375692 |      0.0 | 2.976082 |      0.0 |     0.0 |      0.0 | 143.815029 |      0.0 |      0.0 | 0.737846 | 1.312348 | 1.375692 | 0.803032 | 0.645499 | 0.062779 | 0.448966 | 1.015807 | 0.034445 |
</span><span class="noop">
</span><span class="noop">    The second example deals with a sealed surface:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; lnk(VERS)
</span><span class="noop">
</span><span class="noop">    For sealed surfaces, the soil routine is skippend an no base flow is
</span><span class="noop">    calculated.  Thus the corresponding initial values are set to zero:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test.inits.bowa = 0.
</span><span class="noop">    &gt;&gt;&gt; test.inits.qbgz = 0.
</span><span class="noop">    &gt;&gt;&gt; test.inits.qbga = 0.
</span><span class="noop">
</span><span class="noop">    As retention processes below the surface are assumed to be negligible,
</span><span class="noop">    all water reaching the sealed surface becomes direct discharge
</span><span class="noop">    immediately:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | nied | teml |  glob | nkor | tkor |      et0 |     evpo |     nbes |     sbes |      evi | evb |      wgtf |     schm |     wada |      qdb | qib1 | qib2 | qbb |     qdgz |        q |     inzp |    wats |     waes | bowa |    qdgz1 |    qdgz2 | qigz1 | qigz2 | qbgz |    qdga1 |    qdga2 | qiga1 | qiga2 | qbga |   outlet |
</span><span class="noop">    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 | -5.0 | 100.0 |  0.0 | -4.0 | 0.744738 | 0.372369 |      0.0 |      0.0 |      0.0 | 0.0 |       0.0 |      0.0 |      0.0 |      0.0 |  0.0 |  0.0 | 0.0 |      0.0 |      0.0 |      0.0 |     0.0 |      0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  5.0 | -5.0 | 100.0 |  6.0 | -4.0 | 0.744738 | 0.372369 |      5.2 |      5.2 | 0.372369 | 0.0 |       0.0 |      0.0 |      0.0 |      0.0 |  0.0 |  0.0 | 0.0 |      0.0 |      0.0 | 0.427631 |     5.2 |      5.2 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 |      0.0 |
</span><span class="noop">    | 03.01. |  5.0 |  0.0 | 100.0 |  6.0 |  1.0 | 0.913238 | 0.456619 | 5.627631 | 2.813816 | 0.456619 | 0.0 |  5.012535 | 5.012535 | 6.625839 | 6.625839 |  0.0 |  0.0 | 0.0 | 6.625839 | 2.151239 | 0.343381 | 3.00128 | 4.201792 |  0.0 | 1.849076 | 4.776763 |   0.0 |   0.0 |  0.0 | 0.393967 | 1.757273 |   0.0 |   0.0 |  0.0 | 0.024899 |
</span><span class="noop">    | 04.01. |  5.0 |  5.0 | 100.0 |  6.0 |  6.0 | 1.068676 | 0.534338 | 5.543381 |      0.0 | 0.534338 | 0.0 | 30.075212 |  3.00128 | 9.745173 | 9.745173 |  0.0 |  0.0 | 0.0 | 9.745173 | 5.772522 | 0.265662 |     0.0 |      0.0 |  0.0 | 1.897385 | 7.847788 |   0.0 |   0.0 |  0.0 |   0.9768 | 4.795722 |   0.0 |   0.0 |  0.0 | 0.066812 |
</span><span class="noop">    | 05.01. |  0.0 | 10.0 | 100.0 |  0.0 | 11.0 | 1.212514 | 0.606257 |      0.0 |      0.0 | 0.265662 | 0.0 | 55.137889 |      0.0 |      0.0 |      0.0 |  0.0 |  0.0 | 0.0 |      0.0 | 4.772719 |      0.0 |     0.0 |      0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 | 0.934763 | 3.837956 |   0.0 |   0.0 |  0.0 |  0.05524 |
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    For water areas, even the interception and the snow module are skipped:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; lnk(WASSER)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | nied | teml |  glob | nkor | tkor |      et0 |     evpo | nbes | sbes |      evi | evb | wgtf | schm | wada | qdb | qib1 | qib2 | qbb | qdgz |        q | inzp | wats | waes | bowa |    qdgz1 |    qdgz2 | qigz1 | qigz2 | qbgz |    qdga1 |    qdga2 | qiga1 | qiga2 | qbga |   outlet |
</span><span class="noop">    -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 | -5.0 | 100.0 |  0.0 | -4.0 | 0.744738 | 0.372369 |  0.0 |  0.0 |      0.0 | 0.0 |  0.0 |  0.0 |  0.0 | 0.0 |  0.0 |  0.0 | 0.0 |  0.0 |      0.0 |  0.0 |  0.0 |  0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  5.0 | -5.0 | 100.0 |  6.0 | -4.0 | 0.744738 | 0.372369 |  6.0 |  6.0 | 0.372369 | 0.0 |  0.0 |  0.0 |  6.0 | 6.0 |  0.0 |  0.0 | 0.0 |  6.0 | 1.551075 |  0.0 |  0.0 |  0.0 |  0.0 | 1.833333 | 4.166667 |   0.0 |   0.0 |  0.0 | 0.390612 | 1.532831 |   0.0 |   0.0 |  0.0 | 0.017952 |
</span><span class="noop">    | 03.01. |  5.0 |  0.0 | 100.0 |  6.0 |  1.0 | 0.913238 | 0.456619 |  6.0 |  3.0 | 0.456619 | 0.0 |  0.0 |  0.0 |  6.0 | 6.0 |  0.0 |  0.0 | 0.0 |  6.0 | 3.699393 |  0.0 |  0.0 |  0.0 |  0.0 | 1.833333 | 4.166667 |   0.0 |   0.0 |  0.0 | 0.958279 | 3.197733 |   0.0 |   0.0 |  0.0 | 0.042817 |
</span><span class="noop">    | 04.01. |  5.0 |  5.0 | 100.0 |  6.0 |  6.0 | 1.068676 | 0.534338 |  6.0 |  0.0 | 0.534338 | 0.0 |  0.0 |  0.0 |  6.0 | 6.0 |  0.0 |  0.0 | 0.0 |  6.0 | 4.578464 |  0.0 |  0.0 |  0.0 |  0.0 | 1.833333 | 4.166667 |   0.0 |   0.0 |  0.0 | 1.302586 | 3.810216 |   0.0 |   0.0 |  0.0 | 0.052991 |
</span><span class="noop">    | 05.01. |  0.0 | 10.0 | 100.0 |  0.0 | 11.0 | 1.212514 | 0.606257 |  0.0 |  0.0 | 0.606257 | 0.0 |  0.0 |  0.0 |  0.0 | 0.0 |  0.0 |  0.0 | 0.0 |  0.0 | 3.017254 |  0.0 |  0.0 |  0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 | 1.120806 | 2.502705 |   0.0 |   0.0 |  0.0 | 0.034922 |
</span><span class="noop">
</span><span class="noop">    Note that for water areas, interception evaporation is actually
</span><span class="noop">    evaporation from the water surface.  Also note, that the water land use
</span><span class="noop">    class is the only one, for which evaporation is abstracted after the runoff
</span><span class="noop">    concentration routines have been applied.  Thus water areas can evaporate
</span><span class="noop">    the water supply of previous time steps and, more import, the water supply
</span><span class="noop">    of other areas within the same subbasin.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from lland
</span><span class="hit">from hydpy.models.lland import lland_model
</span><span class="hit">from hydpy.models.lland import lland_control
</span><span class="hit">from hydpy.models.lland import lland_derived
</span><span class="hit">from hydpy.models.lland import lland_inputs
</span><span class="hit">from hydpy.models.lland import lland_fluxes
</span><span class="hit">from hydpy.models.lland import lland_states
</span><span class="hit">from hydpy.models.lland import lland_aides
</span><span class="hit">from hydpy.models.lland import lland_outlets
</span><span class="hit">from hydpy.models.lland.lland_parameters import Parameters
</span><span class="hit">from hydpy.models.lland.lland_constants import *
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;LARSIM-Land version of HydPy-L-Land (lland_v1).&#34;&#34;&#34;
</span><span class="hit">    _RUN_METHODS = (lland_model.calc_nkor_v1,
</span><span class="noop">                    lland_model.calc_tkor_v1,
</span><span class="noop">                    lland_model.calc_et0_v1,
</span><span class="noop">                    lland_model.calc_evpo_v1,
</span><span class="noop">                    lland_model.calc_nbes_inzp_v1,
</span><span class="noop">                    lland_model.calc_evi_inzp_v1,
</span><span class="noop">                    lland_model.calc_sbes_v1,
</span><span class="noop">                    lland_model.calc_wgtf_v1,
</span><span class="noop">                    lland_model.calc_schm_wats_v1,
</span><span class="noop">                    lland_model.calc_wada_waes_v1,
</span><span class="noop">                    lland_model.calc_evb_v1,
</span><span class="noop">                    lland_model.calc_qbb_v1,
</span><span class="noop">                    lland_model.calc_qib1_v1,
</span><span class="noop">                    lland_model.calc_qib2_v1,
</span><span class="noop">                    lland_model.calc_qdb_v1,
</span><span class="noop">                    lland_model.calc_bowa_v1,
</span><span class="noop">                    lland_model.calc_qbgz_v1,
</span><span class="noop">                    lland_model.calc_qigz1_v1,
</span><span class="noop">                    lland_model.calc_qigz2_v1,
</span><span class="noop">                    lland_model.calc_qdgz_v1,
</span><span class="noop">                    lland_model.calc_qdgz1_qdgz2_v1,
</span><span class="noop">                    lland_model.calc_qbga_v1,
</span><span class="noop">                    lland_model.calc_qiga1_v1,
</span><span class="noop">                    lland_model.calc_qiga2_v1,
</span><span class="noop">                    lland_model.calc_qdga1_v1,
</span><span class="noop">                    lland_model.calc_qdga2_v1,
</span><span class="noop">                    lland_model.calc_q_v1)
</span><span class="hit">    _OUTLET_METHODS = (lland_model.pass_q_v1,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of lland_v1, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (lland_control.FT,
</span><span class="noop">                   lland_control.NHRU,
</span><span class="noop">                   lland_control.Lnk,
</span><span class="noop">                   lland_control.FHRU,
</span><span class="noop">                   lland_control.HNN,
</span><span class="noop">                   lland_control.KG,
</span><span class="noop">                   lland_control.KT,
</span><span class="noop">                   lland_control.KE,
</span><span class="noop">                   lland_control.KF,
</span><span class="noop">                   lland_control.FLn,
</span><span class="noop">                   lland_control.HInz,
</span><span class="noop">                   lland_control.LAI,
</span><span class="noop">                   lland_control.TRefT,
</span><span class="noop">                   lland_control.TRefN,
</span><span class="noop">                   lland_control.TGr,
</span><span class="noop">                   lland_control.TSp,
</span><span class="noop">                   lland_control.GTF,
</span><span class="noop">                   lland_control.RSchmelz,
</span><span class="noop">                   lland_control.CPWasser,
</span><span class="noop">                   lland_control.PWMax,
</span><span class="noop">                   lland_control.GrasRef_R,
</span><span class="noop">                   lland_control.NFk,
</span><span class="noop">                   lland_control.RelWZ,
</span><span class="noop">                   lland_control.RelWB,
</span><span class="noop">                   lland_control.Beta,
</span><span class="noop">                   lland_control.FBeta,
</span><span class="noop">                   lland_control.DMax,
</span><span class="noop">                   lland_control.DMin,
</span><span class="noop">                   lland_control.BSf,
</span><span class="noop">                   lland_control.A1,
</span><span class="noop">                   lland_control.A2,
</span><span class="noop">                   lland_control.TInd,
</span><span class="noop">                   lland_control.EQB,
</span><span class="noop">                   lland_control.EQI1,
</span><span class="noop">                   lland_control.EQI2,
</span><span class="noop">                   lland_control.EQD1,
</span><span class="noop">                   lland_control.EQD2)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of lland_v1, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (lland_derived.MOY,
</span><span class="noop">                   lland_derived.KInz,
</span><span class="noop">                   lland_derived.WB,
</span><span class="noop">                   lland_derived.WZ,
</span><span class="noop">                   lland_derived.KB,
</span><span class="noop">                   lland_derived.KI1,
</span><span class="noop">                   lland_derived.KI2,
</span><span class="noop">                   lland_derived.KD1,
</span><span class="noop">                   lland_derived.KD2,
</span><span class="noop">                   lland_derived.QFactor)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequences(sequencetools.InputSequences):
</span><span class="noop">    &#34;&#34;&#34;Input sequences of lland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_inputs.Nied,
</span><span class="noop">                   lland_inputs.TemL,
</span><span class="noop">                   lland_inputs.Glob)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of lland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_fluxes.NKor,
</span><span class="noop">                   lland_fluxes.TKor,
</span><span class="noop">                   lland_fluxes.ET0,
</span><span class="noop">                   lland_fluxes.EvPo,
</span><span class="noop">                   lland_fluxes.NBes,
</span><span class="noop">                   lland_fluxes.SBes,
</span><span class="noop">                   lland_fluxes.EvI,
</span><span class="noop">                   lland_fluxes.EvB,
</span><span class="noop">                   lland_fluxes.WGTF,
</span><span class="noop">                   lland_fluxes.Schm,
</span><span class="noop">                   lland_fluxes.WaDa,
</span><span class="noop">                   lland_fluxes.QDB,
</span><span class="noop">                   lland_fluxes.QIB1,
</span><span class="noop">                   lland_fluxes.QIB2,
</span><span class="noop">                   lland_fluxes.QBB,
</span><span class="noop">                   lland_fluxes.QDGZ,
</span><span class="noop">                   lland_fluxes.Q)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of lland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_states.Inzp,
</span><span class="noop">                   lland_states.WATS,
</span><span class="noop">                   lland_states.WAeS,
</span><span class="noop">                   lland_states.BoWa,
</span><span class="noop">                   lland_states.QDGZ1,
</span><span class="noop">                   lland_states.QDGZ2,
</span><span class="noop">                   lland_states.QIGZ1,
</span><span class="noop">                   lland_states.QIGZ2,
</span><span class="noop">                   lland_states.QBGZ,
</span><span class="noop">                   lland_states.QDGA1,
</span><span class="noop">                   lland_states.QDGA2,
</span><span class="noop">                   lland_states.QIGA1,
</span><span class="noop">                   lland_states.QIGA2,
</span><span class="noop">                   lland_states.QBGA)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of lland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_aides.Temp,
</span><span class="noop">                   lland_aides.SfA,
</span><span class="noop">                   lland_aides.Exz,
</span><span class="noop">                   lland_aides.BVl,
</span><span class="noop">                   lland_aides.MVl,
</span><span class="noop">                   lland_aides.RVl,
</span><span class="noop">                   lland_aides.EPW)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of lland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_outlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland_v2.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland_v2.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Version 2 of the L-Land model (lland_v2) is a slight modification of
</span><span class="noop">:mod:`~hydpy.models.lland_v1`.  :mod:`~hydpy.models.lland_v1`
</span><span class="noop">implements a specific equation for the calculation of reference evaporation
</span><span class="noop">(:class:`~hydpy.models.lland.lland_fluxes.ET0`) for each hydrological
</span><span class="noop">response unit (HRU).  In contrast, lland_v2 expects subbasin wide
</span><span class="noop">potential evaporation values (:class:`~hydpy.models.lland.lland_inputs.PET`)
</span><span class="noop">to be calculated externally and adjusts them to the different HRUs of
</span><span class="noop">the subbasin.
</span><span class="noop">
</span><span class="noop">:mod:`~hydpy.models.lland_v1` should be applied on daily step sized
</span><span class="noop">only due to the restrictions of the Turc-Wendling equation for calculating
</span><span class="noop">reference evaporation.  Instead, lland_v2 can be applied on arbitrary
</span><span class="noop">simulation step sizes.
</span><span class="noop">
</span><span class="noop">Integration tests:
</span><span class="noop">
</span><span class="noop">    All integration tests are performed in January (to allow for realistic
</span><span class="noop">    snow examples), spanning over a period of five days:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import pub, Timegrid, Timegrids
</span><span class="noop">    &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;01.01.2000&#39;,
</span><span class="noop">    ...                                    &#39;06.01.2000&#39;,
</span><span class="noop">    ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">    Note that, for the first four days, all integration tests are virtually
</span><span class="noop">    identical with the ones of :mod:`~hydpy.models.lland_v1`, to prove
</span><span class="noop">    the almost identical behaviour of lland_v2.  This is accomplished by
</span><span class="noop">    feeding in potential evaporation values in accordance with the
</span><span class="noop">    Turc-Wendling equation and the given value of the correction factor
</span><span class="noop">    :class:`~hydpy.models.lland.lland_control.KE`.  Only for the fifths day
</span><span class="noop">    a deviating evaporation value is defined, leading to slighlty different
</span><span class="noop">    calculations for some model components.
</span><span class="noop">
</span><span class="noop">    Prepare the model instance and build the connections to element `land`
</span><span class="noop">    and node `outlet`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland_v2 import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; from hydpy import Node, Element
</span><span class="noop">    &gt;&gt;&gt; outlet = Node(&#39;outlet&#39;)
</span><span class="noop">    &gt;&gt;&gt; land = Element(&#39;land&#39;, outlets=outlet)
</span><span class="noop">    &gt;&gt;&gt; land.connect(model)
</span><span class="noop">
</span><span class="noop">    All tests shall be performed using a single hydrological response unit
</span><span class="noop">    with a size of one square kilometre:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nhru(1)
</span><span class="noop">    &gt;&gt;&gt; ft(1.)
</span><span class="noop">    &gt;&gt;&gt; fhru(1.)
</span><span class="noop">
</span><span class="noop">    Initialize a test function object, which prepares and runs the tests
</span><span class="noop">    and prints their results for the given sequences:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.testtools import IntegrationTest
</span><span class="noop">    &gt;&gt;&gt; test = IntegrationTest(land)
</span><span class="noop">
</span><span class="noop">    Define a format for the dates to be printed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test.dateformat = &#39;%d.%m.&#39;
</span><span class="noop">
</span><span class="noop">    In the first example, coniferous forest is selected as the only
</span><span class="noop">    land use class:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; lnk(NADELW)
</span><span class="noop">
</span><span class="noop">    All control parameters are set in manner, that lets their corresponding
</span><span class="noop">    methods show an impact on the results:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; kg(1.2)
</span><span class="noop">    &gt;&gt;&gt; kt(1.)
</span><span class="noop">    &gt;&gt;&gt; ke(2.)
</span><span class="noop">    &gt;&gt;&gt; fln(.5)
</span><span class="noop">    &gt;&gt;&gt; hinz(.2)
</span><span class="noop">    &gt;&gt;&gt; lai(4.)
</span><span class="noop">    &gt;&gt;&gt; treft(0.)
</span><span class="noop">    &gt;&gt;&gt; trefn(0.)
</span><span class="noop">    &gt;&gt;&gt; tgr(1.)
</span><span class="noop">    &gt;&gt;&gt; tsp(2.)
</span><span class="noop">    &gt;&gt;&gt; gtf(5.)
</span><span class="noop">    &gt;&gt;&gt; rschmelz(334.)
</span><span class="noop">    &gt;&gt;&gt; cpwasser(4.1868)
</span><span class="noop">    &gt;&gt;&gt; pwmax(1.4)
</span><span class="noop">    &gt;&gt;&gt; grasref_r(5.)
</span><span class="noop">    &gt;&gt;&gt; nfk(200.)
</span><span class="noop">    &gt;&gt;&gt; relwz(.5)
</span><span class="noop">    &gt;&gt;&gt; relwb(.05)
</span><span class="noop">    &gt;&gt;&gt; beta(.01)
</span><span class="noop">    &gt;&gt;&gt; fbeta(1.)
</span><span class="noop">    &gt;&gt;&gt; dmax(5.)
</span><span class="noop">    &gt;&gt;&gt; dmin(1.)
</span><span class="noop">    &gt;&gt;&gt; bsf(.4)
</span><span class="noop">    &gt;&gt;&gt; a1(1.)
</span><span class="noop">    &gt;&gt;&gt; a2(1.)
</span><span class="noop">    &gt;&gt;&gt; tind(1.)
</span><span class="noop">    &gt;&gt;&gt; eqb(100.)
</span><span class="noop">    &gt;&gt;&gt; eqi1(50.)
</span><span class="noop">    &gt;&gt;&gt; eqi2(10.)
</span><span class="noop">    &gt;&gt;&gt; eqd1(2.)
</span><span class="noop">    &gt;&gt;&gt; eqd2(1.)
</span><span class="noop">
</span><span class="noop">    Initially, relative soil moisture is 75%, but all other storages are
</span><span class="noop">    empty and there is base flow only:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test.inits = ((states.inzp, 0.),
</span><span class="noop">    ...               (states.wats, 0.),
</span><span class="noop">    ...               (states.waes, 0.),
</span><span class="noop">    ...               (states.bowa, 150.),
</span><span class="noop">    ...               (states.qdgz1, 0.),
</span><span class="noop">    ...               (states.qdgz2, 0.),
</span><span class="noop">    ...               (states.qigz1, 0.),
</span><span class="noop">    ...               (states.qigz2, 0.),
</span><span class="noop">    ...               (states.qbgz, 1.),
</span><span class="noop">    ...               (states.qdga1, 0.),
</span><span class="noop">    ...               (states.qdga2, 0.),
</span><span class="noop">    ...               (states.qiga1, 0.),
</span><span class="noop">    ...               (states.qiga2, 0.),
</span><span class="noop">    ...               (states.qbga, 1.))
</span><span class="noop">
</span><span class="noop">    For the input data, a strong increase in temperature from -5°C to +10°C
</span><span class="noop">    is defined, to activate both the snow and the evapotranspiration routines:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; inputs.nied.series = 0., 5., 5., 5., 0.
</span><span class="noop">    &gt;&gt;&gt; inputs.teml.series = -5., -5., 0., 5., 10.
</span><span class="noop">
</span><span class="noop">    As explained above, the first four values of potential evaporation
</span><span class="noop">    are taken from the integration example of :mod:`~hydpy.models.lland_v1`
</span><span class="noop">    (divided by 2, which is the value defined for the correction factor
</span><span class="noop">    :class:`~hydpy.models.lland.lland_control.KE`):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; inputs.pet.series = (0.372368842264357,
</span><span class="noop">    ...                      0.372368842264357,
</span><span class="noop">    ...                      0.456618961145853,
</span><span class="noop">    ...                      0.534338063059790,
</span><span class="noop">    ...                      1.)
</span><span class="noop">
</span><span class="noop">    For the first four days, the results of the first integration test of
</span><span class="noop">    model :mod:`~hydpy.models.lland_v1` are reproduced.  The increased
</span><span class="noop">    evaporation of the fifth day strenghtens the depletion of the soil
</span><span class="noop">    moisture content.  However, there is no impact on the simulated runoff
</span><span class="noop">    value due the operator splitting scheme implemented for LARSIM&#39;s soil
</span><span class="noop">    routine:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | nied | teml |      pet | nkor | tkor |      et0 |     evpo |     nbes |     sbes |      evi |      evb |      wgtf |     schm |     wada |      qdb |     qib1 |     qib2 |      qbb |     qdgz |        q |     inzp |    wats |     waes |       bowa |    qdgz1 |    qdgz2 |    qigz1 |    qigz2 |     qbgz |    qdga1 |    qdga2 |    qiga1 |    qiga2 |     qbga |   outlet |
</span><span class="noop">    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 | -5.0 | 0.372369 |  0.0 | -4.0 | 0.744738 | 0.372369 |      0.0 |      0.0 |      0.0 | 0.359997 |       0.0 |      0.0 |      0.0 |      0.0 |     0.75 | 1.414214 |      1.4 |      0.0 | 1.077855 |      0.0 |     0.0 |      0.0 |  146.07579 |      0.0 |      0.0 |     0.75 | 1.414214 |      1.4 |      0.0 |      0.0 |  0.00745 | 0.068411 | 1.001993 | 0.012475 |
</span><span class="noop">    | 02.01. |  5.0 | -5.0 | 0.372369 |  6.0 | -4.0 | 0.744738 | 0.372369 |      5.2 |      5.2 | 0.372369 |      0.0 |       0.0 |      0.0 |      0.0 |      0.0 | 0.730379 | 1.251034 | 1.360758 |      0.0 | 1.216305 | 0.427631 |     5.2 |      5.2 | 142.733619 |      0.0 |      0.0 | 0.730379 | 1.251034 | 1.360758 |      0.0 |      0.0 | 0.021959 | 0.188588 | 1.005758 | 0.014078 |
</span><span class="noop">    | 03.01. |  5.0 |  0.0 | 0.456619 |  6.0 |  1.0 | 0.913238 | 0.456619 | 5.627631 | 2.813816 | 0.456619 |      0.0 |  5.012535 | 5.012535 | 6.625839 |  2.04495 | 0.713668 | 1.117415 | 1.327336 |  2.04495 |  1.84654 | 0.343381 | 3.00128 | 4.201792 | 144.156088 | 1.510991 |  0.53396 | 0.713668 | 1.117415 | 1.327336 | 0.321934 | 0.196433 |  0.03582 | 0.283229 | 1.009124 | 0.021372 |
</span><span class="noop">    | 04.01. |  5.0 |  5.0 | 0.534338 |  6.0 |  6.0 | 1.068676 | 0.534338 | 5.543381 |      0.0 | 0.534338 |      0.0 | 30.075212 |  3.00128 | 9.745173 | 3.096033 |  0.72078 |  1.17367 | 1.341561 | 3.096033 | 2.987559 | 0.265662 |     0.0 |      0.0 | 147.569218 | 1.677006 | 1.419027 |  0.72078 |  1.17367 | 1.341561 | 0.825163 | 0.735388 | 0.049313 | 0.365334 | 1.012361 | 0.034578 |
</span><span class="noop">    | 05.01. |  0.0 | 10.0 |      1.0 |  0.0 | 11.0 |      2.0 |      1.0 |      0.0 |      0.0 | 0.265662 | 0.707835 | 55.137889 |      0.0 |      0.0 |      0.0 | 0.737846 | 1.312348 | 1.375692 |      0.0 | 2.976082 |      0.0 |     0.0 |      0.0 | 143.435497 |      0.0 |      0.0 | 0.737846 | 1.312348 | 1.375692 | 0.803032 | 0.645499 | 0.062779 | 0.448966 | 1.015807 | 0.034445 |
</span><span class="noop">
</span><span class="noop">    The second example deals with a sealed surface:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; lnk(VERS)
</span><span class="noop">
</span><span class="noop">    For sealed surfaces, the soil routine is skippend an no base flow is
</span><span class="noop">    calculated.  Thus the corresponding initial values are set to zero:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test.inits.bowa = 0.
</span><span class="noop">    &gt;&gt;&gt; test.inits.qbgz = 0.
</span><span class="noop">    &gt;&gt;&gt; test.inits.qbga = 0.
</span><span class="noop">
</span><span class="noop">    The interception storage is totally drained during the fifth day both
</span><span class="noop">    with the lower potential evaporation value of the second integration
</span><span class="noop">    test of model :mod:`~hydpy.models.lland_v1` and the potential
</span><span class="noop">    evaporation value defined in this example.  Hence only the values
</span><span class="noop">    calculated for sequence :class:`~hydpy.models.lland.lland_fluxes.EvPo`
</span><span class="noop">    differ between both integration tests:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | nied | teml |      pet | nkor | tkor |      et0 |     evpo |     nbes |     sbes |      evi | evb |      wgtf |     schm |     wada |      qdb | qib1 | qib2 | qbb |     qdgz |        q |     inzp |    wats |     waes | bowa |    qdgz1 |    qdgz2 | qigz1 | qigz2 | qbgz |    qdga1 |    qdga2 | qiga1 | qiga2 | qbga |   outlet |
</span><span class="noop">    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 | -5.0 | 0.372369 |  0.0 | -4.0 | 0.744738 | 0.372369 |      0.0 |      0.0 |      0.0 | 0.0 |       0.0 |      0.0 |      0.0 |      0.0 |  0.0 |  0.0 | 0.0 |      0.0 |      0.0 |      0.0 |     0.0 |      0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  5.0 | -5.0 | 0.372369 |  6.0 | -4.0 | 0.744738 | 0.372369 |      5.2 |      5.2 | 0.372369 | 0.0 |       0.0 |      0.0 |      0.0 |      0.0 |  0.0 |  0.0 | 0.0 |      0.0 |      0.0 | 0.427631 |     5.2 |      5.2 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 |      0.0 |
</span><span class="noop">    | 03.01. |  5.0 |  0.0 | 0.456619 |  6.0 |  1.0 | 0.913238 | 0.456619 | 5.627631 | 2.813816 | 0.456619 | 0.0 |  5.012535 | 5.012535 | 6.625839 | 6.625839 |  0.0 |  0.0 | 0.0 | 6.625839 | 2.151239 | 0.343381 | 3.00128 | 4.201792 |  0.0 | 1.849076 | 4.776763 |   0.0 |   0.0 |  0.0 | 0.393967 | 1.757273 |   0.0 |   0.0 |  0.0 | 0.024899 |
</span><span class="noop">    | 04.01. |  5.0 |  5.0 | 0.534338 |  6.0 |  6.0 | 1.068676 | 0.534338 | 5.543381 |      0.0 | 0.534338 | 0.0 | 30.075212 |  3.00128 | 9.745173 | 9.745173 |  0.0 |  0.0 | 0.0 | 9.745173 | 5.772522 | 0.265662 |     0.0 |      0.0 |  0.0 | 1.897385 | 7.847788 |   0.0 |   0.0 |  0.0 |   0.9768 | 4.795722 |   0.0 |   0.0 |  0.0 | 0.066812 |
</span><span class="noop">    | 05.01. |  0.0 | 10.0 |      1.0 |  0.0 | 11.0 |      2.0 |      1.0 |      0.0 |      0.0 | 0.265662 | 0.0 | 55.137889 |      0.0 |      0.0 |      0.0 |  0.0 |  0.0 | 0.0 |      0.0 | 4.772719 |      0.0 |     0.0 |      0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 | 0.934763 | 3.837956 |   0.0 |   0.0 |  0.0 |  0.05524 |
</span><span class="noop">
</span><span class="noop">    For water areas, evaporation is subtracted from the outflow of the
</span><span class="noop">    subbasin.  Hence there is an actual difference between the simulated
</span><span class="noop">    outflow value of the fifth day of this integration example and the
</span><span class="noop">    outflow value of the third integration test of model
</span><span class="noop">    :mod:`~hydpy.models.lland_v1`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; lnk(WASSER)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | nied | teml |      pet | nkor | tkor |      et0 |     evpo | nbes | sbes |      evi | evb | wgtf | schm | wada | qdb | qib1 | qib2 | qbb | qdgz |        q | inzp | wats | waes | bowa |    qdgz1 |    qdgz2 | qigz1 | qigz2 | qbgz |    qdga1 |    qdga2 | qiga1 | qiga2 | qbga |   outlet |
</span><span class="noop">    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 | -5.0 | 0.372369 |  0.0 | -4.0 | 0.744738 | 0.372369 |  0.0 |  0.0 |      0.0 | 0.0 |  0.0 |  0.0 |  0.0 | 0.0 |  0.0 |  0.0 | 0.0 |  0.0 |      0.0 |  0.0 |  0.0 |  0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  5.0 | -5.0 | 0.372369 |  6.0 | -4.0 | 0.744738 | 0.372369 |  6.0 |  6.0 | 0.372369 | 0.0 |  0.0 |  0.0 |  6.0 | 6.0 |  0.0 |  0.0 | 0.0 |  6.0 | 1.551075 |  0.0 |  0.0 |  0.0 |  0.0 | 1.833333 | 4.166667 |   0.0 |   0.0 |  0.0 | 0.390612 | 1.532831 |   0.0 |   0.0 |  0.0 | 0.017952 |
</span><span class="noop">    | 03.01. |  5.0 |  0.0 | 0.456619 |  6.0 |  1.0 | 0.913238 | 0.456619 |  6.0 |  3.0 | 0.456619 | 0.0 |  0.0 |  0.0 |  6.0 | 6.0 |  0.0 |  0.0 | 0.0 |  6.0 | 3.699393 |  0.0 |  0.0 |  0.0 |  0.0 | 1.833333 | 4.166667 |   0.0 |   0.0 |  0.0 | 0.958279 | 3.197733 |   0.0 |   0.0 |  0.0 | 0.042817 |
</span><span class="noop">    | 04.01. |  5.0 |  5.0 | 0.534338 |  6.0 |  6.0 | 1.068676 | 0.534338 |  6.0 |  0.0 | 0.534338 | 0.0 |  0.0 |  0.0 |  6.0 | 6.0 |  0.0 |  0.0 | 0.0 |  6.0 | 4.578464 |  0.0 |  0.0 |  0.0 |  0.0 | 1.833333 | 4.166667 |   0.0 |   0.0 |  0.0 | 1.302586 | 3.810216 |   0.0 |   0.0 |  0.0 | 0.052991 |
</span><span class="noop">    | 05.01. |  0.0 | 10.0 |      1.0 |  0.0 | 11.0 |      2.0 |      1.0 |  0.0 |  0.0 |      1.0 | 0.0 |  0.0 |  0.0 |  0.0 | 0.0 |  0.0 |  0.0 | 0.0 |  0.0 | 2.623511 |  0.0 |  0.0 |  0.0 |  0.0 |      0.0 |      0.0 |   0.0 |   0.0 |  0.0 | 1.120806 | 2.502705 |   0.0 |   0.0 |  0.0 | 0.030365 |
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from lland
</span><span class="hit">from hydpy.models.lland import lland_model
</span><span class="hit">from hydpy.models.lland import lland_control
</span><span class="hit">from hydpy.models.lland import lland_derived
</span><span class="hit">from hydpy.models.lland import lland_inputs
</span><span class="hit">from hydpy.models.lland import lland_fluxes
</span><span class="hit">from hydpy.models.lland import lland_states
</span><span class="hit">from hydpy.models.lland import lland_aides
</span><span class="hit">from hydpy.models.lland import lland_outlets
</span><span class="hit">from hydpy.models.lland.lland_parameters import Parameters
</span><span class="hit">from hydpy.models.lland.lland_constants import *
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;External ET0 version of HydPy-L-Land (lland_v2).&#34;&#34;&#34;
</span><span class="hit">    _RUN_METHODS = (lland_model.calc_nkor_v1,
</span><span class="noop">                    lland_model.calc_tkor_v1,
</span><span class="noop">                    lland_model.calc_et0_v2,
</span><span class="noop">                    lland_model.calc_evpo_v1,
</span><span class="noop">                    lland_model.calc_nbes_inzp_v1,
</span><span class="noop">                    lland_model.calc_evi_inzp_v1,
</span><span class="noop">                    lland_model.calc_sbes_v1,
</span><span class="noop">                    lland_model.calc_wgtf_v1,
</span><span class="noop">                    lland_model.calc_schm_wats_v1,
</span><span class="noop">                    lland_model.calc_wada_waes_v1,
</span><span class="noop">                    lland_model.calc_evb_v1,
</span><span class="noop">                    lland_model.calc_qbb_v1,
</span><span class="noop">                    lland_model.calc_qib1_v1,
</span><span class="noop">                    lland_model.calc_qib2_v1,
</span><span class="noop">                    lland_model.calc_qdb_v1,
</span><span class="noop">                    lland_model.calc_bowa_v1,
</span><span class="noop">                    lland_model.calc_qbgz_v1,
</span><span class="noop">                    lland_model.calc_qigz1_v1,
</span><span class="noop">                    lland_model.calc_qigz2_v1,
</span><span class="noop">                    lland_model.calc_qdgz_v1,
</span><span class="noop">                    lland_model.calc_qdgz1_qdgz2_v1,
</span><span class="noop">                    lland_model.calc_qbga_v1,
</span><span class="noop">                    lland_model.calc_qiga1_v1,
</span><span class="noop">                    lland_model.calc_qiga2_v1,
</span><span class="noop">                    lland_model.calc_qdga1_v1,
</span><span class="noop">                    lland_model.calc_qdga2_v1,
</span><span class="noop">                    lland_model.calc_q_v1)
</span><span class="hit">    _OUTLET_METHODS = (lland_model.pass_q_v1,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of lland_v2, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (lland_control.FT,
</span><span class="noop">                   lland_control.NHRU,
</span><span class="noop">                   lland_control.Lnk,
</span><span class="noop">                   lland_control.FHRU,
</span><span class="noop">                   lland_control.KG,
</span><span class="noop">                   lland_control.KT,
</span><span class="noop">                   lland_control.KE,
</span><span class="noop">                   lland_control.FLn,
</span><span class="noop">                   lland_control.HInz,
</span><span class="noop">                   lland_control.LAI,
</span><span class="noop">                   lland_control.TRefT,
</span><span class="noop">                   lland_control.TRefN,
</span><span class="noop">                   lland_control.TGr,
</span><span class="noop">                   lland_control.TSp,
</span><span class="noop">                   lland_control.GTF,
</span><span class="noop">                   lland_control.RSchmelz,
</span><span class="noop">                   lland_control.CPWasser,
</span><span class="noop">                   lland_control.PWMax,
</span><span class="noop">                   lland_control.GrasRef_R,
</span><span class="noop">                   lland_control.NFk,
</span><span class="noop">                   lland_control.RelWZ,
</span><span class="noop">                   lland_control.RelWB,
</span><span class="noop">                   lland_control.Beta,
</span><span class="noop">                   lland_control.FBeta,
</span><span class="noop">                   lland_control.DMax,
</span><span class="noop">                   lland_control.DMin,
</span><span class="noop">                   lland_control.BSf,
</span><span class="noop">                   lland_control.A1,
</span><span class="noop">                   lland_control.A2,
</span><span class="noop">                   lland_control.TInd,
</span><span class="noop">                   lland_control.EQB,
</span><span class="noop">                   lland_control.EQI1,
</span><span class="noop">                   lland_control.EQI2,
</span><span class="noop">                   lland_control.EQD1,
</span><span class="noop">                   lland_control.EQD2)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of lland_v2, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (lland_derived.MOY,
</span><span class="noop">                   lland_derived.KInz,
</span><span class="noop">                   lland_derived.WB,
</span><span class="noop">                   lland_derived.WZ,
</span><span class="noop">                   lland_derived.KB,
</span><span class="noop">                   lland_derived.KI1,
</span><span class="noop">                   lland_derived.KI2,
</span><span class="noop">                   lland_derived.KD1,
</span><span class="noop">                   lland_derived.KD2,
</span><span class="noop">                   lland_derived.QFactor)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequences(sequencetools.InputSequences):
</span><span class="noop">    &#34;&#34;&#34;Input sequences of lland_v2.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_inputs.Nied,
</span><span class="noop">                   lland_inputs.TemL,
</span><span class="noop">                   lland_inputs.PET)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of lland_v2.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_fluxes.NKor,
</span><span class="noop">                   lland_fluxes.TKor,
</span><span class="noop">                   lland_fluxes.ET0,
</span><span class="noop">                   lland_fluxes.EvPo,
</span><span class="noop">                   lland_fluxes.NBes,
</span><span class="noop">                   lland_fluxes.SBes,
</span><span class="noop">                   lland_fluxes.EvI,
</span><span class="noop">                   lland_fluxes.EvB,
</span><span class="noop">                   lland_fluxes.WGTF,
</span><span class="noop">                   lland_fluxes.Schm,
</span><span class="noop">                   lland_fluxes.WaDa,
</span><span class="noop">                   lland_fluxes.QDB,
</span><span class="noop">                   lland_fluxes.QIB1,
</span><span class="noop">                   lland_fluxes.QIB2,
</span><span class="noop">                   lland_fluxes.QBB,
</span><span class="noop">                   lland_fluxes.QDGZ,
</span><span class="noop">                   lland_fluxes.Q)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of lland_v2.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_states.Inzp,
</span><span class="noop">                   lland_states.WATS,
</span><span class="noop">                   lland_states.WAeS,
</span><span class="noop">                   lland_states.BoWa,
</span><span class="noop">                   lland_states.QDGZ1,
</span><span class="noop">                   lland_states.QDGZ2,
</span><span class="noop">                   lland_states.QIGZ1,
</span><span class="noop">                   lland_states.QIGZ2,
</span><span class="noop">                   lland_states.QBGZ,
</span><span class="noop">                   lland_states.QDGA1,
</span><span class="noop">                   lland_states.QDGA2,
</span><span class="noop">                   lland_states.QIGA1,
</span><span class="noop">                   lland_states.QIGA2,
</span><span class="noop">                   lland_states.QBGA)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of lland_v2.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_aides.Temp,
</span><span class="noop">                   lland_aides.SfA,
</span><span class="noop">                   lland_aides.Exz,
</span><span class="noop">                   lland_aides.BVl,
</span><span class="noop">                   lland_aides.MVl,
</span><span class="noop">                   lland_aides.RVl,
</span><span class="noop">                   lland_aides.EPW)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of lland_v2.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_outlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">The following figure shows the general structure of L-Stream Version 1:
</span><span class="noop">
</span><span class="noop">.. image:: HydPy-L-Stream_Version-1.png
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">Integration test:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lstream_v1 import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">
</span><span class="noop">    Secondly, the final model output shall be passed to `outflow`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.cythons import pointerutils
</span><span class="noop">    &gt;&gt;&gt; inflow, outflow = pointerutils.Double(0.), pointerutils.Double(0.)
</span><span class="noop">    &gt;&gt;&gt; inlets.q.shape = 1
</span><span class="noop">    &gt;&gt;&gt; inlets.q.setpointer(inflow, 0)
</span><span class="noop">    &gt;&gt;&gt; outlets.q.setpointer(outflow)
</span><span class="noop">
</span><span class="noop">    Define the geometry and roughness values for the first test channel:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; bm(2.)
</span><span class="noop">    &gt;&gt;&gt; bnm(4.)
</span><span class="noop">    &gt;&gt;&gt; hm(1.)
</span><span class="noop">    &gt;&gt;&gt; bv(.5, 10.)
</span><span class="noop">    &gt;&gt;&gt; bbv(1., 2.)
</span><span class="noop">    &gt;&gt;&gt; bnv(1., 8.)
</span><span class="noop">    &gt;&gt;&gt; bnvr(20.)
</span><span class="noop">    &gt;&gt;&gt; ekm(1.)
</span><span class="noop">    &gt;&gt;&gt; skm(20.)
</span><span class="noop">    &gt;&gt;&gt; ekv(1.)
</span><span class="noop">    &gt;&gt;&gt; skv(60., 80.)
</span><span class="noop">    &gt;&gt;&gt; gef(.01)
</span><span class="noop">    &gt;&gt;&gt; laen(10.)
</span><span class="noop">
</span><span class="noop">    Set the error tolerances of the iteration small enough, not to
</span><span class="noop">    compromise the shown first six decimal places of the following results:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; qtol(1e-10)
</span><span class="noop">    &gt;&gt;&gt; htol(1e-10)
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; parameters.update()
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; states.qz.old = 1.
</span><span class="noop">    &gt;&gt;&gt; states.qz.new = 1.
</span><span class="noop">    &gt;&gt;&gt; states.qa.old = 1.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; inflow[0] = 2.
</span><span class="noop">    &gt;&gt;&gt; outflow[0] = 0.
</span><span class="noop">    &gt;&gt;&gt; model.doit(0)
</span><span class="noop">    &gt;&gt;&gt; print(round(outflow[0], 6))
</span><span class="noop">    1.737971
</span><span class="noop">    &gt;&gt;&gt; inflow[0] = 2000.
</span><span class="noop">    &gt;&gt;&gt; outflow[0] = 0.
</span><span class="noop">    &gt;&gt;&gt; model.doit(1)
</span><span class="noop">    &gt;&gt;&gt; print(round(outflow[0], 6))
</span><span class="noop">    1932.529863
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from lstream
</span><span class="hit">from hydpy.models.lstream import lstream_model
</span><span class="hit">from hydpy.models.lstream import lstream_control
</span><span class="hit">from hydpy.models.lstream import lstream_derived
</span><span class="hit">from hydpy.models.lstream import lstream_fluxes
</span><span class="hit">from hydpy.models.lstream import lstream_states
</span><span class="hit">from hydpy.models.lstream import lstream_aides
</span><span class="hit">from hydpy.models.lstream import lstream_inlets
</span><span class="hit">from hydpy.models.lstream import lstream_outlets
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;LARSIM-Stream (Manning) version of HydPy-L-Stream (lstream_v1).&#34;&#34;&#34;
</span><span class="hit">    _INLET_METHODS = (lstream_model.pick_q_v1,)
</span><span class="hit">    _RUN_METHODS = (lstream_model.calc_qref_v1,
</span><span class="noop">                    lstream_model.calc_hmin_qmin_hmax_qmax_v1,
</span><span class="noop">                    lstream_model.calc_h_v1,
</span><span class="noop">                    lstream_model.calc_ag_v1,
</span><span class="noop">                    lstream_model.calc_rk_v1,
</span><span class="noop">                    lstream_model.calc_qa_v1)
</span><span class="hit">    _ADD_METHODS = (lstream_model.calc_am_um_v1,
</span><span class="noop">                    lstream_model.calc_qm_v1,
</span><span class="noop">                    lstream_model.calc_av_uv_v1,
</span><span class="noop">                    lstream_model.calc_qv_v1,
</span><span class="noop">                    lstream_model.calc_avr_uvr_v1,
</span><span class="noop">                    lstream_model.calc_qvr_v1,
</span><span class="noop">                    lstream_model.calc_qg_v1)
</span><span class="hit">    _OUTLET_METHODS = (lstream_model.pass_q_v1,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of lstream_v1, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (lstream_control.Laen,
</span><span class="noop">                   lstream_control.Gef,
</span><span class="noop">                   lstream_control.HM,
</span><span class="noop">                   lstream_control.BM,
</span><span class="noop">                   lstream_control.BV,
</span><span class="noop">                   lstream_control.BBV,
</span><span class="noop">                   lstream_control.BNM,
</span><span class="noop">                   lstream_control.BNV,
</span><span class="noop">                   lstream_control.BNVR,
</span><span class="noop">                   lstream_control.SKM,
</span><span class="noop">                   lstream_control.SKV,
</span><span class="noop">                   lstream_control.EKM,
</span><span class="noop">                   lstream_control.EKV,
</span><span class="noop">                   lstream_control.QTol,
</span><span class="noop">                   lstream_control.HTol)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of lstream_v1, indirectly defined by the user.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (lstream_derived.HV,
</span><span class="noop">                   lstream_derived.QM,
</span><span class="noop">                   lstream_derived.QV,
</span><span class="noop">                   lstream_derived.Sek)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of LARSIM-ME.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lstream_fluxes.QRef,
</span><span class="noop">                   lstream_fluxes.H,
</span><span class="noop">                   lstream_fluxes.AM,
</span><span class="noop">                   lstream_fluxes.AV,
</span><span class="noop">                   lstream_fluxes.AVR,
</span><span class="noop">                   lstream_fluxes.AG,
</span><span class="noop">                   lstream_fluxes.UM,
</span><span class="noop">                   lstream_fluxes.UV,
</span><span class="noop">                   lstream_fluxes.UVR,
</span><span class="noop">                   lstream_fluxes.UG,
</span><span class="noop">                   lstream_fluxes.QM,
</span><span class="noop">                   lstream_fluxes.QV,
</span><span class="noop">                   lstream_fluxes.QVR,
</span><span class="noop">                   lstream_fluxes.QG,
</span><span class="noop">                   lstream_fluxes.RK)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of lstream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lstream_states.QZ,
</span><span class="noop">                   lstream_states.QA)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of lstream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lstream_aides.Temp,
</span><span class="noop">                   lstream_aides.HMin,
</span><span class="noop">                   lstream_aides.HMax,
</span><span class="noop">                   lstream_aides.QMin,
</span><span class="noop">                   lstream_aides.QMax,
</span><span class="noop">                   lstream_aides.QTest)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of lstream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lstream_inlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of lstream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lstream_outlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test_v1.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This simple test model is thought for testing numerical integration
</span><span class="noop">strategies.  It can be seen from two perspectives.  On the one hand
</span><span class="noop">it implements the Dahlquist test equation (on the real axis only), which is
</span><span class="noop">related to stiff initial value problems.  On the other hand it describes a
</span><span class="noop">simple storage with a linear loss term and without any input.  The loss rate
</span><span class="noop">:class:`test_fluxes.Q` and the initial storage content :class:`test_states.S`
</span><span class="noop">can be set as required.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># imports...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from test
</span><span class="hit">from hydpy.models.test import test_model
</span><span class="hit">from hydpy.models.test import test_control
</span><span class="hit">from hydpy.models.test import test_solver
</span><span class="hit">from hydpy.models.test import test_fluxes
</span><span class="hit">from hydpy.models.test import test_states
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.ModelELS):
</span><span class="noop">    &#34;&#34;&#34;Test model, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _PART_ODE_METHODS = (test_model.calc_q_v1,)
</span><span class="hit">    _FULL_ODE_METHODS = (test_model.calc_s_v1,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of Test model, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (test_control.K,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SolverParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Solver parameters of the Test model,.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (test_solver.AbsErrorMax,
</span><span class="noop">                   test_solver.RelDTMin)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of Test model, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (test_fluxes.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of Test model, Version 1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (test_states.S,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test_v2.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test_v2.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This simple test model is thought for testing numerical integration
</span><span class="noop">strategies.  It can be seen from two perspectives.  On the one hand
</span><span class="noop">it implements a simple discontinous equation, bringing numerical integration
</span><span class="noop">algorithms into trouble.  On the other hand it describes a simple storage
</span><span class="noop">with a loss that is constant over time, as long as some storage content is
</span><span class="noop">left.  The loss rate :class:`test_fluxes.Q` and the initial storage content
</span><span class="noop">:class:`test_states.S` can be set as required.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># imports...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from test
</span><span class="hit">from hydpy.models.test import test_model
</span><span class="hit">from hydpy.models.test import test_control
</span><span class="hit">from hydpy.models.test import test_solver
</span><span class="hit">from hydpy.models.test import test_fluxes
</span><span class="hit">from hydpy.models.test import test_states
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.ModelELS):
</span><span class="noop">    &#34;&#34;&#34;Test model, Version 2.&#34;&#34;&#34;
</span><span class="hit">    _PART_ODE_METHODS = (test_model.calc_q_v2,)
</span><span class="hit">    _FULL_ODE_METHODS = (test_model.calc_s_v1,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of Test model, Version 2.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (test_control.K,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SolverParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Solver parameters of the Test model,.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (test_solver.AbsErrorMax,
</span><span class="noop">                   test_solver.RelDTMin)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of Test model, Version 2.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (test_fluxes.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of Test model, Version 2.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (test_states.S,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from arma
</span><span class="hit">from hydpy.models.arma.arma_control import ControlParameters
</span><span class="hit">from hydpy.models.arma.arma_derived import DerivedParameters
</span><span class="hit">from hydpy.models.arma.arma_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.arma.arma_logs import LogSequences
</span><span class="hit">from hydpy.models.arma.arma_inlets import InletSequences
</span><span class="hit">from hydpy.models.arma.arma_outlets import OutletSequences
</span><span class="hit">from hydpy.models.arma.arma_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Responses(parametertools.Parameter):
</span><span class="noop">    &#34;&#34;&#34;Assigns different ARMA models to different discharge thresholds.
</span><span class="noop">
</span><span class="noop">    Parameter :class:`Responses` is not involved in the actual calculations
</span><span class="noop">    during the simulation run.  Instead, it is thought for the intuitive
</span><span class="noop">    handling of different ARMA models.  It can be applied as follows.
</span><span class="noop">
</span><span class="noop">    Initially, each new `responses` object is emtpy:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep()
</span><span class="noop">    &gt;&gt;&gt; responses
</span><span class="noop">    responses()
</span><span class="noop">
</span><span class="noop">    One can assign ARMA models as attributes to it:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses.th_0_0 = ((1, 2), (3, 4, 6))
</span><span class="noop">
</span><span class="noop">    `th_0_0` stands for a threshold discharge value of 0.0 m³/s, which the
</span><span class="noop">    given ARMA model corresponds to.  For integer discharge values, one can
</span><span class="noop">    omit the decimal digit:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses.th_1 = ((), (7,))
</span><span class="noop">
</span><span class="noop">    One can also omit the leading letters, but not the underscore:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses.th_2_5 = ([8], range(9, 20))
</span><span class="noop">
</span><span class="noop">    Internally, all threshold keys are brought into the standard format:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses
</span><span class="noop">    responses(th_0_0=((1.0, 2.0),
</span><span class="noop">                      (3.0, 4.0, 6.0)),
</span><span class="noop">              th_1_0=((),
</span><span class="noop">                      (7.0,)),
</span><span class="noop">              th_2_5=((8.0,),
</span><span class="noop">                      (9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0,
</span><span class="noop">                       18.0, 19.0)))
</span><span class="noop">
</span><span class="noop">    All ARMA models are available via attribute access and their attribute
</span><span class="noop">    names are made available to function :func:`dir`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; &#39;th_1_0&#39; in dir(responses)
</span><span class="noop">    True
</span><span class="noop">
</span><span class="noop">    Note that all iterables containing the AR and MA coefficients are
</span><span class="noop">    converted to tuples, to prevent them from being changed by accident:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses.th_1[1][0]
</span><span class="noop">    7.0
</span><span class="noop">    &gt;&gt;&gt; responses.th_1_0[1][0] = 77
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    TypeError: &#39;tuple&#39; object does not support item assignment
</span><span class="noop">
</span><span class="noop">    Instead, one can delete and or overwrite existing ARMA models:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; del responses.th_2_5
</span><span class="noop">    &gt;&gt;&gt; responses.th_1 = ((), (77,))
</span><span class="noop">    &gt;&gt;&gt; responses
</span><span class="noop">    responses(th_0_0=((1.0, 2.0),
</span><span class="noop">                      (3.0, 4.0, 6.0)),
</span><span class="noop">              th_1_0=((),
</span><span class="noop">                      (77.0,)))
</span><span class="noop">
</span><span class="noop">    Names that cannot be identified as threshold values result in an exception:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses.test = ((), ())
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    AttributeError: To define different response functions for parameter `responses` of element `?`, one has to pass them as keyword arguments or set them as additional attributes.  The used name must meet a specific format (see the documentation for further information).  The given name `test` does not meet this format.
</span><span class="noop">
</span><span class="noop">    Suitable get-related attribute exceptions are also implemented:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses.test
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    AttributeError: Parameter `responses` of element `?` does not have an attribute named `test` and the name `test` is also not a valid threshold value identifier.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses._0_1
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    AttributeError: Parameter `responses` of element `?` does not have an attribute attribute named `_0_1` nor an arma model corresponding to a threshold value named `th_0_1`.
</span><span class="noop">
</span><span class="noop">    The above examples show that all AR and MA coefficients are converted to
</span><span class="noop">    floating point values.  It this is not possible or something else goes
</span><span class="noop">    totally wrong during the definition of a new ARMA model, errors like the
</span><span class="noop">    following are raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses.th_10 = ()
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    IndexError: While trying to set a new threshold (th_10) coefficient pair for parameter `responses` of element `?`, the following error occured: tuple index out of range
</span><span class="noop">
</span><span class="noop">    Except for the mentioned conversion to floating point values, there are
</span><span class="noop">    no plausibility checks performed.  You have to use other tools to gain
</span><span class="noop">    plausible coefficients.  The HydPy framework offers the module
</span><span class="noop">    :mod:`~hydpy.auxs.iuhtools` for such purposes.
</span><span class="noop">
</span><span class="noop">    Prepare one instantaneous unit hydrograph (iuh) based on the
</span><span class="noop">    Translation Diffusion Equation and another one based on the Linear
</span><span class="noop">    Storage Cascade:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.iuhtools import TranslationDiffusionEquation
</span><span class="noop">    &gt;&gt;&gt; tde = TranslationDiffusionEquation(d=5., u=2., x=4.)
</span><span class="noop">    &gt;&gt;&gt; from hydpy.auxs.iuhtools import LinearStorageCascade
</span><span class="noop">    &gt;&gt;&gt; lsc = LinearStorageCascade(n=2.5, k=1.)
</span><span class="noop">
</span><span class="noop">    The following line deletes the coefficients defined above and assigns the
</span><span class="noop">    ARMA approximations of both iuh models:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses(lsc, _2=tde)
</span><span class="noop">
</span><span class="noop">    One can change the parameter values of the translation diffusion iuh and
</span><span class="noop">    assign it to the `responses` parameter, without affecting the ARMA
</span><span class="noop">    coefficients of the first tde parametrization:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; tde.u = 1.
</span><span class="noop">    &gt;&gt;&gt; responses._5 = tde
</span><span class="noop">    &gt;&gt;&gt; responses
</span><span class="noop">    responses(th_0_0=((1.001744, -0.32693, 0.034286),
</span><span class="noop">                      (0.050456, 0.199156, 0.04631, -0.004812, -0.00021)),
</span><span class="noop">              th_2_0=((2.028483, -1.447371, 0.420257, -0.039595, -0.000275),
</span><span class="noop">                      (0.165732, 0.061819, -0.377523, 0.215754, -0.024597,
</span><span class="noop">                       -0.002684)),
</span><span class="noop">              th_5_0=((3.032315, -3.506645, 1.908546, -0.479333, 0.042839,
</span><span class="noop">                       0.00009),
</span><span class="noop">                      (0.119252, -0.054959, -0.342744, 0.433585, -0.169102,
</span><span class="noop">                       0.014189, 0.001967)))
</span><span class="noop">
</span><span class="noop">    One may have noted the Linear Storage Cascade model was passed as
</span><span class="noop">    a positional argument and was assigned to a treshold value of 0.0 m³/s
</span><span class="noop">    automatically, which is the default value.  As each treshold value has to
</span><span class="noop">    be unique, one can pass only one positional argument:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses(tde, lsc)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: For parameter `responses` of element `?` at most one positional argument is allowed, but `2` are given.
</span><span class="noop">
</span><span class="noop">    Checks for the repeated definition of the same threshold values are also
</span><span class="noop">    performed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses(tde, _0=lsc, _1=tde, _1_0=lsc)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: For parameter `responses` of element `?` `4` arguments have been given but only `2` response functions could be prepared.  Most probably, you defined the same threshold value(s) twice.
</span><span class="noop">
</span><span class="noop">    The number of response functions and the number of the respective AR and
</span><span class="noop">    MA coefficients of a given `responses` parameter can be easily queried:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses(_0=((1.0, 2.0),
</span><span class="noop">    ...               (3.0, 4.0, 6.0)),
</span><span class="noop">    ...           _1=((),
</span><span class="noop">    ...               (7.0,)))
</span><span class="noop">    &gt;&gt;&gt; len(responses)
</span><span class="noop">    2
</span><span class="noop">    &gt;&gt;&gt; responses.ar_orders
</span><span class="noop">    (2, 0)
</span><span class="noop">    &gt;&gt;&gt; responses.ma_orders
</span><span class="noop">    (3, 1)
</span><span class="noop">
</span><span class="noop">    The threshold values and AR coefficients and the MA coefficients can all
</span><span class="noop">    be queried as numpy arrays:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; responses.thresholds
</span><span class="noop">    array([ 0.,  1.])
</span><span class="noop">    &gt;&gt;&gt; responses.ar_coefs
</span><span class="noop">    array([[  1.,   2.],
</span><span class="noop">           [ nan,  nan]])
</span><span class="noop">    &gt;&gt;&gt; responses.ma_coefs
</span><span class="noop">    array([[  3.,   4.,   6.],
</span><span class="noop">           [  7.,  nan,  nan]])
</span><span class="noop">
</span><span class="noop">    Technical notes:
</span><span class="noop">
</span><span class="noop">    The implementation of this class is much to tricky for subpackage `models`.
</span><span class="noop">    It should be generalized and moved to the framework core later.
</span><span class="noop">
</span><span class="noop">    Furthermore, it would be nice to avoid the `nan` values in the coefficent
</span><span class="noop">    representations.  But this would possibly require to define a specialized
</span><span class="noop">    `arrays in list` type in Cython.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">    def __init__(self, *args, **kwargs):
</span><span class="hit">        self.__dict__[&#39;subpars&#39;] = None
</span><span class="hit">        self.__dict__[&#39;fastaccess&#39;] = None
</span><span class="hit">        self.__dict__[&#39;_coefs&#39;] = {}
</span><span class="hit">        super(Responses, self).__init__(*args, **kwargs)
</span><span class="noop">
</span><span class="hit">    def connect(self, subpars):
</span><span class="hit">        self.__dict__[&#39;subpars&#39;] = subpars
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        self._coefs.clear()
</span><span class="hit">        if len(args) &gt; 1:
</span><span class="hit">            raise ValueError(
</span><span class="noop">                &#39;For parameter `%s` of element `%s` at most one positional &#39;
</span><span class="noop">                &#39;argument is allowed, but `%d` are given.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self.subpars), len(args)))
</span><span class="hit">        for (key, value) in kwargs.items():
</span><span class="hit">            setattr(self, key, value)
</span><span class="hit">        if len(args) == 1:
</span><span class="hit">            setattr(self, &#39;th_0_0&#39;, args[0])
</span><span class="hit">        if len(args)+len(kwargs) != len(self):
</span><span class="hit">            raise ValueError(
</span><span class="noop">                &#39;For parameter `%s` of element `%s` `%d` arguments have been &#39;
</span><span class="noop">                &#39;given but only `%s` response functions could be prepared.  &#39;
</span><span class="noop">                &#39;Most probably, you defined the same threshold value(s) twice.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self.subpars),
</span><span class="noop">                   len(args)+len(kwargs), len(self)))
</span><span class="noop">
</span><span class="hit">    def _has_predefined_attr(self, name):
</span><span class="hit">        return ((name in self.__dict__ or
</span><span class="noop">                 name in Responses.__dict__ or
</span><span class="noop">                 name in parametertools.Parameter.__dict__) and
</span><span class="noop">                not name.startswith(&#39;th_&#39;))
</span><span class="noop">
</span><span class="hit">    def __getattribute__(self, key):
</span><span class="hit">        try:
</span><span class="hit">            return object.__getattribute__(self, key)
</span><span class="hit">        except AttributeError:
</span><span class="hit">            pass
</span><span class="hit">        try:
</span><span class="hit">            std_key = self._standardize_key(key)
</span><span class="hit">        except AttributeError:
</span><span class="hit">            raise AttributeError(
</span><span class="noop">                &#39;Parameter `%s` of element `%s` does not have an attribute &#39;
</span><span class="noop">                &#39;named `%s` and the name `%s` is also not a valid threshold &#39;
</span><span class="noop">                &#39;value identifier.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self.subpars), key, key))
</span><span class="hit">        if std_key in self._coefs:
</span><span class="hit">            return self._coefs[std_key]
</span><span class="noop">        else:
</span><span class="hit">            raise AttributeError(
</span><span class="noop">                &#39;Parameter `%s` of element `%s` does not have an attribute &#39;
</span><span class="noop">                &#39;attribute named `%s` nor an arma model corresponding to a &#39;
</span><span class="noop">                &#39;threshold value named `%s`.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self.subpars),
</span><span class="noop">                   key, std_key))
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, key, value):
</span><span class="hit">        if self._has_predefined_attr(key):
</span><span class="hit">            object.__setattr__(self, key, value)
</span><span class="noop">        else:
</span><span class="hit">            std_key = self._standardize_key(key)
</span><span class="hit">            try:
</span><span class="hit">                try:
</span><span class="hit">                    self._coefs[std_key] = value.arma.coefs
</span><span class="hit">                except AttributeError:
</span><span class="hit">                    self._coefs[std_key] = (tuple(float(v) for v in value[0]),
</span><span class="noop">                                            tuple(float(v) for v in value[1]))
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to set a new threshold (%s) coefficient &#39;
</span><span class="noop">                    &#39;pair for parameter `%s` of element `%s`&#39;
</span><span class="noop">                    % (key, self.name, objecttools.devicename(self.subpars)))
</span><span class="noop">
</span><span class="hit">    def __delattr__(self, key):
</span><span class="hit">        std_key = self._standardize_key(key)
</span><span class="hit">        if std_key in self._coefs:
</span><span class="hit">            del self._coefs[std_key]
</span><span class="noop">
</span><span class="hit">    def _standardize_key(self, key):
</span><span class="hit">        try:
</span><span class="hit">            tuple_ = str(key).split(&#39;_&#39;)
</span><span class="hit">            if (len(tuple_) &gt; 1) and tuple_[-2].isdigit():
</span><span class="hit">                integer = int(tuple_[-2])
</span><span class="hit">                decimal = int(tuple_[-1])
</span><span class="noop">            else:
</span><span class="hit">                integer = int(tuple_[-1])
</span><span class="hit">                decimal = 0
</span><span class="hit">            return &#39;_&#39;.join((&#39;th&#39;, str(integer), str(decimal)))
</span><span class="hit">        except BaseException:
</span><span class="hit">            raise AttributeError(
</span><span class="noop">                &#39;To define different response functions for parameter `%s` of &#39;
</span><span class="noop">                &#39;element `%s`, one has to pass them as keyword arguments or &#39;
</span><span class="noop">                &#39;set them as additional attributes.  The used name must meet &#39;
</span><span class="noop">                &#39;a specific format (see the documentation for further &#39;
</span><span class="noop">                &#39;information).  The given name `%s` does not meet this format.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self.subpars), key))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def thresholds(self):
</span><span class="noop">        &#34;&#34;&#34;Threshold values of the response functions.&#34;&#34;&#34;
</span><span class="hit">        return numpy.array(sorted(self._key2float(key)
</span><span class="noop">                                  for key in self._coefs.keys()), dtype=float)
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def _key2float(key):
</span><span class="hit">        return float(key[3:].replace(&#39;_&#39;, &#39;.&#39;))
</span><span class="noop">
</span><span class="hit">    def _getorders(self, index):
</span><span class="hit">        orders = []
</span><span class="hit">        for _, coefs in self:
</span><span class="hit">            orders.append(len(coefs[index]))
</span><span class="hit">        return tuple(orders)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def ar_orders(self):
</span><span class="noop">        &#34;&#34;&#34;Number of AR coefficients of the different response functions.&#34;&#34;&#34;
</span><span class="hit">        return self._getorders(0)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def ma_orders(self):
</span><span class="noop">        &#34;&#34;&#34;Number of MA coefficients of the different response functions.&#34;&#34;&#34;
</span><span class="hit">        return self._getorders(1)
</span><span class="noop">
</span><span class="hit">    def _getcoefs(self, index):
</span><span class="hit">        orders = self._getorders(index)
</span><span class="hit">        max_orders = max(orders) if len(orders) else 0
</span><span class="hit">        coefs = numpy.full((len(self), max_orders), numpy.nan)
</span><span class="hit">        for idx, (order, (_, coef)) in enumerate(zip(orders, self)):
</span><span class="hit">            coefs[idx, :order] = coef[index]
</span><span class="hit">        return coefs
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def ar_coefs(self):
</span><span class="noop">        &#34;&#34;&#34;AR coefficients of the different response functions.
</span><span class="noop">
</span><span class="noop">        The first row contains the AR coefficients related to the the smallest
</span><span class="noop">        threshold value, the last row contains the AR coefficients related to
</span><span class="noop">        the highest threshold value.  The number of columns depend on the
</span><span class="noop">        highest number of AR coefficients among all response functions.&#34;&#34;&#34;
</span><span class="hit">        return self._getcoefs(0)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def ma_coefs(self):
</span><span class="noop">        &#34;&#34;&#34;AR coefficients of the different response functions.
</span><span class="noop">
</span><span class="noop">        The first row contains the MA coefficients related to the the smallest
</span><span class="noop">        threshold value, the last row contains the AR coefficients related to
</span><span class="noop">        the highest threshold value.  The number of columns depend on the
</span><span class="noop">        highest number of MA coefficients among all response functions.&#34;&#34;&#34;
</span><span class="hit">        return self._getcoefs(1)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return len(self._coefs)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for key in sorted(self._coefs.keys(),  key=self._key2float):
</span><span class="hit">            yield key, self._coefs[key]
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        strings = self.commentrepr()
</span><span class="hit">        prefix = &#39;%s(&#39; % self.name
</span><span class="hit">        blanks = &#39; &#39;*len(prefix)
</span><span class="hit">        if len(self):
</span><span class="hit">            for idx, (th, coefs) in enumerate(self):
</span><span class="hit">                subprefix = (&#39;%s%s=&#39; % (prefix, th) if idx == 0 else
</span><span class="noop">                             &#39;%s%s=&#39; % (blanks, th))
</span><span class="hit">                strings.append(objecttools.assignrepr_tuple2(coefs, subprefix,
</span><span class="noop">                                                             75) + &#39;,&#39;)
</span><span class="hit">            strings[-1] = strings[-1][:-1] + &#39;)&#39;
</span><span class="noop">        else:
</span><span class="hit">            strings.append(prefix + &#39;)&#39;)
</span><span class="hit">        return &#39;\n&#39;.join(strings)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="hit">        attrs = objecttools.dir_(self)
</span><span class="hit">        attrs.extend(self._coefs.keys())
</span><span class="hit">        return attrs
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of arma, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (Responses,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Nmb(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of response functions [-].
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; responses(((1., 2.), (1.,)), th_3=((1.,), (1., 2., 3.)))
</span><span class="noop">    &gt;&gt;&gt; derived.nmb.update()
</span><span class="noop">    &gt;&gt;&gt; derived.nmb
</span><span class="noop">    nmb(2)
</span><span class="noop">
</span><span class="noop">    Note that updating parameter `nmb` sets the shape of the
</span><span class="noop">    flux sequences :class:`~hydpy.models.arma.arma_fluxes.QPIn`,
</span><span class="noop">    :class:`~hydpy.models.arma.arma_fluxes.QPOut`,
</span><span class="noop">    :class:`~hydpy.models.arma.arma_fluxes.QMA`, and
</span><span class="noop">    :class:`~hydpy.models.arma.arma_fluxes.QAR` automatically.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; fluxes.qpin
</span><span class="noop">    qpin(nan, nan)
</span><span class="noop">    &gt;&gt;&gt; fluxes.qpout
</span><span class="noop">    qpout(nan, nan)
</span><span class="noop">    &gt;&gt;&gt; fluxes.qma
</span><span class="noop">    qma(nan, nan)
</span><span class="noop">    &gt;&gt;&gt; fluxes.qar
</span><span class="noop">    qar(nan, nan)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (0, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        pars = self.subpars.pars
</span><span class="hit">        responses = pars.control.responses
</span><span class="hit">        fluxes = pars.model.sequences.fluxes
</span><span class="hit">        self(len(responses))
</span><span class="hit">        fluxes.qpin.shape = self.value
</span><span class="hit">        fluxes.qpout.shape = self.value
</span><span class="hit">        fluxes.qma.shape = self.value
</span><span class="hit">        fluxes.qar.shape = self.value
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MaxQ(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Maximum discharge values of the respective ARMA models [m³/s].
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; responses(((1., 2.), (1.,)), th_3=((1.,), (1., 2., 3.)))
</span><span class="noop">    &gt;&gt;&gt; derived.maxq.update()
</span><span class="noop">    &gt;&gt;&gt; derived.maxq
</span><span class="noop">    maxq(0.0, 3.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        responses = self.subpars.pars.control.responses
</span><span class="hit">        self.shape = len(responses)
</span><span class="hit">        self(responses.thresholds)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DiffQ(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Differences between the values of :class:`MaxQ` [m³/s].
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; responses(((1., 2.), (1.,)), th_3=((1.,), (1., 2., 3.)))
</span><span class="noop">    &gt;&gt;&gt; derived.diffq.update()
</span><span class="noop">    &gt;&gt;&gt; derived.diffq
</span><span class="noop">    diffq(3.0)
</span><span class="noop">     &gt;&gt;&gt; responses(((1., 2.), (1.,)))
</span><span class="noop">    &gt;&gt;&gt; derived.diffq.update()
</span><span class="noop">    &gt;&gt;&gt; derived.diffq
</span><span class="noop">    diffq()
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        responses = self.subpars.pars.control.responses
</span><span class="hit">        self.shape = len(responses)-1
</span><span class="hit">        self(numpy.diff(responses.thresholds))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AR_Order(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of AR coefficients of the different responses [-].
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; responses(((1., 2.), (1.,)), th_3=((1.,), (1., 2., 3.)))
</span><span class="noop">    &gt;&gt;&gt; derived.ar_order.update()
</span><span class="noop">    &gt;&gt;&gt; derived.ar_order
</span><span class="noop">    ar_order(2, 1)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, int, None, (0, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        responses = self.subpars.pars.control.responses
</span><span class="hit">        self.shape = len(responses)
</span><span class="hit">        self(responses.ar_orders)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MA_Order(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of MA coefficients of the different responses [-].
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; responses(((1., 2.), (1.,)), th_3=((1.,), (1., 2., 3.)))
</span><span class="noop">    &gt;&gt;&gt; derived.ma_order.update()
</span><span class="noop">    &gt;&gt;&gt; derived.ma_order
</span><span class="noop">    ma_order(1, 3)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, int, None, (0, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        responses = self.subpars.pars.control.responses
</span><span class="hit">        self.shape = len(responses)
</span><span class="hit">        self(responses.ma_orders)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AR_Coefs(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;AR coefficients of the different responses [-].
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; responses(((1., 2.), (1.,)), th_3=((1.,), (1., 2., 3.)))
</span><span class="noop">    &gt;&gt;&gt; derived.ar_coefs.update()
</span><span class="noop">    &gt;&gt;&gt; derived.ar_coefs
</span><span class="noop">    ar_coefs(1.0, 2.0,
</span><span class="noop">             1.0, nan)
</span><span class="noop">
</span><span class="noop">    Note that updating parameter `ar_coefs` sets the shape of the log
</span><span class="noop">    sequence :class:`~hydpy.models.arma.arma_logs.LogOut` automatically.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; logs.logout
</span><span class="noop">    logout(nan, nan,
</span><span class="noop">           nan, nan)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        pars = self.subpars.pars
</span><span class="hit">        coefs = pars.control.responses.ar_coefs
</span><span class="hit">        self.shape = coefs.shape
</span><span class="hit">        self(coefs)
</span><span class="hit">        pars.model.sequences.logs.logout.shape = self.shape
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MA_Coefs(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;MA coefficients of the different responses [-].
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; responses(((1., 2.), (1.,)), th_3=((1.,), (1., 2., 3.)))
</span><span class="noop">    &gt;&gt;&gt; derived.ma_coefs.update()
</span><span class="noop">    &gt;&gt;&gt; derived.ma_coefs
</span><span class="noop">    ma_coefs(1.0, nan, nan,
</span><span class="noop">             1.0, 2.0, 3.0)
</span><span class="noop">
</span><span class="noop">    Note that updating parameter `ar_coefs` sets the shape of the log
</span><span class="noop">    sequence :class:`~hydpy.models.arma.arma_logs.LogIn` automatically.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; logs.login
</span><span class="noop">    login(nan, nan, nan,
</span><span class="noop">          nan, nan, nan)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        pars = self.subpars.pars
</span><span class="hit">        coefs = pars.control.responses.ma_coefs
</span><span class="hit">        self.shape = coefs.shape
</span><span class="hit">        self(coefs)
</span><span class="hit">        pars.model.sequences.logs.login.shape = self.shape
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of arma, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (Nmb,
</span><span class="noop">                   MaxQ,
</span><span class="noop">                   DiffQ,
</span><span class="noop">                   AR_Order,
</span><span class="noop">                   MA_Order,
</span><span class="noop">                   AR_Coefs,
</span><span class="noop">                   MA_Coefs)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QIn(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Total inflow [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QPIn(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Inflow portions corresponding to the different thresholds [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QMA(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;MA result for the different thresholds [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QAR(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;AR result for the different thresholds [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QPOut(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Outflow portions corresponding to the different thresholds [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QOut(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Total outflow [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of the ARMA model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QIn,
</span><span class="noop">                   QPIn,
</span><span class="noop">                   QMA,
</span><span class="noop">                   QAR,
</span><span class="noop">                   QPOut,
</span><span class="noop">                   QOut)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_inlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_inlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss (runoff) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of the ARMA model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_logs.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_logs.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogIn(sequencetools.LogSequence):
</span><span class="noop">    &#34;&#34;&#34;The recent and the past inflow portions for the application of the
</span><span class="noop">    different MA processes [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 2, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogOut(sequencetools.LogSequence):
</span><span class="noop">    &#34;&#34;&#34;The past outflow portions for the application of the
</span><span class="noop">    different AR processes [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 2, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequences(sequencetools.LogSequences):
</span><span class="noop">    &#34;&#34;&#34;Log sequences of the ARMA model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (LogIn,
</span><span class="noop">                   LogOut)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># imports...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qpin_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the input discharge portions of the different response
</span><span class="noop">    functions.
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.Nmb`
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.MaxQ`
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.DiffQ`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_fluxes.QIn`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_fluxes.QPIn`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Initialize an arma model with three different response functions:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.nmb = 3
</span><span class="noop">        &gt;&gt;&gt; derived.maxq.shape = 3
</span><span class="noop">        &gt;&gt;&gt; derived.diffq.shape = 2
</span><span class="noop">        &gt;&gt;&gt; fluxes.qpin.shape = 3
</span><span class="noop">
</span><span class="noop">        Define the maximum discharge value of the respective response
</span><span class="noop">        functions and their successive differences:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.maxq(0.0, 2.0, 6.0)
</span><span class="noop">        &gt;&gt;&gt; derived.diffq(2., 4.)
</span><span class="noop">
</span><span class="noop">        The first six examples are performed for inflow values ranging from
</span><span class="noop">        0 to 12 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.testtools import UnitTest
</span><span class="noop">        &gt;&gt;&gt; test = UnitTest(model, model.calc_qpin_v1, last_example=6)
</span><span class="noop">        &gt;&gt;&gt; test.nexts.qin = 0., 1., 2., 4., 6., 12.
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | nmb |           maxq |      diffq |  qin |           qpin |
</span><span class="noop">        -------------------------------------------------------------------
</span><span class="noop">        |   1 |   3 | 0.0  2.0   6.0 | 2.0    4.0 |  0.0 | 0.0  0.0   0.0 |
</span><span class="noop">        |   2 |   3 | 0.0  2.0   6.0 | 2.0    4.0 |  1.0 | 1.0  0.0   0.0 |
</span><span class="noop">        |   3 |   3 | 0.0  2.0   6.0 | 2.0    4.0 |  2.0 | 2.0  0.0   0.0 |
</span><span class="noop">        |   4 |   3 | 0.0  2.0   6.0 | 2.0    4.0 |  4.0 | 2.0  2.0   0.0 |
</span><span class="noop">        |   5 |   3 | 0.0  2.0   6.0 | 2.0    4.0 |  6.0 | 2.0  4.0   0.0 |
</span><span class="noop">        |   6 |   3 | 0.0  2.0   6.0 | 2.0    4.0 | 12.0 | 2.0  4.0   6.0 |
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        The following two additional examples are just supposed to demonstrate
</span><span class="noop">        method :func:`calc_qpin_v1` also functions properly if there is only
</span><span class="noop">        one response function, wherefore total discharge does not need to be
</span><span class="noop">        divided:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.nmb = 1
</span><span class="noop">        &gt;&gt;&gt; derived.maxq.shape = 1
</span><span class="noop">        &gt;&gt;&gt; derived.diffq.shape = 0
</span><span class="noop">        &gt;&gt;&gt; fluxes.qpin.shape = 1
</span><span class="noop">        &gt;&gt;&gt; derived.maxq(0.)
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test = UnitTest(model, model.calc_qpin_v1,
</span><span class="noop">        ...                 first_example=7, last_example=8)
</span><span class="noop">        &gt;&gt;&gt; test.nexts.qin = 0., 12.
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | nmb | maxq | diffq |  qin | qpin |
</span><span class="noop">        ------------------------------------------
</span><span class="noop">        |   7 |   1 |  0.0 | empty |  0.0 |  0.0 |
</span><span class="noop">        |   8 |   1 |  0.0 | empty | 12.0 | 12.0 |
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for idx in range(der.nmb-1):
</span><span class="hit">        if flu.qin &lt; der.maxq[idx]:
</span><span class="hit">            flu.qpin[idx] = 0.
</span><span class="hit">        elif flu.qin &lt; der.maxq[idx+1]:
</span><span class="hit">            flu.qpin[idx] = flu.qin-der.maxq[idx]
</span><span class="noop">        else:
</span><span class="hit">            flu.qpin[idx] = der.diffq[idx]
</span><span class="hit">    flu.qpin[der.nmb-1] = max(flu.qin-der.maxq[der.nmb-1], 0.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_login_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Refresh the input log sequence for the different MA processes.
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.Nmb`
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.MA_Order`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_fluxes.QPIn`
</span><span class="noop">
</span><span class="noop">    Updated log sequence:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_log.LogIn`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        Assume there are three response functions, involving one, two and
</span><span class="noop">        three MA coefficients respectively:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.nmb(3)
</span><span class="noop">        &gt;&gt;&gt; derived.ma_order.shape = 3
</span><span class="noop">        &gt;&gt;&gt; derived.ma_order = 1, 2, 3
</span><span class="noop">        &gt;&gt;&gt; fluxes.qpin.shape = 3
</span><span class="noop">        &gt;&gt;&gt; logs.login.shape = (3, 3)
</span><span class="noop">
</span><span class="noop">        The &#34;memory values&#34; of the different MA processes are defined as
</span><span class="noop">        follows (one row for each process):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; logs.login = ((1.0, nan, nan),
</span><span class="noop">        ...               (2.0, 3.0, nan),
</span><span class="noop">        ...               (4.0, 5.0, 6.0))
</span><span class="noop">
</span><span class="noop">        These are the new inflow discharge portions to be included into
</span><span class="noop">        the memories of the different processes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.qpin = 7.0, 8.0, 9.0
</span><span class="noop">
</span><span class="noop">        Through applying method :func:`calc_login_v1` all values already
</span><span class="noop">        existing are shifted to the right (&#34;into the past&#34;).  Values, which
</span><span class="noop">        are no longer required due to the limited order or the different
</span><span class="noop">        MA processes, are discarded.  The new values are inserted in the
</span><span class="noop">        first column:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.calc_login_v1()
</span><span class="noop">        &gt;&gt;&gt; logs.login
</span><span class="noop">        login(7.0, nan, nan,
</span><span class="noop">              8.0, 2.0, nan,
</span><span class="noop">              9.0, 4.0, 5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    log = self.sequences.logs.fastaccess
</span><span class="hit">    for idx in range(der.nmb):
</span><span class="hit">        for jdx in range(der.ma_order[idx]-2, -1, -1):
</span><span class="hit">            log.login[idx, jdx+1] = log.login[idx, jdx]
</span><span class="hit">    for idx in range(der.nmb):
</span><span class="hit">        log.login[idx, 0] = flu.qpin[idx]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qma_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the discharge responses of the different MA processes.
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.Nmb`
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.MA_Order`
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.MA_Coeffs`
</span><span class="noop">
</span><span class="noop">    Required log sequence:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_log.LogIn`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_fluxes.QMA`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Assume there are three response functions, involving one, two and
</span><span class="noop">        three MA coefficients respectively:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.nmb(3)
</span><span class="noop">        &gt;&gt;&gt; derived.ma_order.shape = 3
</span><span class="noop">        &gt;&gt;&gt; derived.ma_order = 1, 2, 3
</span><span class="noop">        &gt;&gt;&gt; derived.ma_coefs.shape = (3, 3)
</span><span class="noop">        &gt;&gt;&gt; logs.login.shape = (3, 3)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qma.shape = 3
</span><span class="noop">
</span><span class="noop">        The coefficients of the different MA processes are stored in
</span><span class="noop">        seperate rows of the 2-dimensional parameter `ma_coefs`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.ma_coefs = ((1.0, nan, nan),
</span><span class="noop">        ...                     (0.8, 0.2, nan),
</span><span class="noop">        ...                     (0.5, 0.3, 0.2))
</span><span class="noop">
</span><span class="noop">        The &#34;memory values&#34; of the different MA processes are defined as
</span><span class="noop">        follows (one row for each process).  The current values are stored
</span><span class="noop">        in first column, the values of the last time step in the second
</span><span class="noop">        column, and so on:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; logs.login = ((1.0, nan, nan),
</span><span class="noop">        ...               (2.0, 3.0, nan),
</span><span class="noop">        ...               (4.0, 5.0, 6.0))
</span><span class="noop">
</span><span class="noop">        Applying method :func:`calc_qma_v1` is equivalent to calculating
</span><span class="noop">        the inner product of the different rows of both matrices:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.calc_qma_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qma
</span><span class="noop">        qma(1.0, 2.2, 4.7)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    log = self.sequences.logs.fastaccess
</span><span class="hit">    for idx in range(der.nmb):
</span><span class="hit">        flu.qma[idx] = 0.
</span><span class="hit">        for jdx in range(der.ma_order[idx]):
</span><span class="hit">            flu.qma[idx] += der.ma_coefs[idx, jdx] * log.login[idx, jdx]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qar_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the discharge responses of the different AR processes.
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.Nmb`
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.AR_Order`
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.AR_Coeffs`
</span><span class="noop">
</span><span class="noop">    Required log sequence:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_log.LogOut`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_fluxes.QAR`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Assume there are four response functions, involving zero, one, two,
</span><span class="noop">        and three AR coefficients respectively:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.nmb(4)
</span><span class="noop">        &gt;&gt;&gt; derived.ar_order.shape = 4
</span><span class="noop">        &gt;&gt;&gt; derived.ar_order = 0, 1, 2, 3
</span><span class="noop">        &gt;&gt;&gt; derived.ar_coefs.shape = (4, 3)
</span><span class="noop">        &gt;&gt;&gt; logs.logout.shape = (4, 3)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qar.shape = 4
</span><span class="noop">
</span><span class="noop">        The coefficients of the different AR processes are stored in
</span><span class="noop">        seperate rows of the 2-dimensional parameter `ma_coefs`.
</span><span class="noop">        Note the special case of the first AR process of zero order
</span><span class="noop">        (first row), which involves no autoregressive memory at all:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.ar_coefs = ((nan, nan, nan),
</span><span class="noop">        ...                     (1.0, nan, nan),
</span><span class="noop">        ...                     (0.8, 0.2, nan),
</span><span class="noop">        ...                     (0.5, 0.3, 0.2))
</span><span class="noop">
</span><span class="noop">        The &#34;memory values&#34; of the different AR processes are defined as
</span><span class="noop">        follows (one row for each process).  The values of the last time
</span><span class="noop">        step are stored in first column, the values of the last time step
</span><span class="noop">        in the second column, and so on:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; logs.logout = ((nan, nan, nan),
</span><span class="noop">        ...                (1.0, nan, nan),
</span><span class="noop">        ...                (2.0, 3.0, nan),
</span><span class="noop">        ...                (4.0, 5.0, 6.0))
</span><span class="noop">
</span><span class="noop">        Applying method :func:`calc_qar_v1` is equivalent to calculating
</span><span class="noop">        the inner product of the different rows of both matrices:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.calc_qar_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qar
</span><span class="noop">        qar(0.0, 1.0, 2.2, 4.7)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    log = self.sequences.logs.fastaccess
</span><span class="hit">    for idx in range(der.nmb):
</span><span class="hit">        flu.qar[idx] = 0.
</span><span class="hit">        for jdx in range(der.ar_order[idx]):
</span><span class="hit">            flu.qar[idx] += der.ar_coefs[idx, jdx] * log.logout[idx, jdx]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qpout_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the ARMA results for the different response functions.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.Nmb`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_fluxes.QMA`
</span><span class="noop">      :class:`~hydpy.models.arma.arma_fluxes.QAR`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_fluxes.QPOut`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Initialize an arma model with three different response functions:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.nmb(3)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qma.shape = 3
</span><span class="noop">        &gt;&gt;&gt; fluxes.qar.shape = 3
</span><span class="noop">        &gt;&gt;&gt; fluxes.qpout.shape = 3
</span><span class="noop">
</span><span class="noop">        Define the output values of the MA and of the AR processes
</span><span class="noop">        associated with the three response functions and apply
</span><span class="noop">        method :func:`calc_qpout_v1`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.qar = 4.0, 5.0, 6.0
</span><span class="noop">        &gt;&gt;&gt; fluxes.qma = 1.0, 2.0, 3.0
</span><span class="noop">        &gt;&gt;&gt; model.calc_qpout_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qpout
</span><span class="noop">        qpout(5.0, 7.0, 9.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for idx in range(der.nmb):
</span><span class="hit">        flu.qpout[idx] = flu.qma[idx]+flu.qar[idx]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_logout_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Refresh the log sequence for the different AR processes.
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.Nmb`
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.AR_Order`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_fluxes.QPOut`
</span><span class="noop">
</span><span class="noop">    Updated log sequence:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_log.LogOut`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        Assume there are four response functions, involving zero, one, two
</span><span class="noop">        and three AR coefficients respectively:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.nmb(4)
</span><span class="noop">        &gt;&gt;&gt; derived.ar_order.shape = 4
</span><span class="noop">        &gt;&gt;&gt; derived.ar_order = 0, 1, 2, 3
</span><span class="noop">        &gt;&gt;&gt; fluxes.qpout.shape = 4
</span><span class="noop">        &gt;&gt;&gt; logs.logout.shape = (4, 3)
</span><span class="noop">
</span><span class="noop">        The &#34;memory values&#34; of the different AR processes are defined as
</span><span class="noop">        follows (one row for each process).  Note the special case of the
</span><span class="noop">        first AR process of zero order (first row), which is why there are
</span><span class="noop">        no autoregressive memory values required:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; logs.logout = ((nan, nan, nan),
</span><span class="noop">        ...                (0.0, nan, nan),
</span><span class="noop">        ...                (1.0, 2.0, nan),
</span><span class="noop">        ...                (3.0, 4.0, 5.0))
</span><span class="noop">
</span><span class="noop">        These are the new outflow discharge portions to be included into
</span><span class="noop">        the memories of the different processes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.qpout = 6.0, 7.0, 8.0, 9.0
</span><span class="noop">
</span><span class="noop">        Through applying method :func:`calc_logout_v1` all values already
</span><span class="noop">        existing are shifted to the right (&#34;into the past&#34;).  Values, which
</span><span class="noop">        are no longer required due to the limited order or the different
</span><span class="noop">        AR processes, are discarded.  The new values are inserted in the
</span><span class="noop">        first column:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.calc_logout_v1()
</span><span class="noop">        &gt;&gt;&gt; logs.logout
</span><span class="noop">        logout(nan, nan, nan,
</span><span class="noop">               7.0, nan, nan,
</span><span class="noop">               8.0, 1.0, nan,
</span><span class="noop">               9.0, 3.0, 4.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    log = self.sequences.logs.fastaccess
</span><span class="hit">    for idx in range(der.nmb):
</span><span class="hit">        for jdx in range(der.ar_order[idx]-2, -1, -1):
</span><span class="hit">            log.logout[idx, jdx+1] = log.logout[idx, jdx]
</span><span class="hit">    for idx in range(der.nmb):
</span><span class="hit">        if der.ar_order[idx] &gt; 0:
</span><span class="hit">            log.logout[idx, 0] = flu.qpout[idx]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qout_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Sum up the results of the different response functions.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_derived.Nmb`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_fluxes.QPOut`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.arma.arma_fluxes.QOut`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Initialize an arma model with three different response functions:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.arma import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.nmb(3)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qpout.shape = 3
</span><span class="noop">
</span><span class="noop">        Define the output values of the three response functions and
</span><span class="noop">        apply method :func:`calc_qout_v1`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.qpout = 1.0, 2.0, 3.0
</span><span class="noop">        &gt;&gt;&gt; model.calc_qout_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qout
</span><span class="noop">        qout(6.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.qout = 0.
</span><span class="hit">    for idx in range(der.nmb):
</span><span class="hit">        flu.qout += flu.qpout[idx]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pick_q_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update inflow.&#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    inl = self.sequences.inlets.fastaccess
</span><span class="hit">    flu.qin = 0.
</span><span class="hit">    for idx in range(inl.len_q):
</span><span class="hit">        flu.qin += inl.q[idx][0]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pass_q_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update outflow.&#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    out = self.sequences.outlets.fastaccess
</span><span class="hit">    out.q[0] += flu.qout
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;Base model ARMA.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _INLET_METHODS = (pick_q_v1,)
</span><span class="hit">    _RUN_METHODS = (calc_qpin_v1,
</span><span class="noop">                    calc_login_v1,
</span><span class="noop">                    calc_qma_v1,
</span><span class="noop">                    calc_qar_v1,
</span><span class="noop">                    calc_qpout_v1,
</span><span class="noop">                    calc_logout_v1,
</span><span class="noop">                    calc_qout_v1)
</span><span class="hit">    _OUTLET_METHODS = (pass_q_v1,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/arma/arma_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss (runoff) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of the ARMA model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">ToDo
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from dam
</span><span class="hit">from hydpy.models.dam.dam_control import ControlParameters
</span><span class="hit">from hydpy.models.dam.dam_derived import DerivedParameters
</span><span class="hit">from hydpy.models.dam.dam_solver import SolverParameters
</span><span class="hit">from hydpy.models.dam.dam_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.dam.dam_states import StateSequences
</span><span class="hit">from hydpy.models.dam.dam_logs import LogSequences
</span><span class="hit">from hydpy.models.dam.dam_receivers import ReceiverSequences
</span><span class="hit">from hydpy.models.dam.dam_inlets import InletSequences
</span><span class="hit">from hydpy.models.dam.dam_outlets import OutletSequences
</span><span class="hit">from hydpy.models.dam.dam_aides import AideSequences
</span><span class="hit">from hydpy.models.dam.dam_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_aides.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_aides.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WaterLevel(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Water level [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, True, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of the dam model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (WaterLevel,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.auxs import anntools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class CatchmentArea(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Size of the catchment draining into the dam [km2].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NmbLogEntries(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of log entries for certain variables [m3/s].
</span><span class="noop">
</span><span class="noop">    Note that setting a new value by calling the parameter object sets
</span><span class="noop">    the shapes of all associated log sequences automatically:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep()
</span><span class="noop">    &gt;&gt;&gt; nmblogentries(3)
</span><span class="noop">    &gt;&gt;&gt; for (name, seq) in logs:
</span><span class="noop">    ...     print(seq)
</span><span class="noop">    loggedtotalremotedischarge(nan, nan, nan)
</span><span class="noop">    loggedoutflow(nan, nan, nan)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (1, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        super(NmbLogEntries, self).__call__(*args, **kwargs)
</span><span class="hit">        for (name, seq) in self.subpars.pars.model.sequences.logs:
</span><span class="hit">            seq.shape = self
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RemoteDischargeMinimum(parametertools.SeasonalParameter):
</span><span class="noop">    &#34;&#34;&#34;Discharge threshold of a cross section far downstream that
</span><span class="noop">    should not be undercut by the actual discharge [m3/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        self.shape = (None, )
</span><span class="hit">        super(RemoteDischargeMinimum, self).__call__(*args, **kwargs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RemoteDischargeSavety(parametertools.SeasonalParameter):
</span><span class="noop">    &#34;&#34;&#34;Safety factor to reduce the risk to release not enough water [m3/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        self.shape = (None, )
</span><span class="hit">        super(RemoteDischargeSavety, self).__call__(*args, **kwargs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NearDischargeMinimumThreshold(parametertools.SeasonalParameter):
</span><span class="noop">    &#34;&#34;&#34;Discharge threshold of a cross section in the near of the dam that
</span><span class="noop">    not be undercut by the actual discharge [m3/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        self.shape = (None, )
</span><span class="hit">        super(NearDischargeMinimumThreshold, self).__call__(*args, **kwargs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NearDischargeMinimumTolerance(parametertools.SeasonalParameter):
</span><span class="noop">    &#34;&#34;&#34;A tolerance value for the &#34;near discharge minimum&#34; [m3/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        self.shape = (None, )
</span><span class="hit">        super(NearDischargeMinimumTolerance, self).__call__(*args, **kwargs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WaterLevelMinimumThreshold(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;The minimum operating water level of the dam [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WaterLevelMinimumTolerance(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;A tolarance value for the minimum operating water level [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WaterVolume2WaterLevel(anntools.ANN):
</span><span class="noop">    &#34;&#34;&#34;Artificial neural network describing the relationship between
</span><span class="noop">    water level and water volume [-].&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WaterLevel2FloodDischarge(anntools.ANN):
</span><span class="noop">    &#34;&#34;&#34;Artificial neural network describing the relationship between
</span><span class="noop">    flood discharge and water volume [-].&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of the dam model, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (CatchmentArea,
</span><span class="noop">                   NmbLogEntries,
</span><span class="noop">                   RemoteDischargeMinimum,
</span><span class="noop">                   RemoteDischargeSavety,
</span><span class="noop">                   NearDischargeMinimumThreshold,
</span><span class="noop">                   NearDischargeMinimumTolerance,
</span><span class="noop">                   WaterLevelMinimumThreshold,
</span><span class="noop">                   WaterLevelMinimumTolerance,
</span><span class="noop">                   WaterVolume2WaterLevel,
</span><span class="noop">                   WaterLevel2FloodDischarge)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.auxs import smoothtools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TOY(parametertools.IndexParameter):
</span><span class="noop">    &#34;&#34;&#34;References the &#34;global&#34; time of the year index array [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, int, None, (0, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        self.setreference(pub.indexer.timeofyear)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Seconds(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Length of the actual simulation step size in seconds [s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        self.value = self.simulationstep.seconds
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RemoteDischargeSmoothPar(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Smoothing parameter to be derived from
</span><span class="noop">    :class:`~hydpy.models.dam.dam_control.RemoteDischargeSavety` [m3/s].
</span><span class="noop">
</span><span class="noop">    The following example is explained in some detail in module
</span><span class="noop">    :mod:`~hydpy.auxs.smoothtools`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">    &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2000.01.01&#39;,
</span><span class="noop">    ...                                    &#39;2000.01.03&#39;,
</span><span class="noop">    ...                                    &#39;1d&#39;))
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep()
</span><span class="noop">    &gt;&gt;&gt; remotedischargesavety(0.0)
</span><span class="noop">    &gt;&gt;&gt; remotedischargesavety.values[1] = 2.5
</span><span class="noop">    &gt;&gt;&gt; derived.remotedischargesmoothpar.update()
</span><span class="noop">    &gt;&gt;&gt; from hydpy.cythons.smoothutils import smooth_logistic1
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; round_(smooth_logistic1(0.1, derived.remotedischargesmoothpar[0]))
</span><span class="noop">    1.0
</span><span class="noop">    &gt;&gt;&gt; round_(smooth_logistic1(2.5, derived.remotedischargesmoothpar[1]))
</span><span class="noop">    0.99
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        metapars = self.subpars.pars.control.remotedischargesavety
</span><span class="hit">        self.shape = metapars.shape
</span><span class="hit">        for idx, metapar in enumerate(metapars.values):
</span><span class="hit">            self.values[idx] = smoothtools.calc_smoothpar_logistic1(metapar)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NearDischargeMinimumSmoothPar1(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Smoothing parameter to be derived from
</span><span class="noop">    :class:`~hydpy.models.dam.dam_control.NearDischargeMinimumThreshold`
</span><span class="noop">    for smoothing kernel :func:`~hydpy.cythons.smoothutils.smooth_logistic1`
</span><span class="noop">    [m3/s].
</span><span class="noop">
</span><span class="noop">    The following example is explained in some detail in module
</span><span class="noop">    :mod:`~hydpy.auxs.smoothtools`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">    &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2000.01.01&#39;,
</span><span class="noop">    ...                                    &#39;2000.01.03&#39;,
</span><span class="noop">    ...                                    &#39;1d&#39;))
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep()
</span><span class="noop">    &gt;&gt;&gt; neardischargeminimumtolerance(0.0)
</span><span class="noop">    &gt;&gt;&gt; neardischargeminimumtolerance.values[1] = 2.5
</span><span class="noop">    &gt;&gt;&gt; derived.neardischargeminimumsmoothpar1.update()
</span><span class="noop">    &gt;&gt;&gt; from hydpy.cythons.smoothutils import smooth_logistic1
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; round_(smooth_logistic1(1.0, derived.neardischargeminimumsmoothpar1[0]))
</span><span class="noop">    1.0
</span><span class="noop">    &gt;&gt;&gt; round_(smooth_logistic1(2.5, derived.neardischargeminimumsmoothpar1[1]))
</span><span class="noop">    0.99
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        metapars = self.subpars.pars.control.neardischargeminimumtolerance
</span><span class="hit">        self.shape = metapars.shape
</span><span class="hit">        for idx, metapar in enumerate(metapars.values):
</span><span class="hit">            self.values[idx] = smoothtools.calc_smoothpar_logistic1(metapar)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NearDischargeMinimumSmoothPar2(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Smoothing parameter to be derived from
</span><span class="noop">    :class:`~hydpy.models.dam.dam_control.NearDischargeMinimumThreshold`
</span><span class="noop">    for smoothing kernel :func:`~hydpy.cythons.smoothutils.smooth_logistic2`
</span><span class="noop">    [m3/s].
</span><span class="noop">
</span><span class="noop">    The following example is explained in some detail in module
</span><span class="noop">    :mod:`~hydpy.auxs.smoothtools`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">    &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2000.01.01&#39;,
</span><span class="noop">    ...                                    &#39;2000.01.03&#39;,
</span><span class="noop">    ...                                    &#39;1d&#39;))
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep()
</span><span class="noop">    &gt;&gt;&gt; neardischargeminimumtolerance(0.0)
</span><span class="noop">    &gt;&gt;&gt; neardischargeminimumtolerance.values[1] = 2.5
</span><span class="noop">    &gt;&gt;&gt; derived.neardischargeminimumsmoothpar2.update()
</span><span class="noop">    &gt;&gt;&gt; from hydpy.cythons.smoothutils import smooth_logistic2
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; round_(smooth_logistic2(0.0, derived.neardischargeminimumsmoothpar2[0]))
</span><span class="noop">    0.0
</span><span class="noop">    &gt;&gt;&gt; round_(smooth_logistic2(2.5, derived.neardischargeminimumsmoothpar2[1]))
</span><span class="noop">    2.51
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        metapars = self.subpars.pars.control.neardischargeminimumtolerance
</span><span class="hit">        self.shape = metapars.shape
</span><span class="hit">        for idx, metapar in enumerate(metapars.values):
</span><span class="hit">            self.values[idx] = smoothtools.calc_smoothpar_logistic2(metapar)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WaterLevelMinimumSmoothPar(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Smoothing parameter to be derived from
</span><span class="noop">    :class:`~hydpy.models.dam.dam_control.WaterLevelMinimumTolerance` [m].
</span><span class="noop">
</span><span class="noop">    The following example is explained in some detail in module
</span><span class="noop">    :mod:`~hydpy.auxs.smoothtools`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep()
</span><span class="noop">    &gt;&gt;&gt; waterlevelminimumtolerance(0.0)
</span><span class="noop">    &gt;&gt;&gt; derived.waterlevelminimumsmoothpar.update()
</span><span class="noop">    &gt;&gt;&gt; from hydpy.cythons.smoothutils import smooth_logistic1
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">    &gt;&gt;&gt; round_(smooth_logistic1(0.1, derived.waterlevelminimumsmoothpar))
</span><span class="noop">    1.0
</span><span class="noop">    &gt;&gt;&gt; waterlevelminimumtolerance(2.5)
</span><span class="noop">    &gt;&gt;&gt; derived.waterlevelminimumsmoothpar.update()
</span><span class="noop">    &gt;&gt;&gt; round_(smooth_logistic1(2.5, derived.waterlevelminimumsmoothpar))
</span><span class="noop">    0.99
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        metapar = self.subpars.pars.control.waterlevelminimumtolerance
</span><span class="hit">        self.value = smoothtools.calc_smoothpar_logistic1(metapar)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of the dam model.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (TOY,
</span><span class="noop">                   Seconds,
</span><span class="noop">                   RemoteDischargeSmoothPar,
</span><span class="noop">                   NearDischargeMinimumSmoothPar1,
</span><span class="noop">                   NearDischargeMinimumSmoothPar2,
</span><span class="noop">                   WaterLevelMinimumSmoothPar)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Inflow(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Total inflow [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, True
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FloodDischarge(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Water release associated with flood events [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, True
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TotalRemoteDischarge(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Total discharge at a cross section far downstream [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NaturalRemoteDischarge(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Natural discharge at a cross section far downstream [m³/s].
</span><span class="noop">
</span><span class="noop">    `Natural` means: without the water released by the dam.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RemoteDemand(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Discharge demand at a cross section far downstream [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RemoteFailure(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Difference between the the actual and the required discharge at
</span><span class="noop">    a cross section far downstream [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RequiredRemoteRelease(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Water release considered appropriate to reduce drought events
</span><span class="noop">    at cross sections far downstream to the desired degree [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RequiredRelease(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Required water release for reducing drought events downstream [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TargetedRelease(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;The targeted water release for reducing drought events downstream
</span><span class="noop">    after taking both the required release and additional low flow
</span><span class="noop">    regulations into account [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ActualRelease(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual water release thought for reducing with drought events
</span><span class="noop">    downstream [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, True
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Outflow(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Total outflow [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, True
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of the dam model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Inflow,
</span><span class="noop">                   TotalRemoteDischarge,
</span><span class="noop">                   NaturalRemoteDischarge,
</span><span class="noop">                   RemoteDemand,
</span><span class="noop">                   RemoteFailure,
</span><span class="noop">                   RequiredRemoteRelease,
</span><span class="noop">                   RequiredRelease,
</span><span class="noop">                   TargetedRelease,
</span><span class="noop">                   ActualRelease,
</span><span class="noop">                   FloodDischarge,
</span><span class="noop">                   Outflow)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_inlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_inlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Discharge [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of the dam model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_logs.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_logs.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LoggedTotalRemoteDischarge(sequencetools.LogSequence):
</span><span class="noop">    &#34;&#34;&#34;Discharge values received from cross sections far downstream [m3/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LoggedOutflow(sequencetools.LogSequence):
</span><span class="noop">    &#34;&#34;&#34;Discharge values received from cross sections far downstream [m3/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequences(sequencetools.LogSequences):
</span><span class="noop">    &#34;&#34;&#34;Log sequences of the dam model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (LoggedTotalRemoteDischarge,
</span><span class="noop">                   LoggedOutflow)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># imports...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.cythons import smoothutils
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pic_inflow_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the inlet link sequence.&#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    inl = self.sequences.inlets.fastaccess
</span><span class="hit">    flu.inflow = inl.q[0]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pic_totalremotedischarge_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the receiver link sequence.&#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    rec = self.sequences.receivers.fastaccess
</span><span class="hit">    flu.totalremotedischarge = rec.q[0]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_loggedtotalremotedischarge_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Log a new entry of discharge at a cross section far downstream.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.NmbLogEntries`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.TotalRemoteDischarge`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_logs.LoggedTotalRemoteDischarge`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        The following example shows that, with each new method call, the
</span><span class="noop">        three memorized values are successively moved to the right and the
</span><span class="noop">        respective new value is stored on the bare left position:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nmblogentries(3)
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.testtools import UnitTest
</span><span class="noop">        &gt;&gt;&gt; test = UnitTest(model, model.update_loggedtotalremotedischarge_v1,
</span><span class="noop">        ...                 last_example=4)
</span><span class="noop">        &gt;&gt;&gt; test.nexts.totalremotedischarge = [1., 3., 2., 4]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | totalremotedischarge |           loggedtotalremotedischarge |
</span><span class="noop">        ---------------------------------------------------------------------
</span><span class="noop">        |   1 |                  1.0 | 1.0  nan                         nan |
</span><span class="noop">        |   2 |                  3.0 | 3.0  1.0                         nan |
</span><span class="noop">        |   3 |                  2.0 | 2.0  3.0                         1.0 |
</span><span class="noop">        |   4 |                  4.0 | 4.0  2.0                         3.0 |
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    log = self.sequences.logs.fastaccess
</span><span class="hit">    for idx in range(con.nmblogentries-1, 0, -1):
</span><span class="hit">        log.loggedtotalremotedischarge[idx] = \
</span><span class="noop">                                log.loggedtotalremotedischarge[idx-1]
</span><span class="hit">    log.loggedtotalremotedischarge[0] = flu.totalremotedischarge
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_waterlevel_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Determine the water level based on an artificial neural network
</span><span class="noop">    describing the relationship between water level and water stage.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.WaterVolume2WaterLevel`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_states.WaterVolume`
</span><span class="noop">
</span><span class="noop">    Calculated aide sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_aides.WaterLevel`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        Prepare a dam model:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">
</span><span class="noop">        Prepare a very simple relationship based on one single neuron:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; watervolume2waterlevel(
</span><span class="noop">        ...         nmb_inputs=1, nmb_neurons=(1,), nmb_outputs=1,
</span><span class="noop">        ...         weights_input=0.5, weights_output=1.0,
</span><span class="noop">        ...         intercepts_hidden=0.0, intercepts_output=-0.5)
</span><span class="noop">
</span><span class="noop">        At least in the water volume range used in the following examples,
</span><span class="noop">        the shape of the relationship looks acceptable:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.testtools import UnitTest
</span><span class="noop">        &gt;&gt;&gt; test = UnitTest(model, model.calc_waterlevel_v1, last_example=10)
</span><span class="noop">        &gt;&gt;&gt; test.nexts.watervolume = range(10)
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | watervolume | waterlevel |
</span><span class="noop">        ----------------------------------
</span><span class="noop">        |   1 |         0.0 |        0.0 |
</span><span class="noop">        |   2 |         1.0 |   0.122459 |
</span><span class="noop">        |   3 |         2.0 |   0.231059 |
</span><span class="noop">        |   4 |         3.0 |   0.317574 |
</span><span class="noop">        |   5 |         4.0 |   0.380797 |
</span><span class="noop">        |   6 |         5.0 |   0.424142 |
</span><span class="noop">        |   7 |         6.0 |   0.452574 |
</span><span class="noop">        |   8 |         7.0 |   0.470688 |
</span><span class="noop">        |   9 |         8.0 |   0.482014 |
</span><span class="noop">        |  10 |         9.0 |   0.489013 |
</span><span class="noop">
</span><span class="noop">        For more realistic approximations of measured relationships between
</span><span class="noop">        water level and volume, larger neural networks are required.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    con.watervolume2waterlevel.inputs[0] = new.watervolume
</span><span class="hit">    con.watervolume2waterlevel.process_actual_input()
</span><span class="hit">    aid.waterlevel = con.watervolume2waterlevel.outputs[0]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_naturalremotedischarge_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Try to estimate the natural discharge of a cross section far downstream
</span><span class="noop">    based on the last few simulation steps.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.NmbLogEntries`
</span><span class="noop">
</span><span class="noop">    Required log sequences:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_logs.LoggedTotalRemoteDischarge`
</span><span class="noop">      :class:`~hydpy.models.dam.dam_logs.LoggedOutflow`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.NaturalRemoteDischarge`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`RemoteDemand =
</span><span class="noop">      max(\\frac{\\Sigma(LoggedTotalRemoteDischarge - LoggedOutflow)}
</span><span class="noop">      {NmbLogEntries}), 0)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Usually, the mean total remote flow should be larger than the mean
</span><span class="noop">        dam outflows.  Then the estimated natural remote discharge is simply
</span><span class="noop">        the difference of both mean values:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nmblogentries(3)
</span><span class="noop">        &gt;&gt;&gt; logs.loggedtotalremotedischarge(2.5, 2.0, 1.5)
</span><span class="noop">        &gt;&gt;&gt; logs.loggedoutflow(2.0, 1.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; model.calc_naturalremotedischarge_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.naturalremotedischarge
</span><span class="noop">        naturalremotedischarge(1.0)
</span><span class="noop">
</span><span class="noop">        Due to the wave travel times, the difference between remote discharge
</span><span class="noop">        and dam outflow mights sometimes be negative.  To avoid negative
</span><span class="noop">        estimates of natural discharge, it its value is set to zero in
</span><span class="noop">        such cases:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; logs.loggedoutflow(4.0, 3.0, 5.0)
</span><span class="noop">        &gt;&gt;&gt; model.calc_naturalremotedischarge_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.naturalremotedischarge
</span><span class="noop">        naturalremotedischarge(0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    log = self.sequences.logs.fastaccess
</span><span class="hit">    flu.naturalremotedischarge = 0.
</span><span class="hit">    for idx in range(con.nmblogentries):
</span><span class="hit">        flu.naturalremotedischarge += (
</span><span class="noop">                log.loggedtotalremotedischarge[idx] - log.loggedoutflow[idx])
</span><span class="hit">    if flu.naturalremotedischarge &gt; 0.:
</span><span class="hit">        flu.naturalremotedischarge /= con.nmblogentries
</span><span class="noop">    else:
</span><span class="hit">        flu.naturalremotedischarge = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_remotedemand_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Estimate the discharge demand of a cross section far downstream.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.RemoteDischargeMinimum`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.TOY`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.NaturalRemoteDischage`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.RemoteDemand`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`RemoteDemand =
</span><span class="noop">      max(RemoteDischargeMinimum - NaturalRemoteDischarge, 0`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Low water elevation is often restricted to specific month of the year.
</span><span class="noop">        Sometimes the pursued lowest discharge value varies over the year
</span><span class="noop">        to allow for a low flow variability that is in some agreement with
</span><span class="noop">        the natural flow regime.  The HydPy-Dam model supports such
</span><span class="noop">        variations.  Hence we define a short simulation time period first.
</span><span class="noop">        This enables us to show how the related parameters values can be
</span><span class="noop">        defined and how the calculation of the `remote` water demand
</span><span class="noop">        throughout the year actually works:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2001.03.30&#39;,
</span><span class="noop">        ...                                    &#39;2001.04.03&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">        Prepare the dam model:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">
</span><span class="noop">        Assume the required discharge at a gauge downstream beeing 2 m³/s
</span><span class="noop">        in the hydrological summer half-year (April to October).  In the
</span><span class="noop">        winter month (November to May), there is no such requirement:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; remotedischargeminimum(_11_1_12=0.0, _03_31_12=0.0,
</span><span class="noop">        ...                        _04_1_12=2.0, _10_31_12=2.0)
</span><span class="noop">        &gt;&gt;&gt; derived.toy.update()
</span><span class="noop">
</span><span class="noop">        Prepare a test function, that calculates the remote discharge demand
</span><span class="noop">        based on the parameter values defined above and for natural remote
</span><span class="noop">        discharge values ranging between 0 and 3 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.testtools import UnitTest
</span><span class="noop">        &gt;&gt;&gt; test = UnitTest(model, model.calc_remotedemand_v1, last_example=4,
</span><span class="noop">        ...                 parseqs=(fluxes.naturalremotedischarge,
</span><span class="noop">        ...                          fluxes.remotedemand))
</span><span class="noop">        &gt;&gt;&gt; test.nexts.naturalremotedischarge = range(4)
</span><span class="noop">
</span><span class="noop">        On April 1, the required discharge is 2 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.04.01&#39;]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | naturalremotedischarge | remotedemand |
</span><span class="noop">        -----------------------------------------------
</span><span class="noop">        |   1 |                    0.0 |          2.0 |
</span><span class="noop">        |   2 |                    1.0 |          1.0 |
</span><span class="noop">        |   3 |                    2.0 |          0.0 |
</span><span class="noop">        |   4 |                    3.0 |          0.0 |
</span><span class="noop">
</span><span class="noop">        On May 31, the required discharge is 0 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.03.31&#39;]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | naturalremotedischarge | remotedemand |
</span><span class="noop">        -----------------------------------------------
</span><span class="noop">        |   1 |                    0.0 |          0.0 |
</span><span class="noop">        |   2 |                    1.0 |          0.0 |
</span><span class="noop">        |   3 |                    2.0 |          0.0 |
</span><span class="noop">        |   4 |                    3.0 |          0.0 |
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.remotedemand = max(con.remotedischargeminimum[der.toy[self.idx_sim]] -
</span><span class="noop">                           flu.naturalremotedischarge, 0.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_remotefailure_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Estimate the shortfall of actual discharge under the required discharge
</span><span class="noop">    of a cross section far downstream.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.NmbLogEntries`
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.RemoteDischargeMinimum`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.TOY`
</span><span class="noop">
</span><span class="noop">    Required log sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_logs.LoggedTotalRemoteDischarge`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.RemoteFailure`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`RemoteFailure =
</span><span class="noop">      \\frac{\\Sigma(LoggedTotalRemoteDischarge)}{NmbLogEntries} -
</span><span class="noop">      RemoteDischargeMinimum`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        As explained in the documentation on method
</span><span class="noop">        :func:`calc_remotedemand_v1`, we have to define a
</span><span class="noop">        simulation period first:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2001.03.30&#39;,
</span><span class="noop">        ...                                    &#39;2001.04.03&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">        Now we prepare a dam model with log sequences memorizing three values:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nmblogentries(3)
</span><span class="noop">
</span><span class="noop">        Again, the required discharge is 2 m³/s in summer and 0 m³/s in winter:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; remotedischargeminimum(_11_1_12=0.0, _03_31_12=0.0,
</span><span class="noop">        ...                        _04_1_12=2.0, _10_31_12=2.0)
</span><span class="noop">        &gt;&gt;&gt; derived.toy.update()
</span><span class="noop">
</span><span class="noop">        Let it be supposed that the actual discharge at the remote
</span><span class="noop">        cross section droped from 2 m³/s to 0  m³/s over the last three days:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; logs.loggedtotalremotedischarge(0.0, 1.0, 2.0)
</span><span class="noop">
</span><span class="noop">        This means that for the April 1 there would have been an averaged
</span><span class="noop">        shortfall of 1 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.04.01&#39;]
</span><span class="noop">        &gt;&gt;&gt; model.calc_remotefailure_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.remotefailure
</span><span class="noop">        remotefailure(1.0)
</span><span class="noop">
</span><span class="noop">        Instead for May 31 there would have been an excess of 1 m³/s, which
</span><span class="noop">        is interpreted to be a &#34;negative failure&#34;:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.03.31&#39;]
</span><span class="noop">        &gt;&gt;&gt; model.calc_remotefailure_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.remotefailure
</span><span class="noop">        remotefailure(-1.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    log = self.sequences.logs.fastaccess
</span><span class="hit">    flu.remotefailure = 0
</span><span class="hit">    for idx in range(con.nmblogentries):
</span><span class="hit">        flu.remotefailure -= log.loggedtotalremotedischarge[idx]
</span><span class="hit">    flu.remotefailure /= con.nmblogentries
</span><span class="hit">    flu.remotefailure += con.remotedischargeminimum[der.toy[self.idx_sim]]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_requiredremoterelease_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Guess the required release necessary to not fall below the threshold
</span><span class="noop">    value at a cross section far downstream with a certain level of certainty.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_control.RemoteDischargeSafety`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.RemoteDischargeSmoothPar`
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.TOY`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.RemoteDemand`
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.RemoteFailure`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.RequiredRelease`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`RequiredRemoteRelease = RemoteDemand + RemoteDischargeSafety
</span><span class="noop">      \\cdot smooth\_logistic1(RemoteFailure, RemoteDischargeSmoothPar)`
</span><span class="noop">
</span><span class="noop">    Used auxiliary method:
</span><span class="noop">      :func:`~hydpy.cythons.smoothutils.smooth_logistic1`.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        As in the examples above, define a short simulation time period first:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2001.03.30&#39;,
</span><span class="noop">        ...                                    &#39;2001.04.03&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">        Prepare the dam model:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.toy.update()
</span><span class="noop">
</span><span class="noop">        Define a savety factor of 0.5 m³/s for the summer months and
</span><span class="noop">        no savety factor at all for the winter months:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; remotedischargesavety(_11_1_12=0.0, _03_31_12=0.0,
</span><span class="noop">        ...                       _04_1_12=1.0, _10_31_12=1.0)
</span><span class="noop">        &gt;&gt;&gt; derived.remotedischargesmoothpar.update()
</span><span class="noop">
</span><span class="noop">        Assume the actual demand at the cross section downsstream has actually
</span><span class="noop">        been estimated to be 2 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.remotedemand = 2.0
</span><span class="noop">
</span><span class="noop">        Prepare a test function, that calculates the required discharge
</span><span class="noop">        based on the parameter values defined above and for a &#34;remote
</span><span class="noop">        failure&#34; values ranging between -4 and 4 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.testtools import UnitTest
</span><span class="noop">        &gt;&gt;&gt; test = UnitTest(model, model.calc_requiredremoterelease_v1,
</span><span class="noop">        ...                 last_example=9,
</span><span class="noop">        ...                 parseqs=(fluxes.remotefailure,
</span><span class="noop">        ...                          fluxes.requiredremoterelease))
</span><span class="noop">        &gt;&gt;&gt; test.nexts.remotefailure = range(-4, 5)
</span><span class="noop">
</span><span class="noop">        On May 31, the savety factor is 0 m³/s.  Hence no discharge is
</span><span class="noop">        added to the estimated remote demand of 2 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.03.31&#39;]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | remotefailure | requiredremoterelease |
</span><span class="noop">        -----------------------------------------------
</span><span class="noop">        |   1 |          -4.0 |                   2.0 |
</span><span class="noop">        |   2 |          -3.0 |                   2.0 |
</span><span class="noop">        |   3 |          -2.0 |                   2.0 |
</span><span class="noop">        |   4 |          -1.0 |                   2.0 |
</span><span class="noop">        |   5 |           0.0 |                   2.0 |
</span><span class="noop">        |   6 |           1.0 |                   2.0 |
</span><span class="noop">        |   7 |           2.0 |                   2.0 |
</span><span class="noop">        |   8 |           3.0 |                   2.0 |
</span><span class="noop">        |   9 |           4.0 |                   2.0 |
</span><span class="noop">
</span><span class="noop">        On April 1, the savety factor is 1 m³/s.  If the remote failure was
</span><span class="noop">        exactly zero in the past, meaning the control of the dam was perfect,
</span><span class="noop">        only 0.5 m³/s are added to the estimated remote demand of 2 m³/s.
</span><span class="noop">        If the actual recharge did actually fall below the threshold value,
</span><span class="noop">        up to 1 m³/s is added. If the the actual discharge exceeded the
</span><span class="noop">        threshold value by 2 or 3 m³/s, virtually nothing is added:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.04.01&#39;]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | remotefailure | requiredremoterelease |
</span><span class="noop">        -----------------------------------------------
</span><span class="noop">        |   1 |          -4.0 |                   2.0 |
</span><span class="noop">        |   2 |          -3.0 |              2.000001 |
</span><span class="noop">        |   3 |          -2.0 |              2.000102 |
</span><span class="noop">        |   4 |          -1.0 |                  2.01 |
</span><span class="noop">        |   5 |           0.0 |                   2.5 |
</span><span class="noop">        |   6 |           1.0 |                  2.99 |
</span><span class="noop">        |   7 |           2.0 |              2.999898 |
</span><span class="noop">        |   8 |           3.0 |              2.999999 |
</span><span class="noop">        |   9 |           4.0 |                   3.0 |
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.requiredremoterelease = (
</span><span class="noop">            flu.remotedemand+con.remotedischargesavety[der.toy[self.idx_sim]] *
</span><span class="noop">            smoothutils.smooth_logistic1(
</span><span class="noop">                    flu.remotefailure,
</span><span class="noop">                    der.remotedischargesmoothpar[der.toy[self.idx_sim]]))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_requiredrelease_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the total water release required for reducing drought events.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_control.NearDischargeMinimumThreshold`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.NearDischargeMinimumSmoothPar2`
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.TOY`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.RequiredRemoteRelease`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.RequiredRelease`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`RequiredRelease = RequiredRemoteRelease
</span><span class="noop">      \\cdot smooth\_logistic2(
</span><span class="noop">      RequiredRemoteRelease-NearDischargeMinimumThreshold,
</span><span class="noop">      NearDischargeMinimumSmoothPar2)`
</span><span class="noop">
</span><span class="noop">    Used auxiliary method:
</span><span class="noop">      :func:`~hydpy.cythons.smoothutils.smooth_logistic2`.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        As in the examples above, define a short simulation time period first:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2001.03.30&#39;,
</span><span class="noop">        ...                                    &#39;2001.04.03&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">        Prepare the dam model:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.toy.update()
</span><span class="noop">
</span><span class="noop">        Define a minimum discharge value for a cross section immediately
</span><span class="noop">        downstream of 4 m³/s for the summer months and of 0 m³/s for the
</span><span class="noop">        winter months:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; neardischargeminimumthreshold(_11_1_12=0.0, _03_31_12=0.0,
</span><span class="noop">        ...                               _04_1_12=4.0, _10_31_12=4.0)
</span><span class="noop">
</span><span class="noop">        Also define related tolerance values that are 1 m³/s in summer and
</span><span class="noop">        0 m³/s in winter:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; neardischargeminimumtolerance(_11_1_12=0.0, _03_31_12=0.0,
</span><span class="noop">        ...                               _04_1_12=1.0, _10_31_12=1.0)
</span><span class="noop">        &gt;&gt;&gt; derived.neardischargeminimumsmoothpar2.update()
</span><span class="noop">
</span><span class="noop">        Prepare a test function, that calculates the required total discharge
</span><span class="noop">        based on the parameter values defined above and for a required value
</span><span class="noop">        for a cross section far downstream ranging from 0 m³/s to 8 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.testtools import UnitTest
</span><span class="noop">        &gt;&gt;&gt; test = UnitTest(model, model.calc_requiredrelease_v1,
</span><span class="noop">        ...                 last_example=9,
</span><span class="noop">        ...                 parseqs=(fluxes.requiredremoterelease,
</span><span class="noop">        ...                          fluxes.requiredrelease))
</span><span class="noop">        &gt;&gt;&gt; test.nexts.requiredremoterelease = range(9)
</span><span class="noop">
</span><span class="noop">        On May 31, both the threshold and the tolerance value are 0 m³/s.
</span><span class="noop">        Hence the required total and the required remote release are equal:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.03.31&#39;]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | requiredremoterelease | requiredrelease |
</span><span class="noop">        -------------------------------------------------
</span><span class="noop">        |   1 |                   0.0 |             0.0 |
</span><span class="noop">        |   2 |                   1.0 |             1.0 |
</span><span class="noop">        |   3 |                   2.0 |             2.0 |
</span><span class="noop">        |   4 |                   3.0 |             3.0 |
</span><span class="noop">        |   5 |                   4.0 |             4.0 |
</span><span class="noop">        |   6 |                   5.0 |             5.0 |
</span><span class="noop">        |   7 |                   6.0 |             6.0 |
</span><span class="noop">        |   8 |                   7.0 |             7.0 |
</span><span class="noop">        |   9 |                   8.0 |             8.0 |
</span><span class="noop">
</span><span class="noop">        On April 1, the threshold value is 4 m³/s and the tolerance value
</span><span class="noop">        is 1 m³/s.  For low values of the required remote release, the
</span><span class="noop">        required total release approximates the threshold value. For large
</span><span class="noop">        values, it approximates the required remote release itself.  Around
</span><span class="noop">        the threshold value, due to the tolerance value of 1 m³/s, the
</span><span class="noop">        required total release is a little larger than both the treshold
</span><span class="noop">        value and the required remote release value:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.04.01&#39;]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | requiredremoterelease | requiredrelease |
</span><span class="noop">        -------------------------------------------------
</span><span class="noop">        |   1 |                   0.0 |             4.0 |
</span><span class="noop">        |   2 |                   1.0 |        4.000012 |
</span><span class="noop">        |   3 |                   2.0 |        4.000349 |
</span><span class="noop">        |   4 |                   3.0 |            4.01 |
</span><span class="noop">        |   5 |                   4.0 |        4.205524 |
</span><span class="noop">        |   6 |                   5.0 |            5.01 |
</span><span class="noop">        |   7 |                   6.0 |        6.000349 |
</span><span class="noop">        |   8 |                   7.0 |        7.000012 |
</span><span class="noop">        |   9 |                   8.0 |             8.0 |
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.requiredrelease = con.neardischargeminimumthreshold[
</span><span class="noop">                                                    der.toy[self.idx_sim]]
</span><span class="hit">    flu.requiredrelease = (flu.requiredrelease +
</span><span class="noop">                           smoothutils.smooth_logistic2(
</span><span class="noop">                               flu.requiredremoterelease-flu.requiredrelease,
</span><span class="noop">                               der.neardischargeminimumsmoothpar2[
</span><span class="noop">                                                    der.toy[self.idx_sim]]))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_targetedrelease_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the targeted water release for reducing drought events,
</span><span class="noop">    taking into account both the required water release and the actual
</span><span class="noop">    inflow into the dam.
</span><span class="noop">
</span><span class="noop">    Some dams are supposed to maintain a certain degree of low flow
</span><span class="noop">    variability downstream.  Method
</span><span class="noop">    :func:`~hydpy.models.dam.dam_model.calc_targetedrelease_v1` simulates
</span><span class="noop">    this by (approximately) passing inflow as outflow whenever inflow
</span><span class="noop">    is below the value of the threshold parameter
</span><span class="noop">    :class:`~hydpy.models.dam.dam_control.NearDischargeMinimumThreshold`.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_control.NearDischargeMinimumThreshold`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.NearDischargeMinimumSmoothPar1`
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.TOY`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.RequiredRelease`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.TargetedRelease`
</span><span class="noop">
</span><span class="noop">    Used auxiliary method:
</span><span class="noop">      :func:`~hydpy.cythons.smoothutils.smooth_logistic1`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`TargetedRelease =
</span><span class="noop">      w \\cdot RequiredRelease + (1-w) \\cdot Inflow`
</span><span class="noop">
</span><span class="noop">      :math:`w = smooth\\_logistic1(
</span><span class="noop">      Inflow-NearDischargeMinimumThreshold, NearDischargeMinimumSmoothPar)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        As in the examples above, define a short simulation time period first:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2001.03.30&#39;,
</span><span class="noop">        ...                                    &#39;2001.04.03&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">        Prepare the dam model:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.toy.update()
</span><span class="noop">
</span><span class="noop">        Define a minimum discharge value for a cross section immediately
</span><span class="noop">        downstream of 6 m³/s for the summer months and of 4 m³/s for the
</span><span class="noop">        winter months:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; neardischargeminimumthreshold(_11_1_12=6.0, _03_31_12=6.0,
</span><span class="noop">        ...                               _04_1_12=4.0, _10_31_12=4.0)
</span><span class="noop">
</span><span class="noop">        Also define related tolerance values that are 1 m³/s in summer and
</span><span class="noop">        0 m³/s in winter:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; neardischargeminimumtolerance(_11_1_12=0.0, _03_31_12=0.0,
</span><span class="noop">        ...                               _04_1_12=2.0, _10_31_12=2.0)
</span><span class="noop">        &gt;&gt;&gt; derived.neardischargeminimumsmoothpar1.update()
</span><span class="noop">
</span><span class="noop">        Prepare a test function that calculates the targeted water release
</span><span class="noop">        based on the parameter values defined above and for inflows into
</span><span class="noop">        the dam ranging from 0 m³/s to 10 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.testtools import UnitTest
</span><span class="noop">        &gt;&gt;&gt; test = UnitTest(model, model.calc_targetedrelease_v1,
</span><span class="noop">        ...                 last_example=21,
</span><span class="noop">        ...                 parseqs=(fluxes.inflow,
</span><span class="noop">        ...                          fluxes.targetedrelease))
</span><span class="noop">        &gt;&gt;&gt; test.nexts.inflow = numpy.arange(0.0, 10.5, .5)
</span><span class="noop">
</span><span class="noop">        Firstly, assume the required release of water for reducing droughts
</span><span class="noop">        has already been determined to be 10 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.requiredrelease = 10.
</span><span class="noop">
</span><span class="noop">        On May 31, the tolerance value is 0 m³/s.  Hence the targeted
</span><span class="noop">        release jumps from the inflow value to the required release
</span><span class="noop">        when exceeding the threshold value of 6 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.03.31&#39;]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | inflow | targetedrelease |
</span><span class="noop">        ----------------------------------
</span><span class="noop">        |   1 |    0.0 |             0.0 |
</span><span class="noop">        |   2 |    0.5 |             0.5 |
</span><span class="noop">        |   3 |    1.0 |             1.0 |
</span><span class="noop">        |   4 |    1.5 |             1.5 |
</span><span class="noop">        |   5 |    2.0 |             2.0 |
</span><span class="noop">        |   6 |    2.5 |             2.5 |
</span><span class="noop">        |   7 |    3.0 |             3.0 |
</span><span class="noop">        |   8 |    3.5 |             3.5 |
</span><span class="noop">        |   9 |    4.0 |             4.0 |
</span><span class="noop">        |  10 |    4.5 |             4.5 |
</span><span class="noop">        |  11 |    5.0 |             5.0 |
</span><span class="noop">        |  12 |    5.5 |             5.5 |
</span><span class="noop">        |  13 |    6.0 |             8.0 |
</span><span class="noop">        |  14 |    6.5 |            10.0 |
</span><span class="noop">        |  15 |    7.0 |            10.0 |
</span><span class="noop">        |  16 |    7.5 |            10.0 |
</span><span class="noop">        |  17 |    8.0 |            10.0 |
</span><span class="noop">        |  18 |    8.5 |            10.0 |
</span><span class="noop">        |  19 |    9.0 |            10.0 |
</span><span class="noop">        |  20 |    9.5 |            10.0 |
</span><span class="noop">        |  21 |   10.0 |            10.0 |
</span><span class="noop">
</span><span class="noop">        On April 1, the threshold value is 4 m³/s and the tolerance value
</span><span class="noop">        is 2 m³/s.  Hence there is a smooth transition for inflows ranging
</span><span class="noop">        between 2 m³/s and 6 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.04.01&#39;]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | inflow | targetedrelease |
</span><span class="noop">        ----------------------------------
</span><span class="noop">        |   1 |    0.0 |         0.00102 |
</span><span class="noop">        |   2 |    0.5 |        0.503056 |
</span><span class="noop">        |   3 |    1.0 |        1.009127 |
</span><span class="noop">        |   4 |    1.5 |        1.527132 |
</span><span class="noop">        |   5 |    2.0 |            2.08 |
</span><span class="noop">        |   6 |    2.5 |        2.731586 |
</span><span class="noop">        |   7 |    3.0 |        3.639277 |
</span><span class="noop">        |   8 |    3.5 |        5.064628 |
</span><span class="noop">        |   9 |    4.0 |             7.0 |
</span><span class="noop">        |  10 |    4.5 |        8.676084 |
</span><span class="noop">        |  11 |    5.0 |        9.543374 |
</span><span class="noop">        |  12 |    5.5 |        9.861048 |
</span><span class="noop">        |  13 |    6.0 |            9.96 |
</span><span class="noop">        |  14 |    6.5 |        9.988828 |
</span><span class="noop">        |  15 |    7.0 |        9.996958 |
</span><span class="noop">        |  16 |    7.5 |        9.999196 |
</span><span class="noop">        |  17 |    8.0 |        9.999796 |
</span><span class="noop">        |  18 |    8.5 |        9.999951 |
</span><span class="noop">        |  19 |    9.0 |         9.99999 |
</span><span class="noop">        |  20 |    9.5 |        9.999998 |
</span><span class="noop">        |  21 |   10.0 |            10.0 |
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        An required release substantially below the threshold value is
</span><span class="noop">        a rather unlikely scenario, but is at least instructive regarding
</span><span class="noop">        the functioning of the method (when plotting the results
</span><span class="noop">        graphically...):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.requiredrelease = 2.
</span><span class="noop">
</span><span class="noop">        On May 31, the relationship between targeted release and inflow
</span><span class="noop">        is again highly discontinous:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.03.31&#39;]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | inflow | targetedrelease |
</span><span class="noop">        ----------------------------------
</span><span class="noop">        |   1 |    0.0 |             0.0 |
</span><span class="noop">        |   2 |    0.5 |             0.5 |
</span><span class="noop">        |   3 |    1.0 |             1.0 |
</span><span class="noop">        |   4 |    1.5 |             1.5 |
</span><span class="noop">        |   5 |    2.0 |             2.0 |
</span><span class="noop">        |   6 |    2.5 |             2.5 |
</span><span class="noop">        |   7 |    3.0 |             3.0 |
</span><span class="noop">        |   8 |    3.5 |             3.5 |
</span><span class="noop">        |   9 |    4.0 |             4.0 |
</span><span class="noop">        |  10 |    4.5 |             4.5 |
</span><span class="noop">        |  11 |    5.0 |             5.0 |
</span><span class="noop">        |  12 |    5.5 |             5.5 |
</span><span class="noop">        |  13 |    6.0 |             4.0 |
</span><span class="noop">        |  14 |    6.5 |             2.0 |
</span><span class="noop">        |  15 |    7.0 |             2.0 |
</span><span class="noop">        |  16 |    7.5 |             2.0 |
</span><span class="noop">        |  17 |    8.0 |             2.0 |
</span><span class="noop">        |  18 |    8.5 |             2.0 |
</span><span class="noop">        |  19 |    9.0 |             2.0 |
</span><span class="noop">        |  20 |    9.5 |             2.0 |
</span><span class="noop">        |  21 |   10.0 |             2.0 |
</span><span class="noop">
</span><span class="noop">        And on April 1, it is again absolutely smooth:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.04.01&#39;]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | inflow | targetedrelease |
</span><span class="noop">        ----------------------------------
</span><span class="noop">        |   1 |    0.0 |        0.000204 |
</span><span class="noop">        |   2 |    0.5 |        0.500483 |
</span><span class="noop">        |   3 |    1.0 |        1.001014 |
</span><span class="noop">        |   4 |    1.5 |        1.501596 |
</span><span class="noop">        |   5 |    2.0 |             2.0 |
</span><span class="noop">        |   6 |    2.5 |        2.484561 |
</span><span class="noop">        |   7 |    3.0 |        2.908675 |
</span><span class="noop">        |   8 |    3.5 |        3.138932 |
</span><span class="noop">        |   9 |    4.0 |             3.0 |
</span><span class="noop">        |  10 |    4.5 |         2.60178 |
</span><span class="noop">        |  11 |    5.0 |        2.273976 |
</span><span class="noop">        |  12 |    5.5 |        2.108074 |
</span><span class="noop">        |  13 |    6.0 |            2.04 |
</span><span class="noop">        |  14 |    6.5 |        2.014364 |
</span><span class="noop">        |  15 |    7.0 |        2.005071 |
</span><span class="noop">        |  16 |    7.5 |         2.00177 |
</span><span class="noop">        |  17 |    8.0 |        2.000612 |
</span><span class="noop">        |  18 |    8.5 |         2.00021 |
</span><span class="noop">        |  19 |    9.0 |        2.000072 |
</span><span class="noop">        |  20 |    9.5 |        2.000024 |
</span><span class="noop">        |  21 |   10.0 |        2.000008 |
</span><span class="noop">
</span><span class="noop">        For required releases equal with the threshold value, there is
</span><span class="noop">        generally no jump in the relationship.  But on May 31, there
</span><span class="noop">        remains a discontinuity in the first derivative:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.requiredrelease = 6.
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.03.31&#39;]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | inflow | targetedrelease |
</span><span class="noop">        ----------------------------------
</span><span class="noop">        |   1 |    0.0 |             0.0 |
</span><span class="noop">        |   2 |    0.5 |             0.5 |
</span><span class="noop">        |   3 |    1.0 |             1.0 |
</span><span class="noop">        |   4 |    1.5 |             1.5 |
</span><span class="noop">        |   5 |    2.0 |             2.0 |
</span><span class="noop">        |   6 |    2.5 |             2.5 |
</span><span class="noop">        |   7 |    3.0 |             3.0 |
</span><span class="noop">        |   8 |    3.5 |             3.5 |
</span><span class="noop">        |   9 |    4.0 |             4.0 |
</span><span class="noop">        |  10 |    4.5 |             4.5 |
</span><span class="noop">        |  11 |    5.0 |             5.0 |
</span><span class="noop">        |  12 |    5.5 |             5.5 |
</span><span class="noop">        |  13 |    6.0 |             6.0 |
</span><span class="noop">        |  14 |    6.5 |             6.0 |
</span><span class="noop">        |  15 |    7.0 |             6.0 |
</span><span class="noop">        |  16 |    7.5 |             6.0 |
</span><span class="noop">        |  17 |    8.0 |             6.0 |
</span><span class="noop">        |  18 |    8.5 |             6.0 |
</span><span class="noop">        |  19 |    9.0 |             6.0 |
</span><span class="noop">        |  20 |    9.5 |             6.0 |
</span><span class="noop">        |  21 |   10.0 |             6.0 |
</span><span class="noop">
</span><span class="noop">        On April 1, this second order discontinuity is smoothed with
</span><span class="noop">        the help of a little hump around the threshold:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.requiredrelease = 4.
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2001.04.01&#39;]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | inflow | targetedrelease |
</span><span class="noop">        ----------------------------------
</span><span class="noop">        |   1 |    0.0 |        0.000408 |
</span><span class="noop">        |   2 |    0.5 |        0.501126 |
</span><span class="noop">        |   3 |    1.0 |        1.003042 |
</span><span class="noop">        |   4 |    1.5 |         1.50798 |
</span><span class="noop">        |   5 |    2.0 |            2.02 |
</span><span class="noop">        |   6 |    2.5 |        2.546317 |
</span><span class="noop">        |   7 |    3.0 |        3.091325 |
</span><span class="noop">        |   8 |    3.5 |        3.620356 |
</span><span class="noop">        |   9 |    4.0 |             4.0 |
</span><span class="noop">        |  10 |    4.5 |        4.120356 |
</span><span class="noop">        |  11 |    5.0 |        4.091325 |
</span><span class="noop">        |  12 |    5.5 |        4.046317 |
</span><span class="noop">        |  13 |    6.0 |            4.02 |
</span><span class="noop">        |  14 |    6.5 |         4.00798 |
</span><span class="noop">        |  15 |    7.0 |        4.003042 |
</span><span class="noop">        |  16 |    7.5 |        4.001126 |
</span><span class="noop">        |  17 |    8.0 |        4.000408 |
</span><span class="noop">        |  18 |    8.5 |        4.000146 |
</span><span class="noop">        |  19 |    9.0 |        4.000051 |
</span><span class="noop">        |  20 |    9.5 |        4.000018 |
</span><span class="noop">        |  21 |   10.0 |        4.000006 |
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.targetedrelease = smoothutils.smooth_logistic1(
</span><span class="noop">            flu.inflow-con.neardischargeminimumthreshold[
</span><span class="noop">                                                der.toy[self.idx_sim]],
</span><span class="noop">            der.neardischargeminimumsmoothpar1[der.toy[self.idx_sim]])
</span><span class="hit">    flu.targetedrelease = (flu.targetedrelease * flu.requiredrelease +
</span><span class="noop">                           (1.-flu.targetedrelease) * flu.inflow)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_actualrelease_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual water release that can be supplied by the
</span><span class="noop">    dam considering the targeted release and the given water level.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_control.WaterLevelMinimumThreshold`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.WaterLevelMinimumSmoothPar`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.TargetedRelease`
</span><span class="noop">
</span><span class="noop">    Required aide sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_aides.WaterLevel`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.ActualRelease`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`ActualRelease = TargetedRelease \\cdot
</span><span class="noop">      smooth\_logistic1(WaterLevelMinimumThreshold-WaterLevel,
</span><span class="noop">      WaterLevelMinimumSmoothPar)`
</span><span class="noop">
</span><span class="noop">    Used auxiliary method:
</span><span class="noop">      :func:`~hydpy.cythons.smoothutils.smooth_logistic1`.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Prepare the dam model:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">
</span><span class="noop">        Assume the required release has previously been estimated
</span><span class="noop">        to be 2 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.targetedrelease = 2.0
</span><span class="noop">
</span><span class="noop">        Prepare a test function, that calculates the targeted water release
</span><span class="noop">        for water levels ranging between -1 and 5 m:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.testtools import UnitTest
</span><span class="noop">        &gt;&gt;&gt; test = UnitTest(model, model.calc_actualrelease_v1,
</span><span class="noop">        ...                 last_example=7,
</span><span class="noop">        ...                 parseqs=(aides.waterlevel,
</span><span class="noop">        ...                          fluxes.actualrelease))
</span><span class="noop">        &gt;&gt;&gt; test.nexts.waterlevel = range(-1, 6)
</span><span class="noop">
</span><span class="noop">        Firstly, we define a sharp minimum water level of 0 m:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; waterlevelminimumthreshold(0.)
</span><span class="noop">        &gt;&gt;&gt; waterlevelminimumtolerance(0.)
</span><span class="noop">        &gt;&gt;&gt; derived.waterlevelminimumsmoothpar.update()
</span><span class="noop">
</span><span class="noop">        The following test results show that the water releae is reduced
</span><span class="noop">        to 0 m³/s for water levels (even slightly) lower than 0 m and is
</span><span class="noop">        identical with the required value of 2 m³/s (even slighlty) above 0 m:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | waterlevel | actualrelease |
</span><span class="noop">        ------------------------------------
</span><span class="noop">        |   1 |       -1.0 |           0.0 |
</span><span class="noop">        |   2 |        0.0 |           1.0 |
</span><span class="noop">        |   3 |        1.0 |           2.0 |
</span><span class="noop">        |   4 |        2.0 |           2.0 |
</span><span class="noop">        |   5 |        3.0 |           2.0 |
</span><span class="noop">        |   6 |        4.0 |           2.0 |
</span><span class="noop">        |   7 |        5.0 |           2.0 |
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        One may have noted that in the above example the calculated water
</span><span class="noop">        release is 1 m³/s (which is exactly the half of the targeted release)
</span><span class="noop">        at a water level of 1 m.  This looks suspiciously lake a flaw but
</span><span class="noop">        is not of any importance considering the fact, that numerical
</span><span class="noop">        integration algorithms will approximate the analytical solution
</span><span class="noop">        of a complete emptying of a dam emtying (which is a water level
</span><span class="noop">        of 0 m), only with a certain accuracy.
</span><span class="noop">
</span><span class="noop">        Nonetheless, it can (besides some other possible advantages)
</span><span class="noop">        dramatically increase the speed of numerical integration algorithms
</span><span class="noop">        to define a smooth transition area instead of sharp threshold value,
</span><span class="noop">        like in the following example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; waterlevelminimumthreshold(4.)
</span><span class="noop">        &gt;&gt;&gt; waterlevelminimumtolerance(1.)
</span><span class="noop">        &gt;&gt;&gt; derived.waterlevelminimumsmoothpar.update()
</span><span class="noop">
</span><span class="noop">        Now, 98 % of the variation of the total range from 0 m³/s to 2 m³/s
</span><span class="noop">        occurs between a water level of 3 m and 5 m:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | waterlevel | actualrelease |
</span><span class="noop">        ------------------------------------
</span><span class="noop">        |   1 |       -1.0 |           0.0 |
</span><span class="noop">        |   2 |        0.0 |           0.0 |
</span><span class="noop">        |   3 |        1.0 |      0.000002 |
</span><span class="noop">        |   4 |        2.0 |      0.000204 |
</span><span class="noop">        |   5 |        3.0 |          0.02 |
</span><span class="noop">        |   6 |        4.0 |           1.0 |
</span><span class="noop">        |   7 |        5.0 |          1.98 |
</span><span class="noop">
</span><span class="noop">        Note that it is possible to set both parameters in a manner that
</span><span class="noop">        might result in negative water stages beyond numerical inaccuracy:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; waterlevelminimumthreshold(1.)
</span><span class="noop">        &gt;&gt;&gt; waterlevelminimumtolerance(2.)
</span><span class="noop">        &gt;&gt;&gt; derived.waterlevelminimumsmoothpar.update()
</span><span class="noop">
</span><span class="noop">        Here, the actual water release is 0.18 m³/s for a water level
</span><span class="noop">        of 0 m.  Hence water stages in the range of 0 m to -1 m or
</span><span class="noop">        even -2 m might occur during the simulation of long drought events:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | waterlevel | actualrelease |
</span><span class="noop">        ------------------------------------
</span><span class="noop">        |   1 |       -1.0 |          0.02 |
</span><span class="noop">        |   2 |        0.0 |       0.18265 |
</span><span class="noop">        |   3 |        1.0 |           1.0 |
</span><span class="noop">        |   4 |        2.0 |       1.81735 |
</span><span class="noop">        |   5 |        3.0 |          1.98 |
</span><span class="noop">        |   6 |        4.0 |      1.997972 |
</span><span class="noop">        |   7 |        5.0 |      1.999796 |
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    flu.actualrelease = (flu.targetedrelease *
</span><span class="noop">                         smoothutils.smooth_logistic1(
</span><span class="noop">                                 aid.waterlevel-con.waterlevelminimumthreshold,
</span><span class="noop">                                 der.waterlevelminimumsmoothpar))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_flooddischarge_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the discharge during and after a flood event based on an
</span><span class="noop">    artificial neural network describing the relationship between discharge
</span><span class="noop">    and water stage.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_control.WaterLevel2FloodDischarge`
</span><span class="noop">
</span><span class="noop">    Required aide sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_aides.WaterLevel`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.FloodDischarge`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        Prepare a dam model:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">
</span><span class="noop">        Prepare a relatively simple relationship based on two neuron
</span><span class="noop">        contained in a single hidden layer:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; waterlevel2flooddischarge(nmb_inputs=1,
</span><span class="noop">        ...                           nmb_neurons=(2,),
</span><span class="noop">        ...                           nmb_outputs=1,
</span><span class="noop">        ...                           weights_input=[[50., 4]],
</span><span class="noop">        ...                           weights_output=[[2.], [30]],
</span><span class="noop">        ...                           intercepts_hidden=[[-13000, -1046]],
</span><span class="noop">        ...                           intercepts_output=[0.])
</span><span class="noop">
</span><span class="noop">        The following example shows two distinct effects of both neurons.
</span><span class="noop">        One neuron describes a relatively sharp increase between 259.8
</span><span class="noop">        and 260.2 meters from about 0 to 2 m³/s.  This could describe
</span><span class="noop">        a release of water through a bottom outlet controlled by a valve.
</span><span class="noop">        The add something like an exponential increase between 260 and
</span><span class="noop">        261 meters, which could describe the uncontrolled flow over a
</span><span class="noop">        spillway:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.testtools import UnitTest
</span><span class="noop">        &gt;&gt;&gt; test = UnitTest(model, model.calc_flooddischarge_v1,
</span><span class="noop">        ...                 last_example=21)
</span><span class="noop">        &gt;&gt;&gt; test.nexts.waterlevel = numpy.arange(257, 261.1, 0.2)
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | flooddischarge | waterlevel |
</span><span class="noop">        -------------------------------------
</span><span class="noop">        |   1 |            0.0 |      257.0 |
</span><span class="noop">        |   2 |       0.000001 |      257.2 |
</span><span class="noop">        |   3 |       0.000002 |      257.4 |
</span><span class="noop">        |   4 |       0.000005 |      257.6 |
</span><span class="noop">        |   5 |       0.000011 |      257.8 |
</span><span class="noop">        |   6 |       0.000025 |      258.0 |
</span><span class="noop">        |   7 |       0.000056 |      258.2 |
</span><span class="noop">        |   8 |       0.000124 |      258.4 |
</span><span class="noop">        |   9 |       0.000275 |      258.6 |
</span><span class="noop">        |  10 |       0.000612 |      258.8 |
</span><span class="noop">        |  11 |       0.001362 |      259.0 |
</span><span class="noop">        |  12 |       0.003031 |      259.2 |
</span><span class="noop">        |  13 |       0.006745 |      259.4 |
</span><span class="noop">        |  14 |       0.015006 |      259.6 |
</span><span class="noop">        |  15 |       0.033467 |      259.8 |
</span><span class="noop">        |  16 |       1.074179 |      260.0 |
</span><span class="noop">        |  17 |       2.164498 |      260.2 |
</span><span class="noop">        |  18 |       2.363853 |      260.4 |
</span><span class="noop">        |  19 |        2.79791 |      260.6 |
</span><span class="noop">        |  20 |       3.719725 |      260.8 |
</span><span class="noop">        |  21 |       5.576088 |      261.0 |
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    con.waterlevel2flooddischarge.inputs[0] = aid.waterlevel
</span><span class="hit">    con.waterlevel2flooddischarge.process_actual_input()
</span><span class="hit">    flu.flooddischarge = con.waterlevel2flooddischarge.outputs[0]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_outflow_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the total outflow of the dam.
</span><span class="noop">
</span><span class="noop">    Note that the maximum function is used to prevent from negative outflow
</span><span class="noop">    values, which could otherwise occur within the required level of
</span><span class="noop">    numerical accuracy.
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.ActualRelease`
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.FloodDischarge`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.Outflow`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`Outflow = max(ActualRelease + FloodDischarge, 0.)`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; fluxes.actualrelease = 2.0
</span><span class="noop">        &gt;&gt;&gt; fluxes.flooddischarge = 3.0
</span><span class="noop">        &gt;&gt;&gt; model.calc_outflow_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outflow
</span><span class="noop">        outflow(5.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.flooddischarge = -3.0
</span><span class="noop">        &gt;&gt;&gt; model.calc_outflow_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outflow
</span><span class="noop">        outflow(0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.outflow = max(flu.actualrelease + flu.flooddischarge, 0.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_watervolume_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the actual water volume.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.Seconds`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.Inflow`
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.Outflow`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_states.WaterVolume`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`\\frac{d}{dt}WaterVolume = 1e-6 \\cdot (Inflow-Outflow)`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.seconds = 2e6
</span><span class="noop">        &gt;&gt;&gt; states.watervolume.old = 5.0
</span><span class="noop">        &gt;&gt;&gt; fluxes.inflow = 2.0
</span><span class="noop">        &gt;&gt;&gt; fluxes.outflow = 3.0
</span><span class="noop">        &gt;&gt;&gt; model.update_watervolume_v1()
</span><span class="noop">        &gt;&gt;&gt; states.watervolume
</span><span class="noop">        watervolume(3.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    new.watervolume = (old.watervolume +
</span><span class="noop">                       der.seconds*(flu.inflow-flu.outflow)/1e6)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pass_outflow_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the outlet link sequence.&#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    out = self.sequences.outlets.fastaccess
</span><span class="hit">    out.q[0] += flu.outflow
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_loggedoutflow_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Log a new entry of discharge at a cross section far downstream.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_derived.NmbLogEntries`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_fluxes.Outflow`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.dam.dam_logs.LoggedOutflow`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        The following example shows that, with each new method call, the
</span><span class="noop">        three memorized values are successively moved to the right and the
</span><span class="noop">        respective new value is stored on the bare left position:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.dam import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nmblogentries(3)
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.testtools import UnitTest
</span><span class="noop">        &gt;&gt;&gt; test = UnitTest(model, model.update_loggedoutflow_v1,
</span><span class="noop">        ...                 last_example=4)
</span><span class="noop">        &gt;&gt;&gt; test.nexts.outflow = [1., 3., 2., 4]
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        | ex. | outflow |           loggedoutflow |
</span><span class="noop">        -------------------------------------------
</span><span class="noop">        |   1 |     1.0 | 1.0  nan            nan |
</span><span class="noop">        |   2 |     3.0 | 3.0  1.0            nan |
</span><span class="noop">        |   3 |     2.0 | 2.0  3.0            1.0 |
</span><span class="noop">        |   4 |     4.0 | 4.0  2.0            3.0 |
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    log = self.sequences.logs.fastaccess
</span><span class="hit">    for idx in range(con.nmblogentries-1, 0, -1):
</span><span class="hit">        log.loggedoutflow[idx] = log.loggedoutflow[idx-1]
</span><span class="hit">    log.loggedoutflow[0] = flu.outflow
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.ModelELS):
</span><span class="noop">    &#34;&#34;&#34;Dam base model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _INLET_METHODS = (pic_inflow_v1,
</span><span class="noop">                      calc_naturalremotedischarge_v1,
</span><span class="noop">                      calc_remotedemand_v1,
</span><span class="noop">                      calc_remotefailure_v1,
</span><span class="noop">                      calc_requiredremoterelease_v1,
</span><span class="noop">                      calc_requiredrelease_v1,
</span><span class="noop">                      calc_targetedrelease_v1)
</span><span class="hit">    _RECEIVER_METHODS = (pic_totalremotedischarge_v1,
</span><span class="noop">                         update_loggedtotalremotedischarge_v1)
</span><span class="hit">    _PART_ODE_METHODS = (pic_inflow_v1,
</span><span class="noop">                         calc_waterlevel_v1,
</span><span class="noop">                         calc_actualrelease_v1,
</span><span class="noop">                         calc_flooddischarge_v1,
</span><span class="noop">                         calc_outflow_v1)
</span><span class="hit">    _FULL_ODE_METHODS = (update_watervolume_v1,)
</span><span class="hit">    _OUTLET_METHODS = (pass_outflow_v1,
</span><span class="noop">                       update_loggedoutflow_v1)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Discharge [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of the dam model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_receivers.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_receivers.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Discharge at a crosssection far downstream [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ReceiverSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Information link sequences of the dam model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_solver.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_solver.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AbsErrorMax(parametertools.SolverParameter):
</span><span class="noop">    &#34;&#34;&#34;Absolute numerical error tolerance [m3/s].
</span><span class="noop">
</span><span class="noop">    Note that the default initial value 0.01 refers to mm and the actual
</span><span class="noop">    simulation step size. Hence the actual default initial value in m³/s is:
</span><span class="noop">
</span><span class="noop">    :math:`AbsErrorMax = 0.01 \\cdot CatchmentArea \\cdot 1000 / Seconds`
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM = 0
</span><span class="hit">    TYPE = float
</span><span class="hit">    TIME = None
</span><span class="hit">    SPAN = (0., None)
</span><span class="hit">    INIT = 0.01
</span><span class="noop">
</span><span class="hit">    def modify_init(self):
</span><span class="hit">        pars = self.subpars.pars
</span><span class="hit">        catchmentarea = pars.control.catchmentarea
</span><span class="hit">        seconds = pars.derived.seconds
</span><span class="hit">        return self.INIT*catchmentarea*1000./seconds
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelDTMin(parametertools.SolverParameter):
</span><span class="noop">    &#34;&#34;&#34;Smallest relative integration time step size allowed [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM = 0
</span><span class="hit">    TYPE = float
</span><span class="hit">    TIME = None
</span><span class="hit">    SPAN = (0.0, 1.0)
</span><span class="hit">    INIT = 0.001
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SolverParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Solver parameters of the Test model.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (AbsErrorMax, RelDTMin)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/dam/dam_states.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WaterVolume(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Water volume [million m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, True, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of the dam model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (WaterVolume,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;The HydPy-H-Branch model allows for branching the input from a
</span><span class="noop">single inlet :class:`~hydpy.core.devicetools.Node` instance to
</span><span class="noop">an arbitrary number of outlet :class:`~hydpy.core.devicetools.Node`
</span><span class="noop">instances.  In the original  HBV96 implementation, it is supposed to
</span><span class="noop">seperate inflowing discharge, but in :ref:`HydPy` it can be used for
</span><span class="noop">arbitrary variables.  Calculations are performed for each branch
</span><span class="noop">individually by linear interpolation (or extrapolation) in accordance
</span><span class="noop">with tabulated supporting points.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from hbranch
</span><span class="hit">from hydpy.models.hbranch.hbranch_control import ControlParameters
</span><span class="hit">from hydpy.models.hbranch.hbranch_derived import DerivedParameters
</span><span class="hit">from hydpy.models.hbranch.hbranch_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.hbranch.hbranch_inlets import InletSequences
</span><span class="hit">from hydpy.models.hbranch.hbranch_outlets import OutletSequences
</span><span class="hit">from hydpy.models.hbranch.hbranch_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class XPoints(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Supporting points for the independent input variable [eg. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        self.shape = len(args)
</span><span class="hit">        if self.shape[0] &lt; 2:
</span><span class="miss">            raise ValueError(&#39;Branching via linear interpolation requires &#39;
</span><span class="noop">                             &#39;at least two supporting points, but for &#39;
</span><span class="noop">                             &#39;parameter `%s` only %d are given.&#39;
</span><span class="noop">                             % (self.name, self.shape[0]))
</span><span class="hit">        parametertools.MultiParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        if min(numpy.diff(self)) &lt;= 0.:
</span><span class="miss">            raise ValueError(&#39;The values of parameter `xpoints` must be &#39;
</span><span class="noop">                             &#39;arranged in a strictly monotnously manner, &#39;
</span><span class="noop">                             &#39;which is not the case for the given values &#39;
</span><span class="noop">                             &#39;`%s`.&#39; % &#39;, &#39;.join(str(value) for value in self))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class YPoints(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Supporting points for the dependent output variables [eg. m³/s].
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    The documentation on method
</span><span class="noop">    :func:`~hydpy.models.hbranch.Model.calc_outputs_v1` gives examples on how
</span><span class="noop">    to set the values of :class:`~hydpy.models.hbranch.YPoints` properly.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        try:
</span><span class="hit">            self.shape = (len(kwargs), self.subpars.xpoints.shape[0])
</span><span class="miss">        except RuntimeError:
</span><span class="miss">            raise RuntimeError(&#39;The shape of parameter `ypoints` depends on &#39;
</span><span class="noop">                               &#39;the shape of parameter `xpoints`.  Make sure &#39;
</span><span class="noop">                               &#39;parameter `xpoints` is defined first (and is &#39;
</span><span class="noop">                               &#39;integrated into the hmodel as described in &#39;
</span><span class="noop">                               &#39;the documentation).&#39;)
</span><span class="hit">        branched = self.subpars.pars.model.sequences.outlets.branched
</span><span class="hit">        try:
</span><span class="hit">            branched.shape = self.shape[0]
</span><span class="hit">        except RuntimeError:
</span><span class="hit">            if branched.shape[0] != self.shape[0]:
</span><span class="miss">                raise RuntimeError(&#39;The number of branches of the hbranch &#39;
</span><span class="noop">                                   &#39;model should not be changed during run &#39;
</span><span class="noop">                                   &#39;time.  If you really need to do this, &#39;
</span><span class="noop">                                   &#39;first initialize a new `branched` &#39;
</span><span class="noop">                                   &#39;sequence and connect it to the &#39;
</span><span class="noop">                                   &#39;respective outlet nodes properly.&#39;)
</span><span class="hit">        if self.shape[0] == 0:
</span><span class="miss">            raise ValueError(&#39;No branches are defined.  Do this via keyword &#39;
</span><span class="noop">                             &#39;arguments of the same name as the related &#39;
</span><span class="noop">                             &#39;outlet node instances.&#39;)
</span><span class="hit">        self.subpars.pars.model.sequences.fluxes.outputs.shape = self.shape[0]
</span><span class="hit">        for (idx, key) in enumerate(sorted(kwargs)):
</span><span class="hit">            value = kwargs[key]
</span><span class="hit">            if ((key not in devicetools.Node.registered_names()) and
</span><span class="noop">                    (pub.timegrids is not None)):
</span><span class="miss">                raise ValueError(&#39;Node `%s` does not exist so far.  Hence it &#39;
</span><span class="noop">                                 &#39;is not possible to branch to it.&#39; % key)
</span><span class="hit">            try:
</span><span class="hit">                self[idx] = value
</span><span class="miss">            except ValueError:
</span><span class="miss">                if self.shape[1] != len(value):
</span><span class="miss">                    raise ValueError(&#39;Each branch requires the same number of &#39;
</span><span class="noop">                                     &#39;supporting points as given for &#39;
</span><span class="noop">                                     &#39;parameter `xpoints`, which is %d.  But &#39;
</span><span class="noop">                                     &#39;for branch `%s` %d are given.&#39;
</span><span class="noop">                                     % (self.shape[1], key, len(value)))
</span><span class="noop">                else:
</span><span class="miss">                    message = &#39;The affected keyword argument is `%s`&#39; % key
</span><span class="miss">                    objecttools.augmentexcmessage(suffix=message)
</span><span class="hit">            setattr(self, key, self[idx])
</span><span class="hit">            self.subpars.pars.model.nodenames.append(key)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        lines = self.commentrepr()
</span><span class="miss">        nodenames = self.subpars.pars.model.nodenames
</span><span class="miss">        for (idx, values) in enumerate(self):
</span><span class="miss">            line = &#39;%s=%s,&#39; % (nodenames[idx], repr(list(values)))
</span><span class="miss">            if not idx:
</span><span class="miss">                lines.append(&#39;ypoints(&#39;+line)
</span><span class="noop">            else:
</span><span class="miss">                lines.append(&#39;        &#39;+line)
</span><span class="miss">        lines[-1] = lines[-1][:-1]+&#39;)&#39;
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of hbranch, directly defined by the user.
</span><span class="noop">
</span><span class="noop">    Note that the number of supporting points handled parameter
</span><span class="noop">    :class:`~hydpy.models.hbranch.XPoints` and
</span><span class="noop">    :class:`~hydpy.models.hbranch.YPoints` must be identical.  First
</span><span class="noop">    define the values of parameter :class:`~hydpy.models.hbranch.XPoints`,
</span><span class="noop">    then the values  of parameter :class:`~hydpy.models.hbranch.YPoints`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (XPoints, YPoints)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NmbBranches(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of branches [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (1, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.ypoints.shape[0])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NmbPoints(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of supporting points for linear interpolation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (2, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.ypoints.shape[1])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of hbranch, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (NmbBranches, NmbPoints)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Input(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Total input [e.g. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Outputs(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Branched outputs [e.g. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        nodenames = self.subseqs.seqs.model.nodenames
</span><span class="hit">        lines = []
</span><span class="hit">        for (idx, value) in enumerate(self.values):
</span><span class="hit">            line = &#39;%s=%s,&#39; % (nodenames[idx], repr(value))
</span><span class="hit">            if not idx:
</span><span class="hit">                lines.append(&#39;outputs(&#39;+line)
</span><span class="noop">            else:
</span><span class="hit">                lines.append(&#39;        &#39;+line)
</span><span class="hit">        lines[-1] = lines[-1][:-1]+&#39;)&#39;
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of the hbranch model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Input, Outputs)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_inlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_inlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Total(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Total input [e.g. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of the hbranch model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Total,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_outputs_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Performs the actual interpolation or extrapolation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hbranch.XPoints`
</span><span class="noop">      :class:`~hydpy.models.hbranch.YPoints`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.hbranch.hbranch_derived.NmbPoints`
</span><span class="noop">      :class:`~hydpy.models.hbranch.hbranch_derived.NmbBranches`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hbranch.hbranch_fluxes.Input`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hbranch.hbranch_fluxes.Outputs`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        As a simple example, assume a weir directing all discharge into
</span><span class="noop">        `branch1` until the capacity limit of 2 m³/s is reached.  The
</span><span class="noop">        discharge exceeding this threshold is directed into `branch2`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hbranch import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; xpoints(0., 2., 4.)
</span><span class="noop">        &gt;&gt;&gt; ypoints(branch1=[0., 2., 2.],
</span><span class="noop">        ...         branch2=[0., 0., 2.])
</span><span class="noop">        &gt;&gt;&gt; model.parameters.update()
</span><span class="noop">
</span><span class="noop">        Low discharge example (linear interpolation between the first two
</span><span class="noop">        supporting point pairs):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.input = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outputs_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outputs
</span><span class="noop">        outputs(branch1=1.0,
</span><span class="noop">                branch2=0.0)
</span><span class="noop">
</span><span class="noop">        Medium discharge example (linear interpolation between the second
</span><span class="noop">        two supporting point pairs):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.input = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outputs_v1()
</span><span class="noop">        &gt;&gt;&gt; print(fluxes.outputs)
</span><span class="noop">        outputs(branch1=2.0,
</span><span class="noop">                branch2=1.0)
</span><span class="noop">
</span><span class="noop">        High discharge example (linear extrapolation beyond the second two
</span><span class="noop">        supporting point pairs):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.input = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outputs_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outputs
</span><span class="noop">        outputs(branch1=2.0,
</span><span class="noop">                branch2=3.0)
</span><span class="noop">
</span><span class="noop">        Non-monotonous relationships and balance violations are allowed,
</span><span class="noop">        e.g.:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; xpoints(0., 2., 4., 6.)
</span><span class="noop">        &gt;&gt;&gt; ypoints(branch1=[0., 2., 0., 0.],
</span><span class="noop">        ...         branch2=[0., 0., 2., 4.])
</span><span class="noop">        &gt;&gt;&gt; model.parameters.update()
</span><span class="noop">        &gt;&gt;&gt; fluxes.input = 7.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outputs_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outputs
</span><span class="noop">        outputs(branch1=0.0,
</span><span class="noop">                branch2=5.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="noop">    # Search for the index of the two relevant x points...
</span><span class="hit">    for pdx in range(1, der.nmbpoints):
</span><span class="hit">        if con.xpoints[pdx] &gt; flu.input:
</span><span class="hit">            break
</span><span class="noop">    # ...and use it for linear interpolation (or extrapolation).
</span><span class="hit">    for bdx in range(der.nmbbranches):
</span><span class="hit">        flu.outputs[bdx] = (
</span><span class="noop">            (flu.input-con.xpoints[pdx-1]) *
</span><span class="noop">            (con.ypoints[bdx, pdx]-con.ypoints[bdx, pdx-1]) /
</span><span class="noop">            (con.xpoints[pdx]-con.xpoints[pdx-1]) +
</span><span class="noop">            con.ypoints[bdx, pdx-1])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pick_input_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Updates :class:`~hydpy.models.hbranch.Input` based on
</span><span class="noop">    :class:`~hydpy.models.hbranch.Total`.&#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    inl = self.sequences.inlets.fastaccess
</span><span class="hit">    flu.input = inl.total[0]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pass_outputs_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Updates :class:`~hydpy.models.hbranch.Branched` based on
</span><span class="noop">    :class:`~hydpy.models.hbranch.Outputs`.&#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    out = self.sequences.outlets.fastaccess
</span><span class="hit">    for bdx in range(der.nmbbranches):
</span><span class="hit">        out.branched[bdx][0] += flu.outputs[bdx]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;The HydPy-H-Branch model.
</span><span class="noop">
</span><span class="noop">    Additional attribute:
</span><span class="noop">      * nodenames (:class:`list`): Names of the outlet node names, the
</span><span class="noop">        actual model shall be connected to.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _INLET_METHODS = (pick_input_v1,)
</span><span class="hit">    _RUN_METHODS = (calc_outputs_v1,)
</span><span class="hit">    _OUTLET_METHODS = (pass_outputs_v1,)
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        modeltools.Model.__init__(self)
</span><span class="hit">        self.nodenames = []
</span><span class="noop">
</span><span class="hit">    def connect(self):
</span><span class="noop">        &#34;&#34;&#34;Connect the :class:`~hydpy.core.sequencetools.LinkSequence`
</span><span class="noop">        instances handled by the actual model to the
</span><span class="noop">        :class:`~hydpy.core.sequencetools.NodeSequence` instances
</span><span class="noop">        handled by one inlet node and multiple oulet nodes.
</span><span class="noop">
</span><span class="noop">        The HydPy-H-Branch model passes multiple output values to different
</span><span class="noop">        outlet nodes.  This requires additional information regarding the
</span><span class="noop">        `direction` of each output value.  Therefore, node names are used
</span><span class="noop">        as keywords.  Assume, the discharge value of `n1` shall be branched
</span><span class="noop">        to `n1a` and `n1b` via element `e1`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import *
</span><span class="noop">        &gt;&gt;&gt; n1, n1a, n1b = Node(&#39;n1&#39;), Node(&#39;n1a&#39;), Node(&#39;n1b&#39;)
</span><span class="noop">        &gt;&gt;&gt; e1 = Element(&#39;e1&#39;, inlets=n1, outlets=[n1a, n1b])
</span><span class="noop">
</span><span class="noop">        Then parameter :class:`YPoints` relates different supporting
</span><span class="noop">        points via its keyword arguments to the respective nodes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hbranch import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; xpoints(0., 3.)
</span><span class="noop">        &gt;&gt;&gt; ypoints(n1a=[0., 1.], n1b=[0., 2.])
</span><span class="noop">
</span><span class="noop">        After doing some preparations which are normally handled by
</span><span class="noop">        :ref:`HydPy` automatically ...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.element = e1
</span><span class="noop">        &gt;&gt;&gt; model.parameters.update()
</span><span class="noop">        &gt;&gt;&gt; model.connect()
</span><span class="noop">
</span><span class="noop">        ...you can see that an example discharge value handled by the
</span><span class="noop">        :class:`~hydpy.core.devicetools.Node` instance `n1` is properly
</span><span class="noop">        divided:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; n1.sequences.sim = 6.
</span><span class="noop">        &gt;&gt;&gt; model.doit(0)
</span><span class="noop">        &gt;&gt;&gt; print(n1a.sequences.sim, n1b.sequences.sim)
</span><span class="noop">        sim(2.0) sim(4.0)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        nodes = self.element.inlets.slaves
</span><span class="hit">        if len(nodes) == 1:
</span><span class="hit">            double = nodes[0].get_double_via_exits()
</span><span class="hit">            self.sequences.inlets.total.setpointer(double)
</span><span class="noop">        else:
</span><span class="miss">            RuntimeError(&#39;The hbranch model must be connected to exactly one &#39;
</span><span class="noop">                         &#39;inlet node, but its parent element `%s` references &#39;
</span><span class="noop">                         &#39;currently %d inlet nodes.&#39;
</span><span class="noop">                         % (self.element.name, len(nodes)))
</span><span class="hit">        for (idx, name) in enumerate(self.nodenames):
</span><span class="hit">            try:
</span><span class="hit">                outlet = getattr(self.element.outlets, name)
</span><span class="hit">                double = outlet.get_double_via_entries()
</span><span class="miss">            except KeyError:
</span><span class="miss">                if name in devicetools.Node.registered_names():
</span><span class="miss">                    RuntimeError(&#39;The hbranch model tried to connect to the &#39;
</span><span class="noop">                                 &#39;outlet node `%s`, but its parent element &#39;
</span><span class="noop">                                 &#39;`%s` does not reference this node as an &#39;
</span><span class="noop">                                 &#39;outlet node.&#39; % (name, self.element.name))
</span><span class="noop">                else:
</span><span class="miss">                    RuntimeError(&#39;The hbranch model tried to connect to an &#39;
</span><span class="noop">                                 &#39;outlet node named `%s`, which is not &#39;
</span><span class="noop">                                 &#39;initialized yet.&#39; % name)
</span><span class="hit">            self.sequences.outlets.branched.setpointer(double, idx)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hbranch/hbranch_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Branched(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Branched outputs [e.g. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of the hbranch model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Branched,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">The H-Land model is the core of the HydPy implementation of the
</span><span class="noop">the frequently applied HBV96 model.  It consists of some routines
</span><span class="noop">for the preparation of meteorological input, and some process
</span><span class="noop">routines related to interception, snow, soil moisture, upper
</span><span class="noop">groundwater, lower groundwater (including lakes), and runoff
</span><span class="noop">concentration.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from hland
</span><span class="hit">from hydpy.models.hland.hland_constants import FIELD, FOREST, GLACIER, ILAKE
</span><span class="hit">from hydpy.models.hland.hland_parameters import Parameters
</span><span class="hit">from hydpy.models.hland.hland_control import ControlParameters
</span><span class="hit">from hydpy.models.hland.hland_derived import DerivedParameters
</span><span class="hit">from hydpy.models.hland.hland_inputs import InputSequences
</span><span class="hit">from hydpy.models.hland.hland_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.hland.hland_states import StateSequences
</span><span class="hit">from hydpy.models.hland.hland_aides import AideSequences
</span><span class="hit">from hydpy.models.hland.hland_logs import LogSequences
</span><span class="hit">from hydpy.models.hland.hland_outlets import OutletSequences
</span><span class="hit">from hydpy.models.hland.hland_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_aides.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_aides.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Perc(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Percolation from the upper to the lower zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q0(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Outflow from the upper zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of the hland model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Perc, Q0)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_constants.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_constants.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;The HydPy-H-Land model (`hland`) allows for the subdivision of subbasins
</span><span class="noop">into zones (hydrological response units).  Some processes, e.g. interception,
</span><span class="noop">are calculated seperately for each zone.  This is why some parameters (e.g.
</span><span class="noop">the interception capacity :class:`~hydpy.models.hland.hland_control.IcMax`)
</span><span class="noop">and some sequences (e.g. the actual interception storage
</span><span class="noop">:class:`~hydpy.models.hland.hland_states.Ic`) are 1-dimensional.  Each entry
</span><span class="noop">represents the value of a different zone.
</span><span class="noop">
</span><span class="noop">In contrasts to the original HBV96 model, the HydPy-H-Land model allows for
</span><span class="noop">arbitrary definitions of zones.  Nevertheless, the original distinction
</span><span class="noop">in accordance with four different zone types is still supported.  The
</span><span class="noop">parameter :class:`~hydpy.models.hland.hland_control.ZoneType` defines,
</span><span class="noop">which entry of e.g. :class:`~hydpy.models.hland.hland_control.IcMax` is
</span><span class="noop">related to which zone type via integer values.  Note that for zones of
</span><span class="noop">type `field` and `forest`, the same equations are applied. (Usually,
</span><span class="noop">larger :class:`~hydpy.models.hland.hland_control.IcMax` values and smaller
</span><span class="noop">:class:`~hydpy.models.hland.hland_control.CFMax` are assigned to `forest`
</span><span class="noop">zones due to their higher leaf area index and the associated decrease in
</span><span class="noop">solar radiation.) On the contrary, zones of type `glacier` and `ilake` are
</span><span class="noop">partly connected to different process equations.
</span><span class="noop">
</span><span class="noop">For comprehensibility, this module introduces the relevant integer constants.
</span><span class="noop">Through performing a wildcard import
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">
</span><span class="noop">these are available in your local namespace:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; FIELD, FOREST, GLACIER, ILAKE
</span><span class="noop">(1, 2, 3, 4)
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">FIELD = 1
</span><span class="noop">&#34;&#34;&#34;Constant for the zone type `field`.&#34;&#34;&#34;
</span><span class="hit">FOREST = 2
</span><span class="noop">&#34;&#34;&#34;Constant for the zone type `forest.`&#34;&#34;&#34;
</span><span class="hit">GLACIER = 3
</span><span class="noop">&#34;&#34;&#34;Constant for the zone type `glacier`.&#34;&#34;&#34;
</span><span class="hit">ILAKE = 4
</span><span class="noop">&#34;&#34;&#34;Constant for the zone type `internal lake`.&#34;&#34;&#34;
</span><span class="hit">CONSTANTS = {key: value for key, value in locals().items()
</span><span class="noop">             if (key.isupper() and isinstance(value, int))}
</span><span class="hit">&#34;&#34;&#34;Dictionary containing all constants defined by HydPy-H-Land.&#34;&#34;&#34;
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.hland import hland_constants
</span><span class="hit">from hydpy.models.hland import hland_parameters
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Area(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Subbasin area [km²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (1e-10, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NmbZones(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of zones (hydrological response units) in a subbasin [-].
</span><span class="noop">
</span><span class="noop">    Note that :class:`NmbZones` determines the length of most 1-dimensional
</span><span class="noop">    HydPy-H-Land parameters and sequences.  This required that the value of
</span><span class="noop">    the respective :class:`NmbZones` instance is set before any of the values
</span><span class="noop">    of these 1-dimensional parameters or sequences are set.  Changing the
</span><span class="noop">    value of the :class:`NmbZones` instance necessitates setting their values
</span><span class="noop">    again.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">        &gt;&gt;&gt; icmax.shape
</span><span class="noop">        (5,)
</span><span class="noop">        &gt;&gt;&gt; states.ic.shape
</span><span class="noop">        (5,)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (1, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass a value to :class:`NmbZones` instances
</span><span class="noop">        within parameter control files.  Sets the shape of most 1-dimensional
</span><span class="noop">        parameter objects (except :class:`UH`) and sequence objects (except
</span><span class="noop">        :class:`QUH`) additionally.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        for (_name, subpars) in self.subpars.pars.model.parameters:
</span><span class="hit">            for (name, par) in subpars:
</span><span class="hit">                if (par.NDIM &gt; 0) and (name != &#39;uh&#39;):
</span><span class="hit">                    par.shape = self.value
</span><span class="hit">        for (_name, subseqs) in self.subpars.pars.model.sequences:
</span><span class="hit">            for (name, seq) in subseqs:
</span><span class="hit">                if (seq.NDIM &gt; 0) and (name != &#39;quh&#39;):
</span><span class="hit">                    seq.shape = self.value
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZoneType(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Type of each zone: 1 (FIELD), 2 (FOREST), 3 (GLACIER), or 4 (ILAKE).
</span><span class="noop">
</span><span class="noop">    For increasing legibility, the HydPy-H-Land constants are used for string
</span><span class="noop">    representions of :class:`ZoneType` instances:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; nmbzones(8)
</span><span class="noop">    &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE, ILAKE, GLACIER, FOREST, FIELD)
</span><span class="noop">    &gt;&gt;&gt; zonetype.values
</span><span class="noop">    array([1, 2, 3, 4, 4, 3, 2, 1])
</span><span class="noop">    &gt;&gt;&gt; zonetype
</span><span class="noop">    zonetype(FIELD, FOREST, GLACIER, ILAKE, ILAKE, GLACIER, FOREST, FIELD)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, int, None, (1, 4)
</span><span class="noop">
</span><span class="hit">    def compressrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a list which contains a string representation with zone
</span><span class="noop">        types beeing defined by the constants `FIELD`, `FOREST`...
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        invmap = {value: key for key, value in
</span><span class="noop">                  hland_constants.CONSTANTS.items()}
</span><span class="hit">        return [&#39;, &#39;.join(invmap.get(value, repr(value))
</span><span class="noop">                          for value in self.values)]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZoneArea(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Zone area [km²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZoneZ(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Zone elevation [100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZRelT(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Subbasin-wide reference elevation level for temperature [100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZRelP(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Subbasin-wide reference elevation level for precipitation [100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZRelE(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Subbasin-wide reference elevation level for evaporation [100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PCorr(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;General precipitation correction factor [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PCAlt(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Elevation correction factor for precipitation [-1/100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RfCF(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Rainfall correction factor [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SfCF(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Snowfall correction factor [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TCAlt(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Elevation correction factor for temperature [-1°C/100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ECorr(hland_parameters.MultiParameterNoGlacier):
</span><span class="noop">    &#34;&#34;&#34;General evaporation correction factor [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ECAlt(hland_parameters.MultiParameterNoGlacier):
</span><span class="noop">    &#34;&#34;&#34;Elevation correction factor for evaporation [-1/100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EPF(hland_parameters.MultiParameterNoGlacier):
</span><span class="noop">    &#34;&#34;&#34;Decrease in potential evaporation due to precipitation [T/mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ETF(hland_parameters.MultiParameterNoGlacier):
</span><span class="noop">    &#34;&#34;&#34;Temperature factor for evaporation [1/°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ERed(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Factor for restricting actual to potential evaporation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TTIce(hland_parameters.MultiParameterLake):
</span><span class="noop">    &#34;&#34;&#34;Temperature threshold for lake evaporation [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class IcMax(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Maximum interception storage [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TT(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Temperature threshold for snow/rain [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TTInt(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Temperature interval with a mixture of snow and rain [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DTTM(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Difference between :class:`TTM` and :class:`TT` [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class CFMax(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Degree day factor for snow (on glaciers or not) [mm/°C/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class GMelt(hland_parameters.MultiParameterGlacier):
</span><span class="noop">    &#34;&#34;&#34;Degree day factor for glacial ice [mm/°C/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class CFR(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Refreezing factor for water stored within the snow layer [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WHC(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Relative water holding capacity of the snow layer [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FC(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Maximum soil moisture content (field capacity) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LP(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Relative limit for potential evaporation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Beta(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Nonlinearity parameter of the soil routine [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class CFlux(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Capacity (maximum) of the capillary return flux [mm/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RespArea(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Flag to enable the contibuting area approach [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, bool, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RecStep(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of internal computation steps per simulation time step [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, True, (1, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        self.value = int(round(self.value))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PercMax(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Maximum percolation rate [mm/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class K(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Recession coefficient of the upper zone layer [1/T/mm^alpha].
</span><span class="noop">
</span><span class="noop">    In addition to the :class:`parametertools.SingleParameter` call method, it
</span><span class="noop">    is possible to set the value of parameter :class:`K` in accordance to
</span><span class="noop">    the keyword arguments `khq`, `hq` and (optionally) `alpha`.  If `alpha`
</span><span class="noop">    is not given, the value of the respective :class:`Alpha` instance is
</span><span class="noop">    taken.  This requires the :class:`Alpha` instance to be initialized
</span><span class="noop">    beforehand.
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">        :math:`K = \\frac{HQ}{(HQ/KHQ)^{1+Alpha}}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        When directly setting the value of parameter k, one only needs to be
</span><span class="noop">        aware of its time dependence:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; k(2.)
</span><span class="noop">        &gt;&gt;&gt; k
</span><span class="noop">        k(2.0)
</span><span class="noop">        &gt;&gt;&gt; k.value
</span><span class="noop">        1.0
</span><span class="noop">
</span><span class="noop">        Alternatively, one can specify the following three keyword
</span><span class="noop">        arguments directly,...
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; k(hq=10., khq=2., alpha=1.)
</span><span class="noop">        &gt;&gt;&gt; k
</span><span class="noop">        k(0.4)
</span><span class="noop">        &gt;&gt;&gt; k.value
</span><span class="noop">        0.2
</span><span class="noop">
</span><span class="noop">        ...or define the value of parameter alpha beforehand:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; alpha(2.)
</span><span class="noop">        &gt;&gt;&gt; k(hq=10., khq=2.)
</span><span class="noop">        &gt;&gt;&gt; k
</span><span class="noop">        k(0.08)
</span><span class="noop">        &gt;&gt;&gt; k.value
</span><span class="noop">        0.04
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`K` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            counter = (&#39;khq&#39; in kwargs) + (&#39;hq&#39; in kwargs)
</span><span class="hit">            if counter == 0:
</span><span class="miss">                raise ValueError(&#39;For parameter `k` a value can be set &#39;
</span><span class="noop">                                 &#39;directly or indirectly by using the &#39;
</span><span class="noop">                                 &#39;keyword arguments `khq` and `hq`.&#39;)
</span><span class="hit">            elif counter == 1:
</span><span class="miss">                raise ValueError(&#39;For the alternative calculation of &#39;
</span><span class="noop">                                 &#39;parameter `k`, at least the keywords &#39;
</span><span class="noop">                                 &#39;arguments `khq` and `hq` must be given.&#39;)
</span><span class="hit">            elif counter == 2:
</span><span class="hit">                try:
</span><span class="hit">                    alpha = float(kwargs[&#39;alpha&#39;])
</span><span class="hit">                except KeyError:
</span><span class="hit">                    try:
</span><span class="hit">                        alpha = self.subpars.alpha.value
</span><span class="miss">                    except (AttributeError, RuntimeError):
</span><span class="miss">                        raise RuntimeError(&#39;For the alternative calculation &#39;
</span><span class="noop">                                           &#39;of parameter `k`, either the &#39;
</span><span class="noop">                                           &#39;keyword argument `alpha` must be &#39;
</span><span class="noop">                                           &#39;given or the value of parameter &#39;
</span><span class="noop">                                           &#39;`alpha` must be defined &#39;
</span><span class="noop">                                           &#39;beforehand.&#39;)
</span><span class="hit">                khq = float(kwargs[&#39;khq&#39;])
</span><span class="hit">                hq = float(kwargs[&#39;hq&#39;])
</span><span class="hit">                self(hq/((hq/khq)**(alpha+1.)))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Alpha(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Nonlinearity parameter of the upper zone layer [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class K4(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Recession coefficient of the lower zone layer [1/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Gamma(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Nonlinearity parameter of the lower zone layer [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MaxBaz(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Base length of the triangle unit hydrograph [T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Abstr(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Abstraction of water from computed outflow [mm/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of HydPy-H-Land, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (Area, NmbZones, ZoneType, ZoneArea, ZoneZ, ZRelP, ZRelT,
</span><span class="noop">                   ZRelE, PCorr, PCAlt, RfCF, SfCF, TCAlt, ECorr, ECAlt, EPF,
</span><span class="noop">                   ETF, ERed, TTIce, IcMax, TT, TTInt, DTTM, CFMax, GMelt, CFR,
</span><span class="noop">                   WHC, FC, LP, Beta, PercMax, CFlux, RespArea, RecStep, Alpha,
</span><span class="noop">                   K, K4, Gamma, MaxBaz, Abstr)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.hland import hland_parameters
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelZoneArea(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Relative zone area [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelSoilArea(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Total area of all `field` and `forest` zones [km²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelSoilZoneArea(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Relative zone area of all `field` and `forest` zones [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelLandZoneArea(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Relative Zone area of all `field`, `forest` and `glacier` zones [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelLandArea(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Quotient of the sum of :class:`LandZoneArea` and :class:`Area` [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TTM(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Threshold temperature for snow melting and refreezing [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DT(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Relative time step length for the upper zone layer calculations [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NmbUH(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of the required unit hydrograph ordinates [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (0, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class UH(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Unit hydrograph ordinates [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QFactor(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Factor for converting mm/stepsize to m³/s.&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of HydPy-H-Land, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (RelZoneArea, RelSoilArea, RelSoilZoneArea, RelLandZoneArea,
</span><span class="noop">                   RelLandArea, TTM, DT, NmbUH, UH, QFactor)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TMean(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Mean subbasin temperature [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Corrected temperature [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FracRain(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Fraction rainfall / total precipitation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RfC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual precipitation correction related to liquid precipitation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SfC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual precipitation correction related to frozen precipitation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Corrected precipitation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EP(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potential evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EPC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Corrected potential evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EI(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Interception evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TF(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Throughfall [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TFWat(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Liquid throughfall [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TFIce(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Frozen throughfall [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class GlMelt(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Glacier melt [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MeltPot(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potential melting of frozen water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Melt(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual melting of frozen water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RefrPot(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potential (re)freezing of liquid water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Refr(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual (re)freezing of liquid water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class In_(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Snow module release / soil module inflow [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class R(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Effective soil response [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EA(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual soil evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class CFPot(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potential capillary flow [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class CF(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual capillary flow [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ContriArea(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Fraction of the `soil area` contributing to runoff generation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InUZ(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Inflow to the upper zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Perc(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Percolation from the upper to the lower zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q0(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Outflow from the upper zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EL(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual lake evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q1(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Outflow from the lower zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InUH(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Input of the triangle unit hydrograph  [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutUH(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Output of the triangle unit hydrograph  [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QT(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Total model outflow [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of the HydPy-H-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (TMean, TC, FracRain, RfC, SfC, PC, EP, EPC, EI, TF, TFWat,
</span><span class="noop">                   TFIce, GlMelt, MeltPot, Melt, RefrPot, Refr, In_, R,
</span><span class="noop">                   EA, CFPot, CF, Perc, ContriArea, InUZ, Q0, EL, Q1,
</span><span class="noop">                   InUH, OutUH, QT)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_inputs.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_inputs.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class P(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Precipitation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class T(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Temperature [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TN(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Normal temperature [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EPN(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Normal potential evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequences(sequencetools.InputSequences):
</span><span class="noop">    &#34;&#34;&#34;Input sequences of the hland model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (P, T, TN, EPN)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_logs.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_logs.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import sys
</span><span class="hit">import warnings
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QUH(sequencetools.LogSequence):
</span><span class="noop">    &#34;&#34;&#34;Whole outflow delayed by means of the unit hydrograph [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="miss">        try:
</span><span class="miss">            sequencetools.LogSequence.__call__(self, *args)
</span><span class="miss">        except BaseException:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            sequencetools.LogSequence.__call__(self, numpy.sum(args))
</span><span class="miss">            warnings.warn(&#39;Note that, due to the following problem, the &#39;
</span><span class="noop">                          &#39;unit-hydrograph of the affected HydPy-H-Land &#39;
</span><span class="noop">                          &#39;model could be initialised with an summed &#39;
</span><span class="noop">                          &#39;value only: %s&#39; % message)
</span><span class="noop">        # The last value must be zero, otherwise all results were biased:
</span><span class="miss">        self.values[-1] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequences(sequencetools.LogSequences):
</span><span class="noop">    &#34;&#34;&#34;Log sequences of the hland model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QUH,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
1399 &nbsp;
1400 &nbsp;
1401 &nbsp;
1402 &nbsp;
1403 &nbsp;
1404 &nbsp;
1405 &nbsp;
1406 &nbsp;
1407 &nbsp;
1408 &nbsp;
1409 &nbsp;
1410 &nbsp;
1411 &nbsp;
1412 &nbsp;
1413 &nbsp;
1414 &nbsp;
1415 &nbsp;
1416 &nbsp;
1417 &nbsp;
1418 &nbsp;
1419 &nbsp;
1420 &nbsp;
1421 &nbsp;
1422 &nbsp;
1423 &nbsp;
1424 &nbsp;
1425 &nbsp;
1426 &nbsp;
1427 &nbsp;
1428 &nbsp;
1429 &nbsp;
1430 &nbsp;
1431 &nbsp;
1432 &nbsp;
1433 &nbsp;
1434 &nbsp;
1435 &nbsp;
1436 &nbsp;
1437 &nbsp;
1438 &nbsp;
1439 &nbsp;
1440 &nbsp;
1441 &nbsp;
1442 &nbsp;
1443 &nbsp;
1444 &nbsp;
1445 &nbsp;
1446 &nbsp;
1447 &nbsp;
1448 &nbsp;
1449 &nbsp;
1450 &nbsp;
1451 &nbsp;
1452 &nbsp;
1453 &nbsp;
1454 &nbsp;
1455 &nbsp;
1456 &nbsp;
1457 &nbsp;
1458 &nbsp;
1459 &nbsp;
1460 &nbsp;
1461 &nbsp;
1462 &nbsp;
1463 &nbsp;
1464 &nbsp;
1465 &nbsp;
1466 &nbsp;
1467 &nbsp;
1468 &nbsp;
1469 &nbsp;
1470 &nbsp;
1471 &nbsp;
1472 &nbsp;
1473 &nbsp;
1474 &nbsp;
1475 &nbsp;
1476 &nbsp;
1477 &nbsp;
1478 &nbsp;
1479 &nbsp;
1480 &nbsp;
1481 &nbsp;
1482 &nbsp;
1483 &nbsp;
1484 &nbsp;
1485 &nbsp;
1486 &nbsp;
1487 &nbsp;
1488 &nbsp;
1489 &nbsp;
1490 &nbsp;
1491 &nbsp;
1492 &nbsp;
1493 &nbsp;
1494 &nbsp;
1495 &nbsp;
1496 &nbsp;
1497 &nbsp;
1498 &nbsp;
1499 &nbsp;
1500 &nbsp;
1501 &nbsp;
1502 &nbsp;
1503 &nbsp;
1504 &nbsp;
1505 &nbsp;
1506 &nbsp;
1507 &nbsp;
1508 &nbsp;
1509 &nbsp;
1510 &nbsp;
1511 &nbsp;
1512 &nbsp;
1513 &nbsp;
1514 &nbsp;
1515 &nbsp;
1516 &nbsp;
1517 &nbsp;
1518 &nbsp;
1519 &nbsp;
1520 &nbsp;
1521 &nbsp;
1522 &nbsp;
1523 &nbsp;
1524 &nbsp;
1525 &nbsp;
1526 &nbsp;
1527 &nbsp;
1528 &nbsp;
1529 &nbsp;
1530 &nbsp;
1531 &nbsp;
1532 &nbsp;
1533 &nbsp;
1534 &nbsp;
1535 &nbsp;
1536 &nbsp;
1537 &nbsp;
1538 &nbsp;
1539 &nbsp;
1540 &nbsp;
1541 &nbsp;
1542 &nbsp;
1543 &nbsp;
1544 &nbsp;
1545 &nbsp;
1546 &nbsp;
1547 &nbsp;
1548 &nbsp;
1549 &nbsp;
1550 &nbsp;
1551 &nbsp;
1552 &nbsp;
1553 &nbsp;
1554 &nbsp;
1555 &nbsp;
1556 &nbsp;
1557 &nbsp;
1558 &nbsp;
1559 &nbsp;
1560 &nbsp;
1561 &nbsp;
1562 &nbsp;
1563 &nbsp;
1564 &nbsp;
1565 &nbsp;
1566 &nbsp;
1567 &nbsp;
1568 &nbsp;
1569 &nbsp;
1570 &nbsp;
1571 &nbsp;
1572 &nbsp;
1573 &nbsp;
1574 &nbsp;
1575 &nbsp;
1576 &nbsp;
1577 &nbsp;
1578 &nbsp;
1579 &nbsp;
1580 &nbsp;
1581 &nbsp;
1582 &nbsp;
1583 &nbsp;
1584 &nbsp;
1585 &nbsp;
1586 &nbsp;
1587 &nbsp;
1588 &nbsp;
1589 &nbsp;
1590 &nbsp;
1591 &nbsp;
1592 &nbsp;
1593 &nbsp;
1594 &nbsp;
1595 &nbsp;
1596 &nbsp;
1597 &nbsp;
1598 &nbsp;
1599 &nbsp;
1600 &nbsp;
1601 &nbsp;
1602 &nbsp;
1603 &nbsp;
1604 &nbsp;
1605 &nbsp;
1606 &nbsp;
1607 &nbsp;
1608 &nbsp;
1609 &nbsp;
1610 &nbsp;
1611 &nbsp;
1612 &nbsp;
1613 &nbsp;
1614 &nbsp;
1615 &nbsp;
1616 &nbsp;
1617 &nbsp;
1618 &nbsp;
1619 &nbsp;
1620 &nbsp;
1621 &nbsp;
1622 &nbsp;
1623 &nbsp;
1624 &nbsp;
1625 &nbsp;
1626 &nbsp;
1627 &nbsp;
1628 &nbsp;
1629 &nbsp;
1630 &nbsp;
1631 &nbsp;
1632 &nbsp;
1633 &nbsp;
1634 &nbsp;
1635 &nbsp;
1636 &nbsp;
1637 &nbsp;
1638 &nbsp;
1639 &nbsp;
1640 &nbsp;
1641 &nbsp;
1642 &nbsp;
1643 &nbsp;
1644 &nbsp;
1645 &nbsp;
1646 &nbsp;
1647 &nbsp;
1648 &nbsp;
1649 &nbsp;
1650 &nbsp;
1651 &nbsp;
1652 &nbsp;
1653 &nbsp;
1654 &nbsp;
1655 &nbsp;
1656 &nbsp;
1657 &nbsp;
1658 &nbsp;
1659 &nbsp;
1660 &nbsp;
1661 &nbsp;
1662 &nbsp;
1663 &nbsp;
1664 &nbsp;
1665 &nbsp;
1666 &nbsp;
1667 &nbsp;
1668 &nbsp;
1669 &nbsp;
1670 &nbsp;
1671 &nbsp;
1672 &nbsp;
1673 &nbsp;
1674 &nbsp;
1675 &nbsp;
1676 &nbsp;
1677 &nbsp;
1678 &nbsp;
1679 &nbsp;
1680 &nbsp;
1681 &nbsp;
1682 &nbsp;
1683 &nbsp;
1684 &nbsp;
1685 &nbsp;
1686 &nbsp;
1687 &nbsp;
1688 &nbsp;
1689 &nbsp;
1690 &nbsp;
1691 &nbsp;
1692 &nbsp;
1693 &nbsp;
1694 &nbsp;
1695 &nbsp;
1696 &nbsp;
1697 &nbsp;
1698 &nbsp;
1699 &nbsp;
1700 &nbsp;
1701 &nbsp;
1702 &nbsp;
1703 &nbsp;
1704 &nbsp;
1705 &nbsp;
1706 &nbsp;
1707 &nbsp;
1708 &nbsp;
1709 &nbsp;
1710 &nbsp;
1711 &nbsp;
1712 &nbsp;
1713 &nbsp;
1714 &nbsp;
1715 &nbsp;
1716 &nbsp;
1717 &nbsp;
1718 &nbsp;
1719 &nbsp;
1720 &nbsp;
1721 &nbsp;
1722 &nbsp;
1723 &nbsp;
1724 &nbsp;
1725 &nbsp;
1726 &nbsp;
1727 &nbsp;
1728 &nbsp;
1729 &nbsp;
1730 &nbsp;
1731 &nbsp;
1732 &nbsp;
1733 &nbsp;
1734 &nbsp;
1735 &nbsp;
1736 &nbsp;
1737 &nbsp;
1738 &nbsp;
1739 &nbsp;
1740 &nbsp;
1741 &nbsp;
1742 &nbsp;
1743 &nbsp;
1744 &nbsp;
1745 &nbsp;
1746 &nbsp;
1747 &nbsp;
1748 &nbsp;
1749 &nbsp;
1750 &nbsp;
1751 &nbsp;
1752 &nbsp;
1753 &nbsp;
1754 &nbsp;
1755 &nbsp;
1756 &nbsp;
1757 &nbsp;
1758 &nbsp;
1759 &nbsp;
1760 &nbsp;
1761 &nbsp;
1762 &nbsp;
1763 &nbsp;
1764 &nbsp;
1765 &nbsp;
1766 &nbsp;
1767 &nbsp;
1768 &nbsp;
1769 &nbsp;
1770 &nbsp;
1771 &nbsp;
1772 &nbsp;
1773 &nbsp;
1774 &nbsp;
1775 &nbsp;
1776 &nbsp;
1777 &nbsp;
1778 &nbsp;
1779 &nbsp;
1780 &nbsp;
1781 &nbsp;
1782 &nbsp;
1783 &nbsp;
1784 &nbsp;
1785 &nbsp;
1786 &nbsp;
1787 &nbsp;
1788 &nbsp;
1789 &nbsp;
1790 &nbsp;
1791 &nbsp;
1792 &nbsp;
1793 &nbsp;
1794 &nbsp;
1795 &nbsp;
1796 &nbsp;
1797 &nbsp;
1798 &nbsp;
1799 &nbsp;
1800 &nbsp;
1801 &nbsp;
1802 &nbsp;
1803 &nbsp;
1804 &nbsp;
1805 &nbsp;
1806 &nbsp;
1807 &nbsp;
1808 &nbsp;
1809 &nbsp;
1810 &nbsp;
1811 &nbsp;
1812 &nbsp;
1813 &nbsp;
1814 &nbsp;
1815 &nbsp;
1816 &nbsp;
1817 &nbsp;
1818 &nbsp;
1819 &nbsp;
1820 &nbsp;
1821 &nbsp;
1822 &nbsp;
1823 &nbsp;
1824 &nbsp;
1825 &nbsp;
1826 &nbsp;
1827 &nbsp;
1828 &nbsp;
1829 &nbsp;
1830 &nbsp;
1831 &nbsp;
1832 &nbsp;
1833 &nbsp;
1834 &nbsp;
1835 &nbsp;
1836 &nbsp;
1837 &nbsp;
1838 &nbsp;
1839 &nbsp;
1840 &nbsp;
1841 &nbsp;
1842 &nbsp;
1843 &nbsp;
1844 &nbsp;
1845 &nbsp;
1846 &nbsp;
1847 &nbsp;
1848 &nbsp;
1849 &nbsp;
1850 &nbsp;
1851 &nbsp;
1852 &nbsp;
1853 &nbsp;
1854 &nbsp;
1855 &nbsp;
1856 &nbsp;
1857 &nbsp;
1858 &nbsp;
1859 &nbsp;
1860 &nbsp;
1861 &nbsp;
1862 &nbsp;
1863 &nbsp;
1864 &nbsp;
1865 &nbsp;
1866 &nbsp;
1867 &nbsp;
1868 &nbsp;
1869 &nbsp;
1870 &nbsp;
1871 &nbsp;
1872 &nbsp;
1873 &nbsp;
1874 &nbsp;
1875 &nbsp;
1876 &nbsp;
1877 &nbsp;
1878 &nbsp;
1879 &nbsp;
1880 &nbsp;
1881 &nbsp;
1882 &nbsp;
1883 &nbsp;
1884 &nbsp;
1885 &nbsp;
1886 &nbsp;
1887 &nbsp;
1888 &nbsp;
1889 &nbsp;
1890 &nbsp;
1891 &nbsp;
1892 &nbsp;
1893 &nbsp;
1894 &nbsp;
1895 &nbsp;
1896 &nbsp;
1897 &nbsp;
1898 &nbsp;
1899 &nbsp;
1900 &nbsp;
1901 &nbsp;
1902 &nbsp;
1903 &nbsp;
1904 &nbsp;
1905 &nbsp;
1906 &nbsp;
1907 &nbsp;
1908 &nbsp;
1909 &nbsp;
1910 &nbsp;
1911 &nbsp;
1912 &nbsp;
1913 &nbsp;
1914 &nbsp;
1915 &nbsp;
1916 &nbsp;
1917 &nbsp;
1918 &nbsp;
1919 &nbsp;
1920 &nbsp;
1921 &nbsp;
1922 &nbsp;
1923 &nbsp;
1924 &nbsp;
1925 &nbsp;
1926 &nbsp;
1927 &nbsp;
1928 &nbsp;
1929 &nbsp;
1930 &nbsp;
1931 &nbsp;
1932 &nbsp;
1933 &nbsp;
1934 &nbsp;
1935 &nbsp;
1936 &nbsp;
1937 &nbsp;
1938 &nbsp;
1939 &nbsp;
1940 &nbsp;
1941 &nbsp;
1942 &nbsp;
1943 &nbsp;
1944 &nbsp;
1945 &nbsp;
1946 &nbsp;
1947 &nbsp;
1948 &nbsp;
1949 &nbsp;
1950 &nbsp;
1951 &nbsp;
1952 &nbsp;
1953 &nbsp;
1954 &nbsp;
1955 &nbsp;
1956 &nbsp;
1957 &nbsp;
1958 &nbsp;
1959 &nbsp;
1960 &nbsp;
1961 &nbsp;
1962 &nbsp;
1963 &nbsp;
1964 &nbsp;
1965 &nbsp;
1966 &nbsp;
1967 &nbsp;
1968 &nbsp;
1969 &nbsp;
1970 &nbsp;
1971 &nbsp;
1972 &nbsp;
1973 &nbsp;
1974 &nbsp;
1975 &nbsp;
1976 &nbsp;
1977 &nbsp;
1978 &nbsp;
1979 &nbsp;
1980 &nbsp;
1981 &nbsp;
1982 &nbsp;
1983 &nbsp;
1984 &nbsp;
1985 &nbsp;
1986 &nbsp;
1987 &nbsp;
1988 &nbsp;
1989 &nbsp;
1990 &nbsp;
1991 &nbsp;
1992 &nbsp;
1993 &nbsp;
1994 &nbsp;
1995 &nbsp;
1996 &nbsp;
1997 &nbsp;
1998 &nbsp;
1999 &nbsp;
2000 &nbsp;
2001 &nbsp;
2002 &nbsp;
2003 &nbsp;
2004 &nbsp;
2005 &nbsp;
2006 &nbsp;
2007 &nbsp;
2008 &nbsp;
2009 &nbsp;
2010 &nbsp;
2011 &nbsp;
2012 &nbsp;
2013 &nbsp;
2014 &nbsp;
2015 &nbsp;
2016 &nbsp;
2017 &nbsp;
2018 &nbsp;
2019 &nbsp;
2020 &nbsp;
2021 &nbsp;
2022 &nbsp;
2023 &nbsp;
2024 &nbsp;
2025 &nbsp;
2026 &nbsp;
2027 &nbsp;
2028 &nbsp;
2029 &nbsp;
2030 &nbsp;
2031 &nbsp;
2032 &nbsp;
2033 &nbsp;
2034 &nbsp;
2035 &nbsp;
2036 &nbsp;
2037 &nbsp;
2038 &nbsp;
2039 &nbsp;
2040 &nbsp;
2041 &nbsp;
2042 &nbsp;
2043 &nbsp;
2044 &nbsp;
2045 &nbsp;
2046 &nbsp;
2047 &nbsp;
2048 &nbsp;
2049 &nbsp;
2050 &nbsp;
2051 &nbsp;
2052 &nbsp;
2053 &nbsp;
2054 &nbsp;
2055 &nbsp;
2056 &nbsp;
2057 &nbsp;
2058 &nbsp;
2059 &nbsp;
2060 &nbsp;
2061 &nbsp;
2062 &nbsp;
2063 &nbsp;
2064 &nbsp;
2065 &nbsp;
2066 &nbsp;
2067 &nbsp;
2068 &nbsp;
2069 &nbsp;
2070 &nbsp;
2071 &nbsp;
2072 &nbsp;
2073 &nbsp;
2074 &nbsp;
2075 &nbsp;
2076 &nbsp;
2077 &nbsp;
2078 &nbsp;
2079 &nbsp;
2080 &nbsp;
2081 &nbsp;
2082 &nbsp;
2083 &nbsp;
2084 &nbsp;
2085 &nbsp;
2086 &nbsp;
2087 &nbsp;
2088 &nbsp;
2089 &nbsp;
2090 &nbsp;
2091 &nbsp;
2092 &nbsp;
2093 &nbsp;
2094 &nbsp;
2095 &nbsp;
2096 &nbsp;
2097 &nbsp;
2098 &nbsp;
2099 &nbsp;
2100 &nbsp;
2101 &nbsp;
2102 &nbsp;
2103 &nbsp;
2104 &nbsp;
2105 &nbsp;
2106 &nbsp;
2107 &nbsp;
2108 &nbsp;
2109 &nbsp;
2110 &nbsp;
2111 &nbsp;
2112 &nbsp;
2113 &nbsp;
2114 &nbsp;
2115 &nbsp;
2116 &nbsp;
2117 &nbsp;
2118 &nbsp;
2119 &nbsp;
2120 &nbsp;
2121 &nbsp;
2122 &nbsp;
2123 &nbsp;
2124 &nbsp;
2125 &nbsp;
2126 &nbsp;
2127 &nbsp;
2128 &nbsp;
2129 &nbsp;
2130 &nbsp;
2131 &nbsp;
2132 &nbsp;
2133 &nbsp;
2134 &nbsp;
2135 &nbsp;
2136 &nbsp;
2137 &nbsp;
2138 &nbsp;
2139 &nbsp;
2140 &nbsp;
2141 &nbsp;
2142 &nbsp;
2143 &nbsp;
2144 &nbsp;
2145 &nbsp;
2146 &nbsp;
2147 &nbsp;
2148 &nbsp;
2149 &nbsp;
2150 &nbsp;
2151 &nbsp;
2152 &nbsp;
2153 &nbsp;
2154 &nbsp;
2155 &nbsp;
2156 &nbsp;
2157 &nbsp;
2158 &nbsp;
2159 &nbsp;
2160 &nbsp;
2161 &nbsp;
2162 &nbsp;
2163 &nbsp;
2164 &nbsp;
2165 &nbsp;
2166 &nbsp;
2167 &nbsp;
2168 &nbsp;
2169 &nbsp;
2170 &nbsp;
2171 &nbsp;
2172 &nbsp;
2173 &nbsp;
2174 &nbsp;
2175 &nbsp;
2176 &nbsp;
2177 &nbsp;
2178 &nbsp;
2179 &nbsp;
2180 &nbsp;
2181 &nbsp;
2182 &nbsp;
2183 &nbsp;
2184 &nbsp;
2185 &nbsp;
2186 &nbsp;
2187 &nbsp;
2188 &nbsp;
2189 &nbsp;
2190 &nbsp;
2191 &nbsp;
2192 &nbsp;
2193 &nbsp;
2194 &nbsp;
2195 &nbsp;
2196 &nbsp;
2197 &nbsp;
2198 &nbsp;
2199 &nbsp;
2200 &nbsp;
2201 &nbsp;
2202 &nbsp;
2203 &nbsp;
2204 &nbsp;
2205 &nbsp;
2206 &nbsp;
2207 &nbsp;
2208 &nbsp;
2209 &nbsp;
2210 &nbsp;
2211 &nbsp;
2212 &nbsp;
2213 &nbsp;
2214 &nbsp;
2215 &nbsp;
2216 &nbsp;
2217 &nbsp;
2218 &nbsp;
2219 &nbsp;
2220 &nbsp;
2221 &nbsp;
2222 &nbsp;
2223 &nbsp;
2224 &nbsp;
2225 &nbsp;
2226 &nbsp;
2227 &nbsp;
2228 &nbsp;
2229 &nbsp;
2230 &nbsp;
2231 &nbsp;
2232 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># imports...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.cythons import modelutils
</span><span class="noop"># ...model specifc
</span><span class="hit">from hydpy.models.hland.hland_constants import FIELD, FOREST, GLACIER, ILAKE
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_tc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Adjust the measured air temperature to the altitude of the
</span><span class="noop">    individual zones.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.TCAlt`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneZ`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZRelT`
</span><span class="noop">
</span><span class="noop">    Required input sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_inputs.T`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`TC = T - TCAlt \\cdot (ZoneZ-ZRelT)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Prepare two zones, the first one lying at the reference
</span><span class="noop">        height and the second one 200 meters above:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(2); zrelt(2.); zonez(2., 4.)
</span><span class="noop">
</span><span class="noop">        Applying the usual temperature lapse rate of 0.6°C/100m does
</span><span class="noop">        not affect the temperature of the first zone but reduces the
</span><span class="noop">        temperature of the second zone by 1.2°C:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; tcalt(.6)
</span><span class="noop">        &gt;&gt;&gt; inputs.t = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_tc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc
</span><span class="noop">        tc(5.0, 3.8)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    inp = self.sequences.inputs.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        flu.tc[k] = inp.t-con.tcalt[k]*(con.zonez[k]-con.zrelt)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_tmean_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the areal mean temperature of the subbasin.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_derived.RelZoneArea`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TMean`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Prepare sized zones, the first one beeing twice as large
</span><span class="noop">        as the second one:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(2)
</span><span class="noop">        &gt;&gt;&gt; derived.relzonearea(2./3., 1./3.)
</span><span class="noop">
</span><span class="noop">        With temperature values of 5°C and 8°C  of the respective zones,
</span><span class="noop">        the mean temperature is 6°C:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 5., 8.
</span><span class="noop">        &gt;&gt;&gt; model.calc_tmean_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.tmean
</span><span class="noop">        tmean(6.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.tmean = 0.
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        flu.tmean += der.relzonearea[k]*flu.tc[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_fracrain_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Determine the temperature dependend fraction of (liquid) rainfall
</span><span class="noop">    and (total) precipitation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.TT`,
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.TTInt`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.FracRain`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`FracRain = \\frac{TC-(TT-\\frac{TTInt}{2})}{TTInt}`
</span><span class="noop">
</span><span class="noop">    Restriction:
</span><span class="noop">      :math:`0 \\leq FracRain \\leq 1`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        The threshold temperature of seven zones is 0°C and the corresponding
</span><span class="noop">        temperature intervall of mixed precipitation 2°C:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">        &gt;&gt;&gt; tt(0.)
</span><span class="noop">        &gt;&gt;&gt; ttint(2.)
</span><span class="noop">
</span><span class="noop">        The fraction of rainfall is zero below -1°C, is one above 1°C and
</span><span class="noop">        increases linearly in between:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = -10., -1., -.5, 0., .5, 1., 10.
</span><span class="noop">        &gt;&gt;&gt; model.calc_fracrain_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.fracrain
</span><span class="noop">        fracrain(0.0, 0.0, 0.25, 0.5, 0.75, 1.0, 1.0)
</span><span class="noop">
</span><span class="noop">        Note the special case of a zero temperature intervall.  With a
</span><span class="noop">        actual temperature beeing equal to the threshold temperature, the
</span><span class="noop">        rainfall fraction is one:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ttint(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_fracrain_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.fracrain
</span><span class="noop">        fracrain(0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if flu.tc[k] &gt;= (con.tt[k]+con.ttint[k]/2.):
</span><span class="hit">            flu.fracrain[k] = 1.
</span><span class="hit">        elif flu.tc[k] &lt;= (con.tt[k]-con.ttint[k]/2.):
</span><span class="hit">            flu.fracrain[k] = 0.
</span><span class="noop">        else:
</span><span class="hit">            flu.fracrain[k] = ((flu.tc[k]-(con.tt[k]-con.ttint[k]/2.)) /
</span><span class="noop">                               con.ttint[k])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_rfc_sfc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the corrected fractions rainfall/snowfall and total
</span><span class="noop">    precipitation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.RfCF`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.SfCF`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.RfC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.SfC`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`RfC = RfCF \\cdot FracRain` \n
</span><span class="noop">      :math:`SfC = SfCF \\cdot (1 - FracRain)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Assume five zones with different temperatures and hence
</span><span class="noop">        different fractions of rainfall and total precipitation:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.fracrain = 0., .25, .5, .75, 1.
</span><span class="noop">
</span><span class="noop">        With no rainfall and no snowfall correction (implied by the
</span><span class="noop">        respective factors beeing one), the corrected fraction related
</span><span class="noop">        to rainfall is identical with the original fraction and the
</span><span class="noop">        corrected fraction related to snowfall behaves opposite:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; rfcf(1.)
</span><span class="noop">        &gt;&gt;&gt; sfcf(1.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_rfc_sfc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.rfc
</span><span class="noop">        rfc(0.0, 0.25, 0.5, 0.75, 1.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.sfc
</span><span class="noop">        sfc(1.0, 0.75, 0.5, 0.25, 0.0)
</span><span class="noop">
</span><span class="noop">        With a negative rainfall correction of 20% and a positive
</span><span class="noop">        snowfall correction of 20 % the corrected fractions are:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; rfcf(0.8)
</span><span class="noop">        &gt;&gt;&gt; sfcf(1.2)
</span><span class="noop">        &gt;&gt;&gt; model.calc_rfc_sfc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.rfc
</span><span class="noop">        rfc(0.0, 0.2, 0.4, 0.6, 0.8)
</span><span class="noop">        &gt;&gt;&gt; fluxes.sfc
</span><span class="noop">        sfc(1.2, 0.9, 0.6, 0.3, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        flu.rfc[k] = flu.fracrain[k]*con.rfcf[k]
</span><span class="hit">        flu.sfc[k] = (1.-flu.fracrain[k])*con.sfcf[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_pc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Apply the precipitation correction factors and adjust precipitation
</span><span class="noop">    to the altitude of the individual zones.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.PCorr`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.PCAlt`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneZ`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZRelP`
</span><span class="noop">
</span><span class="noop">    Required input sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_inputs.P`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.RfC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.SfC`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.PC`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Five zones are at an elevation of 200 m.  A precipitation value
</span><span class="noop">        of 5 mm has been measured at a gauge at an elevation of 300 m:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">        &gt;&gt;&gt; zrelp(2.)
</span><span class="noop">        &gt;&gt;&gt; zonez(3.)
</span><span class="noop">        &gt;&gt;&gt; inputs.p = 5.
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`PC = P \\cdot PCorr
</span><span class="noop">          \\cdot (1+PCAlt \\cdot (ZoneZ-ZRelP))
</span><span class="noop">          \\cdot (RfC + SfC)`
</span><span class="noop">
</span><span class="noop">        The first four zones illustrate the individual precipitation
</span><span class="noop">        corrections due to the general precipitation correction factor
</span><span class="noop">        (first zone), the altitude correction (second zone), the rainfall
</span><span class="noop">        related correction factor (third zone), and the snowfall related
</span><span class="noop">        correction factor (fourth zone):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; pcorr(1.3, 1.0, 1.0, 1.0, 1.3)
</span><span class="noop">        &gt;&gt;&gt; pcalt(0.0, 0.1, 0.0, 0.0, 0.1)
</span><span class="noop">        &gt;&gt;&gt; fluxes.rfc = 0.5, 0.5, 0.4, 0.5, 0.4
</span><span class="noop">        &gt;&gt;&gt; fluxes.sfc = 0.5, 0.5, 0.5, 0.7, 0.7
</span><span class="noop">        &gt;&gt;&gt; model.calc_pc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.pc
</span><span class="noop">        pc(6.5, 5.5, 4.5, 6.0, 7.865)
</span><span class="noop">
</span><span class="noop">        The fifth zone illustrates the interaction between all corrections
</span><span class="noop">        --- note that each correction (except the first one) is based the
</span><span class="noop">        corrected precipitation value determined beforehand.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    inp = self.sequences.inputs.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        flu.pc[k] = inp.p*con.pcorr[k]
</span><span class="hit">        flu.pc[k] *= 1.+con.pcalt[k]*(con.zonez[k]-con.zrelp)
</span><span class="hit">        flu.pc[k] *= flu.rfc[k]+flu.sfc[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_ep_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Adjust potential norm evaporation to the actual temperature.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ETF`
</span><span class="noop">
</span><span class="noop">    Required input sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_inputs.EPN`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_inputs.TN`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TMean`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EP`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`EP = EPN \\cdot (1 + ETF \\cdot (TMean - TN))`
</span><span class="noop">
</span><span class="noop">    Restriction:
</span><span class="noop">      :math:`0 \leq EP \leq 2 \\cdot EPN`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Assume four zones with different values of the temperature
</span><span class="noop">        related factor for the adjustment of evaporation (the
</span><span class="noop">        negative value of the first zone is not meaningful, but used
</span><span class="noop">        for illustration purporses):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(4)
</span><span class="noop">        &gt;&gt;&gt; etf(-0.5, 0.0, 0.1, 0.5)
</span><span class="noop">        &gt;&gt;&gt; inputs.tn = 20.
</span><span class="noop">        &gt;&gt;&gt; inputs.epn = 2.
</span><span class="noop">
</span><span class="noop">        With mean temperature equal to norm temperature, actual
</span><span class="noop">        (uncorrected) evaporation is equal to norm evaporation:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tmean = 20.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ep_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ep
</span><span class="noop">        ep(2.0, 2.0, 2.0, 2.0)
</span><span class="noop">
</span><span class="noop">        With mean temperature 5°C higher than norm temperature, potential
</span><span class="noop">        evaporation is increased by 1 mm for the third zone, which
</span><span class="noop">        possesses a very common adjustment factor.  For the first zone,
</span><span class="noop">        potential evaporation is 0 mm (which is the smallest value
</span><span class="noop">        allowed), and for the fourth zone it is the double value of the
</span><span class="noop">        norm evaporation (which is the largest value allowed):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tmean  = 25.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ep_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ep
</span><span class="noop">        ep(0.0, 2.0, 3.0, 4.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    inp = self.sequences.inputs.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        flu.ep[k] = inp.epn*(1.+con.etf[k]*(flu.tmean-inp.tn))
</span><span class="hit">        flu.ep[k] = min(max(flu.ep[k], 0.), 2.*inp.epn)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_epc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Apply the evaporation correction factors and adjust evaporation
</span><span class="noop">    to the altitude of the individual zones.
</span><span class="noop">
</span><span class="noop">    Calculate the areal mean of (uncorrected) potential evaporation
</span><span class="noop">    for the subbasin, adjust it to the individual zones in accordance
</span><span class="noop">    with their heights and perform some corrections, among which one
</span><span class="noop">    depends on the actual precipitation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ECorr`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ECAlt`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneZ`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZRelE`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.EPF`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EP`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.PC`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EPC`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`EPC = EP \\cdot ECorr
</span><span class="noop">      \\cdot (1+ECAlt \\cdot (ZoneZ-ZRelE))
</span><span class="noop">      \\cdot exp(-EPF \\cdot PC)`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Four zones are at an elevation of 200 m.  A (uncorrected)
</span><span class="noop">        potential evaporation value of 2 mm and a (corrected) precipitation
</span><span class="noop">        value of 5 mm have been determined for each zone beforehand:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(4)
</span><span class="noop">        &gt;&gt;&gt; zrele(2.)
</span><span class="noop">        &gt;&gt;&gt; zonez(3.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.ep = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.pc = 5.
</span><span class="noop">
</span><span class="noop">        The first three zones  illustrate the individual evaporation
</span><span class="noop">        corrections due to the general evaporation correction factor
</span><span class="noop">        (first zone), the altitude correction (second zone), the
</span><span class="noop">        precipitation related correction (third zone):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ecorr(1.3, 1.0, 1.0, 1.3)
</span><span class="noop">        &gt;&gt;&gt; ecalt(0.0, 0.1, 0.0, 0.1)
</span><span class="noop">        &gt;&gt;&gt; epf(0.0, 0.0, -numpy.log(.7)/10., -numpy.log(.7)/10.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_epc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.epc
</span><span class="noop">        epc(2.6, 1.8, 1.4, 1.638)
</span><span class="noop">
</span><span class="noop">        The fourth zone illustrates the interaction between all corrections
</span><span class="noop">        --- note that each correction (except the first one) is based the
</span><span class="noop">        corrected evaporation value determined beforehand.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        flu.epc[k] = (flu.ep[k]*con.ecorr[k] *
</span><span class="noop">                      (1. - con.ecalt[k]*(con.zonez[k]-con.zrele)))
</span><span class="hit">        flu.epc[k] *= modelutils.exp(-con.epf[k]*flu.pc[k])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_tf_ic_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate throughfall and update the interception storage
</span><span class="noop">    accordingly.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.IcMax`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.PC`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TF`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.Ic`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`TF = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {PC \\ | \\ Ic = IcMax}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ Ic &lt; IcMax}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize six zones of different types.  Assume a
</span><span class="noop">        generall maximum interception capacity of 2 mm. All zones receive
</span><span class="noop">        a 0.5 mm input of precipitation:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(GLACIER, ILAKE, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; icmax(2.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.pc = .5
</span><span class="noop">        &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_tf_ic_v1()
</span><span class="noop">
</span><span class="noop">        For glaciers (first zone) and internal lakes (second zone) the
</span><span class="noop">        interception routine does not apply.  Hence, all precipitation is
</span><span class="noop">        routed as throughfall. For fields and forests, the interception
</span><span class="noop">        routine is identical (usually, only larger capacities for forests
</span><span class="noop">        are assumed, due to their higher leaf area index).  Hence, the
</span><span class="noop">        results of the third and the second zone are equal.  The last
</span><span class="noop">        three zones demonstrate, that all precipitation is stored until
</span><span class="noop">        the interception capacity is reached; afterwards, all precepitation
</span><span class="noop">        is routed as throughfall.  Initial storage reduces the effective
</span><span class="noop">        capacity of the respective simulation step:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 0.5, 0.5, 1.5, 2.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.tf
</span><span class="noop">        tf(0.5, 0.5, 0.0, 0.0, 0.0, 0.5)
</span><span class="noop">
</span><span class="noop">        A zero precipitation example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.pc = 0.
</span><span class="noop">        &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_tf_ic_v1()
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 0.0, 0.0, 1.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.tf
</span><span class="noop">        tf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        A high precipitation example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.pc = 5.
</span><span class="noop">        &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_tf_ic_v1()
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.tf
</span><span class="noop">        tf(5.0, 5.0, 3.0, 3.0, 4.0, 5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">            flu.tf[k] = max(flu.pc[k]-(con.icmax[k]-sta.ic[k]), 0.)
</span><span class="hit">            sta.ic[k] += flu.pc[k]-flu.tf[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.tf[k] = flu.pc[k]
</span><span class="hit">            sta.ic[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_ei_ic_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate interception evaporation and update the interception
</span><span class="noop">    storage accordingly.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EPC`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EI`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.Ic`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`EI = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {EPC \\ | \\ Ic &gt; 0}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ Ic = 0}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize six zones of different types.  For all zones
</span><span class="noop">        a (corrected) potential evaporation of 0.5 mm is given:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(GLACIER, ILAKE, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; fluxes.epc = .5
</span><span class="noop">        &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ei_ic_v1()
</span><span class="noop">
</span><span class="noop">        For glaciers (first zone) and internal lakes (second zone) the
</span><span class="noop">        interception routine does not apply.  Hence, no interception
</span><span class="noop">        evaporation can occur.  For fields and forests, the interception
</span><span class="noop">        routine is identical (usually, only larger capacities for forests
</span><span class="noop">        are assumed, due to their higher leaf area index).  Hence, the
</span><span class="noop">        results of the third and the second zone are equal.  The last
</span><span class="noop">        three zones demonstrate, that all interception evaporation is equal
</span><span class="noop">        to potential evaporation until the interception storage is empty;
</span><span class="noop">        afterwards, interception evaporation is zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 0.0, 0.0, 0.5, 1.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.ei
</span><span class="noop">        ei(0.0, 0.0, 0.0, 0.0, 0.5, 0.5)
</span><span class="noop">
</span><span class="noop">        A zero evaporation example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.epc = 0.
</span><span class="noop">        &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ei_ic_v1()
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 0.0, 0.0, 1.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.ei
</span><span class="noop">        ei(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        A high evaporation example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.epc = 5.
</span><span class="noop">        &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ei_ic_v1()
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.ei
</span><span class="noop">        ei(0.0, 0.0, 0.0, 0.0, 1.0, 2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">            flu.ei[k] = min(flu.epc[k], sta.ic[k])
</span><span class="hit">            sta.ic[k] -= flu.ei[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.ei[k] = 0.
</span><span class="hit">            sta.ic[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_sp_wc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Add throughfall to the snow layer.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TF`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.RfC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.SfC`
</span><span class="noop">
</span><span class="noop">    Updated state sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.WC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dSP}{dt} = TF \\cdot \\frac{SfC}{SfC+RfC}` \n
</span><span class="noop">      :math:`\\frac{dWC}{dt} = TF \\cdot \\frac{RfC}{SfC+RfC}`
</span><span class="noop">
</span><span class="noop">    Exemples:
</span><span class="noop">        Consider the following setting, in which eight zones of
</span><span class="noop">        different type receive a throughfall of 10mm:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(8)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; fluxes.tf = 10.
</span><span class="noop">        &gt;&gt;&gt; fluxes.sfc = .5, .5, .5, .5, .2, .8, 1., 4.
</span><span class="noop">        &gt;&gt;&gt; fluxes.rfc = .5, .5, .5, .5, .8, .2, 4., 1.
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 5.0, 5.0, 5.0, 2.0, 8.0, 2.0, 8.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 5.0, 5.0, 5.0, 8.0, 2.0, 8.0, 2.0)
</span><span class="noop">
</span><span class="noop">        The snow routine does not apply for internal lakes, which is why
</span><span class="noop">        both  the ice storage and the water storage of the first zone
</span><span class="noop">        remain unchanged.  The snow routine is identical for glaciers,
</span><span class="noop">        fields and forests in the current context, which is why the
</span><span class="noop">        results of the second, third, and fourth zone are equal.  The
</span><span class="noop">        last four zones illustrate that the corrected snowfall fraction
</span><span class="noop">        as well as the corrected rainfall fraction are applied in a
</span><span class="noop">        relative manner, as the total amount of water yield has been
</span><span class="noop">        corrected in the interception module already.
</span><span class="noop">
</span><span class="noop">        When both factors are zero, the neither the water nor the ice
</span><span class="noop">        content of the snow layer changes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.sfc = 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.rfc = 0.
</span><span class="noop">        &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if con.zonetype[k] != ILAKE:
</span><span class="hit">            if (flu.rfc[k]+flu.sfc[k]) &gt; 0.:
</span><span class="hit">                sta.wc[k] += flu.tf[k]*flu.rfc[k]/(flu.rfc[k]+flu.sfc[k])
</span><span class="hit">                sta.sp[k] += flu.tf[k]*flu.sfc[k]/(flu.rfc[k]+flu.sfc[k])
</span><span class="noop">        else:
</span><span class="hit">            sta.wc[k] = 0.
</span><span class="hit">            sta.sp[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_melt_sp_wc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate melting of the ice content within the snow layer and
</span><span class="noop">    update both the snow layers ice and the water content.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.CFMax`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_derived.TTM`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Melt`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">    Updatet state sequence:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_states.WC`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dSP}{dt} = - Melt` \n
</span><span class="noop">      :math:`\\frac{dWC}{dt} = + Melt` \n
</span><span class="noop">      :math:`Melt = min(cfmax \\cdot (TC-TTM), SP)` \n
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Six zones are initialized with the same threshold
</span><span class="noop">        temperature and degree day factor, but  with different zone types
</span><span class="noop">        and initial ice contents:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; cfmax(4.)
</span><span class="noop">        &gt;&gt;&gt; derived.ttm = 2.
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0., 10., 10., 10., 5., 0.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 2.
</span><span class="noop">
</span><span class="noop">        Note that the assumed length of the simulation step is only a
</span><span class="noop">        half day.  Hence the effective value of the degree day factor
</span><span class="noop">        is not 4 but 2:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cfmax
</span><span class="noop">        cfmax(4.0)
</span><span class="noop">        &gt;&gt;&gt; cfmax.values
</span><span class="noop">        array([ 2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">        When the actual temperature is equal to the threshold
</span><span class="noop">        temperature for melting and refreezing, no melting  occurs
</span><span class="noop">        and the states remain unchanged:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_melt_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.melt
</span><span class="noop">        melt(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 10.0, 10.0, 10.0, 5.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">
</span><span class="noop">        The same holds true for an actual temperature lower than the
</span><span class="noop">        threshold temperature:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0., 10., 10., 10., 5., 0.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = -1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_melt_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.melt
</span><span class="noop">        melt(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 10.0, 10.0, 10.0, 5.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">
</span><span class="noop">        With an actual temperature 3°C above the threshold temperature,
</span><span class="noop">        melting can occur. Actual melting is consistent with potential
</span><span class="noop">        melting, except for the first zone, which is an internal lake,
</span><span class="noop">        and the last two zones, for which potential melting exceeds the
</span><span class="noop">        available frozen water content of the snow layer:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0., 10., 10., 10., 5., 0.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_melt_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.melt
</span><span class="noop">        melt(0.0, 6.0, 6.0, 6.0, 5.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 4.0, 4.0, 4.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 8.0, 8.0, 8.0, 7.0, 2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if con.zonetype[k] != ILAKE:
</span><span class="hit">            if flu.tc[k] &gt; der.ttm[k]:
</span><span class="hit">                flu.melt[k] = min(con.cfmax[k] *
</span><span class="noop">                                  (flu.tc[k]-der.ttm[k]), sta.sp[k])
</span><span class="hit">                sta.sp[k] -= flu.melt[k]
</span><span class="hit">                sta.wc[k] += flu.melt[k]
</span><span class="noop">            else:
</span><span class="hit">                flu.melt[k] = 0.
</span><span class="noop">        else:
</span><span class="hit">            flu.melt[k] = 0.
</span><span class="hit">            sta.wc[k] = 0.
</span><span class="hit">            sta.sp[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_refr_sp_wc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate refreezing of the water content within the snow layer and
</span><span class="noop">    update both the snow layers ice and the water content.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.CFMax`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.CFR`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_derived.TTM`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Refr`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.WC`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dSP}{dt} =  + Refr` \n
</span><span class="noop">      :math:`\\frac{dWC}{dt} =  - Refr` \n
</span><span class="noop">      :math:`Refr = min(cfr \\cdot cfmax \\cdot (TTM-TC), WC)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Six zones are initialized with the same threshold
</span><span class="noop">        temperature, degree day factor and refreezing coefficient, but
</span><span class="noop">        with different zone types and initial states:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; cfmax(4.)
</span><span class="noop">        &gt;&gt;&gt; cfr(.1)
</span><span class="noop">        &gt;&gt;&gt; derived.ttm = 2.
</span><span class="noop">        &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0., 1., 1., 1., .5, 0.
</span><span class="noop">
</span><span class="noop">        Note that the assumed length of the simulation step is only
</span><span class="noop">        a half day.  Hence the effective value of the degree day
</span><span class="noop">        factor is not 4 but 2:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cfmax
</span><span class="noop">        cfmax(4.0)
</span><span class="noop">        &gt;&gt;&gt; cfmax.values
</span><span class="noop">        array([ 2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">        When the actual temperature is equal to the threshold
</span><span class="noop">        temperature for melting and refreezing, neither no refreezing
</span><span class="noop">        occurs and the states remain unchanged:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_refr_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.refr
</span><span class="noop">        refr(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 1.0, 1.0, 1.0, 0.5, 0.0)
</span><span class="noop">
</span><span class="noop">        The same holds true for an actual temperature higher than the
</span><span class="noop">        threshold temperature:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0., 1., 1., 1., .5, 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_refr_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.refr
</span><span class="noop">        refr(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 1.0, 1.0, 1.0, 0.5, 0.0)
</span><span class="noop">
</span><span class="noop">        With an actual temperature 3°C above the threshold temperature,
</span><span class="noop">        only melting can occur. Actual melting is consistent with
</span><span class="noop">        potential melting, except for the first zone, which is an
</span><span class="noop">        internal lake, and the last two zones, for which potential
</span><span class="noop">        melting exceeds the available frozen water content of the
</span><span class="noop">        snow layer:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0., 1., 1., 1., .5, 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_refr_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.refr
</span><span class="noop">        refr(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 1.0, 1.0, 1.0, 0.5, 0.0)
</span><span class="noop">
</span><span class="noop">        With an actual temperature 3°C below the threshold temperature,
</span><span class="noop">        refreezing can occur. Actual refreezing is consistent with
</span><span class="noop">        potential refreezing, except for the first zone, which is an
</span><span class="noop">        internal lake, and the last two zones, for which potential
</span><span class="noop">        refreezing exceeds the available liquid water content of the
</span><span class="noop">        snow layer:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0., 1., 1., 1., .5, 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = -1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_refr_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.refr
</span><span class="noop">        refr(0.0, 0.6, 0.6, 0.6, 0.5, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 2.6, 2.6, 2.6, 2.5, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 0.4, 0.4, 0.4, 0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if con.zonetype[k] != ILAKE:
</span><span class="hit">            if flu.tc[k] &lt; der.ttm[k]:
</span><span class="hit">                flu.refr[k] = min(con.cfr[k]*con.cfmax[k] *
</span><span class="noop">                                  (der.ttm[k]-flu.tc[k]), sta.wc[k])
</span><span class="hit">                sta.sp[k] += flu.refr[k]
</span><span class="hit">                sta.wc[k] -= flu.refr[k]
</span><span class="noop">            else:
</span><span class="hit">                flu.refr[k] = 0.
</span><span class="noop">
</span><span class="noop">        else:
</span><span class="hit">            flu.refr[k] = 0.
</span><span class="hit">            sta.wc[k] = 0.
</span><span class="hit">            sta.sp[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_in_wc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual water release from the snow layer due to the
</span><span class="noop">    exceedance of the snow layers capacity for (liquid) water.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.WHC`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">    Required flux sequence
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TF`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.In_`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.WC`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dWC}{dt} = -In` \n
</span><span class="noop">      :math:`-In = max(WC - WHC \\cdot SP, 0)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize six zones of different types and frozen water
</span><span class="noop">        contents of the snow layer and set the relative water holding
</span><span class="noop">        capacity to 20% of the respective frozen water content:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; whc(.2)
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0., 10., 10., 10., 5., 0.
</span><span class="noop">
</span><span class="noop">        Also set the actual value of stand precipitation to 5 mm/d:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tf = 5.
</span><span class="noop">
</span><span class="noop">        When there is no (liquid) water content in the snow layer, no water
</span><span class="noop">        can be released:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_in_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.in_
</span><span class="noop">        in_(5.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        When there is a (liquid) water content in the snow layer, the water
</span><span class="noop">        release depends on the frozen water content.  Note the special
</span><span class="noop">        cases of the first zone beeing an internal lake, for which the snow
</span><span class="noop">        routine does not apply, and of the last zone, which has no ice
</span><span class="noop">        content and thus effectively not really a snow layer:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.wc = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_in_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.in_
</span><span class="noop">        in_(5.0, 3.0, 3.0, 3.0, 4.0, 5.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 2.0, 2.0, 2.0, 1.0, 0.0)
</span><span class="noop">
</span><span class="noop">        When the relative water holding capacity is assumed to be zero,
</span><span class="noop">        all liquid water is released:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; whc(0.)
</span><span class="noop">        &gt;&gt;&gt; states.wc = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_in_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.in_
</span><span class="noop">        in_(5.0, 5.0, 5.0, 5.0, 5.0, 5.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        Note that for the single lake zone, stand precipitation is
</span><span class="noop">        directly passed to `in_` in all three examples.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if con.zonetype[k] != ILAKE:
</span><span class="hit">            flu.in_[k] = max(sta.wc[k]-con.whc[k]*sta.sp[k], 0.)
</span><span class="hit">            sta.wc[k] -= flu.in_[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.in_[k] = flu.tf[k]
</span><span class="hit">            sta.wc[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_glmelt_in_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate melting from glaciers which are actually not covered by
</span><span class="noop">    a snow layer and add it to the water release of the snow module.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.GMelt`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.GlMelt`
</span><span class="noop">
</span><span class="noop">    Updated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.In_`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">
</span><span class="noop">      :math:`GlMelt = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {max(GMelt \\cdot (TC-TTM), 0) \\ | \\ SP = 0}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ SP &gt; 0}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Seven zones are prepared, but glacier melting occurs only
</span><span class="noop">        in the fourth one, as the first three zones are no glaciers, the
</span><span class="noop">        fifth zone is covered by a snow layer and the actual temperature
</span><span class="noop">        of the last two zones is not above the threshold temperature:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FOREST, ILAKE, GLACIER, GLACIER, GLACIER, GLACIER)
</span><span class="noop">        &gt;&gt;&gt; gmelt(4.)
</span><span class="noop">        &gt;&gt;&gt; derived.ttm(2.)
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0., 0., 0., 0., .1, 0., 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 3., 3., 3., 3., 3., 2., 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.in_ = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_glmelt_in_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.glmelt
</span><span class="noop">        glmelt(0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.in_
</span><span class="noop">        in_(3.0, 3.0, 3.0, 5.0, 3.0, 3.0, 3.0)
</span><span class="noop">
</span><span class="noop">        Note that the assumed length of the simulation step is only
</span><span class="noop">        a half day. Hence the effective value of the degree day factor
</span><span class="noop">        is not 4 but 2:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; gmelt
</span><span class="noop">        gmelt(4.0)
</span><span class="noop">        &gt;&gt;&gt; gmelt.values
</span><span class="noop">        array([ 2.,  2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if ((con.zonetype[k] == GLACIER) and
</span><span class="noop">                (sta.sp[k] &lt;= 0.) and (flu.tc[k] &gt; der.ttm[k])):
</span><span class="hit">            flu.glmelt[k] = con.gmelt[k]*(flu.tc[k]-der.ttm[k])
</span><span class="hit">            flu.in_[k] += flu.glmelt[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.glmelt[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_r_sm_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate effective precipitation and update soil moisture.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.FC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.Beta`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.In_`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.R`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SM`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dSM}{dt} = IN - R` \n
</span><span class="noop">      :math:`R = IN \\cdot \\left(\\frac{SM}{FC}\\right)^{Beta}`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize six zones of different types.  The field
</span><span class="noop">        capacity of all fields and forests is set to 200mm, the input
</span><span class="noop">        of each zone is 10mm:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; fc(200.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.in_ = 10.
</span><span class="noop">
</span><span class="noop">        With a common nonlinearity parameter value of 2, a relative
</span><span class="noop">        soil moisture of 50%  (zones three and four) results in a
</span><span class="noop">        discharge coefficient of 25%. For a soil completely dried
</span><span class="noop">        (zone five) or completely saturated (one six) the discharge
</span><span class="noop">        coefficient does not depend on the nonlinearity parameter and
</span><span class="noop">        is 0% and 100% respectively.  Glaciers and internal lakes also
</span><span class="noop">        always route 100% of their input as effective precipitation:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; beta(2.)
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; model.calc_r_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.r
</span><span class="noop">        r(10.0, 10.0, 2.5, 2.5, 0.0, 10.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 107.5, 107.5, 10.0, 200.0)
</span><span class="noop">
</span><span class="noop">        Through decreasing the nonlinearity parameter, the discharge
</span><span class="noop">        coefficient increases.  A parameter value of zero leads to a
</span><span class="noop">        discharge coefficient of 100% for any soil moisture:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; beta(0.)
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; model.calc_r_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.r
</span><span class="noop">        r(10.0, 10.0, 10.0, 10.0, 10.0, 10.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 100.0, 100.0, 0.0, 200.0)
</span><span class="noop">
</span><span class="noop">        With zero field capacity, the discharge coefficient also always
</span><span class="noop">        equates to 100%:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fc(0.)
</span><span class="noop">        &gt;&gt;&gt; beta(2.)
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_r_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.r
</span><span class="noop">        r(10.0, 10.0, 10.0, 10.0, 10.0, 10.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">            if con.fc[k] &gt; 0.:
</span><span class="hit">                flu.r[k] = flu.in_[k]*(sta.sm[k]/con.fc[k])**con.beta[k]
</span><span class="hit">                flu.r[k] = max(flu.r[k], sta.sm[k]+flu.in_[k]-con.fc[k])
</span><span class="noop">            else:
</span><span class="hit">                flu.r[k] = flu.in_[k]
</span><span class="hit">            sta.sm[k] += flu.in_[k]-flu.r[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.r[k] = flu.in_[k]
</span><span class="hit">            sta.sm[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_cf_sm_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate capillary flow and update soil moisture.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.FC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.CFlux`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.R`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.UZ`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.CF`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SM`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dSM}{dt} = CF` \n
</span><span class="noop">      :math:`CF = CFLUX \\cdot (1 - \\frac{SM}{FC})`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize six zones of different types.  The field
</span><span class="noop">        capacity of als fields and forests is set to 200mm, the maximum
</span><span class="noop">        capillary flow rate is 4mm/d:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; fc(200.)
</span><span class="noop">        &gt;&gt;&gt; cflux(4.)
</span><span class="noop">
</span><span class="noop">        Note that the assumed length of the simulation step is only
</span><span class="noop">        a half day.  Hence the maximum capillary flow per simulation
</span><span class="noop">        step is 2 instead of 4:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cflux
</span><span class="noop">        cflux(4.0)
</span><span class="noop">        &gt;&gt;&gt; cflux.values
</span><span class="noop">        array([ 2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">        For fields and forests, the actual capillary return flow depends
</span><span class="noop">        on the relative soil moisture deficite, if either the upper zone
</span><span class="noop">        layer provides enough water...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.r = 0.
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; states.uz = 20.
</span><span class="noop">        &gt;&gt;&gt; model.calc_cf_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf
</span><span class="noop">        cf(0.0, 0.0, 1.0, 1.0, 2.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 101.0, 101.0, 2.0, 200.0)
</span><span class="noop">
</span><span class="noop">        ...our enough effective precipitation is generated, which can be
</span><span class="noop">        rerouted directly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cflux(4.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.r = 10.
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; states.uz = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_cf_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf
</span><span class="noop">        cf(0.0, 0.0, 1.0, 1.0, 2.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 101.0, 101.0, 2.0, 200.0)
</span><span class="noop">
</span><span class="noop">        If the upper zone layer is empty and no effective precipitation is
</span><span class="noop">        generated, capillary flow is zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cflux(4.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.r = 0.
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; states.uz = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_cf_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf
</span><span class="noop">        cf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 100.0, 100.0, 0.0, 200.0)
</span><span class="noop">
</span><span class="noop">        Here an example, where both the upper zone layer and effective
</span><span class="noop">        precipitation provide water for the capillary flow, but less then
</span><span class="noop">        the maximum flow rate times the relative soil moisture:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cflux(4.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.r = 0.1
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; states.uz = 0.2
</span><span class="noop">        &gt;&gt;&gt; model.calc_cf_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf
</span><span class="noop">        cf(0.0, 0.0, 0.3, 0.3, 0.3, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 100.3, 100.3, 0.3, 200.0)
</span><span class="noop">
</span><span class="noop">        Even unrealistic high maximum capillary flow rates do not result
</span><span class="noop">        in overfilled soils:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cflux(1000.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.r = 200.
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; states.uz = 200.
</span><span class="noop">        &gt;&gt;&gt; model.calc_cf_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf
</span><span class="noop">        cf(0.0, 0.0, 100.0, 100.0, 200.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 200.0, 200.0, 200.0, 200.0)
</span><span class="noop">
</span><span class="noop">        For (unrealistic) soils with zero field capacity, capillary flow
</span><span class="noop">        is always zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fc(0.)
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_cf_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf
</span><span class="noop">        cf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">            if con.fc[k] &gt; 0.:
</span><span class="hit">                flu.cf[k] = con.cflux[k]*(1.-sta.sm[k]/con.fc[k])
</span><span class="hit">                flu.cf[k] = min(flu.cf[k], sta.uz+flu.r[k])
</span><span class="hit">                flu.cf[k] = min(flu.cf[k], con.fc[k]-sta.sm[k])
</span><span class="noop">            else:
</span><span class="hit">                flu.cf[k] = 0.
</span><span class="hit">            sta.sm[k] += flu.cf[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.cf[k] = 0.
</span><span class="hit">            sta.sm[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_ea_sm_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate soil evaporation and update soil moisture.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.FC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.LP`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ERed`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EPC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EI`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EA`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SM`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dSM}{dt} = - EA` \n
</span><span class="noop">      :math:`EA_{temp} = \\biggl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {EPC \\cdot min\\left(\\frac{SM}{LP \\cdot FC}, 1\\right)
</span><span class="noop">      \\ | \\ SP = 0}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ SP &gt; 0}
</span><span class="noop">      }` \n
</span><span class="noop">      :math:`EA = EA_{temp} - max(ERED \\cdot (EA_{temp} + EI - EPC), 0)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize seven zones of different types.  The field capacity
</span><span class="noop">         of all fields and forests is set to 200mm, potential evaporation
</span><span class="noop">         and interception evaporation are 2mm and 1mm respectively:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; fc(200.)
</span><span class="noop">        &gt;&gt;&gt; lp(.0, .0, .5, .5, .0, .8, 1.)
</span><span class="noop">        &gt;&gt;&gt; ered(0.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.epc = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.ei = 1.
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0.
</span><span class="noop">
</span><span class="noop">        Only fields and forests include soils; for glaciers and zones (the
</span><span class="noop">        first two zones) no soil evaporation is performed.  For fields and
</span><span class="noop">        forests, the underlying calculations are the same. In the following
</span><span class="noop">        example, the relative soil moisture is 50% in all field and forest
</span><span class="noop">        zones.  Hence, differences in soil evaporation are related to the
</span><span class="noop">        different soil evaporation parameter values only:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ea_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ea
</span><span class="noop">        ea(0.0, 0.0, 2.0, 2.0, 2.0, 1.25, 1.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 98.0, 98.0, 98.0, 98.75, 99.0)
</span><span class="noop">
</span><span class="noop">        In the last example, evaporation values of 2mm have been calculated
</span><span class="noop">        for some zones despite the fact, that these 2mm added to the actual
</span><span class="noop">        interception evaporation of 1mm exceed potential evaporation.  This
</span><span class="noop">        behaviour can be reduced...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">        &gt;&gt;&gt; ered(.5)
</span><span class="noop">        &gt;&gt;&gt; model.calc_ea_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ea
</span><span class="noop">        ea(0.0, 0.0, 1.5, 1.5, 1.5, 1.125, 1.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 98.5, 98.5, 98.5, 98.875, 99.0)
</span><span class="noop">
</span><span class="noop">        ...or be completely excluded:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">        &gt;&gt;&gt; ered(1.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_ea_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ea
</span><span class="noop">        ea(0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 99.0, 99.0, 99.0, 99.0, 99.0)
</span><span class="noop">
</span><span class="noop">        Any occurence of a snow layer suppresses soil evaporation
</span><span class="noop">        completely:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0.01
</span><span class="noop">        &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ea_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ea
</span><span class="noop">        ea(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 100.0, 100.0, 100.0, 100.0, 100.0)
</span><span class="noop">
</span><span class="noop">        For (unrealistic) soils with zero field capacity, soil evaporation
</span><span class="noop">        is always zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fc(0.)
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ea_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ea
</span><span class="noop">        ea(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">            if sta.sp[k] &lt;= 0.:
</span><span class="hit">                if (con.lp[k]*con.fc[k]) &gt; 0.:
</span><span class="hit">                    flu.ea[k] = flu.epc[k]*sta.sm[k]/(con.lp[k]*con.fc[k])
</span><span class="hit">                    flu.ea[k] = min(flu.ea[k], flu.epc[k])
</span><span class="noop">                else:
</span><span class="hit">                    flu.ea[k] = flu.epc[k]
</span><span class="hit">                flu.ea[k] -= max(con.ered[k] *
</span><span class="noop">                                 (flu.ea[k]+flu.ei[k]-flu.epc[k]), 0.)
</span><span class="hit">                flu.ea[k] = min(flu.ea[k], sta.sm[k])
</span><span class="noop">            else:
</span><span class="hit">                flu.ea[k] = 0.
</span><span class="hit">            sta.sm[k] -= flu.ea[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.ea[k] = 0.
</span><span class="hit">            sta.sm[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_inuz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Accumulate the total inflow into the upper zone layer.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_derived.RelLandZoneArea`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.R`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.CF`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.InUZ`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`InUZ = R - CF`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize three zones of different relative `land sizes`
</span><span class="noop">        (area related to the total size of the subbasin except lake areas):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(3)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, ILAKE, GLACIER)
</span><span class="noop">        &gt;&gt;&gt; derived.rellandzonearea = 2./3., 0., 1./3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.r = 6., 0., 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf = 2., 0., 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_inuz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuz
</span><span class="noop">        inuz(3.0)
</span><span class="noop">
</span><span class="noop">        Internal lakes do not contribute to the upper zone layer.  Hence
</span><span class="noop">        for a subbasin consisting only of interal lakes a zero input
</span><span class="noop">        value would be calculated:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, ILAKE, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; model.calc_inuz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuz
</span><span class="noop">        inuz(0.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.inuz = 0.
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if con.zonetype[k] != ILAKE:
</span><span class="hit">            flu.inuz += der.rellandzonearea[k]*(flu.r[k]-flu.cf[k])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_contriarea_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Determine the relative size of the contributing area of the whole
</span><span class="noop">    subbasin.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.RespArea`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.FC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.Beta`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">    :class:`~hydpy.models.hland.hland_derived.RelSoilArea`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SM`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.ContriArea`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`ContriArea = \\left( \\frac{SM}{FC} \\right)^{Beta}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Four zones are initialized, but only the first two zones
</span><span class="noop">        of type field and forest are taken into account in the calculation
</span><span class="noop">        of the relative contributing area of the catchment (even, if also
</span><span class="noop">        glaciers contribute to the inflow of the upper zone layer):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(4)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; beta(2.)
</span><span class="noop">        &gt;&gt;&gt; fc(200.)
</span><span class="noop">        &gt;&gt;&gt; resparea(True)
</span><span class="noop">        &gt;&gt;&gt; derived.relsoilarea(.5)
</span><span class="noop">        &gt;&gt;&gt; derived.relsoilzonearea(1./3., 2./3., 0., 0.)
</span><span class="noop">
</span><span class="noop">        With a relative soil moisture of 100% in the whole subbasin, the
</span><span class="noop">        contributing area is also estimated as 100%,...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sm = 200.
</span><span class="noop">        &gt;&gt;&gt; model.calc_contriarea_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">        contriarea(1.0)
</span><span class="noop">
</span><span class="noop">        ...and relative soil moistures of 0% result in an contributing
</span><span class="noop">        area of 0%:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_contriarea_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">        contriarea(0.0)
</span><span class="noop">
</span><span class="noop">        With the given value 2 of the nonlinearity parameter Beta, soil
</span><span class="noop">        moisture of 50% results in a contributing area estimate of 25%:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">        &gt;&gt;&gt; model.calc_contriarea_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">        contriarea(0.25)
</span><span class="noop">
</span><span class="noop">        Setting the response area option to False,...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; resparea(False)
</span><span class="noop">        &gt;&gt;&gt; model.calc_contriarea_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">        contriarea(1.0)
</span><span class="noop">
</span><span class="noop">        ... setting the soil area (total area of all field and forest
</span><span class="noop">        zones in the subbasin) to zero...,
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; resparea(True)
</span><span class="noop">        &gt;&gt;&gt; derived.relsoilarea(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_contriarea_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">        contriarea(1.0)
</span><span class="noop">
</span><span class="noop">        ...or setting all field capacities to zero...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.relsoilarea(.5)
</span><span class="noop">        &gt;&gt;&gt; fc(0.)
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_contriarea_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">        contriarea(1.0)
</span><span class="noop">
</span><span class="noop">        ...leads to contributing area values of 100%.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    if con.resparea and (der.relsoilarea &gt; 0.):
</span><span class="hit">        flu.contriarea = 0.
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">                if con.fc[k] &gt; 0.:
</span><span class="hit">                    flu.contriarea += (der.relsoilzonearea[k] *
</span><span class="noop">                                       (sta.sm[k]/con.fc[k])**con.beta[k])
</span><span class="noop">                else:
</span><span class="hit">                    flu.contriarea += der.relsoilzonearea[k]
</span><span class="noop">    else:
</span><span class="hit">        flu.contriarea = 1.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_q0_perc_uz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Perform the upper zone layer routine which determines percolation
</span><span class="noop">    to the lower zone layer and the fast response of the hland model.
</span><span class="noop">    Note that the system behaviour of this method depends strongly on the
</span><span class="noop">    specifications of the options :class:`RespArea` and :class:`RecStep`.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.RecStep`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.PercMax`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.K`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.Alpha`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.DT`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.InUZ`
</span><span class="noop">
</span><span class="noop">    Used Aide sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_aides.Perc`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_aides.Q0`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Perc`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Q0`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.UZ`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dUZ}{dt} = InUZ - Perc - Q0` \n
</span><span class="noop">      :math:`Perc = PercMax \\cdot ContriArea` \n
</span><span class="noop">      :math:`Q0 = \\left( \\frac{UZ}{ContriArea} \\right)^{1+Alpha}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        The upper zone layer routine is an exception compared to
</span><span class="noop">        the other routines of the HydPy-H-Land model, regarding its
</span><span class="noop">        consideration of numerical accuracy.  To increase the accuracy of
</span><span class="noop">        the numerical integration of the underlying ordinary differential
</span><span class="noop">        equation, each simulation step can be devided into substeps, which
</span><span class="noop">        are all solved with first order accuracy.  In the first example,
</span><span class="noop">        this option is omitted through setting the RecStep parameter to one:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; recstep(2)
</span><span class="noop">        &gt;&gt;&gt; derived.dt = 1./recstep
</span><span class="noop">        &gt;&gt;&gt; percmax(2.)
</span><span class="noop">        &gt;&gt;&gt; alpha(1.)
</span><span class="noop">        &gt;&gt;&gt; k(2.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea = 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuz = 0.
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(1.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.0)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.0)
</span><span class="noop">
</span><span class="noop">        Due to the sequential calculation of the upper zone routine, the
</span><span class="noop">        upper zone storage is drained completely through percolation and
</span><span class="noop">        no water is left for fast discharge response.  By dividing the
</span><span class="noop">        simulation step in 100 substeps, the results are quite different:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; recstep(200)
</span><span class="noop">        &gt;&gt;&gt; derived.dt = 1./recstep
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(0.786934)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.213066)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.0)
</span><span class="noop">
</span><span class="noop">        Note that the assumed length of the simulation step is only a
</span><span class="noop">        half day. Hence the effective values of the maximum percolation
</span><span class="noop">        rate and the storage coefficient is not 2 but 1:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; percmax
</span><span class="noop">        percmax(2.0)
</span><span class="noop">        &gt;&gt;&gt; k
</span><span class="noop">        k(2.0)
</span><span class="noop">        &gt;&gt;&gt; percmax.value
</span><span class="noop">        1.0
</span><span class="noop">        &gt;&gt;&gt; k.value
</span><span class="noop">        1.0
</span><span class="noop">
</span><span class="noop">        By decreasing the contributing area one decreases percolation but
</span><span class="noop">        increases fast discharge response:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea = .5
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(0.434108)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.565892)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.0)
</span><span class="noop">
</span><span class="noop">        Resetting RecStep leads to more transparent results.  Note that, due
</span><span class="noop">        to the large value of the storage coefficient and the low accuracy
</span><span class="noop">        of the numerical approximation, direct discharge drains the rest of
</span><span class="noop">        the upper zone storage:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; recstep(2)
</span><span class="noop">        &gt;&gt;&gt; derived.dt = 1./recstep
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(0.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.5)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.0)
</span><span class="noop">
</span><span class="noop">        Applying a more reasonable storage coefficient results in:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; k(.5)
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(0.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.25)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.25)
</span><span class="noop">
</span><span class="noop">        Adding an input of 0.3 mm results the same percolation value (which,
</span><span class="noop">        in the given example, is determined by the maximum percolation rate
</span><span class="noop">        only), but in an increases value of the direct response (which
</span><span class="noop">        always depends on the actual upper zone storage directly):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuz = .3
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(0.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.64)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.16)
</span><span class="noop">
</span><span class="noop">        Due to the same reasons, another increase in numerical accuracy has
</span><span class="noop">        no impact on percolation but decreases the direct response in the
</span><span class="noop">        given example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; recstep(200)
</span><span class="noop">        &gt;&gt;&gt; derived.dt = 1./recstep
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(0.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.421708)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.378292)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    flu.perc = 0.
</span><span class="hit">    flu.q0 = 0.
</span><span class="hit">    for jdx in range(con.recstep):
</span><span class="noop">        # First state update related to the upper zone input.
</span><span class="hit">        sta.uz += der.dt*flu.inuz
</span><span class="noop">        # Second state update related to percolation.
</span><span class="hit">        aid.perc = min(der.dt*con.percmax*flu.contriarea, sta.uz)
</span><span class="hit">        sta.uz -= aid.perc
</span><span class="hit">        flu.perc += aid.perc
</span><span class="noop">        # Third state update related to fast runoff response.
</span><span class="hit">        if sta.uz &gt; 0.:
</span><span class="hit">            if flu.contriarea &gt; 0.:
</span><span class="hit">                aid.q0 = (der.dt*con.k *
</span><span class="noop">                          (sta.uz/flu.contriarea)**(1.+con.alpha))
</span><span class="hit">                aid.q0 = min(aid.q0, sta.uz)
</span><span class="noop">            else:
</span><span class="miss">                aid.q0 = sta.uz
</span><span class="hit">            sta.uz -= aid.q0
</span><span class="hit">            flu.q0 += aid.q0
</span><span class="noop">        else:
</span><span class="hit">            aid.q0 = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_lz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the lower zone layer in accordance with percolation from
</span><span class="noop">    upper groundwater to lower groundwater and/or in accordance with
</span><span class="noop">    lake precipitation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.RelLandArea`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.RelZoneArea`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.PC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Perc`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.LZ`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`\\frac{dLZ}{dt} = Perc + Pc`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        At first, a subbasin with two field zones is assumed (the zones
</span><span class="noop">        could be of type forest or glacier as well).  In such zones,
</span><span class="noop">        precipitation does not fall directly into the lower zone layer,
</span><span class="noop">        hence the given precipitation of 2mm has no impact.  Only
</span><span class="noop">        the actual percolation from the upper zone layer (underneath
</span><span class="noop">        both field zones) is added to the lower zone storage:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(2)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; derived.rellandarea = 1.
</span><span class="noop">        &gt;&gt;&gt; derived.relzonearea = 2./3., 1./3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.pc = 5.
</span><span class="noop">        &gt;&gt;&gt; states.lz = 10.
</span><span class="noop">        &gt;&gt;&gt; model.calc_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(12.0)
</span><span class="noop">
</span><span class="noop">        If the second zone is an internal lake, its precipitation falls
</span><span class="noop">        on the lower zone layer directly.  Note that only 5/3mm
</span><span class="noop">        precipitation are added, due to the relative size of the
</span><span class="noop">        internal lake within the subbasin. Percolation from the upper
</span><span class="noop">        zone layer increases the lower zone storage only by two thirds
</span><span class="noop">        of its original value, due to the larger spatial extend of
</span><span class="noop">        the lower zone layer:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; derived.rellandarea = 2./3.
</span><span class="noop">        &gt;&gt;&gt; derived.relzonearea = 2./3., 1./3.
</span><span class="noop">        &gt;&gt;&gt; states.lz = 10.
</span><span class="noop">        &gt;&gt;&gt; model.calc_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(13.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    sta.lz += der.rellandarea*flu.perc
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if con.zonetype[k] == ILAKE:
</span><span class="hit">            sta.lz += der.relzonearea[k]*flu.pc[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_el_lz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate lake evaporation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.TTIce`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.RelZoneArea`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequences:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.EPC`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_states.LZ`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">        :math:`\\frac{dLZ}{dt} = -EL` \n
</span><span class="noop">        :math:`EL = \\Bigl \\lbrace
</span><span class="noop">        {
</span><span class="noop">        {EPC \\ | \\ TC &gt; TTIce}
</span><span class="noop">        \\atop
</span><span class="noop">        {0 \\ | \\ TC \\leq TTIce}
</span><span class="noop">        }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Six zones of the same size are initialized.  The first three
</span><span class="noop">        zones are no internal lakes, they can not exhibit any lake
</span><span class="noop">        evaporation.  Of the last three zones, which are internal lakes,
</span><span class="noop">        only the last one evaporates water.  For zones five and six,
</span><span class="noop">        evaporation is suppressed due to an assumed ice layer, whenever
</span><span class="noop">        the associated theshold temperature is not exceeded:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE, ILAKE, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; ttice(-1.)
</span><span class="noop">        &gt;&gt;&gt; derived.relzonearea = 1./6.
</span><span class="noop">        &gt;&gt;&gt; fluxes.epc = .6
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 0., 0., 0., 0., -1., -2.
</span><span class="noop">        &gt;&gt;&gt; states.lz = 10.
</span><span class="noop">        &gt;&gt;&gt; model.calc_el_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.el
</span><span class="noop">        el(0.0, 0.0, 0.0, 0.6, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(9.9)
</span><span class="noop">
</span><span class="noop">        Note that internal lakes always contain water.  Hence, the
</span><span class="noop">        HydPy-H-Land model allows for negative values of the lower
</span><span class="noop">        zone storage:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.lz = .05
</span><span class="noop">        &gt;&gt;&gt; model.calc_el_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.el
</span><span class="noop">        el(0.0, 0.0, 0.0, 0.6, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(-0.05)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if (con.zonetype[k] == ILAKE) and (flu.tc[k] &gt; con.ttice[k]):
</span><span class="hit">            flu.el[k] = flu.epc[k]
</span><span class="hit">            sta.lz -= der.relzonearea[k]*flu.el[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.el[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_q1_lz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the slow response of the lower zone layer.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.K4`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.Gamma`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequence:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.Q1`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_states.LZ`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">        :math:`\\frac{dLZ}{dt} = -Q1` \n
</span><span class="noop">        :math:`Q1 = \\Bigl \\lbrace
</span><span class="noop">        {
</span><span class="noop">        {K4 \\cdot LZ^{1+Gamma} \\ | \\ LZ &gt; 0}
</span><span class="noop">        \\atop
</span><span class="noop">        {0 \\ | \\ LZ\\leq 0}
</span><span class="noop">        }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        As long as the lower zone storage is negative...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; k4(.2)
</span><span class="noop">        &gt;&gt;&gt; gamma(0.)
</span><span class="noop">        &gt;&gt;&gt; states.lz = -2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q1_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q1
</span><span class="noop">        q1(0.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(-2.0)
</span><span class="noop">
</span><span class="noop">        ...or zero, no slow discharge response occurs:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.lz = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q1_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q1
</span><span class="noop">        q1(0.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(0.0)
</span><span class="noop">
</span><span class="noop">        For storage values above zero the linear...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.lz = 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q1_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q1
</span><span class="noop">        q1(0.2)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(1.8)
</span><span class="noop">
</span><span class="noop">        ...or nonlinear storage routing equation applies:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; gamma(1.)
</span><span class="noop">        &gt;&gt;&gt; states.lz = 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q1_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q1
</span><span class="noop">        q1(0.4)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(1.6)
</span><span class="noop">
</span><span class="noop">        Note that the assumed length of the simulation step is only a
</span><span class="noop">        half day. Hence the effective value of the storage coefficient
</span><span class="noop">        is not 0.2 but 0.1:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; k4
</span><span class="noop">        k4(0.2)
</span><span class="noop">        &gt;&gt;&gt; k4.value
</span><span class="noop">        0.1
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    if sta.lz &gt; 0.:
</span><span class="hit">        flu.q1 = con.k4*sta.lz**(1.+con.gamma)
</span><span class="noop">    else:
</span><span class="hit">        flu.q1 = 0.
</span><span class="hit">    sta.lz -= flu.q1
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_inuh_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the unit hydrograph input.
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_derived.RelLandArea`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Q0`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Q1`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.InUH`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">        :math:`InUH = Q0 + Q1`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        The unit hydrographs receives base flow from the whole subbasin
</span><span class="noop">        and direct flow from zones of type field, forest and glacier only.
</span><span class="noop">        In the following example, these occupy only one half of the
</span><span class="noop">        subbasin, which is why the partial input of q0 is halved:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.rellandarea = 0.5
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0 = 4.
</span><span class="noop">        &gt;&gt;&gt; fluxes.q1 = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_inuh_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuh
</span><span class="noop">        inuh(3.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.inuh = der.rellandarea*flu.q0+flu.q1
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_outuh_quh_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the unit hydrograph output (convolution).
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_derived.UH`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_derived.NmbUH`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.Q0`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.Q1`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.InUH`
</span><span class="noop">
</span><span class="noop">    Updated log sequence:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_logs.QUH`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.OutUH`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Prepare a unit hydrograph with only three ordinates ---
</span><span class="noop">        representing a fast catchment response compared to the selected
</span><span class="noop">        step size:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.nmbuh = 3
</span><span class="noop">        &gt;&gt;&gt; derived.uh.shape = derived.nmbuh
</span><span class="noop">        &gt;&gt;&gt; derived.uh = 0.3, 0.5, 0.2
</span><span class="noop">        &gt;&gt;&gt; logs.quh.shape = 3
</span><span class="noop">        &gt;&gt;&gt; logs.quh = 1., 3., 0.
</span><span class="noop">
</span><span class="noop">        Without new input, the actual output is simply the first value
</span><span class="noop">        stored in the logging sequence and the values of the logging
</span><span class="noop">        sequence are shifted to the left:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuh = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outuh_quh_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">        outuh(1.0)
</span><span class="noop">        &gt;&gt;&gt; logs.quh
</span><span class="noop">        quh(3.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        With an new input of 4mm, the actual output consists of the first
</span><span class="noop">        value stored in the logging sequence and the input value
</span><span class="noop">        multiplied with the first unit hydrograph ordinate.  The updated
</span><span class="noop">        logging sequence values result from the multiplication of the
</span><span class="noop">        input values and the remaining ordinates:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuh = 4.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outuh_quh_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">        outuh(4.2)
</span><span class="noop">        &gt;&gt;&gt; logs.quh
</span><span class="noop">        quh(2.0, 0.8, 0.0)
</span><span class="noop">
</span><span class="noop">        The next example demonstates the updating of non empty logging
</span><span class="noop">        sequence:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuh = 4.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outuh_quh_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">        outuh(3.2)
</span><span class="noop">        &gt;&gt;&gt; logs.quh
</span><span class="noop">        quh(2.8, 0.8, 0.0)
</span><span class="noop">
</span><span class="noop">        A unit hydrograph with only one ordinate results in the direct
</span><span class="noop">        routing of the input:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.nmbuh = 1
</span><span class="noop">        &gt;&gt;&gt; derived.uh.shape = derived.nmbuh
</span><span class="noop">        &gt;&gt;&gt; derived.uh = 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuh = 0.
</span><span class="noop">        &gt;&gt;&gt; logs.quh.shape = 1
</span><span class="noop">        &gt;&gt;&gt; logs.quh = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outuh_quh_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">        outuh(0.0)
</span><span class="noop">        &gt;&gt;&gt; logs.quh
</span><span class="noop">        quh(0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuh = 4.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outuh_quh()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">        outuh(4.0)
</span><span class="noop">        &gt;&gt;&gt; logs.quh
</span><span class="noop">        quh(0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    log = self.sequences.logs.fastaccess
</span><span class="hit">    flu.outuh = der.uh[0]*flu.inuh+log.quh[0]
</span><span class="hit">    for jdx in range(1, der.nmbuh):
</span><span class="hit">        log.quh[jdx-1] = der.uh[jdx]*flu.inuh+log.quh[jdx]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qt_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calcutate the total discharge after possible abstractions.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.Abstr`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.OutUH`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.QT`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">        :math:`QT = max(OutUH - Abstr, 0)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Trying to abstract less then available, as much as available and
</span><span class="noop">        less then available results in:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; abstr(2.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh = 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qt_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qt
</span><span class="noop">        qt(1.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qt_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qt
</span><span class="noop">        qt(0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh = .5
</span><span class="noop">        &gt;&gt;&gt; model.calc_qt_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qt
</span><span class="noop">        qt(0.0)
</span><span class="noop">
</span><span class="noop">        Note that &#34;negative abstractions&#34; are allowed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; abstr(-2.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qt_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qt
</span><span class="noop">        qt(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.qt = max(flu.outuh-con.abstr, 0.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_q_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the outlet link sequence.&#34;&#34;&#34;
</span><span class="miss">    der = self.parameters.derived.fastaccess
</span><span class="miss">    flu = self.sequences.fluxes.fastaccess
</span><span class="miss">    out = self.sequences.outlets.fastaccess
</span><span class="miss">    out.q[0] += der.qfactor*flu.qt
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;The HydPy-H-Land base model.&#34;&#34;&#34;
</span><span class="hit">    _RUN_METHODS = (calc_tc_v1,
</span><span class="noop">                    calc_tmean_v1,
</span><span class="noop">                    calc_fracrain_v1,
</span><span class="noop">                    calc_rfc_sfc_v1,
</span><span class="noop">                    calc_pc_v1,
</span><span class="noop">                    calc_ep_v1,
</span><span class="noop">                    calc_epc_v1,
</span><span class="noop">                    calc_tf_ic_v1,
</span><span class="noop">                    calc_ei_ic_v1,
</span><span class="noop">                    calc_sp_wc_v1,
</span><span class="noop">                    calc_melt_sp_wc_v1,
</span><span class="noop">                    calc_refr_sp_wc_v1,
</span><span class="noop">                    calc_glmelt_in_v1,
</span><span class="noop">                    calc_in_wc_v1,
</span><span class="noop">                    calc_r_sm_v1,
</span><span class="noop">                    calc_cf_sm_v1,
</span><span class="noop">                    calc_ea_sm_v1,
</span><span class="noop">                    calc_inuz_v1,
</span><span class="noop">                    calc_contriarea_v1,
</span><span class="noop">                    calc_q0_perc_uz_v1,
</span><span class="noop">                    calc_lz_v1,
</span><span class="noop">                    calc_el_lz_v1,
</span><span class="noop">                    calc_q1_lz_v1,
</span><span class="noop">                    calc_inuh_v1,
</span><span class="noop">                    calc_outuh_quh_v1,
</span><span class="noop">                    calc_qt_v1)
</span><span class="hit">    _OUTLET_METHODS = (update_q_v1,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Runoff [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of the hland model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_parameters.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_parameters.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...third party
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.hland.hland_constants import FIELD, FOREST, ILAKE, GLACIER
</span><span class="hit">from hydpy.models.hland.hland_constants import CONSTANTS
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameter(parametertools.ZipParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the HydPy-H-Land model
</span><span class="noop">    (potentially) handling multiple values.
</span><span class="noop">
</span><span class="noop">    Due to inheriting from :class:`~hydpy.core.parametertools.ZipParameter`,
</span><span class="noop">    additional keyword zipping functionality is offered.  The optional
</span><span class="noop">    `kwargs` are checked for the keywords `field`, `forest`, `glacier`,
</span><span class="noop">    `ilake,` and `default`.  If available, the respective values are used to
</span><span class="noop">    define the values of those 1-dimensional arrays, whose entries are related
</span><span class="noop">    to the different zone types. Also the method
</span><span class="noop">    :func:`~MultiParameter.compressrepr` tries to find compressed string
</span><span class="noop">    representations based on the mentioned zone types.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Prepare a :class:`MultiParameter` instance:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland.hland_parameters import MultiParameter
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; mp = MultiParameter()
</span><span class="noop">        &gt;&gt;&gt; mp.DIM, mp.TYPE, mp.TIME = 1, float, None
</span><span class="noop">        &gt;&gt;&gt; mp.subpars = control
</span><span class="noop">
</span><span class="noop">        Usually, one would indirectly define its shape through parameter
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.NmbZones`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.shape
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        RuntimeError: Shape information for parameter `multiparameter` can only be retrieved after it has been defined.  You can do this manually, but usually it is done automatically by defining the value of parameter `nmbzones` first in each parameter control file.
</span><span class="noop">
</span><span class="noop">        But here it is set manually to the value 5 for representing
</span><span class="noop">        five different zone types:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; zonetype.shape = 5
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE, FIELD)
</span><span class="noop">        &gt;&gt;&gt; mp.shape = 5
</span><span class="noop">
</span><span class="noop">        Assign values to all four zone types explicitely:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp(field=2., forest=1., glacier=4., ilake=3.)
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(field=2.0, forest=1.0, glacier=4.0, ilake=3.0)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([ 2.,  1.,  4.,  3.,  2.])
</span><span class="noop">
</span><span class="noop">        Specify a default value for all zone types not included in the
</span><span class="noop">        keyword list:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp(field=2., forest=1., default=9.)
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(field=2.0, forest=1.0, glacier=9.0, ilake=9.0)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([ 2.,  1.,  9.,  9.,  2.])
</span><span class="noop">
</span><span class="noop">        If no default value is given, numpys `nan` is applied:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp(field=2., forest=1.)
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(field=2.0, forest=1.0, glacier=nan, ilake=nan)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([  2.,   1.,  nan,  nan,   2.])
</span><span class="noop">
</span><span class="noop">        Of course, the usual value assignments remain unaffected:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.values = 5.
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(5.0)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([ 5.,  5.,  5.,  5.,  5.])
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.values = 5., 4., 3., 2., 1.
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(5.0, 4.0, 3.0, 2.0, 1.0)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([ 5.,  4.,  3.,  2.,  1.])
</span><span class="noop">
</span><span class="noop">    Another feature of :class:`MultiParameter` is that it relates the property
</span><span class="noop">    :func:`~MultiParameter.verifymask` to the defined zone types.
</span><span class="noop">    This requires the definition of the class attribute
</span><span class="noop">    :const:`~MultiParameter.REQUIRED_VALUES` for :class:`MultiParameter`
</span><span class="noop">    subclasses.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        When values for all zone types are required, all entries of the
</span><span class="noop">        verification mask are `True`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.REQUIRED_VALUES = (FIELD, FOREST, GLACIER, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; mp.verifymask
</span><span class="noop">        array([ True,  True,  True,  True,  True], dtype=bool)
</span><span class="noop">
</span><span class="noop">        When values for field and forest zones are required only, the
</span><span class="noop">        entries related to glacier and ilake zones are `False`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.REQUIRED_VALUES = (FIELD, FOREST)
</span><span class="noop">        &gt;&gt;&gt; mp.verifymask
</span><span class="noop">        array([ True,  True, False, False,  True], dtype=bool)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (FIELD, FOREST, GLACIER, ILAKE)
</span><span class="hit">    MODEL_CONSTANTS = CONSTANTS
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def refparameter(self):
</span><span class="noop">        &#34;&#34;&#34;Alias for the associated instance of
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.ZoneType`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self.subpars.pars.control.zonetype
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def shapeparameter(self):
</span><span class="noop">        &#34;&#34;&#34;Alias for the associated instance of
</span><span class="noop">        :class:`~hydpy.models.lland.lland_control.NmbZones`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self.subpars.pars.control.nmbzones
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterSoil(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for `soil zones` (and interception).
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (FIELD, FOREST)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterLand(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for all `land zones`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (FIELD, FOREST, GLACIER)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterLake(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for `lake zones` only.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (ILAKE,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterGlacier(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for `glacier zones` only.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (GLACIER,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterNoGlacier(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for `glacier free zones` only.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (FIELD, FOREST, ILAKE)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Parameters(parametertools.Parameters):
</span><span class="noop">    &#34;&#34;&#34;All parameters of the hland model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the values of the parameters handled by
</span><span class="noop">        :class:`DerivedParameters` based on the values of the parameters
</span><span class="noop">        handled by :class:`ControlParameters`.  The results of the different
</span><span class="noop">        methods are not interdependend, meaning their order could be changed.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.calc_relzonearea()
</span><span class="miss">        self.calc_landzonearea()
</span><span class="miss">        self.calc_soilarea()
</span><span class="miss">        self.calc_ttm()
</span><span class="miss">        self.calc_dt()
</span><span class="miss">        self.calc_nmbuh_uh()
</span><span class="miss">        self.calc_qfactor()
</span><span class="noop">
</span><span class="hit">    def calc_relzonearea(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the relative areas of all zones within the subbasin.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneArea`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelZoneArea`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            With one single zone, its relative area is one by definition:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(1)
</span><span class="noop">            &gt;&gt;&gt; zonearea(1111.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_relzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.relzonearea
</span><span class="noop">            relzonearea(1.0)
</span><span class="noop">
</span><span class="noop">            An example for three zones of different sizes:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; nmbzones(3)
</span><span class="noop">            &gt;&gt;&gt; zonearea(1., 3., 2.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_relzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.relzonearea
</span><span class="noop">            relzonearea(0.166667, 0.5, 0.333333)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.relzonearea(con.zonearea/sum(con.zonearea))
</span><span class="noop">
</span><span class="hit">    def calc_landzonearea(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the fraction of the summed area of all &#34;land zones&#34;
</span><span class="noop">        (of type FIELD, FOREST, or ILAKE) and the total subbasin area, and
</span><span class="noop">        calculate the fractions of all &#34;land zones&#34; and the total &#34;land area&#34;
</span><span class="noop">        of the subbasin.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.Area`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelLandArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelLandZoneArea`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            With all zones beeing &#34;land zones&#34;, the relative land area is
</span><span class="noop">            one by definition and the relative &#34;land zone&#34; areas are in
</span><span class="noop">            accordance with the original zone areas:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(3)
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER)
</span><span class="noop">            &gt;&gt;&gt; area(100.)
</span><span class="noop">            &gt;&gt;&gt; zonearea(25., 25., 50.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_landzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.rellandarea
</span><span class="noop">            rellandarea(1.0)
</span><span class="noop">            &gt;&gt;&gt; derived.rellandzonearea
</span><span class="noop">            rellandzonearea(field=0.25, forest=0.25, glacier=0.5)
</span><span class="noop">
</span><span class="noop">            With one zone beeing a lake zone, the relative &#34;land area&#34; is
</span><span class="noop">            decreased and the relative &#34;land zone&#34; areas are increased ---
</span><span class="noop">            except the one related to the internal lake, which is set to zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_landzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.rellandarea
</span><span class="noop">            rellandarea(0.5)
</span><span class="noop">            &gt;&gt;&gt; derived.rellandzonearea
</span><span class="noop">            rellandzonearea(field=0.5, forest=0.5, ilake=0.0)
</span><span class="noop">
</span><span class="noop">            With all zones beeing lake zones, all relative areas are zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(ILAKE, ILAKE, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_landzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.rellandarea
</span><span class="noop">            rellandarea(0.0)
</span><span class="noop">            &gt;&gt;&gt; derived.rellandzonearea
</span><span class="noop">            rellandzonearea(0.0)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        landzonearea = con.zonearea.copy()
</span><span class="hit">        landzonearea[con.zonetype == ILAKE] = 0.
</span><span class="hit">        landarea = numpy.sum(landzonearea)
</span><span class="hit">        if landarea &gt; 0.:
</span><span class="hit">            der.rellandzonearea(landzonearea/landarea)
</span><span class="noop">        else:
</span><span class="hit">            der.rellandzonearea(0.)
</span><span class="hit">        der.rellandarea(landarea/con.area)
</span><span class="noop">
</span><span class="hit">    def calc_soilarea(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the fraction of the summed area of all &#34;soil zones&#34;
</span><span class="noop">        (of type FIELD or FOREST) and the total subbasin area, and
</span><span class="noop">        calculate the fractions of all &#34;soil zones&#34; and the total &#34;soil area&#34;
</span><span class="noop">        of the subbasin.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.Area`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelSoilArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelSoilZoneArea`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            With all zones beeing &#34;soil zones&#34;, the relative land area is
</span><span class="noop">            one by definition and the relative &#34;soil zone&#34; areas are in
</span><span class="noop">            accordance with the original zone areas:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(4)
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, FIELD, FOREST)
</span><span class="noop">            &gt;&gt;&gt; area(100.)
</span><span class="noop">            &gt;&gt;&gt; zonearea(25., 25., 25., 25.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_soilarea()
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilarea
</span><span class="noop">            relsoilarea(1.0)
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilzonearea
</span><span class="noop">            relsoilzonearea(0.25)
</span><span class="noop">
</span><span class="noop">            With one zone beeing a lake zone one one zone beeing a glacier
</span><span class="noop">            zone, the relative &#34;soil area&#34; is decreased and the relative
</span><span class="noop">            &#34;soil zone&#34; areas are increased --- except the ones related to
</span><span class="noop">            the internal lake and the glacier, which are set to zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_soilarea()
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilarea
</span><span class="noop">            relsoilarea(0.5)
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilzonearea
</span><span class="noop">            relsoilzonearea(field=0.5, forest=0.5, glacier=0.0, ilake=0.0)
</span><span class="noop">
</span><span class="noop">            With all zones beeing lake or glacier zones, all relative areas
</span><span class="noop">            are zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(GLACIER, GLACIER, ILAKE, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_soilarea()
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilarea
</span><span class="noop">            relsoilarea(0.0)
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilzonearea
</span><span class="noop">            relsoilzonearea(0.0)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        soilzonearea = con.zonearea.copy()
</span><span class="hit">        soilzonearea[con.zonetype == GLACIER] = 0.
</span><span class="hit">        soilzonearea[con.zonetype == ILAKE] = 0.
</span><span class="hit">        soilarea = numpy.sum(soilzonearea)
</span><span class="hit">        if soilarea &gt; 0.:
</span><span class="hit">            der.relsoilzonearea(soilzonearea/soilarea)
</span><span class="noop">        else:
</span><span class="hit">            der.relsoilzonearea(0.)
</span><span class="hit">        der.relsoilarea(soilarea/con.area)
</span><span class="noop">
</span><span class="hit">    def calc_ttm(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the threshold temperature for melting and refreezing.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.TT`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.DTTM`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.TTM`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`TTM = TT+DTTM`
</span><span class="noop">
</span><span class="noop">        Example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(1)
</span><span class="noop">            &gt;&gt;&gt; tt(1.)
</span><span class="noop">            &gt;&gt;&gt; dttm(-2.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_ttm()
</span><span class="noop">            &gt;&gt;&gt; derived.ttm
</span><span class="noop">            ttm(-1.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.ttm(con.tt+con.dttm)
</span><span class="noop">
</span><span class="hit">    def calc_dt(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the relative time step size for solving the upper
</span><span class="noop">        zone layer routine.
</span><span class="noop">
</span><span class="noop">        Required control parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.RecStep`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.DT`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`DT = \\frac{1}{RecStep}`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">            &gt;&gt;&gt; recstep(2.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_dt()
</span><span class="noop">            &gt;&gt;&gt; derived.dt
</span><span class="noop">            dt(1.0)
</span><span class="noop">            &gt;&gt;&gt; recstep(10.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_dt()
</span><span class="noop">            &gt;&gt;&gt; derived.dt
</span><span class="noop">            dt(0.2)
</span><span class="noop">
</span><span class="noop">            Note that the value assigned to recstep is related to the given
</span><span class="noop">            parameter step size of one day.  The actually applied recstep of
</span><span class="noop">            the last example is:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; recstep.value
</span><span class="noop">            5
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.dt(1./con.recstep)
</span><span class="noop">
</span><span class="hit">    def calc_qfactor(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the factor for converting values of
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.QT` [mm/T] to values of
</span><span class="noop">        :class:`~hydpy.models.hland.hland_outlets.Q` [m³/s].
</span><span class="noop">
</span><span class="noop">        Required control parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.Area`
</span><span class="noop">
</span><span class="noop">        Required property of
</span><span class="noop">        :class:`~hydpy.core.parametertools.Parameter`:
</span><span class="noop">
</span><span class="noop">          :attr:`~hydpy.core.parametertools.Parameter.seconds`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.QFactor`
</span><span class="noop">
</span><span class="noop">        Example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">            &gt;&gt;&gt; area(50.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_qfactor()
</span><span class="noop">            &gt;&gt;&gt; derived.qfactor
</span><span class="noop">            qfactor(1.157407)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.qfactor(con.area*1000./der.qfactor.simulationstep.seconds)
</span><span class="noop">
</span><span class="hit">    def calc_nmbuh_uh(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the ordinates of the triangle unit hydrograph.
</span><span class="noop">
</span><span class="noop">        Note that also the shape of sequence
</span><span class="noop">        :class:`~hydpy.models.hland.hland_logs.QUH` is defined in accordance
</span><span class="noop">        with :class:`~hydpy.models.hland.hland_derived.NmbUH`.
</span><span class="noop">
</span><span class="noop">        Required control parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.MaxBaz`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.NmbUH`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.UH`
</span><span class="noop">
</span><span class="noop">        Prepared log sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_logs.QUH`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            MaxBaz determines the end point of the triangle.  A value of
</span><span class="noop">            MaxBaz beeing not larger than the simulation step size is
</span><span class="noop">            identical with applying no unit hydrograph at all:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">            &gt;&gt;&gt; maxbaz(0.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(1)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (1,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(1.0)
</span><span class="noop">
</span><span class="noop">            Note that, due to difference of the parameter and the simulation
</span><span class="noop">            step size in the given example, the largest assignement resulting
</span><span class="noop">            in a `inactive` unit hydrograph is 1/2:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; maxbaz(0.5)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(1)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (1,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(1.0)
</span><span class="noop">
</span><span class="noop">            When MaxBaz is in accordance with two simulation steps, both
</span><span class="noop">            unit hydrograph ordinats must be 1/2, due to symmetry of the
</span><span class="noop">            triangle:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; maxbaz(1.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(2)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (2,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(0.5)
</span><span class="noop">
</span><span class="noop">            A MaxBaz value in accordance with three simulation steps results
</span><span class="noop">            --- when expressed as fractions --- in the ordinate values 2/9,
</span><span class="noop">            5/9, and 2/9:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; maxbaz(1.5)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(3)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (3,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(0.222222, 0.555556, 0.222222)
</span><span class="noop">
</span><span class="noop">            And a final example, where the end of the triangle lies within
</span><span class="noop">            a simulation step, resulting in the fractions 8/49, 23/49, 16/49,
</span><span class="noop">            and 2/49:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; maxbaz(1.75)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(4)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (4,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(0.163265, 0.469388, 0.326531, 0.040816)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        log = self.model.sequences.logs
</span><span class="noop">        # Determine UH parameters...
</span><span class="hit">        if con.maxbaz &lt;= 1.:
</span><span class="noop">            # ...when MaxBaz smaller than or equal to the simulation time step.
</span><span class="hit">            der.nmbuh = 1
</span><span class="hit">            der.uh.shape = 1
</span><span class="hit">            der.uh(1.)
</span><span class="hit">            log.quh.shape = 1
</span><span class="noop">        else:
</span><span class="noop">            # ...when MaxBaz is greater than the simulation time step.
</span><span class="noop">            # Define some shortcuts for the following calculations.
</span><span class="hit">            full = con.maxbaz.value
</span><span class="noop">            # Now comes a terrible trick due to rounding problems coming from
</span><span class="noop">            # the conversation of the SMHI parameter set to the HydPy
</span><span class="noop">            # parameter set.  Time to get rid of it...
</span><span class="hit">            if (full % 1.) &lt; 1e-4:
</span><span class="hit">                full //= 1.
</span><span class="hit">            full_f = int(numpy.floor(full))
</span><span class="hit">            full_c = int(numpy.ceil(full))
</span><span class="hit">            half = full/2.
</span><span class="hit">            half_f = int(numpy.floor(half))
</span><span class="hit">            half_c = int(numpy.ceil(half))
</span><span class="hit">            full_2 = full**2.
</span><span class="noop">            # Calculate the triangle ordinate(s)...
</span><span class="hit">            der.nmbuh(full_c)
</span><span class="hit">            der.uh.shape = full_c
</span><span class="hit">            log.quh.shape = full_c
</span><span class="noop">            # ...of the rising limb.
</span><span class="hit">            points = numpy.arange(1, half_f+1)
</span><span class="hit">            der.uh[:half_f] = (2.*points-1.)/(2.*full_2)
</span><span class="noop">            # ...around the peak (if it exists).
</span><span class="hit">            if numpy.mod(half, 1.) != 0.:
</span><span class="hit">                der.uh[half_f] = \
</span><span class="noop">                    ((half_c-half)/full +
</span><span class="noop">                     (2*half**2.-half_f**2.-half_c**2.)/(2.*full_2))
</span><span class="noop">            # ...of the falling limb (eventually except the last one).
</span><span class="hit">            points = numpy.arange(half_c+1., full_f+1.)
</span><span class="hit">            der.uh[half_c:full_f] = 1./full-(2.*points-1.)/(2.*full_2)
</span><span class="noop">            # ...at the end (if not already done).
</span><span class="hit">            if numpy.mod(full, 1.) != 0.:
</span><span class="hit">                der.uh[full_f] = ((full-full_f)/full -
</span><span class="noop">                                  (full_2-full_f**2.)/(2.*full_2))
</span><span class="noop">            # Normalize the ordinates.
</span><span class="hit">            der.uh(der.uh/numpy.sum(der.uh))
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hland/hland_states.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="hit">from hydpy.models.hland.hland_constants import ILAKE
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Ic(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Interception storage [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with :math:`IC \\leq ICMAX`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">        &gt;&gt;&gt; icmax(2.)
</span><span class="noop">        &gt;&gt;&gt; states.ic(-1.,0., 1., 2., 3.)
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 1.0, 2.0, 2.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            control = self.subseqs.seqs.model.parameters.control
</span><span class="hit">            upper = control.icmax
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SP(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Frozen water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (None, None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`WC \\leq WHC \\cdot SP`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">        &gt;&gt;&gt; whc(.1)
</span><span class="noop">        &gt;&gt;&gt; states.wc.values = -1., 0., 1., -1., 0., .5, 1.
</span><span class="noop">        &gt;&gt;&gt; states.sp(-1., 0., 0., 5., 5., 5., 5.)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 0.0, 10.0, 5.0, 5.0, 5.0, 10.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        whc = self.subseqs.seqs.model.parameters.control.whc
</span><span class="hit">        wc = self.subseqs.wc
</span><span class="hit">        if lower is None:
</span><span class="hit">            if wc.values is not None:
</span><span class="hit">                lower = numpy.clip(wc/whc, 0., numpy.inf)
</span><span class="noop">            else:
</span><span class="miss">                lower = 0.
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WC(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Liquid water content of the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`WC \\leq WHC \\cdot SP`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">        &gt;&gt;&gt; whc(.1)
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0., 0., 0., 5., 5., 5., 5.
</span><span class="noop">        &gt;&gt;&gt; states.wc(-1., 0., 1., -1., 0., .5, 1.)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        whc = self.subseqs.seqs.model.parameters.control.whc
</span><span class="hit">        sp = self.subseqs.sp
</span><span class="hit">        if (upper is None) and (sp.values is not None):
</span><span class="hit">            upper = whc*sp
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SM(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Soil moisture [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`SM \\leq FC`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">        &gt;&gt;&gt; fc(200.)
</span><span class="noop">        &gt;&gt;&gt; states.sm(-100.,0., 100., 200., 300.)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 100.0, 200.0, 200.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subseqs.seqs.model.parameters.control.fc
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class UZ(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Storage in the upper zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LZ(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Storage in the lower zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (None, None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim negative value whenever there is no internal lake within
</span><span class="noop">        the respective subbasin.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(2)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; states.lz(-1.)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(-1.0)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FOREST)
</span><span class="noop">        &gt;&gt;&gt; states.lz(-1.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(0.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz(1.)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(1.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            control = self.subseqs.seqs.model.parameters.control
</span><span class="hit">            if not any(control.zonetype == ILAKE):
</span><span class="hit">                lower = 0.
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of the HydPy-H-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Ic, SP, WC, SM, UZ, LZ)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;The HydPy-H-Stream model is an very simple routing approach.  More
</span><span class="noop">precisely, it is a simplification of the Muskingum approach, which
</span><span class="noop">itself can be seen as a naive finite difference solution of the
</span><span class="noop">routing problem.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from hstream
</span><span class="hit">from hydpy.models.hstream.hstream_parameters import Parameters
</span><span class="hit">from hydpy.models.hstream.hstream_control import ControlParameters
</span><span class="hit">from hydpy.models.hstream.hstream_derived import DerivedParameters
</span><span class="hit">from hydpy.models.hstream.hstream_states import StateSequences
</span><span class="hit">from hydpy.models.hstream.hstream_inlets import InletSequences
</span><span class="hit">from hydpy.models.hstream.hstream_outlets import OutletSequences
</span><span class="hit">from hydpy.models.hstream.hstream_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Lag(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Time lag between inflow and outflow [T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Damp(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Damping of the hydrograph [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of hstream, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (Lag, Damp)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NmbSegments(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of river segments [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (0, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class C1(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;First coefficient of the muskingum working formula [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., .5)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class C2(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Second coefficient of the muskingum working formula [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class C3(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Third coefficient of the muskingum working formula [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., .5)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of hstream, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (NmbSegments, C1, C2, C3)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_inlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_inlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Runoff [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of the hstream model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qjoints_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Apply the routing equation.
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.hstream.hstream_derived.NmbSegments`
</span><span class="noop">      :class:`~hydpy.models.hstream.hstream_derived.C1`
</span><span class="noop">      :class:`~hydpy.models.hstream.hstream_derived.C2`
</span><span class="noop">      :class:`~hydpy.models.hstream.hstream_derived.C3`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hstream.hstream_states.QJoints`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`Q_{space+1,time+1} =
</span><span class="noop">      c1 \\cdot Q_{space,time+1} +
</span><span class="noop">      c2 \\cdot Q_{space,time} +
</span><span class="noop">      c3 \\cdot Q_{space+1,time}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Firstly, define a reach divided into 4 segments:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsegments(4)
</span><span class="noop">        &gt;&gt;&gt; states.qjoints.shape = 5
</span><span class="noop">
</span><span class="noop">        Zero damping is achieved through the following coefficients:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.c1(0.)
</span><span class="noop">        &gt;&gt;&gt; derived.c2(1.)
</span><span class="noop">        &gt;&gt;&gt; derived.c3(0.)
</span><span class="noop">
</span><span class="noop">        For initialization, assume a base flow of 2m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.qjoints.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qjoints.new = 2.
</span><span class="noop">
</span><span class="noop">        Through successive assignements of different discharge values
</span><span class="noop">        to the upper junction one can see, that these discharge values
</span><span class="noop">        are simply shifted from each junction to the respective lower
</span><span class="noop">        junction at each time step:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.qjoints[0] = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qjoints_v1()
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; states.qjoints
</span><span class="noop">        qjoints(5.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.qjoints[0] = 8.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qjoints_v1()
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; states.qjoints
</span><span class="noop">        qjoints(8.0, 5.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.qjoints[0] = 6.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qjoints_v1()
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; states.qjoints
</span><span class="noop">        qjoints(6.0, 8.0, 5.0, 2.0, 2.0)
</span><span class="noop">
</span><span class="noop">        With the maximum damping allowed, the values of the derived
</span><span class="noop">        parameters are:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.c1(.5)
</span><span class="noop">        &gt;&gt;&gt; derived.c2(.0)
</span><span class="noop">        &gt;&gt;&gt; derived.c3(.5)
</span><span class="noop">
</span><span class="noop">        Assuming again a base flow of 2m³/s and the same input values
</span><span class="noop">        results in:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.qjoints.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qjoints.new = 2.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.qjoints[0] = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qjoints_v1()
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; states.qjoints
</span><span class="noop">        qjoints(5.0, 3.5, 2.75, 2.375, 2.1875)
</span><span class="noop">        &gt;&gt;&gt; states.qjoints[0] = 8.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qjoints_v1()
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; states.qjoints
</span><span class="noop">        qjoints(8.0, 5.75, 4.25, 3.3125, 2.75)
</span><span class="noop">        &gt;&gt;&gt; states.qjoints[0] = 6.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qjoints_v1()
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; states.qjoints
</span><span class="noop">        qjoints(6.0, 5.875, 5.0625, 4.1875, 3.46875)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    for j in range(der.nmbsegments):
</span><span class="hit">        new.qjoints[j+1] = (der.c1*new.qjoints[j] +
</span><span class="noop">                            der.c2*old.qjoints[j] +
</span><span class="noop">                            der.c3*old.qjoints[j+1])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pick_q_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Assign the actual value of the inlet sequence to the upper joint
</span><span class="noop">    of the subreach upstream.&#34;&#34;&#34;
</span><span class="miss">    sta = self.sequences.states.fastaccess
</span><span class="miss">    inl = self.sequences.inlets.fastaccess
</span><span class="miss">    sta.qjoints[0] = inl.q[0]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pass_q_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Assing the actual value of the lower joint of of the subreach
</span><span class="noop">    downstream to the outlet sequence.&#34;&#34;&#34;
</span><span class="miss">    der = self.parameters.derived.fastaccess
</span><span class="miss">    sta = self.sequences.states.fastaccess
</span><span class="miss">    out = self.sequences.outlets.fastaccess
</span><span class="miss">    out.q[0] += sta.qjoints[der.nmbsegments]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;The HydPy-H-Stream model.&#34;&#34;&#34;
</span><span class="hit">    _INLET_METHODS = (pick_q_v1,)
</span><span class="hit">    _RUN_METHODS = (calc_qjoints_v1,)
</span><span class="hit">    _OUTLET_METHODS = (pass_q_v1,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Runoff [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of the hstream model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_parameters.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_parameters.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Parameters(parametertools.Parameters):
</span><span class="noop">    &#34;&#34;&#34;All parameters of the hstream model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Determines the values of the parameters handled by
</span><span class="noop">        :class:`DerivedParameters` based on the values of the parameters.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.calc_nmbsegments()
</span><span class="miss">        self.calc_coefficients()
</span><span class="noop">
</span><span class="hit">    def calc_nmbsegments(self):
</span><span class="noop">        &#34;&#34;&#34;Determines in how many segments the whole reach needs to be
</span><span class="noop">        divided to approximate the desired lag time via integer rounding.
</span><span class="noop">        Adjusts the shape of sequence :class:`QJoints` additionally.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`Lag`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`NmbSegments`
</span><span class="noop">
</span><span class="noop">        Prepared state sequence:
</span><span class="noop">          :class:`QJoints`
</span><span class="noop">
</span><span class="noop">        Example:
</span><span class="noop">
</span><span class="noop">            Define a lag time of 1.4 days and a simulation step size of 12
</span><span class="noop">            hours:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hstream import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">            &gt;&gt;&gt; lag(1.4)
</span><span class="noop">
</span><span class="noop">            Then the actual lag value for the simulation step size is 2.8
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; lag
</span><span class="noop">            lag(1.4)
</span><span class="noop">            &gt;&gt;&gt; lag.value
</span><span class="noop">            2.8
</span><span class="noop">
</span><span class="noop">            Through rounding the number of segments is determined:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbsegments()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbsegments
</span><span class="noop">            nmbsegments(3)
</span><span class="noop">
</span><span class="noop">            The number of joints is always the number of segments plus one:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.qjoints.shape
</span><span class="noop">            (4,)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.nmbsegments = int(round(con.lag))
</span><span class="hit">        self.model.sequences.states.qjoints.shape = der.nmbsegments+1
</span><span class="noop">
</span><span class="hit">    def calc_coefficients(self):
</span><span class="noop">        &#34;&#34;&#34;Calculates the Muskingum coefficients.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`Damp`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`C1`
</span><span class="noop">          :class:`C2`
</span><span class="noop">          :class:`C3`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">          :math:`c_1 = \\frac{Damp}{1+Damp}`\n
</span><span class="noop">          :math:`c_3 = \\frac{Damp}{1+Damp}`\n
</span><span class="noop">          :math:`c_2 = 1.-c_1-c_3`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            If no damping is required, the coeffients are:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hstream import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; damp(0.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_coefficients()
</span><span class="noop">            &gt;&gt;&gt; derived.c1, derived.c2, derived.c3
</span><span class="noop">            (c1(0.0), c2(1.0), c3(0.0))
</span><span class="noop">
</span><span class="noop">            The strongest damping is achieved through:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; damp(1.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_coefficients()
</span><span class="noop">            &gt;&gt;&gt; derived.c1, derived.c2, derived.c3
</span><span class="noop">            (c1(0.5), c2(0.0), c3(0.5))
</span><span class="noop">
</span><span class="noop">            And finally an intermediate example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; damp(.25)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_coefficients()
</span><span class="noop">            &gt;&gt;&gt; derived.c1, derived.c2, derived.c3
</span><span class="noop">            (c1(0.2), c2(0.6), c3(0.2))
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.c1 = der.c3 = numpy.clip(con.damp/(1.+con.damp), 0., .5)
</span><span class="hit">        der.c2 = numpy.clip(1.-der.c1-der.c3, 0., 1.)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/hstream/hstream_states.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import sys
</span><span class="hit">import warnings
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QJoints(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Runoff at the segment junctions [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="miss">        try:
</span><span class="miss">            sequencetools.StateSequence.__call__(self, *args)
</span><span class="miss">        except BaseException:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            sequencetools.StateSequence.__call__(self, numpy.mean(args))
</span><span class="miss">            warnings.warn(&#39;Note that, due to the following problem, the&#39;
</span><span class="noop">                          &#39;affected HydPy-H-Stream model could be initialised &#39;
</span><span class="noop">                          &#39;with an averaged value only: %s&#39; % message)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of the hstream model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QJoints,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">The L-Lake model defines the methods and classes required for
</span><span class="noop">performing lake and dam retention processes as implemented in
</span><span class="noop">LARSIM.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from llake
</span><span class="hit">from hydpy.models.llake.llake_control import ControlParameters
</span><span class="hit">from hydpy.models.llake.llake_derived import DerivedParameters
</span><span class="hit">from hydpy.models.llake.llake_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.llake.llake_states import StateSequences
</span><span class="hit">from hydpy.models.llake.llake_inlets import InletSequences
</span><span class="hit">from hydpy.models.llake.llake_outlets import OutletSequences
</span><span class="hit">from hydpy.models.llake.llake_aides import AideSequences
</span><span class="hit">from hydpy.models.llake.llake_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_aides.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_aides.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QA(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Seeausfluss (outflow from the lake) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class VQ(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Hilfsterm (auxiliary term) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class V(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasservolumen (water volume) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of HydPy-L-Lake.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QA, VQ, V)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class N(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Anzahl Interpolationsstützstellen (number of nodes for the
</span><span class="noop">    interpolation between water state, volume and discharge) [-].
</span><span class="noop">
</span><span class="noop">    Parameter :class:`N` determines the length of all 1- and 2-dimensional
</span><span class="noop">    parameters of HydPy-L-Lake.  This requires that the value of
</span><span class="noop">    the respective :class:`N` instance is set before any of the values
</span><span class="noop">    of these 1- and 2-dimensional parameters are set.  Changing the
</span><span class="noop">    value of the :class:`N` instance necessitates setting their values
</span><span class="noop">    again.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; n(5)
</span><span class="noop">
</span><span class="noop">        For &#34;simple&#34; 1-dimensional parameters, the shape depends on the
</span><span class="noop">        value of :class:`N` only:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; w.shape
</span><span class="noop">        (5,)
</span><span class="noop">
</span><span class="noop">        For time varying parameters (derived from
</span><span class="noop">        :class:`~hydpy.core.parametertools.SeasonalParameter`), it also depends
</span><span class="noop">        on the defined number simulation steps per leap year:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; verzw.shape
</span><span class="noop">        (732,)
</span><span class="noop">        &gt;&gt;&gt; q.shape
</span><span class="noop">        (732, 5)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (2, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass a value to :class:`N` instances
</span><span class="noop">        within parameter control files.  Sets the shape of the associated
</span><span class="noop">        1- and 2-dimensional parameter objects additionally.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        for (_name, subpars) in self.subpars.pars.model.parameters:
</span><span class="hit">            for (name, par) in subpars:
</span><span class="hit">                if name == &#39;toy&#39;:
</span><span class="hit">                    continue
</span><span class="hit">                elif par.NDIM == 1:
</span><span class="hit">                    if isinstance(par, parametertools.SeasonalParameter):
</span><span class="hit">                        par.shape = (0,)
</span><span class="noop">                    else:
</span><span class="hit">                        par.shape = self.value
</span><span class="hit">                elif ((par.NDIM == 2) and
</span><span class="noop">                      isinstance(par, parametertools.SeasonalParameter)):
</span><span class="hit">                    par.shape = (None, self.value)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class W(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Wasserstand (water stage) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class V(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Wasservolumen bei vorgegebenem Wasserstand (water volume for a
</span><span class="noop">    given water stage) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(parametertools.SeasonalParameter):
</span><span class="noop">    &#34;&#34;&#34;Üblicher Seeausfluss bei vorgegebenem Wasserstand (sea outlet discharge
</span><span class="noop">    for a given water stage) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MaxDT(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Maximale interne Rechenschrittweite (maximum of the internal step size)
</span><span class="noop">    [T].
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Initialize a llake model and set different time step length for
</span><span class="noop">        parameterstep, simulationstep and maxdt:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;1h&#39;)
</span><span class="noop">
</span><span class="noop">        Internally, the value of maxdt is stored in seconds, but in string
</span><span class="noop">        representations it is shown as a :class:`~hydpy.core.timetools.Period`
</span><span class="noop">        string:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt.value
</span><span class="noop">        3600.0
</span><span class="noop">        &gt;&gt;&gt; maxdt
</span><span class="noop">        maxdt(&#39;1h&#39;)
</span><span class="noop">
</span><span class="noop">        Note that maxdt only defines the maximum internal step size, not the
</span><span class="noop">        one actually used.  Hence, maxdt is e.g. allowed to be larger than the
</span><span class="noop">        actual simulation step size:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;2d&#39;)
</span><span class="noop">        &gt;&gt;&gt; maxdt
</span><span class="noop">        maxdt(&#39;2d&#39;)
</span><span class="noop">
</span><span class="noop">        It is allowed the set the number of seconds directly or modify it
</span><span class="noop">        by mathematical operations:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt.value = 60.
</span><span class="noop">        &gt;&gt;&gt; maxdt
</span><span class="noop">        maxdt(&#39;1m&#39;)
</span><span class="noop">        &gt;&gt;&gt; maxdt *= 120.
</span><span class="noop">        &gt;&gt;&gt; maxdt
</span><span class="noop">        maxdt(&#39;2h&#39;)
</span><span class="noop">
</span><span class="noop">        However, for the more secure way of calling the object trying to
</span><span class="noop">        pass an argument which cannot be converted to a Period instance
</span><span class="noop">        unambiguously results in an exception:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt(60.)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: While trying the set the value of parameter `maxdt` of the lake model handled by element `?`, the following error occured: The supplied argument must be either an instance of `datetime.timedelta` or `str`.  The given arguments type is float. (An example: set `max dt` to 3600 seconds by writing `maxdt(&#34;1h&#34;))
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        try:
</span><span class="hit">            args = [timetools.Period(args[0]).seconds]
</span><span class="hit">        except BaseException:
</span><span class="hit">            objecttools.augmentexcmessage(
</span><span class="noop">                &#39;While trying the set the value of parameter `maxdt` &#39;
</span><span class="noop">                &#39;of the lake model handled by element `%s`&#39;
</span><span class="noop">                % objecttools.devicename(self),
</span><span class="noop">                &#39;(An example: set `max dt` to 3600 seconds by writing &#39;
</span><span class="noop">                &#39;`maxdt(&#34;1h&#34;))&#39;)
</span><span class="hit">        parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        try:
</span><span class="hit">            return &#34;%s(&#39;%s&#39;)&#34; % (self.name,
</span><span class="noop">                                 str(timetools.Period.fromseconds(self.value)))
</span><span class="miss">        except BaseException:
</span><span class="miss">            return &#39;%s(?)&#39; % self.name
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MaxDW(parametertools.SeasonalParameter):
</span><span class="noop">    &#34;&#34;&#34;Maximale Absenkgeschwindigkeit (maximum drop in water level) [m/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Verzw(parametertools.SeasonalParameter):
</span><span class="noop">    &#34;&#34;&#34;Zu- oder Abschlag des Seeausflusses (addition to or abstraction from
</span><span class="noop">    the seas outlet discharge) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of HydPy-L-Lake, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (N, W, V, Q, MaxDT, MaxDW, Verzw)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TOY(parametertools.IndexParameter):
</span><span class="noop">    &#34;&#34;&#34;References the &#34;global&#34; time of the year index array [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, int, None, (0, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        self.setreference(pub.indexer.timeofyear)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Seconds(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Length of the actual simulation step size in seconds [s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        self.value = self.simulationstep.seconds
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NmbSubsteps(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of the internal simulation steps [-].
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Initialize a llake model and assume a simulation step size of 12 hours:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">
</span><span class="noop">        If the maximum internal step size is also set to 12 hours, there is
</span><span class="noop">        only one internal calculation step per outer simulation step:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps
</span><span class="noop">        nmbsubsteps(1)
</span><span class="noop">
</span><span class="noop">        Assigning smaller values to `maxdt` increases `nmbstepsize`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;1h&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps
</span><span class="noop">        nmbsubsteps(12)
</span><span class="noop">
</span><span class="noop">        In case the simulationstep is not a whole multiple of `dwmax`,
</span><span class="noop">        the value of `nmbsubsteps` is rounded up:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;59m&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps
</span><span class="noop">        nmbsubsteps(13)
</span><span class="noop">
</span><span class="noop">        Even for `maxdt` values exceeding the simulationstep, the value
</span><span class="noop">        of `numbsubsteps` does not become smaller than one:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;2d&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps
</span><span class="noop">        nmbsubsteps(1)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (1, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        maxdt = self.subpars.pars.control.maxdt
</span><span class="hit">        seconds = self.simulationstep.seconds
</span><span class="hit">        self.value = numpy.ceil(seconds/maxdt)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class VQ(parametertools.SeasonalParameter):
</span><span class="noop">    &#34;&#34;&#34;Hilfsterm (auxiliary term): math:VdtQ = 2 \\cdot + dt \\cdot Q` [m³].
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">    &gt;&gt;&gt; n(3)
</span><span class="noop">    &gt;&gt;&gt; v(0., 1e5, 1e6)
</span><span class="noop">    &gt;&gt;&gt; q(_1=[0., 1., 2.], _7=[0., 2., 5.])
</span><span class="noop">    &gt;&gt;&gt; maxdt(&#39;12h&#39;)
</span><span class="noop">    &gt;&gt;&gt; derived.seconds.update()
</span><span class="noop">    &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">    &gt;&gt;&gt; derived.vq.update()
</span><span class="noop">    &gt;&gt;&gt; derived.vq
</span><span class="noop">    vq(toy_1_1_0_0_0=[0.0, 243200.0, 2086400.0],
</span><span class="noop">       toy_7_1_0_0_0=[0.0, 286400.0, 2216000.0])
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        der = self.subpars
</span><span class="hit">        for (toy, qs) in con.q:
</span><span class="hit">            setattr(self, str(toy), 2.*con.v+der.seconds/der.nmbsubsteps*qs)
</span><span class="hit">        self.refresh()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of HydPy-L-Lake, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (TOY, Seconds, NmbSubsteps, VQ)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QZ(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Seezufluss (inflow into the lake) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QA(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Seeausfluss (outflow from the lake) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of HydPy-L-Lake.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QZ, QA)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_inlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_inlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss (runoff) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of HydPy-L-Lake.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># imports...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def solve_dv_dt_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Solve the differential equation of HydPy-L.
</span><span class="noop">
</span><span class="noop">    At the moment, HydPy-L only implements a simple numerical solution of
</span><span class="noop">    its underlying ordinary differential equation.  To increase the accuracy
</span><span class="noop">    (or sometimes even to prevent instability) of this approximation, one
</span><span class="noop">    can set the value of parameter
</span><span class="noop">    :class:`~hydpy.models.llake.llake_control.MaxDT` to a value smaller than
</span><span class="noop">    the actual simulation step size.  Method :func:`solve_dv_dt_v1` then
</span><span class="noop">    applies the methods related to the numerical approximation multiple times
</span><span class="noop">    and aggregates the results.
</span><span class="noop">
</span><span class="noop">    Note that the order of convergence is one only.  It is hard to tell how
</span><span class="noop">    short the internal simulation step needs to be to ensure a certain degree
</span><span class="noop">    of accuracy.  In most cases one hour or very often even one day should be
</span><span class="noop">    sufficient to gain acceptable results.  However, this strongly depends on
</span><span class="noop">    the given water stage-volume-discharge relationship.  Hence it seems
</span><span class="noop">    advisable to always define a few test waves and apply the llake model with
</span><span class="noop">    different :class:`~hydpy.models.llake.llake_control.MaxDT` values.
</span><span class="noop">    Afterwards, select a :class:`~hydpy.models.llake.llake_control.MaxDT`
</span><span class="noop">    value  lower than one which results in acceptable approximations for
</span><span class="noop">    all test waves.  The computation time of the llake mode per substep is
</span><span class="noop">    rather small, so always include a savety factor.
</span><span class="noop">
</span><span class="noop">    Of course, an adaptive step size determination would be much more
</span><span class="noop">    convenient...
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.NmbSubsteps`
</span><span class="noop">
</span><span class="noop">    Used aide sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.V`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.QA`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.V`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_fluxes.QA`
</span><span class="noop">
</span><span class="noop">    Note that method :func:`solve_dv_dt_v1` calls the versions of `calc_vq`,
</span><span class="noop">    `interp_qa` and `calc_v_qa` selected by the respective application model.
</span><span class="noop">    Hence, also their parameter and sequence specifications need to be
</span><span class="noop">    considered.
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`\\frac{dV}{dt}= QZ - QA(V)`
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    flu.qa = 0.
</span><span class="hit">    aid.v = old.v
</span><span class="hit">    for i in range(der.nmbsubsteps):
</span><span class="hit">        self.calc_vq()
</span><span class="hit">        self.interp_qa()
</span><span class="hit">        self.calc_v_qa()
</span><span class="hit">        flu.qa += aid.qa
</span><span class="hit">    flu.qa /= der.nmbsubsteps
</span><span class="hit">    new.v = aid.v
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_vq_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the auxiliary term.
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.Seconds`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.NmbSubsteps`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_fluxes.QZ`
</span><span class="noop">
</span><span class="noop">    Required aide sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.V`
</span><span class="noop">
</span><span class="noop">    Calculated aide sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.VQ`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`VQ = 2 \\cdot V + \\frac{Seconds}{NmbSubsteps} \\cdot QZ`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        The following example shows that the auxiliary term `vq` does not
</span><span class="noop">        depend on the (outer) simulation step size but on the (inner)
</span><span class="noop">        calculation step size defined by parameter `maxdt`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;6h&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.seconds.update()
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qz = 2.
</span><span class="noop">        &gt;&gt;&gt; aides.v = 1e5
</span><span class="noop">        &gt;&gt;&gt; model.calc_vq_v1()
</span><span class="noop">        &gt;&gt;&gt; aides.vq
</span><span class="noop">        vq(243200.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    aid.vq = 2.*aid.v+der.seconds/der.nmbsubsteps*flu.qz
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def interp_qa_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the lake outflow based on linear interpolation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.N`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.Q`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.TOY`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.VQ`
</span><span class="noop">
</span><span class="noop">    Required aide sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.VQ`
</span><span class="noop">
</span><span class="noop">    Calculated aide sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.QA`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        In preparation for the following examples, define a short simulation
</span><span class="noop">        time period with a simulation step size of 12 hours and initialize
</span><span class="noop">        the required model object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2000.01.01&#39;,
</span><span class="noop">        ...                                    &#39;2000.01.04&#39;,
</span><span class="noop">        ...                                    &#39;12h&#39;))
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">
</span><span class="noop">        Next, for the sake of brevity, define a test function:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; def test(*vqs):
</span><span class="noop">        ...     for vq in vqs:
</span><span class="noop">        ...         aides.vq(vq)
</span><span class="noop">        ...         model.interp_qa_v1()
</span><span class="noop">        ...         print(repr(aides.vq), repr(aides.qa))
</span><span class="noop">
</span><span class="noop">        The following three relationships between the auxiliary term `vq` and
</span><span class="noop">        the tabulated discharge `q` are taken as examples.  Each one is valid
</span><span class="noop">        for one of the first three days in January and is defined via five
</span><span class="noop">        nodes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; n(5)
</span><span class="noop">        &gt;&gt;&gt; derived.toy.update()
</span><span class="noop">        &gt;&gt;&gt; derived.vq(_1_1_6=[0., 1., 2., 2., 3.],
</span><span class="noop">        ...            _1_2_6=[0., 1., 2., 2., 3.],
</span><span class="noop">        ...            _1_3_6=[0., 1., 2., 3., 4.])
</span><span class="noop">        &gt;&gt;&gt; q(_1_1_6=[0., 0., 0., 0., 0.],
</span><span class="noop">        ...   _1_2_6=[0., 2., 5., 6., 9.],
</span><span class="noop">        ...   _1_3_6=[0., 2., 1., 3., 2.])
</span><span class="noop">
</span><span class="noop">        In the first example, discharge does not depend on the actual value
</span><span class="noop">        of the auxiliary term and is always zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2000.01.01&#39;]
</span><span class="noop">        &gt;&gt;&gt; test(0., .75, 1., 4./3., 2., 7./3., 3., 10./3.)
</span><span class="noop">        vq(0.0) qa(0.0)
</span><span class="noop">        vq(0.75) qa(0.0)
</span><span class="noop">        vq(1.0) qa(0.0)
</span><span class="noop">        vq(1.333333) qa(0.0)
</span><span class="noop">        vq(2.0) qa(0.0)
</span><span class="noop">        vq(2.333333) qa(0.0)
</span><span class="noop">        vq(3.0) qa(0.0)
</span><span class="noop">        vq(3.333333) qa(0.0)
</span><span class="noop">
</span><span class="noop">        The seconds example demonstrates that relationships are allowed to
</span><span class="noop">        contain jumps, which is the case for the (`vq`,`q`) pairs (2,6) and
</span><span class="noop">        (2,7).  Also it demonstrates that when the highest `vq` value is
</span><span class="noop">        exceeded linear extrapolation based on the two highest (`vq`,`q`)
</span><span class="noop">        pairs is performed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2000.01.02&#39;]
</span><span class="noop">        &gt;&gt;&gt; test(0., .75, 1., 4./3., 2., 7./3., 3., 10./3.)
</span><span class="noop">        vq(0.0) qa(0.0)
</span><span class="noop">        vq(0.75) qa(1.5)
</span><span class="noop">        vq(1.0) qa(2.0)
</span><span class="noop">        vq(1.333333) qa(3.0)
</span><span class="noop">        vq(2.0) qa(5.0)
</span><span class="noop">        vq(2.333333) qa(7.0)
</span><span class="noop">        vq(3.0) qa(9.0)
</span><span class="noop">        vq(3.333333) qa(10.0)
</span><span class="noop">
</span><span class="noop">        The third example shows that the relationships do not need to be
</span><span class="noop">        arranged monotonously increasing.  Particualarly for the extrapolation
</span><span class="noop">        range, this could result in negative values of `qa`, which is avoided
</span><span class="noop">        by setting it to zero in such cases:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2000.01.03&#39;]
</span><span class="noop">        &gt;&gt;&gt; test(.5, 1.5, 2.5, 3.5, 4.5, 10.)
</span><span class="noop">        vq(0.5) qa(1.0)
</span><span class="noop">        vq(1.5) qa(1.5)
</span><span class="noop">        vq(2.5) qa(2.0)
</span><span class="noop">        vq(3.5) qa(2.5)
</span><span class="noop">        vq(4.5) qa(1.5)
</span><span class="noop">        vq(10.0) qa(0.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    idx = der.toy[self.idx_sim]
</span><span class="hit">    for jdx in range(1, con.n):
</span><span class="hit">        if der.vq[idx, jdx] &gt;= aid.vq:
</span><span class="hit">            break
</span><span class="hit">    aid.qa = ((aid.vq-der.vq[idx, jdx-1]) *
</span><span class="noop">              (con.q[idx, jdx]-con.q[idx, jdx-1]) /
</span><span class="noop">              (der.vq[idx, jdx]-der.vq[idx, jdx-1]) +
</span><span class="noop">              con.q[idx, jdx-1])
</span><span class="hit">    aid.qa = max(aid.qa, 0.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_v_qa_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the stored water volume based on the equation of continuity.
</span><span class="noop">
</span><span class="noop">    Note that for too high outflow values, which would result in overdraining
</span><span class="noop">    the lake, the outflow is trimmed.
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.Seconds`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.NmbSubsteps`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_fluxes.QZ`
</span><span class="noop">
</span><span class="noop">    Updated aide sequences:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.QA`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.V`
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">      :math:`\\frac{dV}{dt}= QZ - QA`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Prepare a lake model with an initial storage of 100.000 m³ and an
</span><span class="noop">        inflow of 2 m³/s and a (potential) outflow of 6 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;6h&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.seconds.update()
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">        &gt;&gt;&gt; aides.v = 1e5
</span><span class="noop">        &gt;&gt;&gt; fluxes.qz = 2.
</span><span class="noop">        &gt;&gt;&gt; aides.qa = 6.
</span><span class="noop">
</span><span class="noop">        Through calling method `calc_v_qa_v1` three times with the same inflow
</span><span class="noop">        and outflow values, the storage is emptied after the second step and
</span><span class="noop">        outflow is equal to inflow after the third step:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.calc_v_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; aides.v
</span><span class="noop">        v(13600.0)
</span><span class="noop">        &gt;&gt;&gt; aides.qa
</span><span class="noop">        qa(6.0)
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; model.calc_v_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; aides.v
</span><span class="noop">        v(0.0)
</span><span class="noop">        &gt;&gt;&gt; aides.qa
</span><span class="noop">        qa(2.62963)
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; model.calc_v_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; aides.v
</span><span class="noop">        v(0.0)
</span><span class="noop">        &gt;&gt;&gt; aides.qa
</span><span class="noop">        qa(2.0)
</span><span class="noop">
</span><span class="noop">        Note that the results of method :func:`calc_v_qa_v1` are not based
</span><span class="noop">        depend on the (outer) simulation step size but on the (inner)
</span><span class="noop">        calculation step size defined by parameter `maxdt`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    aid.qa = min(aid.qa, flu.qz+der.nmbsubsteps/der.seconds*aid.v)
</span><span class="hit">    aid.v = max(aid.v+der.seconds/der.nmbsubsteps*(flu.qz-aid.qa), 0.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def interp_w_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual water stage based on linear interpolation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.N`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.V`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.W`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.V`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.W`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Prepare a model object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">
</span><span class="noop">        For the sake of brevity, define a test function:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; def test(*vs):
</span><span class="noop">        ...     for v in vs:
</span><span class="noop">        ...         states.v.new = v
</span><span class="noop">        ...         model.interp_w_v1()
</span><span class="noop">        ...         print(repr(states.v), repr(states.w))
</span><span class="noop">
</span><span class="noop">        Define a simple `w`-`v` relationship consisting of three nodes and
</span><span class="noop">        calculate the water stages for different volumes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; n(3)
</span><span class="noop">        &gt;&gt;&gt; v(0., 2., 4.)
</span><span class="noop">        &gt;&gt;&gt; w(-1., 1., 2.)
</span><span class="noop">
</span><span class="noop">        Perform the interpolation for a few test points:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(0., .5, 2., 3., 4., 5.)
</span><span class="noop">        v(0.0) w(-1.0)
</span><span class="noop">        v(0.5) w(-0.5)
</span><span class="noop">        v(2.0) w(1.0)
</span><span class="noop">        v(3.0) w(1.5)
</span><span class="noop">        v(4.0) w(2.0)
</span><span class="noop">        v(5.0) w(2.5)
</span><span class="noop">
</span><span class="noop">        The reference water stage of the relationship can be selected
</span><span class="noop">        arbitrarily.  Even negative water stages are returned, as is
</span><span class="noop">        demonstrated by the first two calculations.  For volumes outside
</span><span class="noop">        the range of the (`v`,`w`) pairs, the outer two highest pairs are
</span><span class="noop">        used for linear extrapolation.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    for jdx in range(1, con.n):
</span><span class="hit">        if con.v[jdx] &gt;= new.v:
</span><span class="hit">            break
</span><span class="hit">    new.w = ((new.v-con.v[jdx-1]) *
</span><span class="noop">             (con.w[jdx]-con.w[jdx-1]) /
</span><span class="noop">             (con.v[jdx]-con.v[jdx-1]) +
</span><span class="noop">             con.w[jdx-1])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def interp_v_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual water volume based on linear interpolation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.N`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.V`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.W`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.W`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.V`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Prepare a model object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">
</span><span class="noop">        For the sake of brevity, define a test function:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; def test(*ws):
</span><span class="noop">        ...     for w in ws:
</span><span class="noop">        ...         states.w.new = w
</span><span class="noop">        ...         model.interp_v_v1()
</span><span class="noop">        ...         print(repr(states.w), repr(states.v))
</span><span class="noop">
</span><span class="noop">        Define a simple `v`-`w` relationship consisting of three nodes and
</span><span class="noop">        calculate the water stages for different volumes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; n(3)
</span><span class="noop">        &gt;&gt;&gt; w(-1., 1., 2.)
</span><span class="noop">        &gt;&gt;&gt; v(0., 2., 4.)
</span><span class="noop">
</span><span class="noop">        Perform the interpolation for a few test points:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(-1., -.5, 1., 1.5, 2., 2.5)
</span><span class="noop">        w(-1.0) v(0.0)
</span><span class="noop">        w(-0.5) v(0.5)
</span><span class="noop">        w(1.0) v(2.0)
</span><span class="noop">        w(1.5) v(3.0)
</span><span class="noop">        w(2.0) v(4.0)
</span><span class="noop">        w(2.5) v(5.0)
</span><span class="noop">
</span><span class="noop">        The reference water stage of the relationship can be selected
</span><span class="noop">        arbitrarily, hence even the negative water contained in the given
</span><span class="noop">        example is allowed.  For volumes outside the range of the (`w`,`v`)
</span><span class="noop">        pairs, the outer two highest pairs are used for linear extrapolation.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    for jdx in range(1, con.n):
</span><span class="hit">        if con.w[jdx] &gt;= new.w:
</span><span class="hit">            break
</span><span class="hit">    new.v = ((new.w-con.w[jdx-1]) *
</span><span class="noop">             (con.v[jdx]-con.v[jdx-1]) /
</span><span class="noop">             (con.w[jdx]-con.w[jdx-1]) +
</span><span class="noop">             con.v[jdx-1])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def corr_dw_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Adjust the water stage drop to the highest value allowed and correct
</span><span class="noop">    the associated fluxes.
</span><span class="noop">
</span><span class="noop">    Note that method :func:`corr_dw_v1` calls the method `interp_v` of the
</span><span class="noop">    respective application model.  Hence the requirements of the actual
</span><span class="noop">    `interp_v` need to be considered additionally.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.MaxDW`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.TOY`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.Seconds`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_fluxes.QZ`
</span><span class="noop">
</span><span class="noop">    Updated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_fluxes.QA`
</span><span class="noop">
</span><span class="noop">    Updated state sequences:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.W`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.V`
</span><span class="noop">
</span><span class="noop">    Basic Restriction:
</span><span class="noop">      :math:`W_{old} - W_{new} \\leq MaxDW`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        In preparation for the following examples, define a short simulation
</span><span class="noop">        time period with a simulation step size of 12 hours and initialize
</span><span class="noop">        the required model object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2000.01.01&#39;,
</span><span class="noop">        ...                                    &#39;2000.01.04&#39;,
</span><span class="noop">        ...                                    &#39;12h&#39;))
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.toy.update()
</span><span class="noop">        &gt;&gt;&gt; derived.seconds.update()
</span><span class="noop">
</span><span class="noop">        Select the first half of the second day of January as the simulation
</span><span class="noop">        step relevant for the following examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2000.01.02&#39;]
</span><span class="noop">
</span><span class="noop">        The following tests are based on method :func:`interp_v_v1` for the
</span><span class="noop">        interpolation of the stored water volume based on the corrected
</span><span class="noop">        water stage:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.interp_v = model.interp_v_v1
</span><span class="noop">
</span><span class="noop">        For the sake of simplicity, the underlying `w`-`v` relationship is
</span><span class="noop">        assumed to be linear:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; n(2.)
</span><span class="noop">        &gt;&gt;&gt; w(0., 1.)
</span><span class="noop">        &gt;&gt;&gt; v(0., 1e6)
</span><span class="noop">
</span><span class="noop">        The maximum drop in water stage for the first half of the second
</span><span class="noop">        day of January is set to 0.4 m/d.  Note that, due to the difference
</span><span class="noop">        between the parameter step size and the simulation step size, the
</span><span class="noop">        actual value used for calculation is 0.2 m/12h:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdw(_1_1_18=.1,
</span><span class="noop">        ...       _1_2_6=.4,
</span><span class="noop">        ...       _1_2_18=.1)
</span><span class="noop">        &gt;&gt;&gt; maxdw
</span><span class="noop">        maxdw(toy_1_1_18_0_0=0.1,
</span><span class="noop">              toy_1_2_6_0_0=0.4,
</span><span class="noop">              toy_1_2_18_0_0=0.1)
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(maxdw.value[2])
</span><span class="noop">        0.2
</span><span class="noop">
</span><span class="noop">        Define old and new water stages and volumes in agreement with the
</span><span class="noop">        given linear relationship:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.w.old = 1.
</span><span class="noop">        &gt;&gt;&gt; states.v.old = 1e6
</span><span class="noop">        &gt;&gt;&gt; states.w.new = .9
</span><span class="noop">        &gt;&gt;&gt; states.v.new = 9e5
</span><span class="noop">
</span><span class="noop">        Also define an inflow and an outflow value.  Note the that the latter
</span><span class="noop">        is set to zero, which is inconsistent with the actual water stage drop
</span><span class="noop">        defined above, but done for didactic reasons:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.qz = 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa = 0.
</span><span class="noop">
</span><span class="noop">        Calling the :func:`corr_dw_v1` method does not change the values of
</span><span class="noop">        either of following sequences, as the actual drop (0.1 m/12h) is
</span><span class="noop">        smaller than the allowed drop (0.2 m/12h):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.corr_dw_v1()
</span><span class="noop">        &gt;&gt;&gt; states.w
</span><span class="noop">        w(0.9)
</span><span class="noop">        &gt;&gt;&gt; states.v
</span><span class="noop">        v(900000.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa
</span><span class="noop">        qa(0.0)
</span><span class="noop">
</span><span class="noop">        Note that the values given above are not recalculated, which can
</span><span class="noop">        clearly be seen for the lake outflow, which is still zero.
</span><span class="noop">
</span><span class="noop">        Through setting the new value of the water stage to 0.6 m, the actual
</span><span class="noop">        drop (0.4 m/12h) exceeds the allowed drop (0.2 m/12h). Hence the
</span><span class="noop">        water stage is trimmed and the other values are recalculated:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.w.new = .6
</span><span class="noop">        &gt;&gt;&gt; model.corr_dw_v1()
</span><span class="noop">        &gt;&gt;&gt; states.w
</span><span class="noop">        w(0.8)
</span><span class="noop">        &gt;&gt;&gt; states.v
</span><span class="noop">        v(800000.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa
</span><span class="noop">        qa(5.62963)
</span><span class="noop">
</span><span class="noop">        Through setting the maximum water stage drop to zero, method
</span><span class="noop">        :func:`corr_dw_v1` is effectively disabled.  Regardless of the
</span><span class="noop">        actual change in water stage, no trimming or recalculating is
</span><span class="noop">        performed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdw.toy_01_02_06 = 0.
</span><span class="noop">        &gt;&gt;&gt; states.w.new = .6
</span><span class="noop">        &gt;&gt;&gt; model.corr_dw_v1()
</span><span class="noop">        &gt;&gt;&gt; states.w
</span><span class="noop">        w(0.6)
</span><span class="noop">        &gt;&gt;&gt; states.v
</span><span class="noop">        v(800000.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa
</span><span class="noop">        qa(5.62963)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    idx = der.toy[self.idx_sim]
</span><span class="hit">    if (con.maxdw[idx] &gt; 0.) and ((old.w-new.w) &gt; con.maxdw[idx]):
</span><span class="hit">        new.w = old.w-con.maxdw[idx]
</span><span class="hit">        self.interp_v()
</span><span class="hit">        flu.qa = flu.qz+(old.v-new.v)/der.seconds
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def modify_qa_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Add water to or remove water from the calculated lake outflow.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.Verzw`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.TOY`
</span><span class="noop">
</span><span class="noop">    Updated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_fluxes.QA`
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">      :math:`QA = QA* - Verzw`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        In preparation for the following examples, define a short simulation
</span><span class="noop">        time period with a simulation step size of 12 hours and initialize
</span><span class="noop">        the required model object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2000.01.01&#39;,
</span><span class="noop">        ...                                    &#39;2000.01.04&#39;,
</span><span class="noop">        ...                                    &#39;12h&#39;))
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.toy.update()
</span><span class="noop">
</span><span class="noop">        Select the first half of the second day of January as the simulation
</span><span class="noop">        step relevant for the following examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2000.01.02&#39;]
</span><span class="noop">
</span><span class="noop">        Assume that, in accordance with previous calculations, the original
</span><span class="noop">        outflow value is 3 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa = 3.
</span><span class="noop">
</span><span class="noop">        Prepare the shape of parameter `verzw` (usually, this is done
</span><span class="noop">        automatically when calling parameter `n`):
</span><span class="noop">        &gt;&gt;&gt; verzw.shape = (None,)
</span><span class="noop">
</span><span class="noop">        Set the value of the abstraction on the first half of the second
</span><span class="noop">        day of January to 2 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; verzw(_1_1_18=0.,
</span><span class="noop">        ...       _1_2_6=2.,
</span><span class="noop">        ...       _1_2_18=0.)
</span><span class="noop">
</span><span class="noop">        In the first example `verzw` is simply subtracted from `qa`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.modify_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa
</span><span class="noop">        qa(1.0)
</span><span class="noop">
</span><span class="noop">        In the second example `verzw` exceeds `qa`, resulting in a zero
</span><span class="noop">        outflow value:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.modify_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa
</span><span class="noop">        qa(0.0)
</span><span class="noop">
</span><span class="noop">        The last example demonstrates, that &#34;negative abstractions&#34; are
</span><span class="noop">        allowed, resulting in an increase in simulated outflow:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; verzw.toy_1_2_6 = -2.
</span><span class="noop">        &gt;&gt;&gt; model.modify_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa
</span><span class="noop">        qa(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    idx = der.toy[self.idx_sim]
</span><span class="hit">    flu.qa = max(flu.qa-con.verzw[idx], 0.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pick_q_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the inlet link sequence.&#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    inl = self.sequences.inlets.fastaccess
</span><span class="hit">    flu.qz = 0.
</span><span class="hit">    for idx in range(inl.len_q):
</span><span class="hit">        flu.qz += inl.q[idx][0]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pass_q_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the outlet link sequence.&#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    out = self.sequences.outlets.fastaccess
</span><span class="hit">    out.q[0] += flu.qa
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;Base model for HydPy-L-Lake.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _INLET_METHODS = (pick_q_v1,)
</span><span class="hit">    _RUN_METHODS = (solve_dv_dt_v1,
</span><span class="noop">                    interp_w_v1,
</span><span class="noop">                    corr_dw_v1,
</span><span class="noop">                    modify_qa_v1,)
</span><span class="hit">    _ADD_METHODS = (interp_v_v1,
</span><span class="noop">                    calc_vq_v1,
</span><span class="noop">                    interp_qa_v1,
</span><span class="noop">                    calc_v_qa_v1)
</span><span class="hit">    _OUTLET_METHODS = (pass_q_v1,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss (runoff) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of HydPy-L-Lake.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/llake/llake_states.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class V(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasservolumen (water volume) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class W(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasserstand (water stage) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of HydPy-L-Lake.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (V, W)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">The L-Land model is the core of the HydPy implementation of the
</span><span class="noop">LARSIM model.  It consists of routines for the preparation
</span><span class="noop">of meteorological input, the calculation of potential evaporation,
</span><span class="noop">the simulation of water stored on plants, in the snow layer and in the
</span><span class="noop">soil, as well as runoff concentration.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from lland
</span><span class="hit">from hydpy.models.lland.lland_constants import (SIED_D, SIED_L, VERS, ACKER,
</span><span class="noop">                                                WEINB, OBSTB, BODEN, GLETS,
</span><span class="noop">                                                GRUE_I, FEUCHT, GRUE_E, BAUMB,
</span><span class="noop">                                                NADELW, LAUBW, MISCHW, WASSER)
</span><span class="hit">from hydpy.models.lland.lland_parameters import Parameters
</span><span class="hit">from hydpy.models.lland.lland_control import ControlParameters
</span><span class="hit">from hydpy.models.lland.lland_derived import DerivedParameters
</span><span class="hit">from hydpy.models.lland.lland_inputs import InputSequences
</span><span class="hit">from hydpy.models.lland.lland_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.lland.lland_states import StateSequences
</span><span class="hit">from hydpy.models.lland.lland_aides import AideSequences
</span><span class="hit">from hydpy.models.lland.lland_outlets import OutletSequences
</span><span class="hit">from hydpy.models.lland.lland_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_aides.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_aides.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Temp(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Temporary variable used in different methods [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SfA(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Sättigungsflächen-Aktivität (activity of the saturated surface) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Exz(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Bodenfeuchteüberschuss (excess of soil water) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BVl(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Berechneter Bodenwasserverlust (calculated amount of water that should
</span><span class="noop">    be released from the soil) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MVl(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Möglicher Bodenwasserverlust (maximum amount of water released that can
</span><span class="noop">    be released from the soil) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RVl(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Relation von MVl und BVl (ratio of MVl and BVl) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EPW(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Potenzielle Evaporation/Evapotranspiration von Wasserflächen (potential
</span><span class="noop">    evaporation/evapotranspiration combined from all water areas) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of the HydPy-L-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Temp, SfA, Exz, BVl, MVl, RVl, EPW)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_constants.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_constants.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;The HydPy-L-Land model (`lland`) allows for the subdivision of subbasins
</span><span class="noop">into hydrological response units (hru).  Some processes, e.g. interception,
</span><span class="noop">are calculated seperately for each zone.  This is why some parameters (e.g.
</span><span class="noop">the usable field capacity :class:`~hydpy.models.lland.lland_control.NFk`)
</span><span class="noop">and some sequences (e.g. the actual soil water storage
</span><span class="noop">:class:`~hydpy.models.lland.lland_states.BoWa`) are 1-dimensional.  Each entry
</span><span class="noop">represents the value of a different hru.
</span><span class="noop">
</span><span class="noop">In contrasts to the original LARSIM model, the HydPy-L-Land model allows for
</span><span class="noop">arbitrary definitions of units.  Nevertheless, the original distinction
</span><span class="noop">in accordance with sixteen different landuse types is still supported.  The
</span><span class="noop">parameter :class:`~hydpy.models.lland.lland_control.Lnk` defines,
</span><span class="noop">which entry of e.g. :class:`~hydpy.models.lland.lland_control.NFk` is
</span><span class="noop">related to which land use type via integer values.  Note that for the units
</span><span class="noop">of the most land use types, the same equations are applied. Only units
</span><span class="noop">of type `VERS` and `WASSER` are partly connected to different process
</span><span class="noop">equations.
</span><span class="noop">
</span><span class="noop">For comprehensibility, this module introduces the relevant integer constants.
</span><span class="noop">Through performing a wildcard import
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">
</span><span class="noop">these are available in your local namespace:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; (SIED_D, SIED_L, VERS, ACKER, WEINB, OBSTB, BODEN, GLETS, GRUE_I,
</span><span class="noop">...  FEUCHT, GRUE_E, BAUMB, NADELW, LAUBW, MISCHW, WASSER)
</span><span class="noop">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">SIED_D = 1
</span><span class="noop">&#34;&#34;&#34;Constant for `Siedlung, dicht` (settlement, dense).&#34;&#34;&#34;
</span><span class="hit">SIED_L = 2
</span><span class="noop">&#34;&#34;&#34;Constant for `Siedlung, locker` (settlement, light).&#34;&#34;&#34;
</span><span class="hit">VERS = 3
</span><span class="noop">&#34;&#34;&#34;Constant for `versiegelt` (sealed).&#34;&#34;&#34;
</span><span class="hit">ACKER = 4
</span><span class="noop">&#34;&#34;&#34;Constant for `Acker` (fields).&#34;&#34;&#34;
</span><span class="hit">WEINB = 5
</span><span class="noop">&#34;&#34;&#34;Constant for `Weinbau` (viniculture).&#34;&#34;&#34;
</span><span class="hit">OBSTB = 6
</span><span class="noop">&#34;&#34;&#34;Constant for `Obstbau` (intensive orchards).&#34;&#34;&#34;
</span><span class="hit">BODEN = 7
</span><span class="noop">&#34;&#34;&#34;Constant for `unbewachsener Boden` (unsealed soil, not overgrown).&#34;&#34;&#34;
</span><span class="hit">GLETS = 8
</span><span class="noop">&#34;&#34;&#34;Constant for `Gletscher` (`glacier`).&#34;&#34;&#34;
</span><span class="hit">GRUE_I = 9
</span><span class="noop">&#34;&#34;&#34;Constant for `Grünland, intensiv` (intensive pasture).&#34;&#34;&#34;
</span><span class="hit">FEUCHT = 10
</span><span class="noop">&#34;&#34;&#34;Constant for `Feuchtflächen` (wetlands).&#34;&#34;&#34;
</span><span class="hit">GRUE_E = 11
</span><span class="noop">&#34;&#34;&#34;Constant for `Grünland, extensiv` (extensive pasture).&#34;&#34;&#34;
</span><span class="hit">BAUMB = 12
</span><span class="noop">&#34;&#34;&#34;Constant for `lockerer Baumbestand` (sparsely populated forest).&#34;&#34;&#34;
</span><span class="hit">NADELW = 13
</span><span class="noop">&#34;&#34;&#34;Constant for `Nadelwald` (coniferous forest).&#34;&#34;&#34;
</span><span class="hit">LAUBW = 14
</span><span class="noop">&#34;&#34;&#34;Constant for `Laubwald` (deciduous forest).&#34;&#34;&#34;
</span><span class="hit">MISCHW = 15
</span><span class="noop">&#34;&#34;&#34;Constant for `Mischwald` (mixed forest).&#34;&#34;&#34;
</span><span class="hit">WASSER = 16
</span><span class="noop">&#34;&#34;&#34;Constant for `Wasser` (water).&#34;&#34;&#34;
</span><span class="hit">CONSTANTS = {key: value for key, value in locals().items()
</span><span class="noop">             if (key.isupper() and isinstance(value, int))}
</span><span class="hit">&#34;&#34;&#34;Dictionary containing all constants defined by HydPy-L-Land.&#34;&#34;&#34;
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import warnings
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import timetools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.lland import lland_constants
</span><span class="hit">from hydpy.models.lland import lland_parameters
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FT(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Teileinzugsgebietsfläche (subbasin area) [km²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (1e-10, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NHRU(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Anzahl der Hydrotope (number of hydrological response units) [-].
</span><span class="noop">
</span><span class="noop">    Note that :class:`NHRU` determines the length of most 1-dimensional
</span><span class="noop">    HydPy-L-Land parameters and sequences.  This required that the value of
</span><span class="noop">    the respective :class:`NHRU` instance is set before any of the values
</span><span class="noop">    of these 1-dimensional parameters or sequences are set.  Changing the
</span><span class="noop">    value of the :class:`NHRU` instance necessitates setting their values
</span><span class="noop">    again.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(5)
</span><span class="noop">        &gt;&gt;&gt; control.kg.shape
</span><span class="noop">        (5,)
</span><span class="noop">        &gt;&gt;&gt; fluxes.tkor.shape
</span><span class="noop">        (5,)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (1, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass a value to :class:`NHRU` instances
</span><span class="noop">        within parameter control files.  Sets the shape of the associated
</span><span class="noop">        1-dimensional parameter and sequence objects additionally.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        for (_name, subpars) in self.subpars.pars.model.parameters:
</span><span class="hit">            for (name, par) in subpars:
</span><span class="hit">                if par.NDIM == 1:
</span><span class="hit">                    par.shape = self.value
</span><span class="hit">        for (_name, subseqs) in self.subpars.pars.model.sequences:
</span><span class="hit">            for (name, seq) in subseqs:
</span><span class="hit">                if (seq.NDIM == 1) and (seq.name != &#39;moy&#39;):
</span><span class="hit">                    seq.shape = self.value
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FHRU(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Flächenanteile der Hydrotope (area percentages of the respective
</span><span class="noop">    HRUs) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Lnk(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Landnutzungsklasse (land use class) [-].
</span><span class="noop">
</span><span class="noop">    For increasing legibility, the HydPy-L-Land constants are used for string
</span><span class="noop">    representions of :class:`Lnk` instances:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; nhru(4)
</span><span class="noop">    &gt;&gt;&gt; lnk(ACKER, ACKER, WASSER, MISCHW)
</span><span class="noop">    &gt;&gt;&gt; lnk.values
</span><span class="noop">    array([ 4,  4, 16, 15])
</span><span class="noop">    &gt;&gt;&gt; lnk
</span><span class="noop">    lnk(ACKER, ACKER, WASSER, MISCHW)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME = 1, int, None
</span><span class="hit">    SPAN = (min(lland_constants.CONSTANTS.values()),
</span><span class="noop">            max(lland_constants.CONSTANTS.values()))
</span><span class="noop">
</span><span class="hit">    def compressrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a list which contains a string representation with land
</span><span class="noop">        uses beeing defined by the constants
</span><span class="noop">        :const:`~hydpy.models.lland.lland_constants.SIED_D`,
</span><span class="noop">        :const:`~hydpy.models.lland.lland_constants.SIED_L`...
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        invmap = {value: key for key, value in
</span><span class="noop">                  lland_constants.CONSTANTS.items()}
</span><span class="hit">        return [&#39;, &#39;.join(invmap.get(value, repr(value))
</span><span class="noop">                          for value in self.values)]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HNN(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Höhe über Normal-Null (height above sea level) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KG(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Niederschlagskorrekturfaktor (adjustment factor for precipitation)
</span><span class="noop">    [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="hit">    INIT = 1.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KT(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Temperaturkorrektursummand (adjustment summand for air temperature)
</span><span class="noop">    [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="hit">    INIT = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KE(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Grasreferenzverdunstungskorrekturfaktor (adjustment factor for
</span><span class="noop">    reference evapotranspiration) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="hit">    INIT = 1.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KF(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Küstenfaktor (&#34;coast factor&#34; of Turc-Wendling&#39;s evaporation equation
</span><span class="noop">    [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (.6, 1.)
</span><span class="hit">    INIT = 1.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FLn(lland_parameters.LanduseMonthParameter):
</span><span class="noop">    &#34;&#34;&#34;Landnutzungsabhängiger Verdunstungsfaktor (factor for adjusting
</span><span class="noop">    reference evapotranspiration to different land use classes) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (0., None)
</span><span class="hit">    INIT = 1.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HInz(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Interzeptionskapazität bezogen auf die Blattoberfläche (interception
</span><span class="noop">    capacity normalized to the leaf surface area) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = .2
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LAI(lland_parameters.LanduseMonthParameter):
</span><span class="noop">    &#34;&#34;&#34;Blattflächenindex (leaf area index) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (0., None)
</span><span class="hit">    INIT = 5.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TRefT(lland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Lufttemperaturgrenzwert des grundlegenden Grad-Tag-Verfahrens
</span><span class="noop">    (air temperature threshold of the degree-day method) [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="hit">    INIT = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TRefN(lland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Niederschlagstemperaturgrenzwert des erweiterten Grad-Tag-Verfahrens
</span><span class="noop">    (precipitation temperature threshold of the degree-day method) [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="hit">    INIT = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TGr(lland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Temperaturgrenzwert flüssiger/fester Niederschlag (threshold
</span><span class="noop">    temperature liquid/frozen precipitation) [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="hit">    INIT = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TSp(lland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Temperaturspanne flüssiger/fester Niederschlag (temperature range
</span><span class="noop">    with mixed precipitation) [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="hit">    INIT = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class GTF(lland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Grad-Tag-Faktor (factor of the degree-day method) [mm/°C/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="hit">    INIT = 3.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RSchmelz(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Spezifische Schmelzwärme von Wasser (specific melt heat of water)
</span><span class="noop">    [J/g].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 334.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class CPWasser(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Spezifische Wärmekapazität von Wasser (specific heat capacity of water)
</span><span class="noop">    [J/g].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 4.1868
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PWMax(lland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Maximalverhältnis Gesamt- zu Trockenschnee (maximum ratio of the
</span><span class="noop">    total and the frozen water equivalent stored in the snow cover) [-].
</span><span class="noop">
</span><span class="noop">    In addition to the :class:`parametertools.SingleParameter` call method, it
</span><span class="noop">    is possible to set the value of parameter :class:`PWMax` in accordance to
</span><span class="noop">    the keyword arguments `rhot0` and `rhodkrit`.
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">        :math:`PWMax = \\frac{1.474 \\cdot rhodkrit}
</span><span class="noop">        {rhot0 + 0.474 \\cdot rhodkrit}`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        Using the common values for both rhot0 and rhodkrit...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nhru(1)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER)
</span><span class="noop">        &gt;&gt;&gt; pwmax(rhot0=0.2345, rhodkrit=0.42)
</span><span class="noop">
</span><span class="noop">        ...leads to,...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; pwmax
</span><span class="noop">        pwmax(1.427833)
</span><span class="noop">
</span><span class="noop">        This is also the default value of :class:`PWMax` and means that
</span><span class="noop">        the proportion of the liquid water in the snow cover cannot go
</span><span class="noop">        above 30%.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (1., None)
</span><span class="hit">    INIT = 1.4278333871488538
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`PWMax` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            lland_parameters.MultiParameterLand.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            counter = (&#39;rhot0&#39; in kwargs) + (&#39;rhodkrit&#39; in kwargs)
</span><span class="hit">            if counter == 0:
</span><span class="miss">                raise ValueError(&#39;For parameter `pwmax` a value can be set &#39;
</span><span class="noop">                                 &#39;directly by passing a single value or &#39;
</span><span class="noop">                                 &#39;indirectly by using the keyword arguments &#39;
</span><span class="noop">                                 &#39;`rhot0` and `rhodkrit`.&#39;)
</span><span class="hit">            elif counter == 1:
</span><span class="miss">                raise ValueError(&#39;For the alternative calculation of &#39;
</span><span class="noop">                                 &#39;parameter `pwmax`, values for both keyword &#39;
</span><span class="noop">                                 &#39;keyword arguments `rhot0` and `rhodkrit` &#39;
</span><span class="noop">                                 &#39;must be given.&#39;)
</span><span class="noop">            else:
</span><span class="hit">                rhot0 = float(kwargs[&#39;rhot0&#39;])
</span><span class="hit">                rhodkrit = float(kwargs[&#39;rhodkrit&#39;])
</span><span class="hit">                self(1.474*rhodkrit/(rhot0+0.474*rhodkrit))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class GrasRef_R(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Bodenfeuchte-Verdunstung-Parameter (soil moisture dependend
</span><span class="noop">    evaporation factor) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 5.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NFk(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Nutzbare Feldkapazität (usable field capacity) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="hit">    INIT = 100.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelWZ(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Relative Mindestbodenfeuchte für die Interflowentstehung (threshold
</span><span class="noop">       value of relative soil moisture for interflow generation) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, 1.)
</span><span class="hit">    INIT = .8
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with :math:`RelWB \\leq RelWZ`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(3)
</span><span class="noop">        &gt;&gt;&gt; relwb.values = .5
</span><span class="noop">        &gt;&gt;&gt; relwz(0.2, .5, .8)
</span><span class="noop">        &gt;&gt;&gt; relwz
</span><span class="noop">        relwz(0.5, 0.5, 0.8)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        relwb = self.subpars.relwb.value
</span><span class="hit">        if (lower is None) and (relwb is not None):
</span><span class="hit">            lower = relwb
</span><span class="hit">        lland_parameters.MultiParameterSoil.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelWB(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Relative Mindestbodenfeuchte für die Basisabflussentstehung (threshold
</span><span class="noop">       value of relative soil moisture for base flow generation) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="hit">    INIT = .05
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with :math:`RelWB \\leq RelWZ`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(3)
</span><span class="noop">        &gt;&gt;&gt; relwz.values = .5
</span><span class="noop">        &gt;&gt;&gt; relwb(0.2, .5, .8)
</span><span class="noop">        &gt;&gt;&gt; relwb
</span><span class="noop">        relwb(0.2, 0.5, 0.5)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        relwz = self.subpars.relwz.value
</span><span class="hit">        if (upper is None) and (relwz is not None):
</span><span class="hit">            upper = relwz
</span><span class="hit">        lland_parameters.MultiParameterSoil.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Beta(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Drainageindex des tiefen Bodenspeichers (storage coefficient for
</span><span class="noop">    releasing base flow from the lower soil compartment) [1/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="hit">    INIT = .01
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FBeta(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Faktor zur Erhöhung der Perkolation im Grobporenbereich (factor for
</span><span class="noop">    increasing percolation under wet conditions) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (1., None)
</span><span class="hit">    INIT = 1.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DMin(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Drainageindex des mittleren Bodenspeichers (flux rate for
</span><span class="noop">    releasing interflow from the middle soil compartment) [mm/T].
</span><span class="noop">
</span><span class="noop">    In addition to the :class:`parametertools.MultiParameterSoil` call method,
</span><span class="noop">    it is possible to set the value of parameter :class:`DMin` in accordance
</span><span class="noop">    to the keyword argument `r_dmin` due to compatibility reasons with the
</span><span class="noop">    original LARSIM implemetation.
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">        :math:`Dmin = 0.024192 \\cdot r_dmin`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(1)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER)
</span><span class="noop">        &gt;&gt;&gt; dmax(10.) # to prevent trimming of dmin, see below
</span><span class="noop">        &gt;&gt;&gt; dmin(r_dmin=10.)
</span><span class="noop">        &gt;&gt;&gt; dmin
</span><span class="noop">        dmin(0.24192)
</span><span class="noop">
</span><span class="noop">        Note the additional dependence of the parameter value on the
</span><span class="noop">        relation between the `parameterstep` and the actual `simulationstep`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; dmin.values
</span><span class="noop">        array([ 0.12096])
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="hit">    INIT = 0.
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`DMin` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            lland_parameters.MultiParameterSoil.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            args = kwargs.get(&#39;r_dmin&#39;)
</span><span class="hit">            if args is not None:
</span><span class="hit">                self.values = 0.024192*self.applytimefactor(numpy.array(args))
</span><span class="hit">                self.trim()
</span><span class="noop">            else:
</span><span class="miss">                objecttools.augmentexcmessage()
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with :math:`DMin \\leq DMax`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(5)
</span><span class="noop">        &gt;&gt;&gt; dmax.values = 2.
</span><span class="noop">        &gt;&gt;&gt; dmin(-2., 0., 2., 4., 6.)
</span><span class="noop">        &gt;&gt;&gt; dmin
</span><span class="noop">        dmin(0.0, 0.0, 2.0, 4.0, 4.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subpars.dmax
</span><span class="hit">        lland_parameters.MultiParameterSoil.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DMax(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Drainageindex des oberen Bodenspeichers (additional flux rate for
</span><span class="noop">    releasing interflow from the upper soil compartment) [mm/T].
</span><span class="noop">
</span><span class="noop">    In addition to the :class:`parametertools.MultiParameterSoil` call method,
</span><span class="noop">    it is possible to set the value of parameter :class:`DMax` in accordance
</span><span class="noop">    to the keyword argument `r_dmax` due to compatibility reasons with the
</span><span class="noop">    original LARSIM implemetation.
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">        :math:`Dmax = 2.4192 \\cdot r_dmax`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(1)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER)
</span><span class="noop">        &gt;&gt;&gt; dmin(0.) # to prevent trimming of dmax, see below
</span><span class="noop">        &gt;&gt;&gt; dmax(r_dmax=10.)
</span><span class="noop">        &gt;&gt;&gt; dmax
</span><span class="noop">        dmax(24.192)
</span><span class="noop">
</span><span class="noop">        Note the additional dependence of the parameter value on the
</span><span class="noop">        relation between the `parameterstep` and the actual `simulationstep`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; dmax.values
</span><span class="noop">        array([ 12.096])
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (None, None)
</span><span class="hit">    INIT = 1.
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`DMin` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            lland_parameters.MultiParameterSoil.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            args = kwargs.get(&#39;r_dmax&#39;)
</span><span class="hit">            if args is not None:
</span><span class="hit">                self.values = 2.4192*self.applytimefactor(numpy.array(args))
</span><span class="hit">                self.trim()
</span><span class="noop">            else:
</span><span class="miss">                objecttools.augmentexcmessage()
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with :math:`DMax \\geq DMin`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(3)
</span><span class="noop">        &gt;&gt;&gt; dmin.values = 2.
</span><span class="noop">        &gt;&gt;&gt; dmax(2., 4., 6.)
</span><span class="noop">        &gt;&gt;&gt; dmax
</span><span class="noop">        dmax(4.0, 4.0, 6.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if lower is None:
</span><span class="hit">            lower = self.subpars.dmin
</span><span class="hit">        lland_parameters.MultiParameterSoil.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BSf(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Bodenfeuchte-Sättigungsfläche-Parameter (shape parameter for the
</span><span class="noop">    relation between the avarage soil moisture and the relative saturated
</span><span class="noop">    area of a subbasin) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="hit">    INIT = .4
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class A1(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Parameter für die kontinuierliche Aufteilung der
</span><span class="noop">    Direktabflusskomponenten (threshold value for the continuous seperation
</span><span class="noop">    of direct runoff in a slow and a fast component) [mm/d]
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (0., None)
</span><span class="hit">    INIT = numpy.inf
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class A2(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Parameter für die diskontinuierliche Aufteilung der
</span><span class="noop">    Direktabflusskomponenten (threshold value for the discontinuous seperation
</span><span class="noop">    of direct runoff in a slow and a fast component) [mm/d]
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (0., None)
</span><span class="hit">    INIT = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TInd(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Fließzeitindex (factor related to the time of concentration) [T].
</span><span class="noop">
</span><span class="noop">    In addition to the :class:`parametertools.SingleParameter` call method, it
</span><span class="noop">    is possible to set the value of parameter :class:`TInd` in accordance to
</span><span class="noop">    the keyword arguments `tal` (talweg, [km]), `hot` (higher reference
</span><span class="noop">    altitude, [m]), and `hut` (lower reference altitude, [m]).  This is
</span><span class="noop">    supposed to decrease the time of runoff concentration in small and/or
</span><span class="noop">    steep catchments.  Note that :class:`TInd` does not only affect direct
</span><span class="noop">    runoff, but interflow and base flow as well.  Hence it seems advisable
</span><span class="noop">    to use this regionalization strategy with caution.
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">        :math:`TInd[h] = (0.868 \\cdot \\frac{Tal^3}{HOT-HUT})^{0.385}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Using typical values:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; tind(tal=5., hot=210., hut=200.)
</span><span class="noop">        &gt;&gt;&gt; tind
</span><span class="noop">        tind(0.104335)
</span><span class="noop">
</span><span class="noop">        Note that this result is related to the selected parameter step size
</span><span class="noop">        of one day.  The value related to the selected simulation step size
</span><span class="noop">        of 12 hours is:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; round(tind.value, 6)
</span><span class="noop">        0.20867
</span><span class="noop">
</span><span class="noop">        Unplausible input values lead to the following exception:
</span><span class="noop">        &gt;&gt;&gt; tind(tal=5., hot=200., hut=200.)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: For the alternative calculation of parameter `tind`, the value assigned to keyword argument `tal` must be greater then zero and the one of `hot` must be greater than the one of `hut`.  However, for element ?, the values `5.0`, `200.0` and `200.0` were given respectively.
</span><span class="noop">        &gt;&gt;&gt; tind(tal=0., hot=210., hut=200.)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: For the alternative calculation of parameter `tind`, the value assigned to keyword argument `tal` must be greater then zero and the one of `hot` must be greater than the one of `hut`.  However, for element ?, the values `0.0`, `210.0` and `200.0` were given respectively.
</span><span class="noop">
</span><span class="noop">        However, it is hard to define exact bounds for the value of
</span><span class="noop">        :class:`TInd` itself.  Whenever it is below 0.001 or above 1000 days,
</span><span class="noop">        the following warning is given:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; tind(tal=.001, hot=210., hut=200.)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        UserWarning: Due to the given values for the keyword arguments `tal` (0.001), `hot` (210.0) and `hut` (200.0), parameter `tind` of element `?` has been set to an unrealistic value of `0.000134 hours`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, False, (0., None)
</span><span class="hit">    INIT = 1.
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`TInd` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            counter = (&#39;tal&#39; in kwargs) + (&#39;hot&#39; in kwargs) + (&#39;hut&#39; in kwargs)
</span><span class="hit">            if counter == 0:
</span><span class="miss">                raise ValueError(&#39;For parameter `tind` a value can be set &#39;
</span><span class="noop">                                 &#39;directly by passing a single value or &#39;
</span><span class="noop">                                 &#39;indirectly by using the keyword arguments &#39;
</span><span class="noop">                                 &#39;`tal`, `hot`, and `hut`.&#39;)
</span><span class="hit">            elif counter &lt; 3:
</span><span class="miss">                raise ValueError(&#39;For the alternative calculation of &#39;
</span><span class="noop">                                 &#39;parameter `tind`, values for all three &#39;
</span><span class="noop">                                 &#39;keyword keyword arguments `tal`, `hot`, &#39;
</span><span class="noop">                                 &#39;and `hut` must be given.&#39;)
</span><span class="noop">            else:
</span><span class="hit">                tal = float(kwargs[&#39;tal&#39;])
</span><span class="hit">                hot = float(kwargs[&#39;hot&#39;])
</span><span class="hit">                hut = float(kwargs[&#39;hut&#39;])
</span><span class="hit">                if (tal &lt;= 0.) or (hot &lt;= hut):
</span><span class="hit">                    raise ValueError(&#39;For the alternative calculation of &#39;
</span><span class="noop">                                     &#39;parameter `tind`, the value assigned to &#39;
</span><span class="noop">                                     &#39;keyword argument `tal` must be greater &#39;
</span><span class="noop">                                     &#39;then zero and the one of `hot` must be &#39;
</span><span class="noop">                                     &#39;greater than the one of `hut`.  &#39;
</span><span class="noop">                                     &#39;However, for element %s, the values &#39;
</span><span class="noop">                                     &#39;`%s`, `%s` and `%s` were given &#39;
</span><span class="noop">                                     &#39;respectively.&#39;
</span><span class="noop">                                     % (objecttools.devicename(self),
</span><span class="noop">                                        tal, hot, hut))
</span><span class="hit">                self.value = (.868*tal**3/(hot-hut))**.385
</span><span class="hit">                if (self &gt; 1000.) or (self &lt; .001):
</span><span class="hit">                    warnings.warn(&#39;Due to the given values for the keyword &#39;
</span><span class="noop">                                  &#39;arguments `tal` (%s), `hot` (%s) and `hut` &#39;
</span><span class="noop">                                  &#39;(%s), parameter `tind` of element `%s` has &#39;
</span><span class="noop">                                  &#39;been set to an unrealistic value of `%s &#39;
</span><span class="noop">                                  &#39;hours`.&#39; % (tal, hot, hut,
</span><span class="noop">                                               objecttools.devicename(self),
</span><span class="noop">                                               round(self.value, 6)))
</span><span class="hit">                self.value *= timetools.Period(&#39;1h&#39;)/self.simulationstep
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EQB(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor für die Basisabflusskonzentration (factor for adjusting
</span><span class="noop">    the concentration time of baseflow). [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 5000.
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with :math:`EQI1 \\leq EQB`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; eqi1.value = 2.
</span><span class="noop">        &gt;&gt;&gt; eqb(1.)
</span><span class="noop">        &gt;&gt;&gt; eqb
</span><span class="noop">        eqb(2.0)
</span><span class="noop">        &gt;&gt;&gt; eqb(2.)
</span><span class="noop">        &gt;&gt;&gt; eqb
</span><span class="noop">        eqb(2.0)
</span><span class="noop">        &gt;&gt;&gt; eqb(3.)
</span><span class="noop">        &gt;&gt;&gt; eqb
</span><span class="noop">        eqb(3.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if lower is None:
</span><span class="hit">            lower = self.subpars.eqi1
</span><span class="hit">        parametertools.SingleParameter.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EQI1(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor für die &#34;untere&#34; Zwischenabflusskonzentration
</span><span class="noop">    (factor for adjusting the concentration time of the first interflow
</span><span class="noop">    component) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 2000.
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with
</span><span class="noop">        :math:`EQI2 \\leq EQI1 \\leq EQB`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; eqb.value = 3.
</span><span class="noop">        &gt;&gt;&gt; eqi2.value = 1.
</span><span class="noop">        &gt;&gt;&gt; eqi1(0.)
</span><span class="noop">        &gt;&gt;&gt; eqi1
</span><span class="noop">        eqi1(1.0)
</span><span class="noop">        &gt;&gt;&gt; eqi1(1.)
</span><span class="noop">        &gt;&gt;&gt; eqi1
</span><span class="noop">        eqi1(1.0)
</span><span class="noop">        &gt;&gt;&gt; eqi1(2.)
</span><span class="noop">        &gt;&gt;&gt; eqi1
</span><span class="noop">        eqi1(2.0)
</span><span class="noop">        &gt;&gt;&gt; eqi1(3.)
</span><span class="noop">        &gt;&gt;&gt; eqi1
</span><span class="noop">        eqi1(3.0)
</span><span class="noop">        &gt;&gt;&gt; eqi1(4.)
</span><span class="noop">        &gt;&gt;&gt; eqi1
</span><span class="noop">        eqi1(3.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if lower is None:
</span><span class="hit">            lower = self.subpars.eqi2
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subpars.eqb
</span><span class="hit">        parametertools.SingleParameter.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EQI2(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor für die &#34;obere&#34; Zwischenabflusskonzentration
</span><span class="noop">    (factor for adjusting the concentration time of the second interflow
</span><span class="noop">    component) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 1000.
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with
</span><span class="noop">        :math:`EQD \\leq EQI2 \\leq EQI1`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; eqi1.value = 3.
</span><span class="noop">        &gt;&gt;&gt; eqd1.value = 1.
</span><span class="noop">        &gt;&gt;&gt; eqi2(0.)
</span><span class="noop">        &gt;&gt;&gt; eqi2
</span><span class="noop">        eqi2(1.0)
</span><span class="noop">        &gt;&gt;&gt; eqi2(1.)
</span><span class="noop">        &gt;&gt;&gt; eqi2
</span><span class="noop">        eqi2(1.0)
</span><span class="noop">        &gt;&gt;&gt; eqi2(2.)
</span><span class="noop">        &gt;&gt;&gt; eqi2
</span><span class="noop">        eqi2(2.0)
</span><span class="noop">        &gt;&gt;&gt; eqi2(3.)
</span><span class="noop">        &gt;&gt;&gt; eqi2
</span><span class="noop">        eqi2(3.0)
</span><span class="noop">        &gt;&gt;&gt; eqi2(4.)
</span><span class="noop">        &gt;&gt;&gt; eqi2
</span><span class="noop">        eqi2(3.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if lower is None:
</span><span class="hit">            lower = self.subpars.eqd1
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subpars.eqi1
</span><span class="hit">        parametertools.SingleParameter.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EQD1(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor für die langsamere Direktabflusskonzentration (factor
</span><span class="noop">    for adjusting the concentration time of the slower component of direct
</span><span class="noop">    runoff). [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 100.
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with
</span><span class="noop">        :math:`EQD2 \\leq EQD1 \\leq EQI2`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; eqi2.value = 3.
</span><span class="noop">        &gt;&gt;&gt; eqd2.value = 1.
</span><span class="noop">        &gt;&gt;&gt; eqd1(0.)
</span><span class="noop">        &gt;&gt;&gt; eqd1
</span><span class="noop">        eqd1(1.0)
</span><span class="noop">        &gt;&gt;&gt; eqd1(1.)
</span><span class="noop">        &gt;&gt;&gt; eqd1
</span><span class="noop">        eqd1(1.0)
</span><span class="noop">        &gt;&gt;&gt; eqd1(2.)
</span><span class="noop">        &gt;&gt;&gt; eqd1
</span><span class="noop">        eqd1(2.0)
</span><span class="noop">        &gt;&gt;&gt; eqd1(3.)
</span><span class="noop">        &gt;&gt;&gt; eqd1
</span><span class="noop">        eqd1(3.0)
</span><span class="noop">        &gt;&gt;&gt; eqd1(4.)
</span><span class="noop">        &gt;&gt;&gt; eqd1
</span><span class="noop">        eqd1(3.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if lower is None:
</span><span class="hit">            lower = self.subpars.eqd2
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subpars.eqi2
</span><span class="hit">        parametertools.SingleParameter.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EQD2(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor für die schnellere Direktabflusskonzentration (factor
</span><span class="noop">    for adjusting the concentration time of the faster component of direct
</span><span class="noop">    runoff). [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 50.
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with
</span><span class="noop">        :math:`EQD2 \\leq EQD1`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; eqd1.value = 3.
</span><span class="noop">        &gt;&gt;&gt; eqd2(2.)
</span><span class="noop">        &gt;&gt;&gt; eqd2
</span><span class="noop">        eqd2(2.0)
</span><span class="noop">        &gt;&gt;&gt; eqd2(3.)
</span><span class="noop">        &gt;&gt;&gt; eqd2
</span><span class="noop">        eqd2(3.0)
</span><span class="noop">        &gt;&gt;&gt; eqd2(4.)
</span><span class="noop">        &gt;&gt;&gt; eqd2
</span><span class="noop">        eqd2(3.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subpars.eqd1
</span><span class="hit">        parametertools.SingleParameter.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of HydPy-L-Land, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (FT, NHRU, Lnk, FHRU, HNN, KG, KT, KE, KF, FLn, HInz, LAI,
</span><span class="noop">                   TRefT, TRefN, TGr, TSp, GTF, RSchmelz, CPWasser, PWMax,
</span><span class="noop">                   GrasRef_R, NFk, RelWZ, RelWB, Beta, FBeta, DMax, DMin, BSf,
</span><span class="noop">                   A1, A2, TInd, EQB, EQI1, EQI2, EQD1, EQD2)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.lland import lland_parameters
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MOY(parametertools.IndexParameter):
</span><span class="noop">    &#34;&#34;&#34;References the &#34;global&#34; month of the year index array [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, int, None, (0, 11)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        self.setreference(pub.indexer.monthofyear)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KInz(lland_parameters.LanduseMonthParameter):
</span><span class="noop">    &#34;&#34;&#34;Interzeptionskapazität bezogen auf die Bodenoberfläche (interception
</span><span class="noop">    capacity normalized to the soil surface area) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.hinz*con.lai)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WB(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Absolute Mindestbodenfeuchte für die Basisabflussentstehung (threshold
</span><span class="noop">       value of absolute soil moisture for base flow generation) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.relwb*con.nfk)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WZ(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Absolute Mindestbodenfeuchte für die Interflowentstehung (threshold
</span><span class="noop">       value of absolute soil moisture for interflow generation) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.relwz*con.nfk)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KB(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Konzentrationszeit des Basisabflusses (concentration time of baseflow)
</span><span class="noop">    [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.eqb*con.tind)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KI1(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Konzentrationszeit des &#34;unteren&#34; Zwischenabflusses (concentration time
</span><span class="noop">    of the first interflow component) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.eqi1*con.tind)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KI2(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Konzentrationszeit des &#34;oberen&#34; Zwischenabflusses&#34; (concentration time
</span><span class="noop">    of the second interflow component) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.eqi2*con.tind)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KD1(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Konzentrationszeit des &#34;langsamen&#34; Direktabflusses (concentration time
</span><span class="noop">    of the slower component of direct runoff) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.eqd1*con.tind)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KD2(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Konzentrationszeit des &#34;schnellen&#34; Direktabflusses (concentration time
</span><span class="noop">    of the faster component of direct runoff) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.eqd2*con.tind)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QFactor(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Factor for converting mm/stepsize to m³/s.&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.ft*1000./self.simulationstep.seconds)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of HydPy-H-Land, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (MOY, KInz, WB, WZ, KB, KI1, KI2, KD1, KD2, QFactor)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NKor(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Korrigierter Niederschlag (corrected precipitation) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TKor(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Korrigierte Lufttemperatur (corrected air temperature) [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ET0(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Grasreferenzverdunstung (reference evapotranspiration) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EvPo(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potenzielle Evaporation/Evapotranspiration (potential
</span><span class="noop">    evaporation/evapotranspiration) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NBes(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Gesamter Bestandsniederschlag (total stand precipitation) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SBes(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Schneeanteil Bestandsniederschlag (frozen stand precipitation) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EvI(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Tatsächliche Interzeptionsverdunstung (actual evaporation of
</span><span class="noop">    intercepted water) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EvB(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Tatsächliche Bodenverdunstung (actual evaporation of
</span><span class="noop">    soil water) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WGTF(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potenzielle Schneeschmelze (maximum amount of frozen water that could
</span><span class="noop">    be melted) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Schm(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Tatsächliche Schneeschmelze (actual amount of water melting within the
</span><span class="noop">    snow cover) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WaDa(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasserdargebot (water reaching the soil routine) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QDB(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Direktabfluss-Abgabe aus dem Bodenspeicher (direct runoff release
</span><span class="noop">    from the soil storage) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QIB1(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Erste Komponente der Interflow-Abgabe aus dem Bodenspeicher (first
</span><span class="noop">    component of the interflow release from the soil storage) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QIB2(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Zweite Komponente der Interflow-Abgabe aus dem Bodenspeicher (second
</span><span class="noop">    component of the interflow release from the soil storage) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QBB(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Basisabfluss-Abgabe aus dem Bodenspeicher (base flow release
</span><span class="noop">    from the soil storage) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QDGZ(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Gesamtzufluss in beide Direktabfluss-Gebietsspeicher (total inflow
</span><span class="noop">    into both storage compartments for direct runoff) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Gesamtabfluss des Teilgebiets (runoff at the catchment outlet) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of the HydPy-L-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (NKor, TKor, ET0, EvPo, SBes, NBes, EvI, EvB,
</span><span class="noop">                   WGTF, Schm, WaDa, QDB, QIB1, QIB2, QBB, QDGZ, Q)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_inputs.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_inputs.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Nied(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Niederschlag (precipitation) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TemL(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Lufttemperatur (air temperature) [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Glob(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Globalstrahlung (global radiation) [W/m²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PET(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Potenzielle Verdunstung (potential evapotranspiration) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequences(sequencetools.InputSequences):
</span><span class="noop">    &#34;&#34;&#34;Input sequences of the HydPy-L-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Nied, TemL, Glob, PET)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
1399 &nbsp;
1400 &nbsp;
1401 &nbsp;
1402 &nbsp;
1403 &nbsp;
1404 &nbsp;
1405 &nbsp;
1406 &nbsp;
1407 &nbsp;
1408 &nbsp;
1409 &nbsp;
1410 &nbsp;
1411 &nbsp;
1412 &nbsp;
1413 &nbsp;
1414 &nbsp;
1415 &nbsp;
1416 &nbsp;
1417 &nbsp;
1418 &nbsp;
1419 &nbsp;
1420 &nbsp;
1421 &nbsp;
1422 &nbsp;
1423 &nbsp;
1424 &nbsp;
1425 &nbsp;
1426 &nbsp;
1427 &nbsp;
1428 &nbsp;
1429 &nbsp;
1430 &nbsp;
1431 &nbsp;
1432 &nbsp;
1433 &nbsp;
1434 &nbsp;
1435 &nbsp;
1436 &nbsp;
1437 &nbsp;
1438 &nbsp;
1439 &nbsp;
1440 &nbsp;
1441 &nbsp;
1442 &nbsp;
1443 &nbsp;
1444 &nbsp;
1445 &nbsp;
1446 &nbsp;
1447 &nbsp;
1448 &nbsp;
1449 &nbsp;
1450 &nbsp;
1451 &nbsp;
1452 &nbsp;
1453 &nbsp;
1454 &nbsp;
1455 &nbsp;
1456 &nbsp;
1457 &nbsp;
1458 &nbsp;
1459 &nbsp;
1460 &nbsp;
1461 &nbsp;
1462 &nbsp;
1463 &nbsp;
1464 &nbsp;
1465 &nbsp;
1466 &nbsp;
1467 &nbsp;
1468 &nbsp;
1469 &nbsp;
1470 &nbsp;
1471 &nbsp;
1472 &nbsp;
1473 &nbsp;
1474 &nbsp;
1475 &nbsp;
1476 &nbsp;
1477 &nbsp;
1478 &nbsp;
1479 &nbsp;
1480 &nbsp;
1481 &nbsp;
1482 &nbsp;
1483 &nbsp;
1484 &nbsp;
1485 &nbsp;
1486 &nbsp;
1487 &nbsp;
1488 &nbsp;
1489 &nbsp;
1490 &nbsp;
1491 &nbsp;
1492 &nbsp;
1493 &nbsp;
1494 &nbsp;
1495 &nbsp;
1496 &nbsp;
1497 &nbsp;
1498 &nbsp;
1499 &nbsp;
1500 &nbsp;
1501 &nbsp;
1502 &nbsp;
1503 &nbsp;
1504 &nbsp;
1505 &nbsp;
1506 &nbsp;
1507 &nbsp;
1508 &nbsp;
1509 &nbsp;
1510 &nbsp;
1511 &nbsp;
1512 &nbsp;
1513 &nbsp;
1514 &nbsp;
1515 &nbsp;
1516 &nbsp;
1517 &nbsp;
1518 &nbsp;
1519 &nbsp;
1520 &nbsp;
1521 &nbsp;
1522 &nbsp;
1523 &nbsp;
1524 &nbsp;
1525 &nbsp;
1526 &nbsp;
1527 &nbsp;
1528 &nbsp;
1529 &nbsp;
1530 &nbsp;
1531 &nbsp;
1532 &nbsp;
1533 &nbsp;
1534 &nbsp;
1535 &nbsp;
1536 &nbsp;
1537 &nbsp;
1538 &nbsp;
1539 &nbsp;
1540 &nbsp;
1541 &nbsp;
1542 &nbsp;
1543 &nbsp;
1544 &nbsp;
1545 &nbsp;
1546 &nbsp;
1547 &nbsp;
1548 &nbsp;
1549 &nbsp;
1550 &nbsp;
1551 &nbsp;
1552 &nbsp;
1553 &nbsp;
1554 &nbsp;
1555 &nbsp;
1556 &nbsp;
1557 &nbsp;
1558 &nbsp;
1559 &nbsp;
1560 &nbsp;
1561 &nbsp;
1562 &nbsp;
1563 &nbsp;
1564 &nbsp;
1565 &nbsp;
1566 &nbsp;
1567 &nbsp;
1568 &nbsp;
1569 &nbsp;
1570 &nbsp;
1571 &nbsp;
1572 &nbsp;
1573 &nbsp;
1574 &nbsp;
1575 &nbsp;
1576 &nbsp;
1577 &nbsp;
1578 &nbsp;
1579 &nbsp;
1580 &nbsp;
1581 &nbsp;
1582 &nbsp;
1583 &nbsp;
1584 &nbsp;
1585 &nbsp;
1586 &nbsp;
1587 &nbsp;
1588 &nbsp;
1589 &nbsp;
1590 &nbsp;
1591 &nbsp;
1592 &nbsp;
1593 &nbsp;
1594 &nbsp;
1595 &nbsp;
1596 &nbsp;
1597 &nbsp;
1598 &nbsp;
1599 &nbsp;
1600 &nbsp;
1601 &nbsp;
1602 &nbsp;
1603 &nbsp;
1604 &nbsp;
1605 &nbsp;
1606 &nbsp;
1607 &nbsp;
1608 &nbsp;
1609 &nbsp;
1610 &nbsp;
1611 &nbsp;
1612 &nbsp;
1613 &nbsp;
1614 &nbsp;
1615 &nbsp;
1616 &nbsp;
1617 &nbsp;
1618 &nbsp;
1619 &nbsp;
1620 &nbsp;
1621 &nbsp;
1622 &nbsp;
1623 &nbsp;
1624 &nbsp;
1625 &nbsp;
1626 &nbsp;
1627 &nbsp;
1628 &nbsp;
1629 &nbsp;
1630 &nbsp;
1631 &nbsp;
1632 &nbsp;
1633 &nbsp;
1634 &nbsp;
1635 &nbsp;
1636 &nbsp;
1637 &nbsp;
1638 &nbsp;
1639 &nbsp;
1640 &nbsp;
1641 &nbsp;
1642 &nbsp;
1643 &nbsp;
1644 &nbsp;
1645 &nbsp;
1646 &nbsp;
1647 &nbsp;
1648 &nbsp;
1649 &nbsp;
1650 &nbsp;
1651 &nbsp;
1652 &nbsp;
1653 &nbsp;
1654 &nbsp;
1655 &nbsp;
1656 &nbsp;
1657 &nbsp;
1658 &nbsp;
1659 &nbsp;
1660 &nbsp;
1661 &nbsp;
1662 &nbsp;
1663 &nbsp;
1664 &nbsp;
1665 &nbsp;
1666 &nbsp;
1667 &nbsp;
1668 &nbsp;
1669 &nbsp;
1670 &nbsp;
1671 &nbsp;
1672 &nbsp;
1673 &nbsp;
1674 &nbsp;
1675 &nbsp;
1676 &nbsp;
1677 &nbsp;
1678 &nbsp;
1679 &nbsp;
1680 &nbsp;
1681 &nbsp;
1682 &nbsp;
1683 &nbsp;
1684 &nbsp;
1685 &nbsp;
1686 &nbsp;
1687 &nbsp;
1688 &nbsp;
1689 &nbsp;
1690 &nbsp;
1691 &nbsp;
1692 &nbsp;
1693 &nbsp;
1694 &nbsp;
1695 &nbsp;
1696 &nbsp;
1697 &nbsp;
1698 &nbsp;
1699 &nbsp;
1700 &nbsp;
1701 &nbsp;
1702 &nbsp;
1703 &nbsp;
1704 &nbsp;
1705 &nbsp;
1706 &nbsp;
1707 &nbsp;
1708 &nbsp;
1709 &nbsp;
1710 &nbsp;
1711 &nbsp;
1712 &nbsp;
1713 &nbsp;
1714 &nbsp;
1715 &nbsp;
1716 &nbsp;
1717 &nbsp;
1718 &nbsp;
1719 &nbsp;
1720 &nbsp;
1721 &nbsp;
1722 &nbsp;
1723 &nbsp;
1724 &nbsp;
1725 &nbsp;
1726 &nbsp;
1727 &nbsp;
1728 &nbsp;
1729 &nbsp;
1730 &nbsp;
1731 &nbsp;
1732 &nbsp;
1733 &nbsp;
1734 &nbsp;
1735 &nbsp;
1736 &nbsp;
1737 &nbsp;
1738 &nbsp;
1739 &nbsp;
1740 &nbsp;
1741 &nbsp;
1742 &nbsp;
1743 &nbsp;
1744 &nbsp;
1745 &nbsp;
1746 &nbsp;
1747 &nbsp;
1748 &nbsp;
1749 &nbsp;
1750 &nbsp;
1751 &nbsp;
1752 &nbsp;
1753 &nbsp;
1754 &nbsp;
1755 &nbsp;
1756 &nbsp;
1757 &nbsp;
1758 &nbsp;
1759 &nbsp;
1760 &nbsp;
1761 &nbsp;
1762 &nbsp;
1763 &nbsp;
1764 &nbsp;
1765 &nbsp;
1766 &nbsp;
1767 &nbsp;
1768 &nbsp;
1769 &nbsp;
1770 &nbsp;
1771 &nbsp;
1772 &nbsp;
1773 &nbsp;
1774 &nbsp;
1775 &nbsp;
1776 &nbsp;
1777 &nbsp;
1778 &nbsp;
1779 &nbsp;
1780 &nbsp;
1781 &nbsp;
1782 &nbsp;
1783 &nbsp;
1784 &nbsp;
1785 &nbsp;
1786 &nbsp;
1787 &nbsp;
1788 &nbsp;
1789 &nbsp;
1790 &nbsp;
1791 &nbsp;
1792 &nbsp;
1793 &nbsp;
1794 &nbsp;
1795 &nbsp;
1796 &nbsp;
1797 &nbsp;
1798 &nbsp;
1799 &nbsp;
1800 &nbsp;
1801 &nbsp;
1802 &nbsp;
1803 &nbsp;
1804 &nbsp;
1805 &nbsp;
1806 &nbsp;
1807 &nbsp;
1808 &nbsp;
1809 &nbsp;
1810 &nbsp;
1811 &nbsp;
1812 &nbsp;
1813 &nbsp;
1814 &nbsp;
1815 &nbsp;
1816 &nbsp;
1817 &nbsp;
1818 &nbsp;
1819 &nbsp;
1820 &nbsp;
1821 &nbsp;
1822 &nbsp;
1823 &nbsp;
1824 &nbsp;
1825 &nbsp;
1826 &nbsp;
1827 &nbsp;
1828 &nbsp;
1829 &nbsp;
1830 &nbsp;
1831 &nbsp;
1832 &nbsp;
1833 &nbsp;
1834 &nbsp;
1835 &nbsp;
1836 &nbsp;
1837 &nbsp;
1838 &nbsp;
1839 &nbsp;
1840 &nbsp;
1841 &nbsp;
1842 &nbsp;
1843 &nbsp;
1844 &nbsp;
1845 &nbsp;
1846 &nbsp;
1847 &nbsp;
1848 &nbsp;
1849 &nbsp;
1850 &nbsp;
1851 &nbsp;
1852 &nbsp;
1853 &nbsp;
1854 &nbsp;
1855 &nbsp;
1856 &nbsp;
1857 &nbsp;
1858 &nbsp;
1859 &nbsp;
1860 &nbsp;
1861 &nbsp;
1862 &nbsp;
1863 &nbsp;
1864 &nbsp;
1865 &nbsp;
1866 &nbsp;
1867 &nbsp;
1868 &nbsp;
1869 &nbsp;
1870 &nbsp;
1871 &nbsp;
1872 &nbsp;
1873 &nbsp;
1874 &nbsp;
1875 &nbsp;
1876 &nbsp;
1877 &nbsp;
1878 &nbsp;
1879 &nbsp;
1880 &nbsp;
1881 &nbsp;
1882 &nbsp;
1883 &nbsp;
1884 &nbsp;
1885 &nbsp;
1886 &nbsp;
1887 &nbsp;
1888 &nbsp;
1889 &nbsp;
1890 &nbsp;
1891 &nbsp;
1892 &nbsp;
1893 &nbsp;
1894 &nbsp;
1895 &nbsp;
1896 &nbsp;
1897 &nbsp;
1898 &nbsp;
1899 &nbsp;
1900 &nbsp;
1901 &nbsp;
1902 &nbsp;
1903 &nbsp;
1904 &nbsp;
1905 &nbsp;
1906 &nbsp;
1907 &nbsp;
1908 &nbsp;
1909 &nbsp;
1910 &nbsp;
1911 &nbsp;
1912 &nbsp;
1913 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># imports...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.cythons import modelutils
</span><span class="noop"># ...model specifc
</span><span class="hit">from hydpy.models.lland.lland_constants import WASSER, VERS
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_nkor_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Adjust the given precipitation values.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KG`
</span><span class="noop">
</span><span class="noop">    Required input sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_inputs.Nied`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.NKor`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`NKor = KG \\cdot Nied`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; nhru(3)
</span><span class="noop">    &gt;&gt;&gt; kg(.8, 1., 1.2)
</span><span class="noop">    &gt;&gt;&gt; inputs.nied = 10.
</span><span class="noop">    &gt;&gt;&gt; model.calc_nkor_v1()
</span><span class="noop">    &gt;&gt;&gt; fluxes.nkor
</span><span class="noop">    nkor(8.0, 10.0, 12.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    inp = self.sequences.inputs.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        flu.nkor[k] = con.kg[k] * inp.nied
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_tkor_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Adjust the given air temperature values.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KT`
</span><span class="noop">
</span><span class="noop">    Required input sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_inputs.TemL`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.TKor`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`TKor = KT + TemL`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; nhru(3)
</span><span class="noop">    &gt;&gt;&gt; kt(-2., 0., 2.)
</span><span class="noop">    &gt;&gt;&gt; inputs.teml(1.)
</span><span class="noop">    &gt;&gt;&gt; model.calc_tkor_v1()
</span><span class="noop">    &gt;&gt;&gt; fluxes.tkor
</span><span class="noop">    tkor(-1.0, 1.0, 3.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    inp = self.sequences.inputs.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        flu.tkor[k] = con.kt[k] + inp.teml
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_et0_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate reference evapotranspiration after Turc-Wendling.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KE`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KF`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.HNN`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Required input sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_inputs.Glob`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.TKor`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.ET0`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`ET0 = KE \\cdot
</span><span class="noop">      \\frac{(8.64 \\cdot Glob+93 \\cdot KF) \\cdot (TKor+22)}
</span><span class="noop">      {165 \\cdot (TKor+123) \\cdot (1 + 0.00019 \\cdot min(HNN, 600))}`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">    &gt;&gt;&gt; nhru(3)
</span><span class="noop">    &gt;&gt;&gt; ke(1.1)
</span><span class="noop">    &gt;&gt;&gt; kf(.6)
</span><span class="noop">    &gt;&gt;&gt; hnn(200., 600., 1000.)
</span><span class="noop">    &gt;&gt;&gt; inputs.glob = 200.
</span><span class="noop">    &gt;&gt;&gt; fluxes.tkor = 15.
</span><span class="noop">    &gt;&gt;&gt; model.calc_et0_v1()
</span><span class="noop">    &gt;&gt;&gt; fluxes.et0
</span><span class="noop">    et0(3.07171, 2.86215, 2.86215)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    inp = self.sequences.inputs.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        flu.et0[k] = (con.ke[k]*(((8.64*inp.glob+93.*con.kf[k]) *
</span><span class="noop">                                  (flu.tkor[k]+22.)) /
</span><span class="noop">                                 (165.*(flu.tkor[k]+123.) *
</span><span class="noop">                                  (1.+0.00019*min(con.hnn[k], 600.)))))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_et0_v2(self):
</span><span class="noop">    &#34;&#34;&#34;Correct the given reference evapotranspiration.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KE`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Required input sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_inputs.PET`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.ET0`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`ET0 = KE \\cdot PET`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">    &gt;&gt;&gt; nhru(2)
</span><span class="noop">    &gt;&gt;&gt; ke(0.8, 1.2)
</span><span class="noop">    &gt;&gt;&gt; inputs.pet = 2.
</span><span class="noop">    &gt;&gt;&gt; model.calc_et0_v2()
</span><span class="noop">    &gt;&gt;&gt; fluxes.et0
</span><span class="noop">    et0(1.6, 2.4)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    inp = self.sequences.inputs.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        flu.et0[k] = con.ke[k]*inp.pet
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_evpo_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate land use and month specific values of potential
</span><span class="noop">    evapotranspiration.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FLn`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.MOY`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.ET0`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvPo`
</span><span class="noop">
</span><span class="noop">    Additional requirements:
</span><span class="noop">      :attr:`~hydpy.core.modeltools.Model.idx_sim`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`EvPo = FLn \\cdot ET0`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        For clarity, this is more of a kind of an integration example.
</span><span class="noop">        Parameter :class:`~hydpy.models.lland.lland_control.FLn` both
</span><span class="noop">        depends on time (the actual month) and space (the actual land use).
</span><span class="noop">        Firstly, let us define a initialization time period spanning the
</span><span class="noop">        transition from June to July:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub, Timegrid, Timegrids
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;30.06.2000&#39;,
</span><span class="noop">        ...                                    &#39;02.07.2000&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">        Secondly, assume that the considered subbasin is differenciated in
</span><span class="noop">        two HRUs, one of primarily consisting of arable land and the other
</span><span class="noop">        one of deciduous forests:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(2)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, LAUBW)
</span><span class="noop">
</span><span class="noop">        Thirdly, set the :class:`~hydpy.models.lland.lland_control.FLn`
</span><span class="noop">        values, one for the relevant months and land use classes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fln.acker_jun = 1.299
</span><span class="noop">        &gt;&gt;&gt; fln.acker_jul = 1.304
</span><span class="noop">        &gt;&gt;&gt; fln.laubw_jun = 1.350
</span><span class="noop">        &gt;&gt;&gt; fln.laubw_jul = 1.365
</span><span class="noop">
</span><span class="noop">        Fourthly, the index array connecting the simulation time steps
</span><span class="noop">        defined above and the month indexes (0...11) can be retrieved
</span><span class="noop">        from the :mod:`~hydpy.pub` module.  This can be done manually
</span><span class="noop">        more conveniently via its update method:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.moy.update()
</span><span class="noop">        &gt;&gt;&gt; derived.moy
</span><span class="noop">        moy(5, 6)
</span><span class="noop">
</span><span class="noop">        Finally, the actual method (with its simple equation) is applied
</span><span class="noop">        as usual:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.et0 = 2.
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = 0
</span><span class="noop">        &gt;&gt;&gt; model.calc_evpo_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.evpo
</span><span class="noop">        evpo(2.598, 2.7)
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = 1
</span><span class="noop">        &gt;&gt;&gt; model.calc_evpo_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.evpo
</span><span class="noop">        evpo(2.608, 2.73)
</span><span class="noop">
</span><span class="noop">        Reset module :mod:`~hydpy.pub` to not interfere the following
</span><span class="noop">        examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = None
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        flu.evpo[k] = con.fln[con.lnk[k]-1, der.moy[self.idx_sim]] * flu.et0[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_nbes_inzp_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate throughfall and update the interception storage
</span><span class="noop">    accordingly.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KInz`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.NKor`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.NBes`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.Inzp`
</span><span class="noop">
</span><span class="noop">    Additional requirements:
</span><span class="noop">      :attr:`~hydpy.core.modeltools.Model.idx_sim`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`NBes = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {PKor \\ | \\ Inzp = KInz}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ Inzp &lt; KInz}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Initialize six HRUs with different land usages:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(4)
</span><span class="noop">        &gt;&gt;&gt; lnk(SIED_D, FEUCHT, GLETS, WASSER)
</span><span class="noop">
</span><span class="noop">        Define values for the maximum interception storage directly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.sied_d_jul = 2.
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.feucht_jul = 1.
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.glets_jul = 0.
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.wasser_jul = 0.
</span><span class="noop">
</span><span class="noop">        Assume that the three consecutive initialization time steps
</span><span class="noop">        lie in three different months (does not make sense for the
</span><span class="noop">        selected time step of one day, but allows for a more rigorous
</span><span class="noop">        testing of proper indexing):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.moy.shape = 3
</span><span class="noop">        &gt;&gt;&gt; derived.moy = numpy.array([5, 6, 7])
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = 1
</span><span class="noop">
</span><span class="noop">        The dense settlement and the wetland area start with a initial
</span><span class="noop">        interception storage of 1/2 mm, the glacier and water area (must)
</span><span class="noop">        start with 0 mm.  In the first example, actual precipition is 2 mm:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.inzp(0.5, 0.5, 0., 0.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nkor = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_nbes_inzp_v1()
</span><span class="noop">        &gt;&gt;&gt; states.inzp
</span><span class="noop">        inzp(1.5, 1.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nbes
</span><span class="noop">        nbes(0.0, 0.5, 1.0, 1.0)
</span><span class="noop">
</span><span class="noop">        Only for the settled area, interception capacity is not exceeded,
</span><span class="noop">        meaning not through fall occurs.
</span><span class="noop">
</span><span class="noop">        If there is no precipitation, there is of course also no through
</span><span class="noop">        fall and interception storage remains unchanged:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.inzp(0.5, 0.5, 0., 0.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nkor = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_nbes_inzp_v1()
</span><span class="noop">        &gt;&gt;&gt; states.inzp
</span><span class="noop">        inzp(0.5, 0.5, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nbes
</span><span class="noop">        nbes(0.0, 0.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        Note the following to peculiarities:  Firstly, the behaviour of
</span><span class="noop">        the glacier area is due to its zero interception capacity.  On the
</span><span class="noop">        contrary, the behaviour of the water area hard coded.  Hence,
</span><span class="noop">        increasing the interception capacity shows no effect:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.glets_jul = 1.
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.wasser_jul = 1.
</span><span class="noop">        &gt;&gt;&gt; states.inzp(0.5, 0.5, 0., 0.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nkor = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_nbes_inzp_v1()
</span><span class="noop">        &gt;&gt;&gt; states.inzp
</span><span class="noop">        inzp(1.5, 1.0, 1.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nbes
</span><span class="noop">        nbes(0.0, 0.5, 0.0, 1.0)
</span><span class="noop">
</span><span class="noop">        Secondly, due to discontinuous changes of the interception capacity
</span><span class="noop">        between two months, through fall can occur after the corresponding
</span><span class="noop">        precipitation event has occured.  In the last example, this results
</span><span class="noop">        from the given decrease of the glaciers interception capacity:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.glets_jul = .6
</span><span class="noop">        &gt;&gt;&gt; fluxes.nkor = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_nbes_inzp_v1()
</span><span class="noop">        &gt;&gt;&gt; states.inzp
</span><span class="noop">        inzp(1.5, 1.0, 0.6, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nbes
</span><span class="noop">        nbes(0.0, 0.0, 0.4, 0.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if con.lnk[k] != WASSER:
</span><span class="hit">            flu.nbes[k] = \
</span><span class="noop">                max(flu.nkor[k]+sta.inzp[k] -
</span><span class="noop">                    der.kinz[con.lnk[k]-1, der.moy[self.idx_sim]], 0.)
</span><span class="hit">            sta.inzp[k] += flu.nkor[k]-flu.nbes[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.nbes[k] = flu.nkor[k]
</span><span class="hit">            sta.inzp[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_evi_inzp_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate interception evaporation and update the interception
</span><span class="noop">    storage accordingly.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.TRefT`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.TRefN`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvPo`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvI`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.Inzp`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`EvI = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {EvPo \\ | \\ Inzp &gt; 0}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ Inzp = 0}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize four HRUs with different combinations of land usage
</span><span class="noop">        and initial interception storage and apply a value of potential
</span><span class="noop">        evaporation of 3 mm on each one:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(4)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, ACKER, ACKER, WASSER)
</span><span class="noop">        &gt;&gt;&gt; states.inzp = 0., 2., 4., 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.evpo = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_evi_inzp_v1()
</span><span class="noop">        &gt;&gt;&gt; states.inzp
</span><span class="noop">        inzp(0.0, 0.0, 1.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.evi
</span><span class="noop">        evi(0.0, 2.0, 3.0, 3.0)
</span><span class="noop">
</span><span class="noop">        For the first three HRUs of land use class
</span><span class="noop">        :const:`~hydpy.models.lland.lland_constants.ACKER`,
</span><span class="noop">        interception evaporation is identical with potential
</span><span class="noop">        evapotranspiration as long as it is met by the available
</span><span class="noop">        intercepted water.  For water areas, interception evaporation is
</span><span class="noop">        generally set to potential evaporation.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if con.lnk[k] != WASSER:
</span><span class="hit">            flu.evi[k] = min(flu.evpo[k], sta.inzp[k])
</span><span class="hit">            sta.inzp[k] -= flu.evi[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.evi[k] = flu.evpo[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_sbes_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the frozen part of stand precipitation.
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.TGr`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.TSp`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.TKor`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.NBes`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.SBes`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        In the first example, the threshold temperature of seven hydrological
</span><span class="noop">        response units is 0°C and the corresponding temperature interval of
</span><span class="noop">        mixed precipitation 2°C:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(7)
</span><span class="noop">        &gt;&gt;&gt; tgr(0.)
</span><span class="noop">        &gt;&gt;&gt; tsp(2.)
</span><span class="noop">
</span><span class="noop">        The value of `sbes` is zero above 1°C and equal to the value of
</span><span class="noop">        `nbes` below -1°C.  Between these temperature values, `sbes`
</span><span class="noop">        decreases linearly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.nbes = 4.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tkor = -10., -1., -.5, 0., .5, 1., 10.
</span><span class="noop">        &gt;&gt;&gt; model.calc_sbes_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.sbes
</span><span class="noop">        sbes(4.0, 4.0, 3.0, 2.0, 1.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        Note the special case of a zero temperature intervall.  With the
</span><span class="noop">        actual temperature beeing equal to the threshold temperature, the
</span><span class="noop">        the value of `sbes` is zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; tsp(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_sbes_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.sbes
</span><span class="noop">        sbes(4.0, 4.0, 4.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if flu.tkor[k] &gt;= (con.tgr[k]+con.tsp[k]/2.):
</span><span class="hit">            flu.sbes[k] = 0.
</span><span class="hit">        elif flu.tkor[k] &lt;= (con.tgr[k]-con.tsp[k]/2.):
</span><span class="hit">            flu.sbes[k] = flu.nbes[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.sbes[k] = ((((con.tgr[k]+con.tsp[k]/2.)-flu.tkor[k]) /
</span><span class="noop">                            con.tsp[k])*flu.nbes[k])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_wgtf_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the potential snow melt.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.GTF`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.TRefT`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.TRefN`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.RSchmelz`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.CPWasser`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.TKor`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.WGTF`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`WGTF = max(GTF \\cdot (TKor - TRefT), 0) +
</span><span class="noop">      max(\\frac{CPWasser}{RSchmelz} \\cdot (TKor - TRefN), 0)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize six HRUs with identical degree-day factors and
</span><span class="noop">        temperature thresholds, but different combinations of land use
</span><span class="noop">        and air temperature:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(6)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, LAUBW, WASSER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; gtf(5.)
</span><span class="noop">        &gt;&gt;&gt; treft(0.)
</span><span class="noop">        &gt;&gt;&gt; trefn(1.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.tkor = 2., 2., 2., -1., 0., 1.
</span><span class="noop">
</span><span class="noop">        The specific heat capacity and melt heat capacity of water are
</span><span class="noop">        (compared to most parameters of hydrological models) relatively
</span><span class="noop">        fixed properties:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cpwasser(4.1868)
</span><span class="noop">        &gt;&gt;&gt; rschmelz(334.0)
</span><span class="noop">
</span><span class="noop">        Note that the values of the degree-day factor are only half
</span><span class="noop">        as much as the given value, due to the small simulation step size
</span><span class="noop">        beeing only half as long as the parameter step size:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; gtf
</span><span class="noop">        gtf(5.0)
</span><span class="noop">        &gt;&gt;&gt; gtf.values
</span><span class="noop">        array([ 2.5,  2.5,  2.5,  2.5,  2.5,  2.5])
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        (These values are not hard coded, to allow for changing the
</span><span class="noop">        sensitivity of the snow routine for precipitation driven snow
</span><span class="noop">        melt events.)
</span><span class="noop">
</span><span class="noop">        When performing the calculations, one sees that the potential
</span><span class="noop">        melting rate is identical for the first two HRUs.  The land use
</span><span class="noop">        class results in no difference, except for water areas (third HRU),
</span><span class="noop">        where no potential melt needs to be calculated.  The last three
</span><span class="noop">        HRUs show the usual behaviour of the degree day method, when the
</span><span class="noop">        actual temperature is below (fourth HRU), equal to (fifth HRU) or
</span><span class="noop">        above (sixths zone) the threshold temperature.  Additionally, the
</span><span class="noop">        first two zones show the influence of the additional energy intake
</span><span class="noop">        due to &#34;warm&#34; precipitation.  Obviously, this additional term is
</span><span class="noop">        quite negligible for common parameterizations, even if lower
</span><span class="noop">        values for the seperate threshold temperature would be taken into
</span><span class="noop">        account:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.calc_wgtf_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.wgtf
</span><span class="noop">        wgtf(5.012535, 5.012535, 0.0, 0.0, 0.0, 2.5)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if con.lnk[k] != WASSER:
</span><span class="hit">            flu.wgtf[k] = (
</span><span class="noop">              max(con.gtf[k]*(flu.tkor[k]-con.treft[k]), 0) +
</span><span class="noop">              max(con.cpwasser/con.rschmelz*(flu.tkor[k]-con.trefn[k]), 0.)
</span><span class="noop">              )
</span><span class="noop">        else:
</span><span class="hit">            flu.wgtf[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_schm_wats_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual amount of water melting within the snow cover.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.SBes`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.WGTF`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.Schm`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.WATS`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dWATS}{dt}  = SBes - Schm`
</span><span class="noop">      :math:`Schm = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {WGTF \\ | \\ WATS &gt; 0}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ WATS = 0}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize one water and four arable land HRUs.  Assume the same
</span><span class="noop">        values for the initial amount of frozen water and the frozen
</span><span class="noop">        part of stand precipitation, but different values for the
</span><span class="noop">        potential snow melt:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(5)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; states.wats = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.sbes = 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.wgtf = 0., 0., 1., 3., 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_schm_wats_v1()
</span><span class="noop">        &gt;&gt;&gt; states.wats
</span><span class="noop">        wats(0.0, 3.0, 2.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.schm
</span><span class="noop">        schm(0.0, 0.0, 1.0, 3.0, 3.0)
</span><span class="noop">
</span><span class="noop">        For water areas, both the frozen amount of water and actual melt
</span><span class="noop">        are set to zero.  For all other land use classes, actual melt
</span><span class="noop">        is either limited by potential melt or the available frozen water,
</span><span class="noop">        which is the sum of initial frozen water and the frozen part
</span><span class="noop">        of stand precipitation.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if con.lnk[k] != WASSER:
</span><span class="hit">            sta.wats[k] += flu.sbes[k]
</span><span class="hit">            flu.schm[k] = min(flu.wgtf[k], sta.wats[k])
</span><span class="hit">            sta.wats[k] -= flu.schm[k]
</span><span class="noop">        else:
</span><span class="hit">            sta.wats[k] = 0.
</span><span class="hit">            flu.schm[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_wada_waes_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual water release from the snow cover.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.PWMax`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.NBes`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.WaDa`
</span><span class="noop">
</span><span class="noop">    Required state sequences
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.WAeS`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.WAeS`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dWAeS}{dt} = NBes - WaDa`
</span><span class="noop">      :math:`WAeS \\leq PWMax \\cdot WATS`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        For simplicity, :class:`~hydpy.models.lland.lland_control.PWMax`
</span><span class="noop">        is set to a value of two for each of the five initialized HRUs.
</span><span class="noop">        Thus, the snow cover can hold as much liquid water as it contains
</span><span class="noop">        frozen water.  Stand precipitation is also always set to the same
</span><span class="noop">        value, but the initial conditions of the snow cover are varied:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(5)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; pwmax(2.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nbes = 1.
</span><span class="noop">        &gt;&gt;&gt; states.wats = 0., 0., 1., 1.0, 1.
</span><span class="noop">        &gt;&gt;&gt; states.waes = 0., 0., 1., 1.5, 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_wada_waes_v1()
</span><span class="noop">        &gt;&gt;&gt; states.waes
</span><span class="noop">        waes(0.0, 0.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.wada
</span><span class="noop">        wada(1.0, 1.0, 0.0, 0.5, 1.0)
</span><span class="noop">
</span><span class="noop">        Note the special cases of the first HRU (the snow routine is not
</span><span class="noop">        applied for water areas) and the second HRU (for all other land
</span><span class="noop">        use classes the snow routine is also applied on &#34;empty&#34; snow
</span><span class="noop">        covers with zero initial values).
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if con.lnk[k] != WASSER:
</span><span class="hit">            sta.waes[k] += flu.nbes[k]
</span><span class="hit">            flu.wada[k] = max(sta.waes[k]-con.pwmax[k]*sta.wats[k], 0.)
</span><span class="hit">            sta.waes[k] -= flu.wada[k]
</span><span class="noop">        else:
</span><span class="hit">            sta.waes[k] = 0.
</span><span class="hit">            flu.wada[k] = flu.nbes[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_evb_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual water release from the snow cover.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NFk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.GrasRef_R`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.BoWa`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvPo`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvI`
</span><span class="noop">
</span><span class="noop">    Used aide sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_aides.Temp`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvB`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`temp = exp(-GrasRef_R \\cdot \\frac{BoWa}{NFk})`
</span><span class="noop">      :math:`EvB = (EvPo - EvI) \\cdot
</span><span class="noop">      \\frac{1 - temp}{1 + temp -2 \\cdot exp(-GrasRef_R)}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Soil evaporation is calculated neither for water nor for sealed
</span><span class="noop">        areas (see HRUs one and two).  All other land use classes are
</span><span class="noop">        handled in accordance with a recommendation of the set of codes
</span><span class="noop">        described in ATV-DVWK-M 504 (arable land has been selected for
</span><span class="noop">        HRUs three to six arbitrarily):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(6)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, VERS, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; grasref_r(5.)
</span><span class="noop">        &gt;&gt;&gt; nfk(0., 0., 0., 100., 100., 100.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.evpo = 5.
</span><span class="noop">        &gt;&gt;&gt; fluxes.evi = 3.
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 0., 0., 0., 0., 50., 100.
</span><span class="noop">        &gt;&gt;&gt; model.calc_evb_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.evb
</span><span class="noop">        evb(0.0, 0.0, 0.0, 0.0, 1.717962, 2.0)
</span><span class="noop">
</span><span class="noop">        In case usable field capacity is zero, soil evaporation is
</span><span class="noop">        generally set to zero (see the third HRU).  The last three
</span><span class="noop">        HRUs demonstrate the rise in soil evaporation with increasing
</span><span class="noop">        soil moisture, lessening in the high soil moisture range.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if ((con.lnk[k] != WASSER) and (con.lnk[k] != VERS) and
</span><span class="noop">                (con.nfk[k] &gt; 0.)):
</span><span class="hit">            aid.temp = modelutils.exp(-con.grasref_r *
</span><span class="noop">                                      sta.bowa[k]/con.nfk[k])
</span><span class="hit">            flu.evb[k] = ((flu.evpo[k]-flu.evi[k]) * (1.-aid.temp) /
</span><span class="noop">                          (1.+aid.temp-2.*modelutils.exp(-con.grasref_r)))
</span><span class="noop">        else:
</span><span class="hit">            flu.evb[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qbb_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the amount of base flow released from the soil.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Beta`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FBeta`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.WB`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.WZ`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.BoWa`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBB`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`Beta_{eff} = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {Beta \\ | \\ BoWa \\leq WZ}
</span><span class="noop">      \\atop
</span><span class="noop">      {Beta \\cdot (1+(FBeta-1)\\cdot\\frac{BoWa-WZ}{NFk-WZ}) \\|\\ BoWa &gt; WZ}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">      :math:`QBB = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {0 \\ | \\ BoWa \\leq WB}
</span><span class="noop">      \\atop
</span><span class="noop">      {Beta_{eff}  \\cdot (BoWa - WB) \\|\\ BoWa &gt; WB}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        For water and sealed areas, no base is flow calculated (see the
</span><span class="noop">        first two HRUs).  No principal distinction is made between the
</span><span class="noop">        remaining land use classes (arable land has been selected for
</span><span class="noop">        the other five HRUs arbitrarily):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(7)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, VERS, ACKER, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; beta(.04)
</span><span class="noop">        &gt;&gt;&gt; fbeta(2.)
</span><span class="noop">        &gt;&gt;&gt; nfk(0., 0., 0., 100., 100., 100., 200.)
</span><span class="noop">        &gt;&gt;&gt; derived.wb(10.)
</span><span class="noop">        &gt;&gt;&gt; derived.wz(70.)
</span><span class="noop">
</span><span class="noop">        Note the time dependence of parameter
</span><span class="noop">        :class:`~hydpy.models.lland.lland_control.Beta`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; beta
</span><span class="noop">        beta(0.04)
</span><span class="noop">        &gt;&gt;&gt; beta.values
</span><span class="noop">        array([ 0.02,  0.02,  0.02,  0.02,  0.02,  0.02,  0.02])
</span><span class="noop">
</span><span class="noop">        In the first example, the actual soil water content is set to low
</span><span class="noop">        values. For values below the threshold `wb`, not percolation occurs.
</span><span class="noop">        Above `wb` (but below `wz`), calculated percolation shows a linear
</span><span class="noop">        behaviour which is only related to parameter `beta`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 0., 0., 0., 0., 10., 20., 20.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qbb_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qbb
</span><span class="noop">        qbb(0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.2)
</span><span class="noop">
</span><span class="noop">        Note that for the last two HRUs the same amount of
</span><span class="noop">        base flow generation is determined, in spite of the fact
</span><span class="noop">        that both exhibit different relative soil moistures.  It is
</span><span class="noop">        common to modify this &#34;pure absolute dependency&#34; to a &#34;mixed
</span><span class="noop">        absolute/relative dependency&#34; through defining the values of
</span><span class="noop">        parameter :class:`~hydpy.models.lland.lland_derived.WB` indirectly
</span><span class="noop">        via parameter :class:`~hydpy.models.lland.lland_control.RelWB`.
</span><span class="noop">
</span><span class="noop">        In the second example, the actual soil water content is set to high
</span><span class="noop">        values.  For values below the threshold `wz`, the disussion above
</span><span class="noop">        remains valid.  For values above `wz`, percolation shows a nonlinear
</span><span class="noop">        behaviour in case factor `fbeta` is set to value larger than one:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; nfk(0., 0., 100., 100., 100, 100., 200.)
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 0., 0., 60., 70., 80., 100., 200.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qbb_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qbb
</span><span class="noop">        qbb(0.0, 0.0, 1.0, 1.2, 1.866667, 3.6, 7.6)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if ((con.lnk[k] == WASSER) or (con.lnk[k] == VERS) or
</span><span class="noop">                (sta.bowa[k] &lt;= der.wb[k]) or (con.nfk[k] &lt;= 0.)):
</span><span class="hit">            flu.qbb[k] = 0.
</span><span class="hit">        elif sta.bowa[k] &lt;= der.wz[k]:
</span><span class="hit">            flu.qbb[k] = con.beta[k]*(sta.bowa[k]-der.wb[k])
</span><span class="noop">        else:
</span><span class="hit">            flu.qbb[k] = (con.beta[k]*(sta.bowa[k]-der.wb[k]) *
</span><span class="noop">                          (1.+(con.fbeta[k]-1.)*((sta.bowa[k]-der.wz[k]) /
</span><span class="noop">                                                 (con.nfk[k]-der.wz[k]))))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qib1_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the first inflow component released from the soil.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NFk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.DMin`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.WB`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.BoWa`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIB1`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`QIB1 = DMin \\cdot \\frac{BoWa}{NFk}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        For water and sealed areas, no interflow is calculated (see the
</span><span class="noop">        first two HRUs).  No principal distinction is made between the
</span><span class="noop">        remaining land use classes (arable land has been selected for
</span><span class="noop">        the other five HRUs arbitrarily):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(7)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, VERS, ACKER, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; dmax(10.)
</span><span class="noop">        &gt;&gt;&gt; dmin(4.)
</span><span class="noop">        &gt;&gt;&gt; nfk(0., 0., 0., 101., 101., 101., 202.)
</span><span class="noop">        &gt;&gt;&gt; derived.wb(10.)
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 0., 0., 0., 0., 10., 10.1, 10.1
</span><span class="noop">
</span><span class="noop">        Note the time dependence of parameter
</span><span class="noop">        :class:`~hydpy.models.lland.lland_control.DMin`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; dmin
</span><span class="noop">        dmin(4.0)
</span><span class="noop">        &gt;&gt;&gt; dmin.values
</span><span class="noop">        array([ 2.,  2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">        Compared to the calculation of
</span><span class="noop">        :class:`~hydpy.models.lland.lland_fluxes.QBB`, the following
</span><span class="noop">        results show some relevant differences:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.calc_qib1_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib1
</span><span class="noop">        qib1(0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.1)
</span><span class="noop">
</span><span class="noop">        Firstly, as demonstrated with the help of the sixths and the
</span><span class="noop">        sevenths HRU the generation of first interflow component depends
</span><span class="noop">        on the relative soil moisture.  Secondly, as demonstratd with the
</span><span class="noop">        help the fifths and the sixths HRU, it starts abruptly whenever
</span><span class="noop">        there is the slightest exceedance of the threshold  parameter
</span><span class="noop">        :class:`~hydpy.models.lland.lland_derived.WB` occurs.  Such step
</span><span class="noop">        functions are a potential source of trouble.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if ((con.lnk[k] != WASSER) and (con.lnk[k] != VERS) and
</span><span class="noop">                (sta.bowa[k] &gt; der.wb[k])):
</span><span class="hit">            flu.qib1[k] = con.dmin[k]*(sta.bowa[k]/con.nfk[k])
</span><span class="noop">        else:
</span><span class="hit">            flu.qib1[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qib2_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the first inflow component released from the soil.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NFk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.DMin`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.DMax`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.WZ`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.BoWa`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIB2`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`QIB2 = (DMax-DMin) \\cdot
</span><span class="noop">      (\\frac{BoWa-WZ}{NFk-WZ})^\\frac{3}{2}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        For water and sealed areas, no interflow is calculated (see the
</span><span class="noop">        first two HRUs).  No principal distinction is made between the
</span><span class="noop">        remaining land use classes (arable land has been selected for
</span><span class="noop">        the other five HRUs arbitrarily):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(7)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, VERS, ACKER, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; dmax(10.)
</span><span class="noop">        &gt;&gt;&gt; dmin(4.)
</span><span class="noop">        &gt;&gt;&gt; nfk(0., 0., 50., 100., 100., 100., 200.)
</span><span class="noop">        &gt;&gt;&gt; derived.wz(50.)
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 0., 0., 50.1, 50., 75., 100., 100.
</span><span class="noop">
</span><span class="noop">        Note the time dependence of parameters
</span><span class="noop">        :class:`~hydpy.models.lland.lland_control.DMin` (see the example
</span><span class="noop">        above) and :class:`~hydpy.models.lland.lland_control.DMax`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; dmax
</span><span class="noop">        dmax(10.0)
</span><span class="noop">        &gt;&gt;&gt; dmax.values
</span><span class="noop">        array([ 5.,  5.,  5.,  5.,  5.,  5.,  5.])
</span><span class="noop">
</span><span class="noop">        The following results show that he calculation of
</span><span class="noop">        :class:`~hydpy.models.lland.lland_fluxes.QIB2` both resembles
</span><span class="noop">        those of :class:`~hydpy.models.lland.lland_fluxes.QBB` and
</span><span class="noop">        :class:`~hydpy.models.lland.lland_fluxes.QIB1` in some regards:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.calc_qib2_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib2
</span><span class="noop">        qib2(0.0, 0.0, 0.0, 0.0, 1.06066, 3.0, 0.57735)
</span><span class="noop">
</span><span class="noop">        In the given example, the maximum rate of total interflow
</span><span class="noop">        generation is 5mm/12h.  For the sixths zone, which contains
</span><span class="noop">        a saturated soil, a value of 3mm/h is calculated.  The &#34;missing&#34;
</span><span class="noop">        2mm/12h would be added to the inflow concentration routine via
</span><span class="noop">        :class:`~hydpy.models.lland.lland_fluxes.QIB1`.
</span><span class="noop">
</span><span class="noop">        (The third zone, which is slightly oversaturated, is only intended
</span><span class="noop">        to demonstrate that zero division due to nfk=wz is circumvented.)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if ((con.lnk[k] != WASSER) and (con.lnk[k] != VERS) and
</span><span class="noop">                (sta.bowa[k] &gt; der.wz[k]) and (con.nfk[k] &gt; der.wz[k])):
</span><span class="hit">            flu.qib2[k] = ((con.dmax[k]-con.dmin[k]) *
</span><span class="noop">                           ((sta.bowa[k]-der.wz[k]) /
</span><span class="noop">                            (con.nfk[k]-der.wz[k]))**1.5)
</span><span class="noop">        else:
</span><span class="hit">            flu.qib2[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qdb_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate direct runoff released from the soil.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NFk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.BSF`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.BoWa`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.WaDa`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDB`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`QDB = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {max(Exz, 0) \\ | \\ SfA \\leq 0}
</span><span class="noop">      \\atop
</span><span class="noop">      {max(Exz + NFk \\cdot SfA^{BSf+1}, 0) \\ | \\ SfA &gt; 0}
</span><span class="noop">      }`
</span><span class="noop">      :math:`SFA = (1 - \\frac{BoWa}{NFk})^\\frac{1}{BSf+1} -
</span><span class="noop">      \\frac{WaDa}{(BSf+1) \\cdot NFk}`
</span><span class="noop">      :math:`Exz = (BoWa + WaDa) - NFk`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        For water areas, sealed areas, and areas without any soil storage
</span><span class="noop">        capacity, all water is completely routed as direct runoff (see the
</span><span class="noop">        first three HRUs).  No principal distinction is made between the
</span><span class="noop">        remaining land use classes (arable land has been selected for
</span><span class="noop">        the other five HRUs arbitrarily):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(8)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, VERS, ACKER, ACKER, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; bsf(0.4)
</span><span class="noop">        &gt;&gt;&gt; nfk(0., 0., 0., 100., 100., 100., 100., 100.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.wada = 10.
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 0., 0., 0., -.1, 0., 50., 100., 100.1
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdb_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qdb
</span><span class="noop">        qdb(10.0, 10.0, 10.0, 0.142039, 0.144959, 1.993649, 10.0, 10.1)
</span><span class="noop">
</span><span class="noop">        With the common bsf value of 0.4, the discharge coefficient
</span><span class="noop">        increases more or less exponentially with soil moisture.
</span><span class="noop">        For soil moisture values slightly below zero or above usable
</span><span class="noop">        field capacity, plausible amounts of generated direct runoff
</span><span class="noop">        are ensured.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if ((con.lnk[k] != WASSER) and (con.lnk[k] != VERS) and
</span><span class="noop">                (con.nfk[k] &gt; 0.)):
</span><span class="hit">            if sta.bowa[k] &lt; con.nfk[k]:
</span><span class="hit">                aid.sfa[k] = (
</span><span class="noop">                    (1.-sta.bowa[k]/con.nfk[k])**(1./(con.bsf[k]+1.)) -
</span><span class="noop">                    (flu.wada[k]/((con.bsf[k]+1.)*con.nfk[k])))
</span><span class="noop">            else:
</span><span class="hit">                aid.sfa[k] = 0.
</span><span class="hit">            aid.exz[k] = sta.bowa[k]+flu.wada[k]-con.nfk[k]
</span><span class="hit">            flu.qdb[k] = aid.exz[k]
</span><span class="hit">            if aid.sfa[k] &gt; 0.:
</span><span class="hit">                flu.qdb[k] += aid.sfa[k]**(con.bsf[k]+1.)*con.nfk[k]
</span><span class="hit">            flu.qdb[k] = max(flu.qdb[k], 0.)
</span><span class="noop">        else:
</span><span class="hit">            flu.qdb[k] = flu.wada[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_bowa_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update soil moisture and correct fluxes if necessary.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.WaDa`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.BoWa`
</span><span class="noop">
</span><span class="noop">    Required (and eventually corrected) flux sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvB`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBB`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIB1`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIB2`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDB`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">       :math:`\\frac{dBoWa}{dt} = WaDa - EvB - QBB - QIB1 - QIB2 - QDB`
</span><span class="noop">       :math:`BoWa \\geq 0`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        For water areas and sealed areas, soil moisture is simply set to
</span><span class="noop">        zero and no flux corrections need not be performed.  No principal
</span><span class="noop">        distinction is made between the remaining land use classes (arable
</span><span class="noop">        land has been selected for the other four HRUs arbitrarily):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(6)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, VERS, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.wada = 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.evb(0., 0., 0., .1, .2, .3)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qbb(0., 0., 0., .2, .4, .6)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib1(0., 0., 0., .3, .6, .9)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib2(0., 0., 0., .4, .8, 1.2)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qdb(0., 0., 0., .5, 1., 1.5)
</span><span class="noop">        &gt;&gt;&gt; model.calc_bowa_v1()
</span><span class="noop">        &gt;&gt;&gt; states.bowa
</span><span class="noop">        bowa(0.0, 0.0, 3.0, 1.5, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.evb
</span><span class="noop">        evb(0.0, 0.0, 0.0, 0.1, 0.2, 0.2)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qbb
</span><span class="noop">        qbb(0.0, 0.0, 0.0, 0.2, 0.4, 0.4)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib1
</span><span class="noop">        qib1(0.0, 0.0, 0.0, 0.3, 0.6, 0.6)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib2
</span><span class="noop">        qib2(0.0, 0.0, 0.0, 0.4, 0.8, 0.8)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qdb
</span><span class="noop">        qdb(0.0, 0.0, 0.0, 0.5, 1.0, 1.0)
</span><span class="noop">
</span><span class="noop">        For the sixths HRU, the original loss terms would result in
</span><span class="noop">        negative soil moisture values.  They are corrected to the same
</span><span class="noop">        loss terms of the fifths HRU, which result in a complete
</span><span class="noop">        emptying of the soil storage exactly.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if (con.lnk[k] != WASSER) and (con.lnk[k] != VERS):
</span><span class="hit">            aid.bvl[k] = (flu.evb[k] +
</span><span class="noop">                          flu.qbb[k]+flu.qib1[k]+flu.qib2[k]+flu.qdb[k])
</span><span class="hit">            aid.mvl[k] = sta.bowa[k]+flu.wada[k]
</span><span class="hit">            if aid.bvl[k] &gt; aid.mvl[k]:
</span><span class="hit">                aid.rvl[k] = aid.mvl[k]/aid.bvl[k]
</span><span class="hit">                flu.evb[k] *= aid.rvl[k]
</span><span class="hit">                flu.qbb[k] *= aid.rvl[k]
</span><span class="hit">                flu.qib1[k] *= aid.rvl[k]
</span><span class="hit">                flu.qib2[k] *= aid.rvl[k]
</span><span class="hit">                flu.qdb[k] *= aid.rvl[k]
</span><span class="hit">                sta.bowa[k] = 0.
</span><span class="noop">            else:
</span><span class="hit">                sta.bowa[k] = aid.mvl[k]-aid.bvl[k]
</span><span class="noop">        else:
</span><span class="hit">            sta.bowa[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qbgz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Aggregate the amount of base flow released by all HRUs.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FHRU`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBB`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBGZ`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QBGZ = \\Sigma(FHRU \\cdot QBB)`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nhru(2)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; fhru(.75, .25)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qbb = 1., 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qbgz_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qbgz
</span><span class="noop">        qbgz(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    sta.qbgz = 0.
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        sta.qbgz += con.fhru[k]*flu.qbb[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qigz1_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Aggregate the amount of the first interflow component released
</span><span class="noop">    by all HRUs.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FHRU`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIB1`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGZ1`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QIGZ1 = \\Sigma(FHRU \\cdot QIB1)`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nhru(2)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; fhru(.75, .25)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib1 = 1., 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qigz1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qigz1
</span><span class="noop">        qigz1(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    sta.qigz1 = 0.
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        sta.qigz1 += con.fhru[k]*flu.qib1[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qigz2_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Aggregate the amount of the second interflow component released
</span><span class="noop">    by all HRUs.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FHRU`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIB2`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGZ2`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QIGZ2 = \\Sigma(FHRU \\cdot QIB2)`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nhru(2)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; fhru(.75, .25)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib2 = 1., 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qigz2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qigz2
</span><span class="noop">        qigz2(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    sta.qigz2 = 0.
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        sta.qigz2 += con.fhru[k]*flu.qib2[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qdgz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Aggregate the amount of total direct flow released by all HRUs.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FHRU`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDB`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGZ`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QDGZ = \\Sigma(FHRU \\cdot QDB)`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nhru(2)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; fhru(.75, .25)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qdb = 1., 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdgz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qdgz
</span><span class="noop">        qdgz(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.qdgz = 0.
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        flu.qdgz += con.fhru[k]*flu.qdb[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qdgz1_qdgz2_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Seperate total direct flow into a small and a fast component.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.A1`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.A2`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGZ`
</span><span class="noop">
</span><span class="noop">    Calculated state sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGZ1`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGZ2`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QDGZ2 = \\frac{(QDGZ-A2)^2}{QDGZ+A1-A2}`
</span><span class="noop">       :math:`QDGZ1 = QDGZ - QDGZ1`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        The formula for calculating the amount of the fast component of
</span><span class="noop">        direct flow is borrowed from the famous curve number approach.
</span><span class="noop">        Parameter :class:`A2` would be the initial loss and parameter
</span><span class="noop">        :class:`A1` the maximum storage, but one should not take this
</span><span class="noop">        analogy too serious.  Instead, with the value of parameter `a1`
</span><span class="noop">        set to zero, parameter `a2` just defines the maximum amount of
</span><span class="noop">        &#34;slow&#34; direct runoff per time step:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; a1(0.)
</span><span class="noop">
</span><span class="noop">        Let us set the value of `a2` to 4 mm/d, which is 2 mm/12h with
</span><span class="noop">        respect to the selected simulation step size:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; a2(4.)
</span><span class="noop">        &gt;&gt;&gt; a2
</span><span class="noop">        a2(4.0)
</span><span class="noop">        &gt;&gt;&gt; a2.value
</span><span class="noop">        2.0
</span><span class="noop">
</span><span class="noop">        Define a small test function to shorten the following examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; def test(*values):
</span><span class="noop">        ...     for value in values:
</span><span class="noop">        ...         fluxes.qdgz = value
</span><span class="noop">        ...         model.calc_qdgz1_qdgz2_v1()
</span><span class="noop">        ...         print(fluxes.qdgz, states.qdgz1, states.qdgz2)
</span><span class="noop">
</span><span class="noop">        The results of the seperation for total direct flow volumes of
</span><span class="noop">        1, 2, 3 and 4 mm/12h are:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(1., 2., 3., 100.)
</span><span class="noop">        qdgz(1.0) qdgz1(1.0) qdgz2(0.0)
</span><span class="noop">        qdgz(2.0) qdgz1(2.0) qdgz2(0.0)
</span><span class="noop">        qdgz(3.0) qdgz1(2.0) qdgz2(1.0)
</span><span class="noop">        qdgz(100.0) qdgz1(2.0) qdgz2(98.0)
</span><span class="noop">
</span><span class="noop">        Setting `a2` to zero and `a1` to 4 mm/d (or 2mm/12h)...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; a2(0.)
</span><span class="noop">        &gt;&gt;&gt; a1(4.)
</span><span class="noop">        &gt;&gt;&gt; a1
</span><span class="noop">        a1(4.0)
</span><span class="noop">        &gt;&gt;&gt; a1.value
</span><span class="noop">        2.0
</span><span class="noop">
</span><span class="noop">        ...results in a smoother transition instead:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(1., 2., 3., 100.)
</span><span class="noop">        qdgz(1.0) qdgz1(0.666667) qdgz2(0.333333)
</span><span class="noop">        qdgz(2.0) qdgz1(1.0) qdgz2(1.0)
</span><span class="noop">        qdgz(3.0) qdgz1(1.2) qdgz2(1.8)
</span><span class="noop">        qdgz(100.0) qdgz1(1.960784) qdgz2(98.039216)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        Alternatively, one can mix these two configurations by setting
</span><span class="noop">        the values of both parameters to 2 mm/h:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; a2(2.)
</span><span class="noop">        &gt;&gt;&gt; a1(2.)
</span><span class="noop">        &gt;&gt;&gt; test(1., 2., 3., 100.)
</span><span class="noop">        qdgz(1.0) qdgz1(1.0) qdgz2(0.0)
</span><span class="noop">        qdgz(2.0) qdgz1(1.5) qdgz2(0.5)
</span><span class="noop">        qdgz(3.0) qdgz1(1.666667) qdgz2(1.333333)
</span><span class="noop">        qdgz(100.0) qdgz1(1.99) qdgz2(98.01)
</span><span class="noop">
</span><span class="noop">        Note the similarity of the results for very high values of total
</span><span class="noop">        direct flow in all three examples, which converge to the sum of
</span><span class="noop">        the values of parameter `a1` and `a2`, representing the maximum
</span><span class="noop">        value of `slow` direct flow generation per simulation step
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    if flu.qdgz &gt; con.a2:
</span><span class="hit">        sta.qdgz2 = (flu.qdgz-con.a2)**2/(flu.qdgz+con.a1-con.a2)
</span><span class="hit">        sta.qdgz1 = flu.qdgz-sta.qdgz2
</span><span class="noop">    else:
</span><span class="hit">        sta.qdgz2 = 0.
</span><span class="hit">        sta.qdgz1 = flu.qdgz
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qbga_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Perform the runoff concentration calculation for base flow.
</span><span class="noop">
</span><span class="noop">    The working equation is the analytical solution of the linear storage
</span><span class="noop">    equation under the assumption of constant change in inflow during
</span><span class="noop">    the simulation time step.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KB`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBGZ`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBGA`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QBGA_{neu} = QBGA_{alt} +
</span><span class="noop">       (QBGZ_{alt}-QBGA_{alt}) \\cdot (1-exp(-KB^{-1})) +
</span><span class="noop">       (QBGZ_{neu}-QBGZ_{alt}) \\cdot (1-KB\\cdot(1-exp(-KB^{-1})))`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        A normal test case:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.kb(0.1)
</span><span class="noop">        &gt;&gt;&gt; states.qbgz.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qbgz.new = 4.
</span><span class="noop">        &gt;&gt;&gt; states.qbga.old = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qbga_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qbga
</span><span class="noop">        qbga(3.800054)
</span><span class="noop">
</span><span class="noop">        First extreme test case (zero division is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kb(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qbga_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qbga
</span><span class="noop">        qbga(4.0)
</span><span class="noop">
</span><span class="noop">        Second extreme test case (numerical overflow is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kb(1e200)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qbga_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qbga
</span><span class="noop">        qbga(5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if der.kb &lt;= 0.:
</span><span class="hit">        new.qbga = new.qbgz
</span><span class="hit">    elif der.kb &gt; 1e200:
</span><span class="miss">        new.qbga = old.qbga+new.qbgz-old.qbgz
</span><span class="noop">    else:
</span><span class="hit">        aid.temp = (1.-modelutils.exp(-1./der.kb))
</span><span class="hit">        new.qbga = (old.qbga +
</span><span class="noop">                    (old.qbgz-old.qbga)*aid.temp +
</span><span class="noop">                    (new.qbgz-old.qbgz)*(1.-der.kb*aid.temp))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qiga1_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Perform the runoff concentration calculation for the first
</span><span class="noop">    interflow component.
</span><span class="noop">
</span><span class="noop">    The working equation is the analytical solution of the linear storage
</span><span class="noop">    equation under the assumption of constant change in inflow during
</span><span class="noop">    the simulation time step.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KI1`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGZ1`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGA1`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QIGA1_{neu} = QIGA1_{alt} +
</span><span class="noop">       (QIGZ1_{alt}-QIGA1_{alt}) \\cdot (1-exp(-KI1^{-1})) +
</span><span class="noop">       (QIGZ1_{neu}-QIGZ1_{alt}) \\cdot (1-KI1\\cdot(1-exp(-KI1^{-1})))`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        A normal test case:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.ki1(0.1)
</span><span class="noop">        &gt;&gt;&gt; states.qigz1.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qigz1.new = 4.
</span><span class="noop">        &gt;&gt;&gt; states.qiga1.old = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qiga1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qiga1
</span><span class="noop">        qiga1(3.800054)
</span><span class="noop">
</span><span class="noop">        First extreme test case (zero division is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.ki1(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qiga1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qiga1
</span><span class="noop">        qiga1(4.0)
</span><span class="noop">
</span><span class="noop">        Second extreme test case (numerical overflow is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.ki1(1e200)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qiga1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qiga1
</span><span class="noop">        qiga1(5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if der.ki1 &lt;= 0.:
</span><span class="hit">        new.qiga1 = new.qigz1
</span><span class="hit">    elif der.ki1 &gt; 1e200:
</span><span class="miss">        new.qiga1 = old.qiga1+new.qigz1-old.qigz1
</span><span class="noop">    else:
</span><span class="hit">        aid.temp = (1.-modelutils.exp(-1./der.ki1))
</span><span class="hit">        new.qiga1 = (old.qiga1 +
</span><span class="noop">                     (old.qigz1-old.qiga1)*aid.temp +
</span><span class="noop">                     (new.qigz1-old.qigz1)*(1.-der.ki1*aid.temp))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qiga2_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Perform the runoff concentration calculation for the second
</span><span class="noop">    interflow component.
</span><span class="noop">
</span><span class="noop">    The working equation is the analytical solution of the linear storage
</span><span class="noop">    equation under the assumption of constant change in inflow during
</span><span class="noop">    the simulation time step.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KI2`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGZ2`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGA2`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QIGA2_{neu} = QIGA2_{alt} +
</span><span class="noop">       (QIGZ2_{alt}-QIGA2_{alt}) \\cdot (1-exp(-KI2^{-1})) +
</span><span class="noop">       (QIGZ2_{neu}-QIGZ2_{alt}) \\cdot (1-KI2\\cdot(1-exp(-KI2^{-1})))`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        A normal test case:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.ki2(0.1)
</span><span class="noop">        &gt;&gt;&gt; states.qigz2.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qigz2.new = 4.
</span><span class="noop">        &gt;&gt;&gt; states.qiga2.old = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qiga2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qiga2
</span><span class="noop">        qiga2(3.800054)
</span><span class="noop">
</span><span class="noop">        First extreme test case (zero division is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.ki2(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qiga2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qiga2
</span><span class="noop">        qiga2(4.0)
</span><span class="noop">
</span><span class="noop">        Second extreme test case (numerical overflow is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.ki2(1e200)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qiga2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qiga2
</span><span class="noop">        qiga2(5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if der.ki2 &lt;= 0.:
</span><span class="hit">        new.qiga2 = new.qigz2
</span><span class="hit">    elif der.ki2 &gt; 1e200:
</span><span class="miss">        new.qiga2 = old.qiga2+new.qigz2-old.qigz2
</span><span class="noop">    else:
</span><span class="hit">        aid.temp = (1.-modelutils.exp(-1./der.ki2))
</span><span class="hit">        new.qiga2 = (old.qiga2 +
</span><span class="noop">                     (old.qigz2-old.qiga2)*aid.temp +
</span><span class="noop">                     (new.qigz2-old.qigz2)*(1.-der.ki2*aid.temp))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qdga1_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Perform the runoff concentration calculation for &#34;slow&#34; direct runoff.
</span><span class="noop">
</span><span class="noop">    The working equation is the analytical solution of the linear storage
</span><span class="noop">    equation under the assumption of constant change in inflow during
</span><span class="noop">    the simulation time step.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.KD1`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGZ1`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGA1`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QDGA1_{neu} = QDGA1_{alt} +
</span><span class="noop">       (QDGZ1_{alt}-QDGA1_{alt}) \\cdot (1-exp(-KD1^{-1})) +
</span><span class="noop">       (QDGZ1_{neu}-QDGZ1_{alt}) \\cdot (1-KD1\\cdot(1-exp(-KD1^{-1})))`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        A normal test case:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.kd1(0.1)
</span><span class="noop">        &gt;&gt;&gt; states.qdgz1.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qdgz1.new = 4.
</span><span class="noop">        &gt;&gt;&gt; states.qdga1.old = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdga1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qdga1
</span><span class="noop">        qdga1(3.800054)
</span><span class="noop">
</span><span class="noop">        First extreme test case (zero division is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kd1(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdga1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qdga1
</span><span class="noop">        qdga1(4.0)
</span><span class="noop">
</span><span class="noop">        Second extreme test case (numerical overflow is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kd1(1e200)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdga1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qdga1
</span><span class="noop">        qdga1(5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if der.kd1 &lt;= 0.:
</span><span class="hit">        new.qdga1 = new.qdgz1
</span><span class="hit">    elif der.kd1 &gt; 1e200:
</span><span class="miss">        new.qdga1 = old.qdga1+new.qdgz1-old.qdgz1
</span><span class="noop">    else:
</span><span class="hit">        aid.temp = (1.-modelutils.exp(-1./der.kd1))
</span><span class="hit">        new.qdga1 = (old.qdga1 +
</span><span class="noop">                     (old.qdgz1-old.qdga1)*aid.temp +
</span><span class="noop">                     (new.qdgz1-old.qdgz1)*(1.-der.kd1*aid.temp))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qdga2_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Perform the runoff concentration calculation for &#34;fast&#34; direct runoff.
</span><span class="noop">
</span><span class="noop">    The working equation is the analytical solution of the linear storage
</span><span class="noop">    equation under the assumption of constant change in inflow during
</span><span class="noop">    the simulation time step.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.KD2`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGZ2`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGA2`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QDGA2_{neu} = QDGA2_{alt} +
</span><span class="noop">       (QDGZ2_{alt}-QDGA2_{alt}) \\cdot (1-exp(-KD2^{-1})) +
</span><span class="noop">       (QDGZ2_{neu}-QDGZ2_{alt}) \\cdot (1-KD2\\cdot(1-exp(-KD2^{-1})))`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        A normal test case:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.kd2(0.1)
</span><span class="noop">        &gt;&gt;&gt; states.qdgz2.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qdgz2.new = 4.
</span><span class="noop">        &gt;&gt;&gt; states.qdga2.old = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdga2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qdga2
</span><span class="noop">        qdga2(3.800054)
</span><span class="noop">
</span><span class="noop">        First extreme test case (zero division is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kd2(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdga2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qdga2
</span><span class="noop">        qdga2(4.0)
</span><span class="noop">
</span><span class="noop">        Second extreme test case (numerical overflow is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kd2(1e200)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdga2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qdga2
</span><span class="noop">        qdga2(5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if der.kd2 &lt;= 0.:
</span><span class="hit">        new.qdga2 = new.qdgz2
</span><span class="hit">    elif der.kd2 &gt; 1e200:
</span><span class="miss">        new.qdga2 = old.qdga2+new.qdgz2-old.qdgz2
</span><span class="noop">    else:
</span><span class="hit">        aid.temp = (1.-modelutils.exp(-1./der.kd2))
</span><span class="hit">        new.qdga2 = (old.qdga2 +
</span><span class="noop">                     (old.qdgz2-old.qdga2)*aid.temp +
</span><span class="noop">                     (new.qdgz2-old.qdgz2)*(1.-der.kd2*aid.temp))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_q_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the final runoff.
</span><span class="noop">
</span><span class="noop">    Note that, in case there are water areas, their (interception)
</span><span class="noop">    evaporation values are subtracted from the &#34;potential&#34; runoff value.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvI`
</span><span class="noop">
</span><span class="noop">    Required state sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBGA`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGA1`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGA2`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGA1`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGA2`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.Q`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">       :math:`Q = QBGA + QIGA1 + QIGA2 + QDGA1 + QDGA2 - EvI_{WASSER}`
</span><span class="noop">       :math:`Q \\geq 0`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        When there are no water areas in the respective subbasin, the
</span><span class="noop">        different runoff components are simply summed up:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nhru(3)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, VERS, NADELW)
</span><span class="noop">        &gt;&gt;&gt; fhru(0.5, 0.2, 0.3)
</span><span class="noop">        &gt;&gt;&gt; states.qbga = .1
</span><span class="noop">        &gt;&gt;&gt; states.qiga1 = .3
</span><span class="noop">        &gt;&gt;&gt; states.qiga2 = .5
</span><span class="noop">        &gt;&gt;&gt; states.qdga1 = .7
</span><span class="noop">        &gt;&gt;&gt; states.qdga2 = .9
</span><span class="noop">        &gt;&gt;&gt; fluxes.evi = 4., 5., 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(2.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.evi
</span><span class="noop">        evi(4.0, 5.0, 3.0)
</span><span class="noop">
</span><span class="noop">        The defined values of interception evaporation do not show any
</span><span class="noop">        impact on the result of the given example.  But when the first
</span><span class="noop">        HRU is assumed to be a water area, its interception evaporation
</span><span class="noop">        is subtracted:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; control.lnk(WASSER, VERS, NADELW)
</span><span class="noop">        &gt;&gt;&gt; model.calc_q_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.evi
</span><span class="noop">        evi(4.0, 5.0, 3.0)
</span><span class="noop">
</span><span class="noop">        Note that only 2mm instead of 4mm are subtracted, as the first
</span><span class="noop">        HRU`s area is only 50% of the subbasin area.
</span><span class="noop">
</span><span class="noop">        Setting also the land use class of the second HRU to water would
</span><span class="noop">        result in overtrying.  To avoid this, both water evaporation
</span><span class="noop">        values are reduced by the same factor:
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; control.lnk(WASSER, WASSER, NADELW)
</span><span class="noop">        &gt;&gt;&gt; model.calc_q_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.evi
</span><span class="noop">        evi(3.333333, 4.166667, 3.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    flu.q = sta.qbga+sta.qiga1+sta.qiga2+sta.qdga1+sta.qdga2
</span><span class="hit">    aid.epw = 0.
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if con.lnk[k] == WASSER:
</span><span class="hit">            aid.epw += con.fhru[k]*flu.evi[k]
</span><span class="hit">    if flu.q &gt; aid.epw:
</span><span class="hit">        flu.q -= aid.epw
</span><span class="hit">    elif aid.epw &gt; 0.:
</span><span class="hit">        for k in range(con.nhru):
</span><span class="hit">            if con.lnk[k] == WASSER:
</span><span class="hit">                flu.evi[k] *= flu.q/aid.epw
</span><span class="hit">        flu.q = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pass_q_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the outlet link sequence.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.QFactor`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.Q`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_outlets.Q`
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    out = self.sequences.outlets.fastaccess
</span><span class="hit">    out.q[0] += der.qfactor*flu.q
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;Base model for HydPy-L-Land.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _RUN_METHODS = (calc_nkor_v1,
</span><span class="noop">                    calc_tkor_v1,
</span><span class="noop">                    calc_et0_v1,
</span><span class="noop">                    calc_et0_v2,
</span><span class="noop">                    calc_evpo_v1,
</span><span class="noop">                    calc_nbes_inzp_v1,
</span><span class="noop">                    calc_evi_inzp_v1,
</span><span class="noop">                    calc_sbes_v1,
</span><span class="noop">                    calc_wgtf_v1,
</span><span class="noop">                    calc_schm_wats_v1,
</span><span class="noop">                    calc_wada_waes_v1,
</span><span class="noop">                    calc_evb_v1,
</span><span class="noop">                    calc_qbb_v1,
</span><span class="noop">                    calc_qib1_v1,
</span><span class="noop">                    calc_qib2_v1,
</span><span class="noop">                    calc_qdb_v1,
</span><span class="noop">                    calc_bowa_v1,
</span><span class="noop">                    calc_qbgz_v1,
</span><span class="noop">                    calc_qigz1_v1,
</span><span class="noop">                    calc_qigz2_v1,
</span><span class="noop">                    calc_qdgz_v1,
</span><span class="noop">                    calc_qdgz1_qdgz2_v1,
</span><span class="noop">                    calc_qbga_v1,
</span><span class="noop">                    calc_qiga1_v1,
</span><span class="noop">                    calc_qiga2_v1,
</span><span class="noop">                    calc_qdga1_v1,
</span><span class="noop">                    calc_qdga2_v1,
</span><span class="noop">                    calc_q_v1)
</span><span class="hit">    _OUTLET_METHODS = (pass_q_v1,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Runoff [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of the HydPy-L-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_parameters.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_parameters.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.lland import lland_constants
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameter(parametertools.ZipParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the HydPy-L-Land model
</span><span class="noop">    (potentially) handling multiple values.
</span><span class="noop">
</span><span class="noop">    Class :class:`MultiParameter` of HydPy-L-Land basically works like
</span><span class="noop">    Class :class:`~hydpy.models.lland.lland_parameters.MultiParameter` of
</span><span class="noop">    HydPy-H-Land, except that keyword arguments specific to HydPy-L-Land
</span><span class="noop">    are applied (acker, nadelw, wasser..., see module
</span><span class="noop">    :mod:`~hydpy.models.lland.lland_constants`) and except that parameter
</span><span class="noop">    :class:`~hydpy.models.lland.lland_control.NHRU` determines the number of
</span><span class="noop">    entries:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland.lland_parameters import MultiParameter
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; mp = MultiParameter()
</span><span class="noop">    &gt;&gt;&gt; mp.subpars = control
</span><span class="noop">    &gt;&gt;&gt; mp.shape
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    RuntimeError: Shape information for parameter `multiparameter` can only be retrieved after it has been defined.  You can do this manually, but usually it is done automatically by defining the value of parameter `nhru` first in each parameter control file.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = tuple(lland_constants.CONSTANTS.values())
</span><span class="hit">    MODEL_CONSTANTS = lland_constants.CONSTANTS
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def refparameter(self):
</span><span class="noop">        &#34;&#34;&#34;Alias for the associated instance of
</span><span class="noop">        :class:`~hydpy.models.lland.lland_control.LNK`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self.subpars.pars.control.lnk
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def shapeparameter(self):
</span><span class="noop">        &#34;&#34;&#34;Alias for the associated instance of
</span><span class="noop">        :class:`~hydpy.models.lland.lland_control.NHRU`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self.subpars.pars.control.nhru
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterLand(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of HydPy-L-Land (potentially)
</span><span class="noop">    handling multiple values relevant for non water HRUs.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = tuple(value for (key, value)
</span><span class="noop">                            in lland_constants.CONSTANTS.items()
</span><span class="noop">                            if value != &#39;WASSER&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterSoil(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of HydPy-L-Land (potentially)
</span><span class="noop">    handling multiple values relevant for non water HRUs without sealed
</span><span class="noop">    surfaces.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = tuple(value for (key, value)
</span><span class="noop">                            in lland_constants.CONSTANTS.items()
</span><span class="noop">                            if value not in (&#39;WASSER&#39;, &#39;VERS&#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LanduseMonthParameter(parametertools.KeywordParameter2D):
</span><span class="noop">    &#34;&#34;&#34;Base class for parameters which values depend both an the actual
</span><span class="noop">    land use class and the actual month.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    COLNAMES = (&#39;jan&#39;, &#39;feb&#39;, &#39;mar&#39;, &#39;apr&#39;, &#39;mai&#39;, &#39;jun&#39;,
</span><span class="noop">                &#39;jul&#39;, &#39;aug&#39;, &#39;sep&#39;, &#39;oct&#39;, &#39;nov&#39;, &#39;dec&#39;)
</span><span class="hit">    ROWNAMES = tuple(key.lower() for (idx, key)
</span><span class="noop">                     in (sorted((idx, key) for (key, idx) in
</span><span class="noop">                         lland_constants.CONSTANTS.items())))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Parameters(parametertools.Parameters):
</span><span class="noop">    &#34;&#34;&#34;All parameters of the HydPy-L-Land model.&#34;&#34;&#34;
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_sequences.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_sequences.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Sequences(sequencetools.Sequences):
</span><span class="noop">    &#34;&#34;&#34;All sequences of the HydPy-L-Land model.&#34;&#34;&#34;
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lland/lland_states.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Inzp(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Interzeptionsspeicherung (interception storage) [mm].
</span><span class="noop">
</span><span class="noop">    Note that :class:`Inzp` of HydPy-L implements no specialized trim method
</span><span class="noop">    (as opposed to :class:`~hydpy.models.hland.hland_states.Ic` of HydPy-H).
</span><span class="noop">    This is due the discontinuous evolution of
</span><span class="noop">    :class:`~hydpy.models.lland.lland_control.IcC` in time.  In accordance
</span><span class="noop">    with the orginal LARSIM implementation, :class:`Inzp` can be temporarily
</span><span class="noop">    overfilled during rain periods whenever
</span><span class="noop">    :class:`~hydpy.models.lland.lland_control.IcC` drops rapidly between two
</span><span class="noop">    months.  A specialized trim method would just make the excess water
</span><span class="noop">    vanish.  But in HydPy-L, the excess water becomes
</span><span class="noop">    :class:`~hydpy.models.lland.lland_fluxes.ThruFall` in the first simulation
</span><span class="noop">    step of the new month.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WATS(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasseräquivalent Trockenschnee (frozen water equivalent of the snow
</span><span class="noop">    cover) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`WAeS \\leq PWMax \\cdot WATS`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(7)
</span><span class="noop">        &gt;&gt;&gt; pwmax(2.)
</span><span class="noop">        &gt;&gt;&gt; states.waes = -1., 0., 1., -1., 5., 10., 20.
</span><span class="noop">        &gt;&gt;&gt; states.wats(-1., 0., 0., 5., 5., 5., 5.)
</span><span class="noop">        &gt;&gt;&gt; states.wats
</span><span class="noop">        wats(0.0, 0.0, 0.5, 5.0, 5.0, 5.0, 10.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        pwmax = self.subseqs.seqs.model.parameters.control.pwmax
</span><span class="hit">        waes = self.subseqs.waes
</span><span class="hit">        if lower is None:
</span><span class="hit">            if waes.values is not None:
</span><span class="hit">                lower = numpy.clip(waes/pwmax, 0., numpy.inf)
</span><span class="noop">            else:
</span><span class="miss">                lower = 0.
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WAeS(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasseräquivalent Gesamtschnee (total water equivalent of the snow
</span><span class="noop">    cover) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`WAeS \\leq PWMax \\cdot WATS`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(7)
</span><span class="noop">        &gt;&gt;&gt; pwmax(2.)
</span><span class="noop">        &gt;&gt;&gt; states.wats = 0., 0., 0., 5., 5., 5., 5.
</span><span class="noop">        &gt;&gt;&gt; states.waes(-1., 0., 1., -1., 5., 10., 20.)
</span><span class="noop">        &gt;&gt;&gt; states.waes
</span><span class="noop">        waes(0.0, 0.0, 0.0, 0.0, 5.0, 10.0, 10.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        pwmax = self.subseqs.seqs.model.parameters.control.pwmax
</span><span class="hit">        wats = self.subseqs.wats
</span><span class="hit">        if (upper is None) and (wats.values is not None):
</span><span class="hit">            upper = pwmax*wats
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BoWa(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Bodenwasserspeicherung (soil water storage) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`BoWa \\leq NFk`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(5)
</span><span class="noop">        &gt;&gt;&gt; nfk(200.)
</span><span class="noop">        &gt;&gt;&gt; states.bowa(-100.,0., 100., 200., 300.)
</span><span class="noop">        &gt;&gt;&gt; states.bowa
</span><span class="noop">        bowa(0.0, 0.0, 100.0, 200.0, 200.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subseqs.seqs.model.parameters.control.nfk
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QDGZ1(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Zufluss in den trägeren Direktabfluss-Gebietsspeicher (inflow into
</span><span class="noop">    the less responsive storage compartment for direct runoff) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QDGZ2(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Zufluss in den dynamischeren Direktabfluss-Gebietsspeicher (inflow into
</span><span class="noop">    the more responsive storage compartment for direct runoff) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QIGZ1(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;&#34;Zufluss in den ersten Zwischenabfluss-Gebietsspeicher (inflow into the
</span><span class="noop">    first storage compartment for interflow) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QIGZ2(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Zufluss in den zweiten Zwischenabfluss-Gebietsspeicher (inflow into the
</span><span class="noop">    second storage compartment for interflow) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QBGZ(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Zufluss in den Basisabfluss-Gebietsspeicher (inflow into the
</span><span class="noop">    storage compartment for base flow) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QDGA1(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss aus dem trägeren Direktabfluss-Gebietsspeicher (outflow from
</span><span class="noop">    the less responsive storage compartment for direct runoff) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QDGA2(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss aus dem dynamischeren Direktabfluss-Gebietsspeicher (outflow
</span><span class="noop">    from the more responsive storage compartment for direct runoff) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QIGA1(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss aus dem &#34;unteren&#34; Zwischenabfluss-Gebietsspeicher (outflow from
</span><span class="noop">    the storage compartment for the first interflow component) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QIGA2(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss aus dem &#34;oberen&#34; Zwischenabfluss-Gebietsspeicher (outflow from
</span><span class="noop">    the storage compartment for the second interflow component) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QBGA(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss aus dem Basisabfluss-Gebietsspeicher (outflow from the
</span><span class="noop">    storage compartment for base flow) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of the HydPy-L-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Inzp, WATS, WAeS, BoWa, QDGZ1, QDGZ2, QIGZ1, QIGZ2,
</span><span class="noop">                   QBGZ, QDGA1, QDGA2, QIGA1, QIGA2, QBGA)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">The L-Stream model defines the methods and classes required for
</span><span class="noop">performing  flood routing calculations after the Williams method
</span><span class="noop">as implemented in LARSIM.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from lstream
</span><span class="hit">from hydpy.models.lstream.lstream_control import ControlParameters
</span><span class="hit">from hydpy.models.lstream.lstream_derived import DerivedParameters
</span><span class="hit">from hydpy.models.lstream.lstream_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.lstream.lstream_states import StateSequences
</span><span class="hit">from hydpy.models.lstream.lstream_aides import AideSequences
</span><span class="hit">from hydpy.models.lstream.lstream_inlets import InletSequences
</span><span class="hit">from hydpy.models.lstream.lstream_outlets import OutletSequences
</span><span class="hit">from hydpy.models.lstream.lstream_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_aides.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_aides.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Temp(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Temporäre Variable (temporary variable) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HMin(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Untere Wasserstandsgrenze (lower water stage boundary) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HMax(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Obere Wasserstandsgrenze (upper water stage boundary) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QMin(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Untere Abflussgrenze (lower discharge boundary) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QMax(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Obere Abflussgrenze (upper discharge boundary) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QTest(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Vergleichsabfluss (discharge to be compared) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of HydPy-L-Stream.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Temp, HMin, HMax, QMin, QMax, QTest)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Laen(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Flusslänge (channel length) [km].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Gef(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Sohlgefälle (channel slope) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HM(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Höhe Hauptgerinne (height of the main channel) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BM(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Sohlbreite Hauptgerinne (bed width of the main channel) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BNM(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Böschungsneigung Hauptgerinne (slope of both main channel embankments)
</span><span class="noop">    [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Sohlbreite Vorländer (bed widths of both forelands) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BBV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Breite Vorlandböschungen (width of both foreland embankments) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BNV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Böschungsneigung Vorländer (slope of both foreland embankments) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BNVR(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Böschungsneigung Vorlandränder (slope of both outer embankments) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SKM(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Rauigkeitsbeiwert Hauptgerinne (roughness coefficient of the main
</span><span class="noop">    channel) [m^(1/3)/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SKV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Rauigkeitsbeiwert Vorländer (roughness coefficient of the both
</span><span class="noop">    forelands) [m^(1/3)/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EKM(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor Hauptgerinne (calibration factor for the main
</span><span class="noop">    channel) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EKV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor Vorländer (calibration factor for both forelands) [m].
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QTol(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Approximationstoleranz Abfluss (discharge related stopping criterion
</span><span class="noop">    for root-finding algorithms) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 1e-6
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HTol(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Approximationstoleranz Wasserstand (water stage related stopping
</span><span class="noop">    criterion for root-finding algorithms) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 1e-6
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters HydPy-L-Stream, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (Laen, Gef, HM, BM, BV, BBV, BNM, BNV, BNVR,
</span><span class="noop">                   SKM, SKV, EKM, EKV, QTol, HTol)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_derived.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Höhe Vorländer (height of both forelands) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Update value based on :math:`HV=BBV/BNV`.
</span><span class="noop">
</span><span class="noop">        Required Parameters:
</span><span class="noop">            :class:`BBV`
</span><span class="noop">            :class:`BNV`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; bbv(left=10., right=40.)
</span><span class="noop">            &gt;&gt;&gt; bnv(left=10., right=20.)
</span><span class="noop">            &gt;&gt;&gt; derived.hv.update()
</span><span class="noop">            &gt;&gt;&gt; derived.hv
</span><span class="noop">            hv(1.0, 2.0)
</span><span class="noop">            &gt;&gt;&gt; bbv(left=10., right=0.)
</span><span class="noop">            &gt;&gt;&gt; bnv(left=0., right=20.)
</span><span class="noop">            &gt;&gt;&gt; derived.hv.update()
</span><span class="noop">            &gt;&gt;&gt; derived.hv
</span><span class="noop">            hv(0.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        for idx in range(2):
</span><span class="hit">            if (con.bbv[idx] &gt; 0.) and (con.bnv[idx] &gt; 0.):
</span><span class="hit">                self[idx] = con.bbv[idx]/con.bnv[idx]
</span><span class="noop">            else:
</span><span class="hit">                self[idx] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QM(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Bordvoller Abfluss Hauptgerinne (maximum discharge of the main channel)
</span><span class="noop">    [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Update value based on the actual
</span><span class="noop">        :func:`~hydpy.models.lstream.lstream_model.calc_qg` method.
</span><span class="noop">
</span><span class="noop">        Required derived parameter:
</span><span class="noop">            :class:`~hydpy.models.lstream.lstream_control.H`
</span><span class="noop">
</span><span class="noop">        Note that the value of parameter :class:`QM` is directly related to
</span><span class="noop">        the value of parameter :class:`HM` and indirectly related to all
</span><span class="noop">        parameters values relevant for method
</span><span class="noop">        :func:`~hydpy.models.lstream.lstream_model.calc_qg`. Hence the
</span><span class="noop">        complete paramter (and sequence) requirements might differ for
</span><span class="noop">        various application models.
</span><span class="noop">
</span><span class="noop">        For examples, see the documentation on method ToDo.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        mod = self.subpars.pars.model
</span><span class="hit">        con = mod.parameters.control
</span><span class="hit">        flu = mod.sequences.fluxes
</span><span class="hit">        flu.h = con.hm
</span><span class="hit">        mod.calc_qg()
</span><span class="hit">        self.value = flu.qg
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Bordvoller Abfluss Vorländer (maximum discharge of both forelands)
</span><span class="noop">    [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Update value based on the actual
</span><span class="noop">        :func:`~hydpy.models.lstream.lstream_model.calc_qg` method.
</span><span class="noop">
</span><span class="noop">        Required derived parameter:
</span><span class="noop">            :class:`HV`
</span><span class="noop">
</span><span class="noop">        Note that the values of parameter :class:`QV` are directly related to
</span><span class="noop">        the values of parameter :class:`HV` and indirectly related to all
</span><span class="noop">        parameters values relevant for method
</span><span class="noop">        :func:`~hydpy.models.lstream.lstream_model.calc_qg`. Hence the
</span><span class="noop">        complete paramter (and sequence) requirements might differ for
</span><span class="noop">        various application models.
</span><span class="noop">
</span><span class="noop">        For examples, see the documentation on method ToDo.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        mod = self.subpars.pars.model
</span><span class="hit">        con = mod.parameters.control
</span><span class="hit">        der = self.subpars
</span><span class="hit">        flu = mod.sequences.fluxes
</span><span class="hit">        for idx in range(2):
</span><span class="hit">            flu.h = con.hm+der.hv[idx]
</span><span class="hit">            mod.calc_qg()
</span><span class="hit">            self[idx] = flu.qg
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Sek(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34; Sekunden im Simulationszeitschritt (Number of seconds of the selected
</span><span class="noop">    simulation time step) [T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Update value based on :math:`HL=BBR/BNR`.
</span><span class="noop">
</span><span class="noop">        Required Parameters:
</span><span class="noop">            :class:`BBR`
</span><span class="noop">            :class:`BNR`
</span><span class="noop">
</span><span class="noop">        Example:
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep()
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; derived.sek.update()
</span><span class="noop">            &gt;&gt;&gt; derived.sek
</span><span class="noop">            sek(86400.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self(self.simulationstep.seconds)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of HydPy-L-Stream, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (HV, QM, QV, Sek)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QRef(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Referenzabfluss (reference flow) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class H(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasserstand (water stage) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AM(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchflossene Fläche Hauptgerinne (flown through area of the
</span><span class="noop">    main channel) [m²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AV(sequencetools.LeftRightSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchflossene Fläche Vorländer (flown through area of both forelands)
</span><span class="noop">    [m²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AVR(sequencetools.LeftRightSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchflossene Fläche Vorlandränder (flown through area of both outer
</span><span class="noop">    embankments) [m²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AG(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchflossene Fläche gesamt  (total flown through area) [m²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class UM(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Benetzter Umfang Hauptgerinne (wetted perimeter of the
</span><span class="noop">    main channel) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class UV(sequencetools.LeftRightSequence):
</span><span class="noop">    &#34;&#34;&#34;Benetzter Umfang Vorländer (wetted perimeter of both forelands) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class UVR(sequencetools.LeftRightSequence):
</span><span class="noop">    &#34;&#34;&#34;Benetzter Umfang Vorlandränder (wetted perimeter of both outer
</span><span class="noop">    embankments) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class UG(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchflossene Fläche gesamt  (total wetted perimeter) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QM(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchfluss Hauptgerinne (discharge of the main channel) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QV(sequencetools.LeftRightSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchfluss Voränder (discharge of both forelands) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QVR(sequencetools.LeftRightSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchfluss Vorlandränder (discharge of both outer embankment) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (1., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QG(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchfluss gesamt (total discharge) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RK(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Schwerpunktlaufzeit (traveling time) [s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of HydPy-L-Stream.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QRef, H, AM, AV, AVR, AG, UM, UV, UVR, UG,
</span><span class="noop">                   QM, QV, QVR, QG, RK)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_inlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_inlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss (runoff) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of HydPy-L-Stream.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.cythons import modelutils
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qref_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Determine the reference discharge within the given space-time intervall.
</span><span class="noop">
</span><span class="noop">    Required state sequences:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_states.QZ`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_states.QA`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QRef`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`QRef = \\frac{QZ_{new}+QZ_{old}+QA_{old}}{3}`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; states.qz.new = 3.
</span><span class="noop">        &gt;&gt;&gt; states.qz.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qa.old = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qref_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qref
</span><span class="noop">        qref(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.qref = (new.qz+old.qz+old.qa)/3.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_rk_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Determine the actual traveling time of the water (not of the wave!).
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_derived.Sek`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.A`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QRef`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.RK`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`RK = \\frac{Laen \\cdot A}{QRef}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        First, note that the traveling time is determined in the unit of the
</span><span class="noop">        actual simulation step size:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; laen(25.)
</span><span class="noop">        &gt;&gt;&gt; derived.sek(24*60*60)
</span><span class="noop">        &gt;&gt;&gt; fluxes.ag = 10.
</span><span class="noop">        &gt;&gt;&gt; fluxes.qref = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_rk_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.rk
</span><span class="noop">        rk(2.893519)
</span><span class="noop">
</span><span class="noop">        Second, for negative values or zero values of
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.A` or
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.QRef`, the value of
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.RK` is set to zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.ag = 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.qref = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_rk_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.rk
</span><span class="noop">        rk(0.0)
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.ag = 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.qref = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_rk_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.rk
</span><span class="noop">        rk(0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    if (flu.ag &gt; 0.) and (flu.qref &gt; 0.):
</span><span class="hit">        flu.rk = (1000.*con.laen*flu.ag)/(der.sek*flu.qref)
</span><span class="noop">    else:
</span><span class="hit">        flu.rk = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_am_um_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the flown through area and the wetted perimeter
</span><span class="noop">    of the main channel.
</span><span class="noop">
</span><span class="noop">    Note that the main channel is assumed to have identical slopes on
</span><span class="noop">    both sides and that water flowing exactly above the main channel is
</span><span class="noop">    contributing to :class:`~hydpy.model.lstream.lstream_fluxes.AM`.
</span><span class="noop">    Both theoretical surfaces seperating water above the main channel
</span><span class="noop">    from water above both forelands are contributing to
</span><span class="noop">    :class:`~hydpy.model.lstream.lstream_fluxes.UM`.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.HM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.BM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.BNM`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.H`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.UM`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Generally, a trapezoid with reflection symmetry is assumed.  Here its
</span><span class="noop">        smaller base (bottom) has a length of 2 meters, its legs show an
</span><span class="noop">        inclination of 1 meter per 4 meters, and its height (depths) is 1
</span><span class="noop">        meter:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; bm(2.)
</span><span class="noop">        &gt;&gt;&gt; bnm(4.)
</span><span class="noop">        &gt;&gt;&gt; hm(1.)
</span><span class="noop">
</span><span class="noop">        The first example deals with normal flow conditions, where water flows
</span><span class="noop">        within the main channel completely:
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_fluxes.H` &lt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_control.HM`):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = .5
</span><span class="noop">        &gt;&gt;&gt; model.calc_am_um_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.am
</span><span class="noop">        am(2.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.um
</span><span class="noop">        um(6.123106)
</span><span class="noop">
</span><span class="noop">        The second example deals with high flow conditions, where water flows
</span><span class="noop">        over the foreland also:
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_fluxes.H` &gt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_control.HM`):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = 1.5
</span><span class="noop">        &gt;&gt;&gt; model.calc_am_um_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.am
</span><span class="noop">        am(11.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.um
</span><span class="noop">        um(11.246211)
</span><span class="noop">
</span><span class="noop">        The third example checks the special case of a main channel with zero
</span><span class="noop">        height:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; hm(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_am_um_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.am
</span><span class="noop">        am(3.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.um
</span><span class="noop">        um(5.0)
</span><span class="noop">
</span><span class="noop">        The fourth example checks the special case of the actual water stage
</span><span class="noop">        not beeing larger than zero (empty channel):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = 0.
</span><span class="noop">        &gt;&gt;&gt; hm(1.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_am_um_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.am
</span><span class="noop">        am(0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.um
</span><span class="noop">        um(0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    if flu.h &lt;= 0.:
</span><span class="hit">        flu.am = 0.
</span><span class="hit">        flu.um = 0.
</span><span class="hit">    elif flu.h &lt; con.hm:
</span><span class="hit">        flu.am = flu.h*(con.bm+flu.h*con.bnm)
</span><span class="hit">        flu.um = con.bm+2.*flu.h*(1.+con.bnm**2)**.5
</span><span class="noop">    else:
</span><span class="hit">        flu.am = (con.hm*(con.bm+con.hm*con.bnm) +
</span><span class="noop">                  ((flu.h-con.hm)*(con.bm+2.*con.hm*con.bnm)))
</span><span class="hit">        flu.um = (con.bm)+(2.*con.hm*(1.+con.bnm**2)**.5)+(2*(flu.h-con.hm))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qm_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the discharge of the main channel after Manning-Strickler.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.EKM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.SKM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.Gef`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.UM`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QM`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        For appropriate strictly positive values:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; ekm(2.)
</span><span class="noop">        &gt;&gt;&gt; skm(50.)
</span><span class="noop">        &gt;&gt;&gt; gef(.01)
</span><span class="noop">        &gt;&gt;&gt; fluxes.am = 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.um = 7.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qm
</span><span class="noop">        qm(17.053102)
</span><span class="noop">
</span><span class="noop">        For zero or negative values of the flown through surface or
</span><span class="noop">        the wetted perimeter:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.am = -1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.um = 7.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qm
</span><span class="noop">        qm(0.0)
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.am = 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.um = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qm
</span><span class="noop">        qm(0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    if (flu.am &gt; 0.) and (flu.um &gt; 0.):
</span><span class="hit">        flu.qm = con.ekm*con.skm*flu.am**(5./3.)/flu.um**(2./3.)*con.gef**.5
</span><span class="noop">    else:
</span><span class="hit">        flu.qm = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_av_uv_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the flown through area and the wetted perimeter of both
</span><span class="noop">    forelands.
</span><span class="noop">
</span><span class="noop">    Note that the each foreland lies between the main channel and one
</span><span class="noop">    outer embankment and that water flowing exactly above the a foreland
</span><span class="noop">    is contributing to :class:`~hydpy.model.lstream.lstream_fluxes.AV`.
</span><span class="noop">    The theoretical surface seperating water above the main channel from
</span><span class="noop">    water above the foreland is not contributing to
</span><span class="noop">    :class:`~hydpy.model.lstream.lstream_fluxes.UV`, but the surface
</span><span class="noop">    seperating water above the foreland from water above its outer embankment
</span><span class="noop">    is contributing to :class:`~hydpy.model.lstream.lstream_fluxes.UV`.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.HM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.BV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.BNV`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_derived.HV`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.H`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.UV`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Generally, right trapezoids are assumed.  Here, for simplicity, both
</span><span class="noop">        forelands are assumed to be symmetrical.  Their smaller bases (bottoms)
</span><span class="noop">        hava a length of 2 meters, their non-vertical legs show an inclination
</span><span class="noop">        of 1 meter per 4 meters, and their height (depths) is 1 meter.  Both
</span><span class="noop">        forelands lie 1 meter above the main channels bottom.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; hm(1.)
</span><span class="noop">        &gt;&gt;&gt; bv(2.)
</span><span class="noop">        &gt;&gt;&gt; bnv(4.)
</span><span class="noop">        &gt;&gt;&gt; derived.hv(1.)
</span><span class="noop">
</span><span class="noop">        The first example deals with normal flow conditions, where water flows
</span><span class="noop">        within the main channel completely:
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_fluxes.H` &lt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_control.HM`):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = .5
</span><span class="noop">        &gt;&gt;&gt; model.calc_av_uv_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.av
</span><span class="noop">        av(0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.uv
</span><span class="noop">        uv(0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        The second example deals with moderate high flow conditions, where
</span><span class="noop">        water flows over both forelands, but not over their embankments:
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_control.HM` &lt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.H` &lt;
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_control.HM` +
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_derived.HV`)):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = 1.5
</span><span class="noop">        &gt;&gt;&gt; model.calc_av_uv_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.av
</span><span class="noop">        av(1.5, 1.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.uv
</span><span class="noop">        uv(4.061553, 4.061553)
</span><span class="noop">
</span><span class="noop">        The third example deals with extreme high flow conditions, where
</span><span class="noop">        water flows over the both foreland and their outer embankments:
</span><span class="noop">        ((:class:`~hydpy.model.lstream.lstream_control.HM` +
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_derived.HV`) &lt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.H`):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = 2.5
</span><span class="noop">        &gt;&gt;&gt; model.calc_av_uv_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.av
</span><span class="noop">        av(7.0, 7.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.uv
</span><span class="noop">        uv(6.623106, 6.623106)
</span><span class="noop">
</span><span class="noop">        The forth example assures that zero widths or hights of the forelands
</span><span class="noop">        are handled properly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; bv.left = 0.
</span><span class="noop">        &gt;&gt;&gt; derived.hv.right = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_av_uv_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.av
</span><span class="noop">        av(4.0, 3.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.uv
</span><span class="noop">        uv(4.623106, 3.5)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for i in range(2):
</span><span class="hit">        if flu.h &lt;= con.hm:
</span><span class="hit">            flu.av[i] = 0.
</span><span class="hit">            flu.uv[i] = 0.
</span><span class="hit">        elif flu.h &lt;= (con.hm+der.hv[i]):
</span><span class="hit">            flu.av[i] = (flu.h-con.hm)*(con.bv[i]+(flu.h-con.hm)*con.bnv[i]/2.)
</span><span class="hit">            flu.uv[i] = con.bv[i]+(flu.h-con.hm)*(1.+con.bnv[i]**2)**.5
</span><span class="noop">        else:
</span><span class="hit">            flu.av[i] = (der.hv[i]*(con.bv[i]+der.hv[i]*con.bnv[i]/2.) +
</span><span class="noop">                         ((flu.h-(con.hm+der.hv[i])) *
</span><span class="noop">                          (con.bv[i]+der.hv[i]*con.bnv[i])))
</span><span class="hit">            flu.uv[i] = ((con.bv[i])+(der.hv[i]*(1.+con.bnv[i]**2)**.5) +
</span><span class="noop">                         (flu.h-(con.hm+der.hv[i])))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qv_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the discharge of both forelands after Manning-Strickler.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.EKV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.SKV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.Gef`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.UV`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QV`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        For appropriate strictly positive values:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; ekv(2.)
</span><span class="noop">        &gt;&gt;&gt; skv(50.)
</span><span class="noop">        &gt;&gt;&gt; gef(.01)
</span><span class="noop">        &gt;&gt;&gt; fluxes.av = 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.uv = 7.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qv_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qv
</span><span class="noop">        qv(17.053102, 17.053102)
</span><span class="noop">
</span><span class="noop">        For zero or negative values of the flown through surface or
</span><span class="noop">        the wetted perimeter:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.av = -1., 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.uv = 7., 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qv_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qv
</span><span class="noop">        qv(0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for i in range(2):
</span><span class="hit">        if (flu.av[i] &gt; 0.) and (flu.uv[i] &gt; 0.):
</span><span class="hit">            flu.qv[i] = (con.ekv[i]*con.skv[i] *
</span><span class="noop">                         flu.av[i]**(5./3.)/flu.uv[i]**(2./3.)*con.gef**.5)
</span><span class="noop">        else:
</span><span class="hit">            flu.qv[i] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_avr_uvr_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the flown through area and the wetted perimeter of both
</span><span class="noop">    outer embankments.
</span><span class="noop">
</span><span class="noop">    Note that each outer embankment lies beyond its foreland and that all
</span><span class="noop">    water flowing exactly above the a embankment is added to
</span><span class="noop">    :class:`~hydpy.model.lstream.lstream_fluxes.AVR`.
</span><span class="noop">    The theoretical surface seperating water above the foreland from water
</span><span class="noop">    above its embankment is not contributing to
</span><span class="noop">    :class:`~hydpy.model.lstream.lstream_fluxes.UVR`.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.HM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.BNVR`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_derived.HV`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.H`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AVR`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.UVR`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Generally, right trapezoids are assumed.  Here, for simplicity, both
</span><span class="noop">        forelands are assumed to be symmetrical.  Their smaller bases (bottoms)
</span><span class="noop">        hava a length of 2 meters, their non-vertical legs show an inclination
</span><span class="noop">        of 1 meter per 4 meters, and their height (depths) is 1 meter.  Both
</span><span class="noop">        forelands lie 1 meter above the main channels bottom.
</span><span class="noop">
</span><span class="noop">        Generally, a triangles are assumed, with the vertical side
</span><span class="noop">        seperating the foreland from its outer embankment.  Here, for
</span><span class="noop">        simplicity, both forelands are assumed to be symmetrical.  Their
</span><span class="noop">        inclinations are 1 meter per 4 meters and their lowest point is
</span><span class="noop">        1 meter above the forelands bottom and 2 meters above the main
</span><span class="noop">        channels bottom:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; hm(1.)
</span><span class="noop">        &gt;&gt;&gt; bnvr(4.)
</span><span class="noop">        &gt;&gt;&gt; derived.hv(1.)
</span><span class="noop">
</span><span class="noop">        The first example deals with moderate high flow conditions, where
</span><span class="noop">        water flows over the forelands, but not over their outer embankments:
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_control.HM` &lt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.H` &lt;
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_control.HM` +
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_derived.HV`)):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = 1.5
</span><span class="noop">        &gt;&gt;&gt; model.calc_avr_uvr_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.avr
</span><span class="noop">        avr(0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.uvr
</span><span class="noop">        uvr(0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        The second example deals with extreme high flow conditions, where
</span><span class="noop">        water flows over the both foreland and their outer embankments:
</span><span class="noop">        ((:class:`~hydpy.model.lstream.lstream_control.HM` +
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_derived.HV`) &lt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.H`):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = 2.5
</span><span class="noop">        &gt;&gt;&gt; model.calc_avr_uvr_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.avr
</span><span class="noop">        avr(0.5, 0.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.uvr
</span><span class="noop">        uvr(2.061553, 2.061553)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for i in range(2):
</span><span class="hit">        if flu.h &lt;= (con.hm+der.hv[i]):
</span><span class="hit">            flu.avr[i] = 0.
</span><span class="hit">            flu.uvr[i] = 0.
</span><span class="noop">        else:
</span><span class="hit">            flu.avr[i] = (flu.h-(con.hm+der.hv[i]))**2*con.bnvr[i]/2.
</span><span class="hit">            flu.uvr[i] = (flu.h-(con.hm+der.hv[i]))*(1.+con.bnvr[i]**2)**.5
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qvr_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the discharge of both outer embankments after
</span><span class="noop">    Manning-Strickler.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.EKV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.SKV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.Gef`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AVR`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.UVR`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QVR`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        For appropriate strictly positive values:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; ekv(2.)
</span><span class="noop">        &gt;&gt;&gt; skv(50.)
</span><span class="noop">        &gt;&gt;&gt; gef(.01)
</span><span class="noop">        &gt;&gt;&gt; fluxes.avr = 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.uvr = 7.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qvr_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qvr
</span><span class="noop">        qvr(17.053102, 17.053102)
</span><span class="noop">
</span><span class="noop">        For zero or negative values of the flown through surface or
</span><span class="noop">        the wetted perimeter:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.avr = -1., 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.uvr = 7., 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qvr_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qvr
</span><span class="noop">        qvr(0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for i in range(2):
</span><span class="hit">        if (flu.avr[i] &gt; 0.) and (flu.uvr[i] &gt; 0.):
</span><span class="hit">            flu.qvr[i] = (con.ekv[i]*con.skv[i] *
</span><span class="noop">                          flu.avr[i]**(5./3.)/flu.uvr[i]**(2./3.)*con.gef**.5)
</span><span class="noop">        else:
</span><span class="hit">            flu.qvr[i] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_ag_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Sum the through flown area of the total cross section.
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AVR`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AG`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; fluxes.am = 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.av= 2., 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.avr = 4., 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ag_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ag
</span><span class="noop">        ag(15.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.ag = flu.am+flu.av[0]+flu.av[1]+flu.avr[0]+flu.avr[1]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qg_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the discharge of the total cross section.
</span><span class="noop">
</span><span class="noop">    Method :func:`calc_qg_v1` applies the actual versions of all methods
</span><span class="noop">    for calculating the flown through areas, wetted perimeters and discharges
</span><span class="noop">    of the different cross section compartments.  Hence its requirements
</span><span class="noop">    might be different for various application models.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    self.calc_am_um()
</span><span class="hit">    self.calc_qm()
</span><span class="hit">    self.calc_av_uv()
</span><span class="hit">    self.calc_qv()
</span><span class="hit">    self.calc_avr_uvr()
</span><span class="hit">    self.calc_qvr()
</span><span class="hit">    flu.qg = flu.qm+flu.qv[0]+flu.qv[1]+flu.qvr[0]+flu.qvr[1]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_hmin_qmin_hmax_qmax_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Determine an starting interval for iteration methods as the one
</span><span class="noop">    implemented in method
</span><span class="noop">    :func:`~hydpy.models.lstream.lstream_model.calc_h_v1`.
</span><span class="noop">
</span><span class="noop">    The resulting interval is determined in a manner, that on the
</span><span class="noop">    one hand :math:`Qmin \\leq QRef \\leq Qmax` is fulfilled and on the
</span><span class="noop">    other hand the results of method :func:`calc_qg_v1` are continuous
</span><span class="noop">    for :math:`Hmin \\leq H \\leq Hmax`.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.HM`
</span><span class="noop">
</span><span class="noop">    Required derived paramters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_derived.HV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_derived.QM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_derived.QV`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QRef`
</span><span class="noop">
</span><span class="noop">    Calculated aide sequences:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.HMin`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.HMax`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.QMin`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.QMax`
</span><span class="noop">
</span><span class="noop">    Besides the mentioned required parameters and sequences, those of the
</span><span class="noop">    actual method for calculating the discharge of the total cross section
</span><span class="noop">    might be required.  This is the case whenever water flows on both outer
</span><span class="noop">    embankments.  In such occasions no previously determined upper boundary
</span><span class="noop">    values are available and method :func:`calc_hmin_qmin_hmax_qmax_v1` needs
</span><span class="noop">    to increase the value of :math:`HMax` successively until the condition
</span><span class="noop">    :math:`QG \\leq QMax` is met.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if flu.qref &lt;= der.qm:
</span><span class="hit">        aid.hmin = 0.
</span><span class="hit">        aid.qmin = 0.
</span><span class="hit">        aid.hmax = con.hm
</span><span class="hit">        aid.qmax = der.qm
</span><span class="hit">    elif flu.qref &lt;= min(der.qv[0], der.qv[1]):
</span><span class="hit">        aid.hmin = con.hm
</span><span class="hit">        aid.qmin = der.qm
</span><span class="hit">        aid.hmax = con.hm+min(der.hv[0], der.hv[1])
</span><span class="hit">        aid.qmax = min(der.qv[0], der.qv[1])
</span><span class="hit">    elif flu.qref &lt; max(der.qv[0], der.qv[1]):
</span><span class="hit">        aid.hmin = con.hm+min(der.hv[0], der.hv[1])
</span><span class="hit">        aid.qmin = min(der.qv[0], der.qv[1])
</span><span class="hit">        aid.hmax = con.hm+max(der.hv[0], der.hv[1])
</span><span class="hit">        aid.qmax = max(der.qv[0], der.qv[1])
</span><span class="noop">    else:
</span><span class="hit">        flu.h = con.hm+max(der.hv[0], der.hv[1])
</span><span class="hit">        aid.hmin = flu.h
</span><span class="hit">        aid.qmin = flu.qg
</span><span class="hit">        while True:
</span><span class="hit">            flu.h *= 2.
</span><span class="hit">            self.calc_qg()
</span><span class="hit">            if flu.qg &lt; flu.qref:
</span><span class="hit">                aid.hmin = flu.h
</span><span class="hit">                aid.qmin = flu.qg
</span><span class="noop">            else:
</span><span class="hit">                aid.hmax = flu.h
</span><span class="hit">                aid.qmax = flu.qg
</span><span class="hit">                break
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_h_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Approximate the water stage resulting in a certain reference discarge
</span><span class="noop">    with the Pegasus iteration method.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.QTol`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.HTol`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QRef`
</span><span class="noop">
</span><span class="noop">    Calculated aide sequences:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.HMin`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.HMax`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.QMin`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.QMax`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.H`
</span><span class="noop">
</span><span class="noop">    Besides the parameters and sequences given above, those of the
</span><span class="noop">    actual method for calculating the discharge of the total cross section
</span><span class="noop">    are required.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Essentially, the Pegasus method is a root finding algorithm which
</span><span class="noop">        sequentially decreases its search radius (like the simple bisection
</span><span class="noop">        algorithm) and shows superlinear convergence properties (like the
</span><span class="noop">        Newton-Raphson algorithm).  Ideally, its convergence should be proved
</span><span class="noop">        for each application model to be derived from HydPy-L-Stream.
</span><span class="noop">        The following examples focus on the methods
</span><span class="noop">        :func:`calc_hmin_qmin_hmax_qmax_v1` and :func:`calc_qg_v1`
</span><span class="noop">        (including their submethods) only:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; model.calc_hmin_qmin_hmax_qmax = model.calc_hmin_qmin_hmax_qmax_v1
</span><span class="noop">        &gt;&gt;&gt; model.calc_qg = model.calc_qg_v1
</span><span class="noop">        &gt;&gt;&gt; model.calc_qm = model.calc_qm_v1
</span><span class="noop">        &gt;&gt;&gt; model.calc_av_uv = model.calc_av_uv_v1
</span><span class="noop">        &gt;&gt;&gt; model.calc_qv = model.calc_qv_v1
</span><span class="noop">        &gt;&gt;&gt; model.calc_avr_uvr = model.calc_avr_uvr_v1
</span><span class="noop">        &gt;&gt;&gt; model.calc_qvr = model.calc_qvr_v1
</span><span class="noop">
</span><span class="noop">        Define the geometry and roughness values for the first test channel:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; bm(2.)
</span><span class="noop">        &gt;&gt;&gt; bnm(4.)
</span><span class="noop">        &gt;&gt;&gt; hm(1.)
</span><span class="noop">        &gt;&gt;&gt; bv(.5, 10.)
</span><span class="noop">        &gt;&gt;&gt; bbv(1., 2.)
</span><span class="noop">        &gt;&gt;&gt; bnv(1., 8.)
</span><span class="noop">        &gt;&gt;&gt; bnvr(20.)
</span><span class="noop">        &gt;&gt;&gt; ekm(1.)
</span><span class="noop">        &gt;&gt;&gt; skm(20.)
</span><span class="noop">        &gt;&gt;&gt; ekv(1.)
</span><span class="noop">        &gt;&gt;&gt; skv(60., 80.)
</span><span class="noop">        &gt;&gt;&gt; gef(.01)
</span><span class="noop">
</span><span class="noop">        Set the error tolerances of the iteration small enough, not to
</span><span class="noop">        compromise the shown first six decimal places of the following results:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; qtol(1e-10)
</span><span class="noop">        &gt;&gt;&gt; htol(1e-10)
</span><span class="noop">
</span><span class="noop">        Derive the required secondary parameters:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.hv.update()
</span><span class="noop">        &gt;&gt;&gt; derived.qm.update()
</span><span class="noop">        &gt;&gt;&gt; derived.qv.update()
</span><span class="noop">
</span><span class="noop">        Define a test function, accepting a reference discharge and printing
</span><span class="noop">        both the approximated water stage and the related discharge value:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; def test(qref):
</span><span class="noop">        ...     fluxes.qref = qref
</span><span class="noop">        ...     model.calc_hmin_qmin_hmax_qmax()
</span><span class="noop">        ...     model.calc_h()
</span><span class="noop">        ...     print(repr(fluxes.h))
</span><span class="noop">        ...     print(repr(fluxes.qg))
</span><span class="noop">
</span><span class="noop">        Zero discharge and the following discharge values are related to the
</span><span class="noop">        only discontinuities of the given root finding problem:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.qm
</span><span class="noop">        qm(8.399238)
</span><span class="noop">        &gt;&gt;&gt; derived.qv
</span><span class="noop">        qv(154.463234, 23.073584)
</span><span class="noop">
</span><span class="noop">        The related water stages are the ones (directly or indirectly)
</span><span class="noop">        defined above:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(0.)
</span><span class="noop">        h(0.0)
</span><span class="noop">        qg(0.0)
</span><span class="noop">        &gt;&gt;&gt; test(derived.qm)
</span><span class="noop">        h(1.0)
</span><span class="noop">        qg(8.399238)
</span><span class="noop">        &gt;&gt;&gt; test(derived.qv.left)
</span><span class="noop">        h(2.0)
</span><span class="noop">        qg(154.463234)
</span><span class="noop">        &gt;&gt;&gt; test(derived.qv.right)
</span><span class="noop">        h(1.25)
</span><span class="noop">        qg(23.073584)
</span><span class="noop">
</span><span class="noop">        Test some intermediate water stages, inundating the only the main
</span><span class="noop">        channel, the main channel along with the right foreland, and the
</span><span class="noop">        main channel along with both forelands respectively:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(6.)
</span><span class="noop">        h(0.859452)
</span><span class="noop">        qg(6.0)
</span><span class="noop">        &gt;&gt;&gt; test(10.)
</span><span class="noop">        h(1.047546)
</span><span class="noop">        qg(10.0)
</span><span class="noop">        &gt;&gt;&gt; test(100)
</span><span class="noop">        h(1.77455)
</span><span class="noop">        qg(100.0)
</span><span class="noop">
</span><span class="noop">        Finally, test two extreme water stages, inundating both outer
</span><span class="noop">        foreland embankments:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(200.)
</span><span class="noop">        h(2.152893)
</span><span class="noop">        qg(200.0)
</span><span class="noop">        &gt;&gt;&gt; test(2000.)
</span><span class="noop">        h(4.240063)
</span><span class="noop">        qg(2000.0)
</span><span class="noop">
</span><span class="noop">        There is a potential risk of the implemented iteration method to fail
</span><span class="noop">        for special channel geometries.  To test such cases in a more
</span><span class="noop">        condensed manner, the following test methods evaluates different water
</span><span class="noop">        stages automatically in accordance with the example above.  An error
</span><span class="noop">        message is printed only, the estimated discharge does not approximate
</span><span class="noop">        the reference discharge with six decimal places:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; def test():
</span><span class="noop">        ...     derived.hv.update()
</span><span class="noop">        ...     derived.qm.update()
</span><span class="noop">        ...     derived.qv.update()
</span><span class="noop">        ...     qm, qv = derived.qm, derived.qv
</span><span class="noop">        ...     for qref in [0., qm, qv.left, qv.right,
</span><span class="noop">        ...                  2./3.*qm+1./3.*min(qv),
</span><span class="noop">        ...                  2./3.*min(qv)+1./3.*max(qv),
</span><span class="noop">        ...                  3.*max(qv), 30.*max(qv)]:
</span><span class="noop">        ...         fluxes.qref = qref
</span><span class="noop">        ...         model.calc_hmin_qmin_hmax_qmax()
</span><span class="noop">        ...         model.calc_h()
</span><span class="noop">        ...         if abs(round(fluxes.qg-qref) &gt; 0.):
</span><span class="noop">        ...             print(&#39;Error!&#39;, &#39;qref:&#39;, qref, &#39;qg:&#39;, fluxes.qg)
</span><span class="noop">
</span><span class="noop">        Check for a triangle main channel:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; bm(0.)
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        &gt;&gt;&gt; bm(2.)
</span><span class="noop">
</span><span class="noop">        Check for a completely flat main channel:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; hm(0.)
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        &gt;&gt;&gt; hm(1.)
</span><span class="noop">
</span><span class="noop">        Check for a nonexistend main channel:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; bm(0.)
</span><span class="noop">        &gt;&gt;&gt; bnm(0.)
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        &gt;&gt;&gt; bm(2.)
</span><span class="noop">        &gt;&gt;&gt; bnm(4.)
</span><span class="noop">
</span><span class="noop">        Check for a nonexistend forelands:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; bv(0.)
</span><span class="noop">        &gt;&gt;&gt; bbv(0.)
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        &gt;&gt;&gt; bv(.5, 10.)
</span><span class="noop">        &gt;&gt;&gt; bbv(1., 2.)
</span><span class="noop">
</span><span class="noop">        Check for nonexistend outer foreland embankments:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; bnvr(0.)
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">
</span><span class="noop">        To take the last test as an illustrative example, one can see that
</span><span class="noop">        the given reference discharge is met by the estimated total discharge,
</span><span class="noop">        which consists of components related to the main channel and the
</span><span class="noop">        forelands only:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.qref
</span><span class="noop">        qref(3932.452785)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qg
</span><span class="noop">        qg(3932.452785)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qm
</span><span class="noop">        qm(530.074621)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qv
</span><span class="noop">        qv(113.780226, 3288.597937)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qvr
</span><span class="noop">        qvr(0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    aid.qmin -= flu.qref
</span><span class="hit">    aid.qmax -= flu.qref
</span><span class="hit">    if modelutils.fabs(aid.qmin) &lt; con.qtol:
</span><span class="hit">        flu.h = aid.hmin
</span><span class="hit">        self.calc_qg()
</span><span class="hit">    elif modelutils.fabs(aid.qmax) &lt; con.qtol:
</span><span class="hit">        flu.h = aid.hmax
</span><span class="hit">        self.calc_qg()
</span><span class="hit">    elif modelutils.fabs(aid.hmax-aid.hmin) &lt; con.htol:
</span><span class="miss">        flu.h = (aid.hmin+aid.hmax)/2.
</span><span class="miss">        self.calc_qg()
</span><span class="noop">    else:
</span><span class="hit">        while True:
</span><span class="hit">            flu.h = aid.hmin-aid.qmin*(aid.hmax-aid.hmin)/(aid.qmax-aid.qmin)
</span><span class="hit">            self.calc_qg()
</span><span class="hit">            aid.qtest = flu.qg-flu.qref
</span><span class="hit">            if modelutils.fabs(aid.qtest) &lt; con.qtol:
</span><span class="hit">                return
</span><span class="hit">            elif (((aid.qmax &lt; 0.) and (aid.qtest &lt; 0.)) or
</span><span class="noop">                    ((aid.qmax &gt; 0.) and (aid.qtest &gt; 0.))):
</span><span class="hit">                aid.qmin *= aid.qmax/(aid.qmax+aid.qtest)
</span><span class="noop">            else:
</span><span class="hit">                aid.hmin = aid.hmax
</span><span class="hit">                aid.qmin = aid.qmax
</span><span class="hit">            aid.hmax = flu.h
</span><span class="hit">            aid.qmax = aid.qtest
</span><span class="hit">            if modelutils.fabs(aid.hmax-aid.hmin) &lt; con.htol:
</span><span class="hit">                return
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qa_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate outflow.
</span><span class="noop">
</span><span class="noop">    The working equation is the analytical solution of the linear storage
</span><span class="noop">    equation under the assumption of constant change in inflow during
</span><span class="noop">    the simulation time step.
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.RK`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_states.QZ`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_states.QA`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QA_{neu} = QA_{alt} +
</span><span class="noop">       (QZ_{alt}-QA_{alt}) \\cdot (1-exp(-RK^{-1})) +
</span><span class="noop">       (QZ_{neu}-QZ_{alt}) \\cdot (1-KR\\cdot(1-exp(-KR^{-1})))`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        A normal test case:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; fluxes.rk(0.1)
</span><span class="noop">        &gt;&gt;&gt; states.qz.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qz.new = 4.
</span><span class="noop">        &gt;&gt;&gt; states.qa.old = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qa
</span><span class="noop">        qa(3.800054)
</span><span class="noop">
</span><span class="noop">        First extreme test case (zero division is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.rk(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qa
</span><span class="noop">        qa(4.0)
</span><span class="noop">
</span><span class="noop">        Second extreme test case (numerical overflow is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.rk(1e200)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qa
</span><span class="noop">        qa(5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if flu.rk &lt;= 0.:
</span><span class="hit">        new.qa = new.qz
</span><span class="hit">    elif flu.rk &gt; 1e200:
</span><span class="miss">        new.qa = old.qa+new.qz-old.qz
</span><span class="noop">    else:
</span><span class="hit">        aid.temp = (1.-modelutils.exp(-1./flu.rk))
</span><span class="hit">        new.qa = (old.qa +
</span><span class="noop">                  (old.qz-old.qa)*aid.temp +
</span><span class="noop">                  (new.qz-old.qz)*(1.-flu.rk*aid.temp))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pick_q_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update inflow.&#34;&#34;&#34;
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    inl = self.sequences.inlets.fastaccess
</span><span class="hit">    sta.qz = 0.
</span><span class="hit">    for idx in range(inl.len_q):
</span><span class="hit">        sta.qz += inl.q[idx][0]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def pass_q_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update outflow.&#34;&#34;&#34;
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    out = self.sequences.outlets.fastaccess
</span><span class="hit">    out.q[0] += sta.qa
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;The HydPy-L-Stream model.&#34;&#34;&#34;
</span><span class="hit">    _INLET_METHODS = (pick_q_v1,)
</span><span class="hit">    _RUN_METHODS = (calc_qref_v1,
</span><span class="noop">                    calc_hmin_qmin_hmax_qmax_v1,
</span><span class="noop">                    calc_h_v1,
</span><span class="noop">                    calc_ag_v1,
</span><span class="noop">                    calc_rk_v1,
</span><span class="noop">                    calc_qa_v1)
</span><span class="hit">    _ADD_METHODS = (calc_am_um_v1,
</span><span class="noop">                    calc_qm_v1,
</span><span class="noop">                    calc_av_uv_v1,
</span><span class="noop">                    calc_qv_v1,
</span><span class="noop">                    calc_avr_uvr_v1,
</span><span class="noop">                    calc_qvr_v1,
</span><span class="noop">                    calc_qg_v1)
</span><span class="hit">    _OUTLET_METHODS = (pass_q_v1,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_outlets.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss (runoff) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of HydPy-L-Stream.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/lstream/lstream_states.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QZ(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Zufluss in Gerinnestrecke (inflow into the channel) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QA(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss aus Gerinnestrecke (outflow out of the channel) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of HydPy-L-Stream.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QZ, QA)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/__init__.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">The base model `Test`is intended for implementing small application model
</span><span class="noop">that allow for testing or demonstrating specific features of the HydPy
</span><span class="noop">framework.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from test
</span><span class="hit">from hydpy.models.test.test_control import ControlParameters
</span><span class="hit">from hydpy.models.test.test_solver import SolverParameters
</span><span class="hit">from hydpy.models.test.test_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.test.test_states import StateSequences
</span><span class="hit">from hydpy.models.test.test_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_control.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class K(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Storage coefficient [1/T].
</span><span class="noop">
</span><span class="noop">    For educational purposes, the actual value of parameter :class:`K` does
</span><span class="noop">    not depend on the difference between the actual simulation time step and
</span><span class="noop">    the actual parameter time step.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of the Test model, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (K,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_fluxes.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Storage loss [mm/T]&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of the Test model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_model.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># imports...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_q_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual storage loss.
</span><span class="noop">
</span><span class="noop">    This simple equation is continuous but potentially stiff.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.test.test_control.K`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">     :class:`~hydpy.models.test.test_states.S`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.test.test_fluxes.Q`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`Q = K \\cdot S`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">       &gt;&gt;&gt; from hydpy.models.test import *
</span><span class="noop">       &gt;&gt;&gt; parameterstep()
</span><span class="noop">       &gt;&gt;&gt; k(0.5)
</span><span class="noop">       &gt;&gt;&gt; states.s = 2.0
</span><span class="noop">       &gt;&gt;&gt; model.calc_q_v1()
</span><span class="noop">       &gt;&gt;&gt; fluxes.q
</span><span class="noop">       q(1.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    flu.q = con.k*sta.s
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_q_v2(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual storage loss.
</span><span class="noop">
</span><span class="noop">    This simple equation is discontinuous.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.test.test_control.K`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">     :class:`~hydpy.models.test.test_states.S`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.test.test_fluxes.Q`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`Q = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {K \\ | \\ S &gt; 0}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ S \\leq 0}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">       &gt;&gt;&gt; from hydpy.models.test import *
</span><span class="noop">       &gt;&gt;&gt; parameterstep()
</span><span class="noop">       &gt;&gt;&gt; k(0.5)
</span><span class="noop">       &gt;&gt;&gt; states.s = 2.0
</span><span class="noop">       &gt;&gt;&gt; model.calc_q_v2()
</span><span class="noop">       &gt;&gt;&gt; fluxes.q
</span><span class="noop">       q(0.5)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    if sta.s &gt; 0.:
</span><span class="hit">        flu.q = con.k
</span><span class="noop">    else:
</span><span class="hit">        flu.q = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_s_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual storage content.
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.test.test_fluxes.Q`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">     :class:`~hydpy.models.test.test_states.S`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`\\frac{dS}{dt} = Q`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">       &gt;&gt;&gt; from hydpy.models.test import *
</span><span class="noop">       &gt;&gt;&gt; parameterstep()
</span><span class="noop">       &gt;&gt;&gt; states.s.old = 1.0
</span><span class="noop">       &gt;&gt;&gt; fluxes.q = 0.8
</span><span class="noop">       &gt;&gt;&gt; model.calc_s_v1()
</span><span class="noop">       &gt;&gt;&gt; states.s
</span><span class="noop">       s(0.2)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    new.s = old.s-flu.q
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.ModelELS):
</span><span class="noop">    &#34;&#34;&#34;Test model.&#34;&#34;&#34;
</span><span class="hit">    _PART_ODE_METHODS = (calc_q_v1,
</span><span class="noop">                         calc_q_v2)
</span><span class="hit">    _FULL_ODE_METHODS = (calc_s_v1,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_solver.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_solver.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AbsErrorMax(parametertools.SolverParameter):
</span><span class="noop">    &#34;&#34;&#34;Absolute numerical error tolerance [mm/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM = 0
</span><span class="hit">    TYPE = float
</span><span class="hit">    TIME = None
</span><span class="hit">    SPAN = (0., None)
</span><span class="hit">    INIT = 0.01
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelDTMin(parametertools.SolverParameter):
</span><span class="noop">    &#34;&#34;&#34;Smallest relative integration time step size allowed [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM = 0
</span><span class="hit">    TYPE = float
</span><span class="hit">    TIME = None
</span><span class="hit">    SPAN = (0.0, 1.0)
</span><span class="hit">    INIT = 0.001
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SolverParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Solver parameters of the Test model.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (AbsErrorMax, RelDTMin)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_states.py">/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/hydpy/models/test/test_states.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class S(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Storage content [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of the Test model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (S,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
    </div>
  </body>
</html>